<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>gadget.h source code [linux-4.14.y/include/linux/usb/gadget.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="usb_dcd_config_params,usb_ep,usb_ep_caps,usb_ep_ops,usb_gadget,usb_gadget_driver,usb_gadget_ops,usb_gadget_string_container,usb_gadget_strings,usb_request,usb_string "/>
<link rel="stylesheet" href="../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'linux-4.14.y/include/linux/usb/gadget.h'; var root_path = '../../../..'; var data_path = '../../../../../data';</script>
<script src='../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>linux-4.14.y</a>/<a href='../..'>include</a>/<a href='..'>linux</a>/<a href='./'>usb</a>/<a href='gadget.h.html'>gadget.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * &lt;linux/usb/gadget.h&gt;</i></td></tr>
<tr><th id="3">3</th><td><i> *</i></td></tr>
<tr><th id="4">4</th><td><i> * We call the USB code inside a Linux-based peripheral device a "gadget"</i></td></tr>
<tr><th id="5">5</th><td><i> * driver, except for the hardware-specific bus glue.  One USB host can</i></td></tr>
<tr><th id="6">6</th><td><i> * master many USB gadgets, but the gadgets are only slaved to one host.</i></td></tr>
<tr><th id="7">7</th><td><i> *</i></td></tr>
<tr><th id="8">8</th><td><i> *</i></td></tr>
<tr><th id="9">9</th><td><i> * (C) Copyright 2002-2004 by David Brownell</i></td></tr>
<tr><th id="10">10</th><td><i> * All Rights Reserved.</i></td></tr>
<tr><th id="11">11</th><td><i> *</i></td></tr>
<tr><th id="12">12</th><td><i> * This software is licensed under the GNU GPL version 2.</i></td></tr>
<tr><th id="13">13</th><td><i> */</i></td></tr>
<tr><th id="14">14</th><td></td></tr>
<tr><th id="15">15</th><td><u>#<span data-ppcond="15">ifndef</span> <span class="macro" data-ref="_M/__LINUX_USB_GADGET_H">__LINUX_USB_GADGET_H</span></u></td></tr>
<tr><th id="16">16</th><td><u>#define <dfn class="macro" id="_M/__LINUX_USB_GADGET_H" data-ref="_M/__LINUX_USB_GADGET_H">__LINUX_USB_GADGET_H</dfn></u></td></tr>
<tr><th id="17">17</th><td></td></tr>
<tr><th id="18">18</th><td><u>#include <a href="../device.h.html">&lt;linux/device.h&gt;</a></u></td></tr>
<tr><th id="19">19</th><td><u>#include <a href="../errno.h.html">&lt;linux/errno.h&gt;</a></u></td></tr>
<tr><th id="20">20</th><td><u>#include <a href="../init.h.html">&lt;linux/init.h&gt;</a></u></td></tr>
<tr><th id="21">21</th><td><u>#include <a href="../list.h.html">&lt;linux/list.h&gt;</a></u></td></tr>
<tr><th id="22">22</th><td><u>#include <a href="../slab.h.html">&lt;linux/slab.h&gt;</a></u></td></tr>
<tr><th id="23">23</th><td><u>#include <a href="../scatterlist.h.html">&lt;linux/scatterlist.h&gt;</a></u></td></tr>
<tr><th id="24">24</th><td><u>#include <a href="../types.h.html">&lt;linux/types.h&gt;</a></u></td></tr>
<tr><th id="25">25</th><td><u>#include <a href="../workqueue.h.html">&lt;linux/workqueue.h&gt;</a></u></td></tr>
<tr><th id="26">26</th><td><u>#include <a href="ch9.h.html">&lt;linux/usb/ch9.h&gt;</a></u></td></tr>
<tr><th id="27">27</th><td></td></tr>
<tr><th id="28">28</th><td><u>#define <dfn class="macro" id="_M/UDC_TRACE_STR_MAX" data-ref="_M/UDC_TRACE_STR_MAX">UDC_TRACE_STR_MAX</dfn>	512</u></td></tr>
<tr><th id="29">29</th><td></td></tr>
<tr><th id="30">30</th><td><b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a>;</td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><i class="doc">/**</i></td></tr>
<tr><th id="33">33</th><td><i class="doc"> * struct usb_request - describes one i/o request</i></td></tr>
<tr><th id="34">34</th><td><i class="doc"> * <span class="command">@buf</span>: Buffer used for data.  Always provide this; some controllers</i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> *	only use PIO, or don't use DMA for some endpoints.</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> *<span class="command"> @dma</span>: DMA address corresponding to 'buf'.  If you don't set this</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> *	field, and the usb controller needs one, it is responsible</i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> *	for mapping and unmapping the buffer.</i></td></tr>
<tr><th id="39">39</th><td><i class="doc"> * <span class="command">@sg</span>: a scatterlist for SG-capable controllers.</i></td></tr>
<tr><th id="40">40</th><td><i class="doc"> * <span class="command">@num_</span><span class="verb">sgs: number of SG entries</span></i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> * <span class="command">@num_</span><span class="verb">mapped_sgs: number of SG entries mapped to DMA (internal)</span></i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> *<span class="command"> @length</span>: Length of that data</i></td></tr>
<tr><th id="43">43</th><td><i class="doc"> *<span class="command"> @stream</span>_id: The stream id, when USB3.0 bulk streams are being used</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> *<span class="command"> @no</span>_interrupt: If true, hints that no completion irq is needed.</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> *	Helpful sometimes with deep request queues that are handled</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> *	directly by DMA controllers.</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> *<span class="command"> @zero</span>: If true, when writing data, makes the last packet be "short"</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> *     by adding a zero length packet as needed;</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> * <span class="command">@short</span>_not_ok: When reading data, makes short packets be</i></td></tr>
<tr><th id="50">50</th><td><i class="doc"> *     treated as errors (queue stops advancing till cleanup).</i></td></tr>
<tr><th id="51">51</th><td><i class="doc"> *<span class="command"> @dma</span>_mapped: Indicates if request has been mapped to DMA (internal)</i></td></tr>
<tr><th id="52">52</th><td><i class="doc"> *<span class="command"> @complete</span>: Function called when request completes, so this request and</i></td></tr>
<tr><th id="53">53</th><td><i class="doc"> *	its buffer may be re-used.  The function will always be called with</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> *	interrupts disabled, and it must not sleep.</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> *	Reads terminate with a short packet, or when the buffer fills,</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> *	whichever comes first.  When writes terminate, some data bytes</i></td></tr>
<tr><th id="57">57</th><td><i class="doc"> *	will usually still be in flight (often in a hardware fifo).</i></td></tr>
<tr><th id="58">58</th><td><i class="doc"> *	Errors (for reads or writes) stop the queue from advancing</i></td></tr>
<tr><th id="59">59</th><td><i class="doc"> *	until the completion function returns, so that any transfers</i></td></tr>
<tr><th id="60">60</th><td><i class="doc"> *	invalidated by the error may first be dequeued.</i></td></tr>
<tr><th id="61">61</th><td><i class="doc"> *<span class="command"> @context</span>: For use by the completion callback</i></td></tr>
<tr><th id="62">62</th><td><i class="doc"> *<span class="command"> @list</span>: For use by the gadget driver.</i></td></tr>
<tr><th id="63">63</th><td><i class="doc"> *<span class="command"> @status</span>: Reports completion code, zero or a negative errno.</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> *	Normally, faults block the transfer queue from advancing until</i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> *	the completion callback returns.</i></td></tr>
<tr><th id="66">66</th><td><i class="doc"> *	Code "-ESHUTDOWN" indicates completion caused by device disconnect,</i></td></tr>
<tr><th id="67">67</th><td><i class="doc"> *	or when the driver disabled the endpoint.</i></td></tr>
<tr><th id="68">68</th><td><i class="doc"> *<span class="command"> @actual</span>: Reports bytes transferred to/from the buffer.  For reads (OUT</i></td></tr>
<tr><th id="69">69</th><td><i class="doc"> *	transfers) this may be less than the requested length.  If the</i></td></tr>
<tr><th id="70">70</th><td><i class="doc"> *	short_not_ok flag is set, short reads are treated as errors</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> *	even when status otherwise indicates successful completion.</i></td></tr>
<tr><th id="72">72</th><td><i class="doc"> *	Note that for writes (IN transfers) some data bytes may still</i></td></tr>
<tr><th id="73">73</th><td><i class="doc"> *	reside in a device-side FIFO when the request is reported as</i></td></tr>
<tr><th id="74">74</th><td><i class="doc"> *	complete.</i></td></tr>
<tr><th id="75">75</th><td><i class="doc"> *</i></td></tr>
<tr><th id="76">76</th><td><i class="doc"> * These are allocated/freed through the endpoint they're used with.  The</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> * hardware's driver can add extra per-request data to the memory it returns,</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> * which often avoids separate memory allocations (potential failures),</i></td></tr>
<tr><th id="79">79</th><td><i class="doc"> * later when the request is queued.</i></td></tr>
<tr><th id="80">80</th><td><i class="doc"> *</i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> * Request flags affect request handling, such as whether a zero length</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> * packet is written (the "zero" flag), whether a short read should be</i></td></tr>
<tr><th id="83">83</th><td><i class="doc"> * treated as an error (blocking request queue advance, the "short_not_ok"</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * flag), or hinting that an interrupt is not required (the "no_interrupt"</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> * flag, for use with deep request queues).</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> *</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> * Bulk endpoints can use any size buffers, and can also be used for interrupt</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> * transfers. interrupt-only endpoints can be much less functional.</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> *</i></td></tr>
<tr><th id="90">90</th><td><i class="doc"> * NOTE:  this is analogous to 'struct urb' on the host side, except that</i></td></tr>
<tr><th id="91">91</th><td><i class="doc"> * it's thinner and promotes more pre-allocation.</i></td></tr>
<tr><th id="92">92</th><td><i class="doc"> */</i></td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td><b>struct</b> <dfn class="type def" id="usb_request" title='usb_request' data-ref="usb_request">usb_request</dfn> {</td></tr>
<tr><th id="95">95</th><td>	<em>void</em>			*<dfn class="decl field" id="usb_request::buf" title='usb_request::buf' data-ref="usb_request::buf">buf</dfn>;</td></tr>
<tr><th id="96">96</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::length" title='usb_request::length' data-ref="usb_request::length">length</dfn>;</td></tr>
<tr><th id="97">97</th><td>	<a class="typedef" href="../types.h.html#dma_addr_t" title='dma_addr_t' data-type='u64' data-ref="dma_addr_t">dma_addr_t</a>		<dfn class="decl field" id="usb_request::dma" title='usb_request::dma' data-ref="usb_request::dma">dma</dfn>;</td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td>	<b>struct</b> <a class="type" href="../scatterlist.h.html#scatterlist" title='scatterlist' data-ref="scatterlist">scatterlist</a>	*<dfn class="decl field" id="usb_request::sg" title='usb_request::sg' data-ref="usb_request::sg">sg</dfn>;</td></tr>
<tr><th id="100">100</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::num_sgs" title='usb_request::num_sgs' data-ref="usb_request::num_sgs">num_sgs</dfn>;</td></tr>
<tr><th id="101">101</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::num_mapped_sgs" title='usb_request::num_mapped_sgs' data-ref="usb_request::num_mapped_sgs">num_mapped_sgs</dfn>;</td></tr>
<tr><th id="102">102</th><td></td></tr>
<tr><th id="103">103</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::stream_id" title='usb_request::stream_id' data-ref="usb_request::stream_id">stream_id</dfn>:<var>16</var>;</td></tr>
<tr><th id="104">104</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::no_interrupt" title='usb_request::no_interrupt' data-ref="usb_request::no_interrupt">no_interrupt</dfn>:<var>1</var>;</td></tr>
<tr><th id="105">105</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::zero" title='usb_request::zero' data-ref="usb_request::zero">zero</dfn>:<var>1</var>;</td></tr>
<tr><th id="106">106</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::short_not_ok" title='usb_request::short_not_ok' data-ref="usb_request::short_not_ok">short_not_ok</dfn>:<var>1</var>;</td></tr>
<tr><th id="107">107</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::dma_mapped" title='usb_request::dma_mapped' data-ref="usb_request::dma_mapped">dma_mapped</dfn>:<var>1</var>;</td></tr>
<tr><th id="108">108</th><td></td></tr>
<tr><th id="109">109</th><td>	<em>void</em>			(*<dfn class="decl field" id="usb_request::complete" title='usb_request::complete' data-ref="usb_request::complete">complete</dfn>)(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col1 decl" id="1ep" title='ep' data-type='struct usb_ep *' data-ref="1ep">ep</dfn>,</td></tr>
<tr><th id="110">110</th><td>					<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col2 decl" id="2req" title='req' data-type='struct usb_request *' data-ref="2req">req</dfn>);</td></tr>
<tr><th id="111">111</th><td>	<em>void</em>			*<dfn class="decl field" id="usb_request::context" title='usb_request::context' data-ref="usb_request::context">context</dfn>;</td></tr>
<tr><th id="112">112</th><td>	<b>struct</b> <a class="type" href="../types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a>	<dfn class="decl field" id="usb_request::list" title='usb_request::list' data-ref="usb_request::list">list</dfn>;</td></tr>
<tr><th id="113">113</th><td></td></tr>
<tr><th id="114">114</th><td>	<em>int</em>			<dfn class="decl field" id="usb_request::status" title='usb_request::status' data-ref="usb_request::status">status</dfn>;</td></tr>
<tr><th id="115">115</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_request::actual" title='usb_request::actual' data-ref="usb_request::actual">actual</dfn>;</td></tr>
<tr><th id="116">116</th><td>};</td></tr>
<tr><th id="117">117</th><td></td></tr>
<tr><th id="118">118</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="119">119</th><td></td></tr>
<tr><th id="120">120</th><td><i>/* endpoint-specific parts of the api to the usb controller hardware.</i></td></tr>
<tr><th id="121">121</th><td><i> * unlike the urb model, (de)multiplexing layers are not required.</i></td></tr>
<tr><th id="122">122</th><td><i> * (so this api could slash overhead if used on the host side...)</i></td></tr>
<tr><th id="123">123</th><td><i> *</i></td></tr>
<tr><th id="124">124</th><td><i> * note that device side usb controllers commonly differ in how many</i></td></tr>
<tr><th id="125">125</th><td><i> * endpoints they support, as well as their capabilities.</i></td></tr>
<tr><th id="126">126</th><td><i> */</i></td></tr>
<tr><th id="127">127</th><td><b>struct</b> <dfn class="type def" id="usb_ep_ops" title='usb_ep_ops' data-ref="usb_ep_ops">usb_ep_ops</dfn> {</td></tr>
<tr><th id="128">128</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::enable" title='usb_ep_ops::enable' data-ref="usb_ep_ops::enable">enable</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col3 decl" id="3ep" title='ep' data-type='struct usb_ep *' data-ref="3ep">ep</dfn>,</td></tr>
<tr><th id="129">129</th><td>		<em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_descriptor" title='usb_endpoint_descriptor' data-ref="usb_endpoint_descriptor">usb_endpoint_descriptor</a> *<dfn class="local col4 decl" id="4desc" title='desc' data-type='const struct usb_endpoint_descriptor *' data-ref="4desc">desc</dfn>);</td></tr>
<tr><th id="130">130</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::disable" title='usb_ep_ops::disable' data-ref="usb_ep_ops::disable">disable</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col5 decl" id="5ep" title='ep' data-type='struct usb_ep *' data-ref="5ep">ep</dfn>);</td></tr>
<tr><th id="131">131</th><td></td></tr>
<tr><th id="132">132</th><td>	<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *(*<dfn class="decl field" id="usb_ep_ops::alloc_request" title='usb_ep_ops::alloc_request' data-ref="usb_ep_ops::alloc_request">alloc_request</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col6 decl" id="6ep" title='ep' data-type='struct usb_ep *' data-ref="6ep">ep</dfn>,</td></tr>
<tr><th id="133">133</th><td>		<a class="typedef" href="../types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col7 decl" id="7gfp_flags" title='gfp_flags' data-type='gfp_t' data-ref="7gfp_flags">gfp_flags</dfn>);</td></tr>
<tr><th id="134">134</th><td>	<em>void</em> (*<dfn class="decl field" id="usb_ep_ops::free_request" title='usb_ep_ops::free_request' data-ref="usb_ep_ops::free_request">free_request</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col8 decl" id="8ep" title='ep' data-type='struct usb_ep *' data-ref="8ep">ep</dfn>, <b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col9 decl" id="9req" title='req' data-type='struct usb_request *' data-ref="9req">req</dfn>);</td></tr>
<tr><th id="135">135</th><td></td></tr>
<tr><th id="136">136</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::queue" title='usb_ep_ops::queue' data-ref="usb_ep_ops::queue">queue</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col0 decl" id="10ep" title='ep' data-type='struct usb_ep *' data-ref="10ep">ep</dfn>, <b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col1 decl" id="11req" title='req' data-type='struct usb_request *' data-ref="11req">req</dfn>,</td></tr>
<tr><th id="137">137</th><td>		<a class="typedef" href="../types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col2 decl" id="12gfp_flags" title='gfp_flags' data-type='gfp_t' data-ref="12gfp_flags">gfp_flags</dfn>);</td></tr>
<tr><th id="138">138</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::dequeue" title='usb_ep_ops::dequeue' data-ref="usb_ep_ops::dequeue">dequeue</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col3 decl" id="13ep" title='ep' data-type='struct usb_ep *' data-ref="13ep">ep</dfn>, <b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col4 decl" id="14req" title='req' data-type='struct usb_request *' data-ref="14req">req</dfn>);</td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::set_halt" title='usb_ep_ops::set_halt' data-ref="usb_ep_ops::set_halt">set_halt</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col5 decl" id="15ep" title='ep' data-type='struct usb_ep *' data-ref="15ep">ep</dfn>, <em>int</em> <dfn class="local col6 decl" id="16value" title='value' data-type='int' data-ref="16value">value</dfn>);</td></tr>
<tr><th id="141">141</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::set_wedge" title='usb_ep_ops::set_wedge' data-ref="usb_ep_ops::set_wedge">set_wedge</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col7 decl" id="17ep" title='ep' data-type='struct usb_ep *' data-ref="17ep">ep</dfn>);</td></tr>
<tr><th id="142">142</th><td></td></tr>
<tr><th id="143">143</th><td>	<em>int</em> (*<dfn class="decl field" id="usb_ep_ops::fifo_status" title='usb_ep_ops::fifo_status' data-ref="usb_ep_ops::fifo_status">fifo_status</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col8 decl" id="18ep" title='ep' data-type='struct usb_ep *' data-ref="18ep">ep</dfn>);</td></tr>
<tr><th id="144">144</th><td>	<em>void</em> (*<dfn class="decl field" id="usb_ep_ops::fifo_flush" title='usb_ep_ops::fifo_flush' data-ref="usb_ep_ops::fifo_flush">fifo_flush</dfn>) (<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col9 decl" id="19ep" title='ep' data-type='struct usb_ep *' data-ref="19ep">ep</dfn>);</td></tr>
<tr><th id="145">145</th><td>};</td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><i class="doc">/**</i></td></tr>
<tr><th id="148">148</th><td><i class="doc"> * struct usb_ep_caps - endpoint capabilities description</i></td></tr>
<tr><th id="149">149</th><td><i class="doc"> *<span class="command"> @type</span>_control:Endpoint supports control type (reserved for ep0).</i></td></tr>
<tr><th id="150">150</th><td><i class="doc"> *<span class="command"> @type</span>_iso:Endpoint supports isochronous transfers.</i></td></tr>
<tr><th id="151">151</th><td><i class="doc"> *<span class="command"> @type</span>_bulk:Endpoint supports bulk transfers.</i></td></tr>
<tr><th id="152">152</th><td><i class="doc"> *<span class="command"> @type</span>_int:Endpoint supports interrupt transfers.</i></td></tr>
<tr><th id="153">153</th><td><i class="doc"> *<span class="command"> @dir</span>_in:Endpoint supports IN direction.</i></td></tr>
<tr><th id="154">154</th><td><i class="doc"> *<span class="command"> @dir</span>_out:Endpoint supports OUT direction.</i></td></tr>
<tr><th id="155">155</th><td><i class="doc"> */</i></td></tr>
<tr><th id="156">156</th><td><b>struct</b> <dfn class="type def" id="usb_ep_caps" title='usb_ep_caps' data-ref="usb_ep_caps">usb_ep_caps</dfn> {</td></tr>
<tr><th id="157">157</th><td>	<em>unsigned</em> <dfn class="decl field" id="usb_ep_caps::type_control" title='usb_ep_caps::type_control' data-ref="usb_ep_caps::type_control">type_control</dfn>:<var>1</var>;</td></tr>
<tr><th id="158">158</th><td>	<em>unsigned</em> <dfn class="decl field" id="usb_ep_caps::type_iso" title='usb_ep_caps::type_iso' data-ref="usb_ep_caps::type_iso">type_iso</dfn>:<var>1</var>;</td></tr>
<tr><th id="159">159</th><td>	<em>unsigned</em> <dfn class="decl field" id="usb_ep_caps::type_bulk" title='usb_ep_caps::type_bulk' data-ref="usb_ep_caps::type_bulk">type_bulk</dfn>:<var>1</var>;</td></tr>
<tr><th id="160">160</th><td>	<em>unsigned</em> <dfn class="decl field" id="usb_ep_caps::type_int" title='usb_ep_caps::type_int' data-ref="usb_ep_caps::type_int">type_int</dfn>:<var>1</var>;</td></tr>
<tr><th id="161">161</th><td>	<em>unsigned</em> <dfn class="decl field" id="usb_ep_caps::dir_in" title='usb_ep_caps::dir_in' data-ref="usb_ep_caps::dir_in">dir_in</dfn>:<var>1</var>;</td></tr>
<tr><th id="162">162</th><td>	<em>unsigned</em> <dfn class="decl field" id="usb_ep_caps::dir_out" title='usb_ep_caps::dir_out' data-ref="usb_ep_caps::dir_out">dir_out</dfn>:<var>1</var>;</td></tr>
<tr><th id="163">163</th><td>};</td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_TYPE_CONTROL" data-ref="_M/USB_EP_CAPS_TYPE_CONTROL">USB_EP_CAPS_TYPE_CONTROL</dfn>     0x01</u></td></tr>
<tr><th id="166">166</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_TYPE_ISO" data-ref="_M/USB_EP_CAPS_TYPE_ISO">USB_EP_CAPS_TYPE_ISO</dfn>         0x02</u></td></tr>
<tr><th id="167">167</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_TYPE_BULK" data-ref="_M/USB_EP_CAPS_TYPE_BULK">USB_EP_CAPS_TYPE_BULK</dfn>        0x04</u></td></tr>
<tr><th id="168">168</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_TYPE_INT" data-ref="_M/USB_EP_CAPS_TYPE_INT">USB_EP_CAPS_TYPE_INT</dfn>         0x08</u></td></tr>
<tr><th id="169">169</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_TYPE_ALL" data-ref="_M/USB_EP_CAPS_TYPE_ALL">USB_EP_CAPS_TYPE_ALL</dfn> \</u></td></tr>
<tr><th id="170">170</th><td><u>	(USB_EP_CAPS_TYPE_ISO | USB_EP_CAPS_TYPE_BULK | USB_EP_CAPS_TYPE_INT)</u></td></tr>
<tr><th id="171">171</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_DIR_IN" data-ref="_M/USB_EP_CAPS_DIR_IN">USB_EP_CAPS_DIR_IN</dfn>           0x01</u></td></tr>
<tr><th id="172">172</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_DIR_OUT" data-ref="_M/USB_EP_CAPS_DIR_OUT">USB_EP_CAPS_DIR_OUT</dfn>          0x02</u></td></tr>
<tr><th id="173">173</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS_DIR_ALL" data-ref="_M/USB_EP_CAPS_DIR_ALL">USB_EP_CAPS_DIR_ALL</dfn>  (USB_EP_CAPS_DIR_IN | USB_EP_CAPS_DIR_OUT)</u></td></tr>
<tr><th id="174">174</th><td></td></tr>
<tr><th id="175">175</th><td><u>#define <dfn class="macro" id="_M/USB_EP_CAPS" data-ref="_M/USB_EP_CAPS">USB_EP_CAPS</dfn>(_type, _dir) \</u></td></tr>
<tr><th id="176">176</th><td><u>	{ \</u></td></tr>
<tr><th id="177">177</th><td><u>		.type_control = !!(_type &amp; USB_EP_CAPS_TYPE_CONTROL), \</u></td></tr>
<tr><th id="178">178</th><td><u>		.type_iso = !!(_type &amp; USB_EP_CAPS_TYPE_ISO), \</u></td></tr>
<tr><th id="179">179</th><td><u>		.type_bulk = !!(_type &amp; USB_EP_CAPS_TYPE_BULK), \</u></td></tr>
<tr><th id="180">180</th><td><u>		.type_int = !!(_type &amp; USB_EP_CAPS_TYPE_INT), \</u></td></tr>
<tr><th id="181">181</th><td><u>		.dir_in = !!(_dir &amp; USB_EP_CAPS_DIR_IN), \</u></td></tr>
<tr><th id="182">182</th><td><u>		.dir_out = !!(_dir &amp; USB_EP_CAPS_DIR_OUT), \</u></td></tr>
<tr><th id="183">183</th><td><u>	}</u></td></tr>
<tr><th id="184">184</th><td></td></tr>
<tr><th id="185">185</th><td><i class="doc">/**</i></td></tr>
<tr><th id="186">186</th><td><i class="doc"> * struct usb_ep - device side representation of USB endpoint</i></td></tr>
<tr><th id="187">187</th><td><i class="doc"> * <span class="command">@name</span>:<span class="verb">identifier for the endpoint, such as "ep-a" or "ep9in-bulk"</span></i></td></tr>
<tr><th id="188">188</th><td><i class="doc"> *<span class="command"> @ops</span>: Function pointers used to access hardware-specific operations.</i></td></tr>
<tr><th id="189">189</th><td><i class="doc"> *<span class="command"> @ep</span>_list:the gadget's ep_list holds all of its endpoints</i></td></tr>
<tr><th id="190">190</th><td><i class="doc"> *<span class="command"> @caps</span>:The structure describing types and directions supported by endoint.</i></td></tr>
<tr><th id="191">191</th><td><i class="doc"> *<span class="command"> @maxpacket</span>:The maximum packet size used on this endpoint.  The initial</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"> *	value can sometimes be reduced (hardware allowing), according to</i></td></tr>
<tr><th id="193">193</th><td><i class="doc"> *	the endpoint descriptor used to configure the endpoint.</i></td></tr>
<tr><th id="194">194</th><td><i class="doc"> *<span class="command"> @maxpacket</span>_limit:The maximum packet size value which can be handled by this</i></td></tr>
<tr><th id="195">195</th><td><i class="doc"> *	endpoint. It's set once by UDC driver when endpoint is initialized, and</i></td></tr>
<tr><th id="196">196</th><td><i class="doc"> *	should not be changed. Should not be confused with maxpacket.</i></td></tr>
<tr><th id="197">197</th><td><i class="doc"> *<span class="command"> @max</span>_streams: The maximum number of streams supported</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> *	by this EP (0 - 16, actual number is 2^n)</i></td></tr>
<tr><th id="199">199</th><td><i class="doc"> *<span class="command"> @mult</span>: multiplier, 'mult' value for SS Isoc EPs</i></td></tr>
<tr><th id="200">200</th><td><i class="doc"> *<span class="command"> @maxburst</span>: the maximum number of bursts supported by this EP (for usb3)</i></td></tr>
<tr><th id="201">201</th><td><i class="doc"> *<span class="command"> @driver</span>_data:for use by the gadget driver.</i></td></tr>
<tr><th id="202">202</th><td><i class="doc"> *<span class="command"> @address</span>: used to identify the endpoint when finding descriptor that</i></td></tr>
<tr><th id="203">203</th><td><i class="doc"> *	matches connection speed</i></td></tr>
<tr><th id="204">204</th><td><i class="doc"> *<span class="command"> @desc</span>: endpoint descriptor.  This pointer is set before the endpoint is</i></td></tr>
<tr><th id="205">205</th><td><i class="doc"> *	enabled and remains valid until the endpoint is disabled.</i></td></tr>
<tr><th id="206">206</th><td><i class="doc"> *<span class="command"> @comp</span>_desc: In case of SuperSpeed support, this is the endpoint companion</i></td></tr>
<tr><th id="207">207</th><td><i class="doc"> *	descriptor that is used to configure the endpoint</i></td></tr>
<tr><th id="208">208</th><td><i class="doc"> *</i></td></tr>
<tr><th id="209">209</th><td><i class="doc"> * the bus controller driver lists all the general purpose endpoints in</i></td></tr>
<tr><th id="210">210</th><td><i class="doc"> * gadget-&gt;ep_list.  the control endpoint (gadget-&gt;ep0) is not in that list,</i></td></tr>
<tr><th id="211">211</th><td><i class="doc"> * and is accessed only in response to a driver setup() callback.</i></td></tr>
<tr><th id="212">212</th><td><i class="doc"> */</i></td></tr>
<tr><th id="213">213</th><td></td></tr>
<tr><th id="214">214</th><td><b>struct</b> <dfn class="type def" id="usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</dfn> {</td></tr>
<tr><th id="215">215</th><td>	<em>void</em>			*<dfn class="decl field" id="usb_ep::driver_data" title='usb_ep::driver_data' data-ref="usb_ep::driver_data">driver_data</dfn>;</td></tr>
<tr><th id="216">216</th><td></td></tr>
<tr><th id="217">217</th><td>	<em>const</em> <em>char</em>		*<dfn class="decl field" id="usb_ep::name" title='usb_ep::name' data-ref="usb_ep::name">name</dfn>;</td></tr>
<tr><th id="218">218</th><td>	<em>const</em> <b>struct</b> <a class="type" href="#usb_ep_ops" title='usb_ep_ops' data-ref="usb_ep_ops">usb_ep_ops</a>	*<dfn class="decl field" id="usb_ep::ops" title='usb_ep::ops' data-ref="usb_ep::ops">ops</dfn>;</td></tr>
<tr><th id="219">219</th><td>	<b>struct</b> <a class="type" href="../types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a>	<dfn class="decl field" id="usb_ep::ep_list" title='usb_ep::ep_list' data-ref="usb_ep::ep_list">ep_list</dfn>;</td></tr>
<tr><th id="220">220</th><td>	<b>struct</b> <a class="type" href="#usb_ep_caps" title='usb_ep_caps' data-ref="usb_ep_caps">usb_ep_caps</a>	<dfn class="decl field" id="usb_ep::caps" title='usb_ep::caps' data-ref="usb_ep::caps">caps</dfn>;</td></tr>
<tr><th id="221">221</th><td>	<a class="typedef" href="../types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a>			<dfn class="decl field" id="usb_ep::claimed" title='usb_ep::claimed' data-ref="usb_ep::claimed">claimed</dfn>;</td></tr>
<tr><th id="222">222</th><td>	<a class="typedef" href="../types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a>			<dfn class="decl field" id="usb_ep::enabled" title='usb_ep::enabled' data-ref="usb_ep::enabled">enabled</dfn>;</td></tr>
<tr><th id="223">223</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_ep::maxpacket" title='usb_ep::maxpacket' data-ref="usb_ep::maxpacket">maxpacket</dfn>:<var>16</var>;</td></tr>
<tr><th id="224">224</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_ep::maxpacket_limit" title='usb_ep::maxpacket_limit' data-ref="usb_ep::maxpacket_limit">maxpacket_limit</dfn>:<var>16</var>;</td></tr>
<tr><th id="225">225</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_ep::max_streams" title='usb_ep::max_streams' data-ref="usb_ep::max_streams">max_streams</dfn>:<var>16</var>;</td></tr>
<tr><th id="226">226</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_ep::mult" title='usb_ep::mult' data-ref="usb_ep::mult">mult</dfn>:<var>2</var>;</td></tr>
<tr><th id="227">227</th><td>	<em>unsigned</em>		<dfn class="decl field" id="usb_ep::maxburst" title='usb_ep::maxburst' data-ref="usb_ep::maxburst">maxburst</dfn>:<var>5</var>;</td></tr>
<tr><th id="228">228</th><td>	<a class="typedef" href="../../asm-generic/int-ll64.h.html#u8" title='u8' data-type='unsigned char' data-ref="u8">u8</a>			<dfn class="decl field" id="usb_ep::address" title='usb_ep::address' data-ref="usb_ep::address">address</dfn>;</td></tr>
<tr><th id="229">229</th><td>	<em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_descriptor" title='usb_endpoint_descriptor' data-ref="usb_endpoint_descriptor">usb_endpoint_descriptor</a>	*<dfn class="decl field" id="usb_ep::desc" title='usb_ep::desc' data-ref="usb_ep::desc">desc</dfn>;</td></tr>
<tr><th id="230">230</th><td>	<em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_ss_ep_comp_descriptor" title='usb_ss_ep_comp_descriptor' data-ref="usb_ss_ep_comp_descriptor">usb_ss_ep_comp_descriptor</a>	*<dfn class="decl field" id="usb_ep::comp_desc" title='usb_ep::comp_desc' data-ref="usb_ep::comp_desc">comp_desc</dfn>;</td></tr>
<tr><th id="231">231</th><td>};</td></tr>
<tr><th id="232">232</th><td></td></tr>
<tr><th id="233">233</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="234">234</th><td></td></tr>
<tr><th id="235">235</th><td><u>#<span data-ppcond="235">if</span> <a class="macro" href="../kconfig.h.html#71" title="1" data-ref="_M/IS_ENABLED">IS_ENABLED</a>(<a class="macro" href="../../generated/autoconf.h.html#554" title="1" data-ref="_M/CONFIG_USB_GADGET">CONFIG_USB_GADGET</a>)</u></td></tr>
<tr><th id="236">236</th><td><em>void</em> <dfn class="decl fn" id="usb_ep_set_maxpacket_limit" title='usb_ep_set_maxpacket_limit' data-ref="usb_ep_set_maxpacket_limit">usb_ep_set_maxpacket_limit</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col0 decl" id="20ep" title='ep' data-type='struct usb_ep *' data-ref="20ep">ep</dfn>, <em>unsigned</em> <dfn class="local col1 decl" id="21maxpacket_limit" title='maxpacket_limit' data-type='unsigned int' data-ref="21maxpacket_limit">maxpacket_limit</dfn>);</td></tr>
<tr><th id="237">237</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_enable" title='usb_ep_enable' data-ref="usb_ep_enable">usb_ep_enable</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col2 decl" id="22ep" title='ep' data-type='struct usb_ep *' data-ref="22ep">ep</dfn>);</td></tr>
<tr><th id="238">238</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_disable" title='usb_ep_disable' data-ref="usb_ep_disable">usb_ep_disable</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col3 decl" id="23ep" title='ep' data-type='struct usb_ep *' data-ref="23ep">ep</dfn>);</td></tr>
<tr><th id="239">239</th><td><b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="decl fn" id="usb_ep_alloc_request" title='usb_ep_alloc_request' data-ref="usb_ep_alloc_request">usb_ep_alloc_request</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col4 decl" id="24ep" title='ep' data-type='struct usb_ep *' data-ref="24ep">ep</dfn>, <a class="typedef" href="../types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col5 decl" id="25gfp_flags" title='gfp_flags' data-type='gfp_t' data-ref="25gfp_flags">gfp_flags</dfn>);</td></tr>
<tr><th id="240">240</th><td><em>void</em> <dfn class="decl fn" id="usb_ep_free_request" title='usb_ep_free_request' data-ref="usb_ep_free_request">usb_ep_free_request</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col6 decl" id="26ep" title='ep' data-type='struct usb_ep *' data-ref="26ep">ep</dfn>, <b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col7 decl" id="27req" title='req' data-type='struct usb_request *' data-ref="27req">req</dfn>);</td></tr>
<tr><th id="241">241</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_queue" title='usb_ep_queue' data-ref="usb_ep_queue">usb_ep_queue</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col8 decl" id="28ep" title='ep' data-type='struct usb_ep *' data-ref="28ep">ep</dfn>, <b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col9 decl" id="29req" title='req' data-type='struct usb_request *' data-ref="29req">req</dfn>, <a class="typedef" href="../types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col0 decl" id="30gfp_flags" title='gfp_flags' data-type='gfp_t' data-ref="30gfp_flags">gfp_flags</dfn>);</td></tr>
<tr><th id="242">242</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_dequeue" title='usb_ep_dequeue' data-ref="usb_ep_dequeue">usb_ep_dequeue</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col1 decl" id="31ep" title='ep' data-type='struct usb_ep *' data-ref="31ep">ep</dfn>, <b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col2 decl" id="32req" title='req' data-type='struct usb_request *' data-ref="32req">req</dfn>);</td></tr>
<tr><th id="243">243</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_set_halt" title='usb_ep_set_halt' data-ref="usb_ep_set_halt">usb_ep_set_halt</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col3 decl" id="33ep" title='ep' data-type='struct usb_ep *' data-ref="33ep">ep</dfn>);</td></tr>
<tr><th id="244">244</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_clear_halt" title='usb_ep_clear_halt' data-ref="usb_ep_clear_halt">usb_ep_clear_halt</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col4 decl" id="34ep" title='ep' data-type='struct usb_ep *' data-ref="34ep">ep</dfn>);</td></tr>
<tr><th id="245">245</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_set_wedge" title='usb_ep_set_wedge' data-ref="usb_ep_set_wedge">usb_ep_set_wedge</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col5 decl" id="35ep" title='ep' data-type='struct usb_ep *' data-ref="35ep">ep</dfn>);</td></tr>
<tr><th id="246">246</th><td><em>int</em> <dfn class="decl fn" id="usb_ep_fifo_status" title='usb_ep_fifo_status' data-ref="usb_ep_fifo_status">usb_ep_fifo_status</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col6 decl" id="36ep" title='ep' data-type='struct usb_ep *' data-ref="36ep">ep</dfn>);</td></tr>
<tr><th id="247">247</th><td><em>void</em> <dfn class="decl fn" id="usb_ep_fifo_flush" title='usb_ep_fifo_flush' data-ref="usb_ep_fifo_flush">usb_ep_fifo_flush</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col7 decl" id="37ep" title='ep' data-type='struct usb_ep *' data-ref="37ep">ep</dfn>);</td></tr>
<tr><th id="248">248</th><td><u>#<span data-ppcond="235">else</span></u></td></tr>
<tr><th id="249">249</th><td><em>static</em> <b>inline</b> <em>void</em> usb_ep_set_maxpacket_limit(<b>struct</b> usb_ep *ep,</td></tr>
<tr><th id="250">250</th><td>		<em>unsigned</em> maxpacket_limit)</td></tr>
<tr><th id="251">251</th><td>{ }</td></tr>
<tr><th id="252">252</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_enable(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="253">253</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="254">254</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_disable(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="255">255</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="256">256</th><td><em>static</em> <b>inline</b> <b>struct</b> usb_request *usb_ep_alloc_request(<b>struct</b> usb_ep *ep,</td></tr>
<tr><th id="257">257</th><td>		gfp_t gfp_flags)</td></tr>
<tr><th id="258">258</th><td>{ <b>return</b> NULL; }</td></tr>
<tr><th id="259">259</th><td><em>static</em> <b>inline</b> <em>void</em> usb_ep_free_request(<b>struct</b> usb_ep *ep,</td></tr>
<tr><th id="260">260</th><td>		<b>struct</b> usb_request *req)</td></tr>
<tr><th id="261">261</th><td>{ }</td></tr>
<tr><th id="262">262</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_queue(<b>struct</b> usb_ep *ep, <b>struct</b> usb_request *req,</td></tr>
<tr><th id="263">263</th><td>		gfp_t gfp_flags)</td></tr>
<tr><th id="264">264</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="265">265</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_dequeue(<b>struct</b> usb_ep *ep, <b>struct</b> usb_request *req)</td></tr>
<tr><th id="266">266</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="267">267</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_set_halt(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="268">268</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="269">269</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_clear_halt(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="270">270</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="271">271</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_set_wedge(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="272">272</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="273">273</th><td><em>static</em> <b>inline</b> <em>int</em> usb_ep_fifo_status(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="274">274</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="275">275</th><td><em>static</em> <b>inline</b> <em>void</em> usb_ep_fifo_flush(<b>struct</b> usb_ep *ep)</td></tr>
<tr><th id="276">276</th><td>{ }</td></tr>
<tr><th id="277">277</th><td><u>#<span data-ppcond="235">endif</span> /* USB_GADGET */</u></td></tr>
<tr><th id="278">278</th><td></td></tr>
<tr><th id="279">279</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="280">280</th><td></td></tr>
<tr><th id="281">281</th><td><b>struct</b> <dfn class="type def" id="usb_dcd_config_params" title='usb_dcd_config_params' data-ref="usb_dcd_config_params">usb_dcd_config_params</dfn> {</td></tr>
<tr><th id="282">282</th><td>	<a class="typedef" href="../../uapi/asm-generic/int-ll64.h.html#__u8" title='__u8' data-type='unsigned char' data-ref="__u8">__u8</a>  <dfn class="decl field" id="usb_dcd_config_params::bU1devExitLat" title='usb_dcd_config_params::bU1devExitLat' data-ref="usb_dcd_config_params::bU1devExitLat">bU1devExitLat</dfn>;	<i>/* U1 Device exit Latency */</i></td></tr>
<tr><th id="283">283</th><td><u>#define <dfn class="macro" id="_M/USB_DEFAULT_U1_DEV_EXIT_LAT" data-ref="_M/USB_DEFAULT_U1_DEV_EXIT_LAT">USB_DEFAULT_U1_DEV_EXIT_LAT</dfn>	0x01	/* Less then 1 microsec */</u></td></tr>
<tr><th id="284">284</th><td>	<a class="typedef" href="../../uapi/linux/types.h.html#__le16" title='__le16' data-type='__u16' data-ref="__le16">__le16</a> <dfn class="decl field" id="usb_dcd_config_params::bU2DevExitLat" title='usb_dcd_config_params::bU2DevExitLat' data-ref="usb_dcd_config_params::bU2DevExitLat">bU2DevExitLat</dfn>;	<i>/* U2 Device exit Latency */</i></td></tr>
<tr><th id="285">285</th><td><u>#define <dfn class="macro" id="_M/USB_DEFAULT_U2_DEV_EXIT_LAT" data-ref="_M/USB_DEFAULT_U2_DEV_EXIT_LAT">USB_DEFAULT_U2_DEV_EXIT_LAT</dfn>	0x1F4	/* Less then 500 microsec */</u></td></tr>
<tr><th id="286">286</th><td>};</td></tr>
<tr><th id="287">287</th><td></td></tr>
<tr><th id="288">288</th><td></td></tr>
<tr><th id="289">289</th><td><b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a>;</td></tr>
<tr><th id="290">290</th><td><b>struct</b> <a class="type" href="#usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</a>;</td></tr>
<tr><th id="291">291</th><td><b>struct</b> <dfn class="type" id="usb_udc" title='usb_udc' data-ref="usb_udc">usb_udc</dfn>;</td></tr>
<tr><th id="292">292</th><td></td></tr>
<tr><th id="293">293</th><td><i>/* the rest of the api to the controller hardware: device operations,</i></td></tr>
<tr><th id="294">294</th><td><i> * which don't involve endpoints (or i/o).</i></td></tr>
<tr><th id="295">295</th><td><i> */</i></td></tr>
<tr><th id="296">296</th><td><b>struct</b> <dfn class="type def" id="usb_gadget_ops" title='usb_gadget_ops' data-ref="usb_gadget_ops">usb_gadget_ops</dfn> {</td></tr>
<tr><th id="297">297</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::get_frame" title='usb_gadget_ops::get_frame' data-ref="usb_gadget_ops::get_frame">get_frame</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="298">298</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::wakeup" title='usb_gadget_ops::wakeup' data-ref="usb_gadget_ops::wakeup">wakeup</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="299">299</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::set_selfpowered" title='usb_gadget_ops::set_selfpowered' data-ref="usb_gadget_ops::set_selfpowered">set_selfpowered</dfn>) (<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *, <em>int</em> <dfn class="local col8 decl" id="38is_selfpowered" title='is_selfpowered' data-type='int' data-ref="38is_selfpowered">is_selfpowered</dfn>);</td></tr>
<tr><th id="300">300</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::vbus_session" title='usb_gadget_ops::vbus_session' data-ref="usb_gadget_ops::vbus_session">vbus_session</dfn>) (<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *, <em>int</em> <dfn class="local col9 decl" id="39is_active" title='is_active' data-type='int' data-ref="39is_active">is_active</dfn>);</td></tr>
<tr><th id="301">301</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::vbus_draw" title='usb_gadget_ops::vbus_draw' data-ref="usb_gadget_ops::vbus_draw">vbus_draw</dfn>) (<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *, <em>unsigned</em> <dfn class="local col0 decl" id="40mA" title='mA' data-type='unsigned int' data-ref="40mA">mA</dfn>);</td></tr>
<tr><th id="302">302</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::pullup" title='usb_gadget_ops::pullup' data-ref="usb_gadget_ops::pullup">pullup</dfn>) (<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *, <em>int</em> <dfn class="local col1 decl" id="41is_on" title='is_on' data-type='int' data-ref="41is_on">is_on</dfn>);</td></tr>
<tr><th id="303">303</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::ioctl" title='usb_gadget_ops::ioctl' data-ref="usb_gadget_ops::ioctl">ioctl</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *,</td></tr>
<tr><th id="304">304</th><td>				<em>unsigned</em> <dfn class="local col2 decl" id="42code" title='code' data-type='unsigned int' data-ref="42code">code</dfn>, <em>unsigned</em> <em>long</em> <dfn class="local col3 decl" id="43param" title='param' data-type='unsigned long' data-ref="43param">param</dfn>);</td></tr>
<tr><th id="305">305</th><td>	<em>void</em>	(*<dfn class="decl field" id="usb_gadget_ops::get_config_params" title='usb_gadget_ops::get_config_params' data-ref="usb_gadget_ops::get_config_params">get_config_params</dfn>)(<b>struct</b> <a class="type" href="#usb_dcd_config_params" title='usb_dcd_config_params' data-ref="usb_dcd_config_params">usb_dcd_config_params</a> *);</td></tr>
<tr><th id="306">306</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::udc_start" title='usb_gadget_ops::udc_start' data-ref="usb_gadget_ops::udc_start">udc_start</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *,</td></tr>
<tr><th id="307">307</th><td>			<b>struct</b> <a class="type" href="#usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</a> *);</td></tr>
<tr><th id="308">308</th><td>	<em>int</em>	(*<dfn class="decl field" id="usb_gadget_ops::udc_stop" title='usb_gadget_ops::udc_stop' data-ref="usb_gadget_ops::udc_stop">udc_stop</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="309">309</th><td>	<em>void</em>	(*<dfn class="decl field" id="usb_gadget_ops::udc_set_speed" title='usb_gadget_ops::udc_set_speed' data-ref="usb_gadget_ops::udc_set_speed">udc_set_speed</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *, <b>enum</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_device_speed" title='usb_device_speed' data-ref="usb_device_speed">usb_device_speed</a>);</td></tr>
<tr><th id="310">310</th><td>	<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *(*<dfn class="decl field" id="usb_gadget_ops::match_ep" title='usb_gadget_ops::match_ep' data-ref="usb_gadget_ops::match_ep">match_ep</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *,</td></tr>
<tr><th id="311">311</th><td>			<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_descriptor" title='usb_endpoint_descriptor' data-ref="usb_endpoint_descriptor">usb_endpoint_descriptor</a> *,</td></tr>
<tr><th id="312">312</th><td>			<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_ss_ep_comp_descriptor" title='usb_ss_ep_comp_descriptor' data-ref="usb_ss_ep_comp_descriptor">usb_ss_ep_comp_descriptor</a> *);</td></tr>
<tr><th id="313">313</th><td>};</td></tr>
<tr><th id="314">314</th><td></td></tr>
<tr><th id="315">315</th><td><i class="doc">/**</i></td></tr>
<tr><th id="316">316</th><td><i class="doc"> * struct usb_gadget - represents a usb slave device</i></td></tr>
<tr><th id="317">317</th><td><i class="doc"> *<span class="command"> @work</span>: (internal use) Workqueue to be used for sysfs_notify()</i></td></tr>
<tr><th id="318">318</th><td><i class="doc"> *<span class="command"> @udc</span>: struct usb_udc pointer for this gadget</i></td></tr>
<tr><th id="319">319</th><td><i class="doc"> *<span class="command"> @ops</span>: Function pointers used to access hardware-specific operations.</i></td></tr>
<tr><th id="320">320</th><td><i class="doc"> *<span class="command"> @ep0</span>: Endpoint zero, used when reading or writing responses to</i></td></tr>
<tr><th id="321">321</th><td><i class="doc"> *	driver setup() requests</i></td></tr>
<tr><th id="322">322</th><td><i class="doc"> *<span class="command"> @ep</span>_list: List of other endpoints supported by the device.</i></td></tr>
<tr><th id="323">323</th><td><i class="doc"> *<span class="command"> @speed</span>: Speed of current connection to USB host.</i></td></tr>
<tr><th id="324">324</th><td><i class="doc"> *<span class="command"> @max</span>_speed: Maximal speed the UDC can handle.  UDC must support this</i></td></tr>
<tr><th id="325">325</th><td><i class="doc"> *      and all slower speeds.</i></td></tr>
<tr><th id="326">326</th><td><i class="doc"> *<span class="command"> @state</span>: the state we are now (attached, suspended, configured, etc)</i></td></tr>
<tr><th id="327">327</th><td><i class="doc"> * <span class="command">@name</span>:<span class="verb"> Identifies the controller hardware type.  Used in diagnostics</span></i></td></tr>
<tr><th id="328">328</th><td><i class="doc"> *	and sometimes configuration.</i></td></tr>
<tr><th id="329">329</th><td><i class="doc"> * <span class="command">@dev</span>:<span class="verb"> Driver model state for this abstract device.</span></i></td></tr>
<tr><th id="330">330</th><td><i class="doc"> *<span class="command"> @out</span>_epnum: last used out ep number</i></td></tr>
<tr><th id="331">331</th><td><i class="doc"> * <span class="command">@in</span>_<span class="verb">epnum: last used in ep number</span></i></td></tr>
<tr><th id="332">332</th><td><i class="doc"> *<span class="command"> @mA</span>: last set mA value</i></td></tr>
<tr><th id="333">333</th><td><i class="doc"> *<span class="command"> @otg</span>_caps: OTG capabilities of this gadget.</i></td></tr>
<tr><th id="334">334</th><td><i class="doc"> * <span class="command">@sg</span>_supported: true if we can handle scatter-gather</i></td></tr>
<tr><th id="335">335</th><td><i class="doc"> *<span class="command"> @is</span>_otg: True if the USB device port uses a Mini-AB jack, so that the</i></td></tr>
<tr><th id="336">336</th><td><i class="doc"> *	gadget driver must provide a USB OTG descriptor.</i></td></tr>
<tr><th id="337">337</th><td><i class="doc"> *<span class="command"> @is</span>_a_peripheral: False unless is_otg, the "A" end of a USB cable</i></td></tr>
<tr><th id="338">338</th><td><i class="doc"> *	is in the Mini-AB jack, and HNP has been used to switch roles</i></td></tr>
<tr><th id="339">339</th><td><i class="doc"> *	so that the "A" device currently acts as A-Peripheral, not A-Host.</i></td></tr>
<tr><th id="340">340</th><td><i class="doc"> *<span class="command"> @a</span><span class="arg">_hnp_support:</span> OTG device feature flag, indicating that the A-Host</i></td></tr>
<tr><th id="341">341</th><td><i class="doc"> *	supports HNP at this port.</i></td></tr>
<tr><th id="342">342</th><td><i class="doc"> *<span class="command"> @a</span><span class="arg">_alt_hnp_support:</span> OTG device feature flag, indicating that the A-Host</i></td></tr>
<tr><th id="343">343</th><td><i class="doc"> *	only supports HNP on a different root port.</i></td></tr>
<tr><th id="344">344</th><td><i class="doc"> *<span class="command"> @b</span><span class="arg">_hnp_enable:</span> OTG device feature flag, indicating that the A-Host</i></td></tr>
<tr><th id="345">345</th><td><i class="doc"> *	enabled HNP support.</i></td></tr>
<tr><th id="346">346</th><td><i class="doc"> *<span class="command"> @hnp</span>_polling_support: OTG device feature flag, indicating if the OTG device</i></td></tr>
<tr><th id="347">347</th><td><i class="doc"> *	in peripheral mode can support HNP polling.</i></td></tr>
<tr><th id="348">348</th><td><i class="doc"> * <span class="command">@host</span>_request_flag: OTG device feature flag, indicating if A-Peripheral</i></td></tr>
<tr><th id="349">349</th><td><i class="doc"> *	or B-Peripheral wants to take host role.</i></td></tr>
<tr><th id="350">350</th><td><i class="doc"> *<span class="command"> @quirk</span>_ep_out_aligned_size: epout requires buffer size to be aligned to</i></td></tr>
<tr><th id="351">351</th><td><i class="doc"> *	MaxPacketSize.</i></td></tr>
<tr><th id="352">352</th><td><i class="doc"> *<span class="command"> @quirk</span>_avoids_skb_reserve: udc/platform wants to avoid skb_reserve() in</i></td></tr>
<tr><th id="353">353</th><td><i class="doc"> *	u_ether.c to improve performance.</i></td></tr>
<tr><th id="354">354</th><td><i class="doc"> *<span class="command"> @is</span>_selfpowered: if the gadget is self-powered.</i></td></tr>
<tr><th id="355">355</th><td><i class="doc"> *<span class="command"> @deactivated</span>: True if gadget is deactivated - in deactivated state it cannot</i></td></tr>
<tr><th id="356">356</th><td><i class="doc"> *	be connected.</i></td></tr>
<tr><th id="357">357</th><td><i class="doc"> *<span class="command"> @connected</span>: True if gadget is connected.</i></td></tr>
<tr><th id="358">358</th><td><i class="doc"> *<span class="command"> @lpm</span>_capable: If the gadget max_speed is FULL or HIGH, this flag</i></td></tr>
<tr><th id="359">359</th><td><i class="doc"> *	indicates that it supports LPM as per the LPM ECN &amp; errata.</i></td></tr>
<tr><th id="360">360</th><td><i class="doc"> *</i></td></tr>
<tr><th id="361">361</th><td><i class="doc"> * Gadgets have a mostly-portable "gadget driver" implementing device</i></td></tr>
<tr><th id="362">362</th><td><i class="doc"> * functions, handling all usb configurations and interfaces.  Gadget</i></td></tr>
<tr><th id="363">363</th><td><i class="doc"> * drivers talk to hardware-specific code indirectly, through ops vectors.</i></td></tr>
<tr><th id="364">364</th><td><i class="doc"> * That insulates the gadget driver from hardware details, and packages</i></td></tr>
<tr><th id="365">365</th><td><i class="doc"> * the hardware endpoints through generic i/o queues.  The "usb_gadget"</i></td></tr>
<tr><th id="366">366</th><td><i class="doc"> * and "usb_ep" interfaces provide that insulation from the hardware.</i></td></tr>
<tr><th id="367">367</th><td><i class="doc"> *</i></td></tr>
<tr><th id="368">368</th><td><i class="doc"> * Except for the driver data, all fields in this structure are</i></td></tr>
<tr><th id="369">369</th><td><i class="doc"> * read-only to the gadget driver.  That driver data is part of the</i></td></tr>
<tr><th id="370">370</th><td><i class="doc"> * "driver model" infrastructure in 2.6 (and later) kernels, and for</i></td></tr>
<tr><th id="371">371</th><td><i class="doc"> * earlier systems is grouped in a similar structure that's not known</i></td></tr>
<tr><th id="372">372</th><td><i class="doc"> * to the rest of the kernel.</i></td></tr>
<tr><th id="373">373</th><td><i class="doc"> *</i></td></tr>
<tr><th id="374">374</th><td><i class="doc"> * Values of the three OTG device feature flags are updated before the</i></td></tr>
<tr><th id="375">375</th><td><i class="doc"> * setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before</i></td></tr>
<tr><th id="376">376</th><td><i class="doc"> * driver suspend() calls.  They are valid only when is_otg, and when the</i></td></tr>
<tr><th id="377">377</th><td><i class="doc"> * device is acting as a B-Peripheral (so is_a_peripheral is false).</i></td></tr>
<tr><th id="378">378</th><td><i class="doc"> */</i></td></tr>
<tr><th id="379">379</th><td><b>struct</b> <dfn class="type def" id="usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</dfn> {</td></tr>
<tr><th id="380">380</th><td>	<b>struct</b> <a class="type" href="../workqueue.h.html#work_struct" title='work_struct' data-ref="work_struct">work_struct</a>		<dfn class="decl field" id="usb_gadget::work" title='usb_gadget::work' data-ref="usb_gadget::work">work</dfn>;</td></tr>
<tr><th id="381">381</th><td>	<b>struct</b> <a class="type" href="#usb_udc" title='usb_udc' data-ref="usb_udc">usb_udc</a>			*<dfn class="decl field" id="usb_gadget::udc" title='usb_gadget::udc' data-ref="usb_gadget::udc">udc</dfn>;</td></tr>
<tr><th id="382">382</th><td>	<i>/* readonly to gadget driver */</i></td></tr>
<tr><th id="383">383</th><td>	<em>const</em> <b>struct</b> <a class="type" href="#usb_gadget_ops" title='usb_gadget_ops' data-ref="usb_gadget_ops">usb_gadget_ops</a>	*<dfn class="decl field" id="usb_gadget::ops" title='usb_gadget::ops' data-ref="usb_gadget::ops">ops</dfn>;</td></tr>
<tr><th id="384">384</th><td>	<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a>			*<dfn class="decl field" id="usb_gadget::ep0" title='usb_gadget::ep0' data-ref="usb_gadget::ep0">ep0</dfn>;</td></tr>
<tr><th id="385">385</th><td>	<b>struct</b> <a class="type" href="../types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a>		<dfn class="decl field" id="usb_gadget::ep_list" title='usb_gadget::ep_list' data-ref="usb_gadget::ep_list">ep_list</dfn>;	<i>/* of usb_ep */</i></td></tr>
<tr><th id="386">386</th><td>	<b>enum</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_device_speed" title='usb_device_speed' data-ref="usb_device_speed">usb_device_speed</a>		<dfn class="decl field" id="usb_gadget::speed" title='usb_gadget::speed' data-ref="usb_gadget::speed">speed</dfn>;</td></tr>
<tr><th id="387">387</th><td>	<b>enum</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_device_speed" title='usb_device_speed' data-ref="usb_device_speed">usb_device_speed</a>		<dfn class="decl field" id="usb_gadget::max_speed" title='usb_gadget::max_speed' data-ref="usb_gadget::max_speed">max_speed</dfn>;</td></tr>
<tr><th id="388">388</th><td>	<b>enum</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_device_state" title='usb_device_state' data-ref="usb_device_state">usb_device_state</a>		<dfn class="decl field" id="usb_gadget::state" title='usb_gadget::state' data-ref="usb_gadget::state">state</dfn>;</td></tr>
<tr><th id="389">389</th><td>	<em>const</em> <em>char</em>			*<dfn class="decl field" id="usb_gadget::name" title='usb_gadget::name' data-ref="usb_gadget::name">name</dfn>;</td></tr>
<tr><th id="390">390</th><td>	<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a>			<dfn class="decl field" id="usb_gadget::dev" title='usb_gadget::dev' data-ref="usb_gadget::dev">dev</dfn>;</td></tr>
<tr><th id="391">391</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::out_epnum" title='usb_gadget::out_epnum' data-ref="usb_gadget::out_epnum">out_epnum</dfn>;</td></tr>
<tr><th id="392">392</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::in_epnum" title='usb_gadget::in_epnum' data-ref="usb_gadget::in_epnum">in_epnum</dfn>;</td></tr>
<tr><th id="393">393</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::mA" title='usb_gadget::mA' data-ref="usb_gadget::mA">mA</dfn>;</td></tr>
<tr><th id="394">394</th><td>	<b>struct</b> <a class="type" href="otg.h.html#usb_otg_caps" title='usb_otg_caps' data-ref="usb_otg_caps" id="usb_otg_caps"><a class="type" href="otg.h.html#usb_otg_caps" title='usb_otg_caps' data-ref="usb_otg_caps">usb_otg_caps</a></a>		*<dfn class="decl field" id="usb_gadget::otg_caps" title='usb_gadget::otg_caps' data-ref="usb_gadget::otg_caps">otg_caps</dfn>;</td></tr>
<tr><th id="395">395</th><td></td></tr>
<tr><th id="396">396</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::sg_supported" title='usb_gadget::sg_supported' data-ref="usb_gadget::sg_supported">sg_supported</dfn>:<var>1</var>;</td></tr>
<tr><th id="397">397</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::is_otg" title='usb_gadget::is_otg' data-ref="usb_gadget::is_otg">is_otg</dfn>:<var>1</var>;</td></tr>
<tr><th id="398">398</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::is_a_peripheral" title='usb_gadget::is_a_peripheral' data-ref="usb_gadget::is_a_peripheral">is_a_peripheral</dfn>:<var>1</var>;</td></tr>
<tr><th id="399">399</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::b_hnp_enable" title='usb_gadget::b_hnp_enable' data-ref="usb_gadget::b_hnp_enable">b_hnp_enable</dfn>:<var>1</var>;</td></tr>
<tr><th id="400">400</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::a_hnp_support" title='usb_gadget::a_hnp_support' data-ref="usb_gadget::a_hnp_support">a_hnp_support</dfn>:<var>1</var>;</td></tr>
<tr><th id="401">401</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::a_alt_hnp_support" title='usb_gadget::a_alt_hnp_support' data-ref="usb_gadget::a_alt_hnp_support">a_alt_hnp_support</dfn>:<var>1</var>;</td></tr>
<tr><th id="402">402</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::hnp_polling_support" title='usb_gadget::hnp_polling_support' data-ref="usb_gadget::hnp_polling_support">hnp_polling_support</dfn>:<var>1</var>;</td></tr>
<tr><th id="403">403</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::host_request_flag" title='usb_gadget::host_request_flag' data-ref="usb_gadget::host_request_flag">host_request_flag</dfn>:<var>1</var>;</td></tr>
<tr><th id="404">404</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::quirk_ep_out_aligned_size" title='usb_gadget::quirk_ep_out_aligned_size' data-ref="usb_gadget::quirk_ep_out_aligned_size">quirk_ep_out_aligned_size</dfn>:<var>1</var>;</td></tr>
<tr><th id="405">405</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::quirk_altset_not_supp" title='usb_gadget::quirk_altset_not_supp' data-ref="usb_gadget::quirk_altset_not_supp">quirk_altset_not_supp</dfn>:<var>1</var>;</td></tr>
<tr><th id="406">406</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::quirk_stall_not_supp" title='usb_gadget::quirk_stall_not_supp' data-ref="usb_gadget::quirk_stall_not_supp">quirk_stall_not_supp</dfn>:<var>1</var>;</td></tr>
<tr><th id="407">407</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::quirk_zlp_not_supp" title='usb_gadget::quirk_zlp_not_supp' data-ref="usb_gadget::quirk_zlp_not_supp">quirk_zlp_not_supp</dfn>:<var>1</var>;</td></tr>
<tr><th id="408">408</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::quirk_avoids_skb_reserve" title='usb_gadget::quirk_avoids_skb_reserve' data-ref="usb_gadget::quirk_avoids_skb_reserve">quirk_avoids_skb_reserve</dfn>:<var>1</var>;</td></tr>
<tr><th id="409">409</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::is_selfpowered" title='usb_gadget::is_selfpowered' data-ref="usb_gadget::is_selfpowered">is_selfpowered</dfn>:<var>1</var>;</td></tr>
<tr><th id="410">410</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::deactivated" title='usb_gadget::deactivated' data-ref="usb_gadget::deactivated">deactivated</dfn>:<var>1</var>;</td></tr>
<tr><th id="411">411</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::connected" title='usb_gadget::connected' data-ref="usb_gadget::connected">connected</dfn>:<var>1</var>;</td></tr>
<tr><th id="412">412</th><td>	<em>unsigned</em>			<dfn class="decl field" id="usb_gadget::lpm_capable" title='usb_gadget::lpm_capable' data-ref="usb_gadget::lpm_capable">lpm_capable</dfn>:<var>1</var>;</td></tr>
<tr><th id="413">413</th><td>};</td></tr>
<tr><th id="414">414</th><td><u>#define <dfn class="macro" id="_M/work_to_gadget" data-ref="_M/work_to_gadget">work_to_gadget</dfn>(w)	(container_of((w), struct usb_gadget, work))</u></td></tr>
<tr><th id="415">415</th><td></td></tr>
<tr><th id="416">416</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> <dfn class="decl def fn" id="set_gadget_data" title='set_gadget_data' data-ref="set_gadget_data">set_gadget_data</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col4 decl" id="44gadget" title='gadget' data-type='struct usb_gadget *' data-ref="44gadget">gadget</dfn>, <em>void</em> *<dfn class="local col5 decl" id="45data" title='data' data-type='void *' data-ref="45data">data</dfn>)</td></tr>
<tr><th id="417">417</th><td>	{ <a class="ref fn" href="../device.h.html#dev_set_drvdata" title='dev_set_drvdata' data-ref="dev_set_drvdata">dev_set_drvdata</a>(&amp;<a class="local col4 ref" href="#44gadget" title='gadget' data-ref="44gadget">gadget</a>-&gt;<a class="ref field" href="#usb_gadget::dev" title='usb_gadget::dev' data-ref="usb_gadget::dev">dev</a>, <a class="local col5 ref" href="#45data" title='data' data-ref="45data">data</a>); }</td></tr>
<tr><th id="418">418</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> *<dfn class="decl def fn" id="get_gadget_data" title='get_gadget_data' data-ref="get_gadget_data">get_gadget_data</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col6 decl" id="46gadget" title='gadget' data-type='struct usb_gadget *' data-ref="46gadget">gadget</dfn>)</td></tr>
<tr><th id="419">419</th><td>	{ <b>return</b> <a class="ref fn" href="../device.h.html#dev_get_drvdata" title='dev_get_drvdata' data-ref="dev_get_drvdata">dev_get_drvdata</a>(&amp;<a class="local col6 ref" href="#46gadget" title='gadget' data-ref="46gadget">gadget</a>-&gt;<a class="ref field" href="#usb_gadget::dev" title='usb_gadget::dev' data-ref="usb_gadget::dev">dev</a>); }</td></tr>
<tr><th id="420">420</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="decl def fn" id="dev_to_usb_gadget" title='dev_to_usb_gadget' data-ref="dev_to_usb_gadget">dev_to_usb_gadget</dfn>(<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a> *<dfn class="local col7 decl" id="47dev" title='dev' data-type='struct device *' data-ref="47dev">dev</dfn>)</td></tr>
<tr><th id="421">421</th><td>{</td></tr>
<tr><th id="422">422</th><td>	<b>return</b> <a class="macro" href="../kernel.h.html#927" title="({ void *__mptr = (void *)(dev); do { bool __cond = !(!(!__builtin_types_compatible_p(typeof(*(dev)), typeof(((struct usb_gadget *)0)-&gt;dev)) &amp;&amp; !__builtin_types_compatible_p(typeof(*(dev)), typeof(void)))); extern void __compiletime_assert_422(void) ; if (__cond) __compiletime_assert_422(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ((struct usb_gadget *)(__mptr - __builtin_offsetof(struct usb_gadget, dev))); })" data-ref="_M/container_of">container_of</a>(<a class="local col7 ref" href="#47dev" title='dev' data-ref="47dev">dev</a>, <b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a>, <a class="ref field" href="#usb_gadget::dev" title='usb_gadget::dev' data-ref="usb_gadget::dev">dev</a>);</td></tr>
<tr><th id="423">423</th><td>}</td></tr>
<tr><th id="424">424</th><td></td></tr>
<tr><th id="425">425</th><td><i>/* iterates the non-control endpoints; 'tmp' is a struct usb_ep pointer */</i></td></tr>
<tr><th id="426">426</th><td><u>#define <dfn class="macro" id="_M/gadget_for_each_ep" data-ref="_M/gadget_for_each_ep">gadget_for_each_ep</dfn>(tmp, gadget) \</u></td></tr>
<tr><th id="427">427</th><td><u>	list_for_each_entry(tmp, &amp;(gadget)-&gt;ep_list, ep_list)</u></td></tr>
<tr><th id="428">428</th><td></td></tr>
<tr><th id="429">429</th><td><i class="doc">/**</i></td></tr>
<tr><th id="430">430</th><td><i class="doc"> * usb_ep_align - returns<span class="command"> @len</span> aligned to ep's maxpacketsize.</i></td></tr>
<tr><th id="431">431</th><td><i class="doc"> *<span class="command"> @ep</span>: the endpoint whose maxpacketsize is used to align<span class="command"> @len</span></i></td></tr>
<tr><th id="432">432</th><td><i class="doc"> *<span class="command"> @len</span>: buffer size's length to align to<span class="command"> @ep</span>'s maxpacketsize</i></td></tr>
<tr><th id="433">433</th><td><i class="doc"> *</i></td></tr>
<tr><th id="434">434</th><td><i class="doc"> * This helper is used to align buffer's size to an ep's maxpacketsize.</i></td></tr>
<tr><th id="435">435</th><td><i class="doc"> */</i></td></tr>
<tr><th id="436">436</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <a class="typedef" href="../types.h.html#size_t" title='size_t' data-type='__kernel_size_t' data-ref="size_t">size_t</a> <dfn class="decl def fn" id="usb_ep_align" title='usb_ep_align' data-ref="usb_ep_align">usb_ep_align</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col8 decl" id="48ep" title='ep' data-type='struct usb_ep *' data-ref="48ep">ep</dfn>, <a class="typedef" href="../types.h.html#size_t" title='size_t' data-type='__kernel_size_t' data-ref="size_t">size_t</a> <dfn class="local col9 decl" id="49len" title='len' data-type='size_t' data-ref="49len">len</dfn>)</td></tr>
<tr><th id="437">437</th><td>{</td></tr>
<tr><th id="438">438</th><td>	<em>int</em> <dfn class="local col0 decl" id="50max_packet_size" title='max_packet_size' data-type='int' data-ref="50max_packet_size">max_packet_size</dfn> = (<a class="typedef" href="../types.h.html#size_t" title='size_t' data-type='__kernel_size_t' data-ref="size_t">size_t</a>)<a class="ref fn" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_maxp" title='usb_endpoint_maxp' data-ref="usb_endpoint_maxp">usb_endpoint_maxp</a>(<a class="local col8 ref" href="#48ep" title='ep' data-ref="48ep">ep</a>-&gt;<a class="ref field" href="#usb_ep::desc" title='usb_ep::desc' data-ref="usb_ep::desc">desc</a>) &amp; <var>0x7ff</var>;</td></tr>
<tr><th id="439">439</th><td></td></tr>
<tr><th id="440">440</th><td>	<b>return</b> <a class="macro" href="../kernel.h.html#87" title="((((len)-1) | ((__typeof__(len))((max_packet_size)-1)))+1)" data-ref="_M/round_up">round_up</a>(<a class="local col9 ref" href="#49len" title='len' data-ref="49len">len</a>, <a class="local col0 ref" href="#50max_packet_size" title='max_packet_size' data-ref="50max_packet_size">max_packet_size</a>);</td></tr>
<tr><th id="441">441</th><td>}</td></tr>
<tr><th id="442">442</th><td></td></tr>
<tr><th id="443">443</th><td><i class="doc">/**</i></td></tr>
<tr><th id="444">444</th><td><i class="doc"> * usb_ep_align_maybe - returns<span class="command"> @len</span> aligned to ep's maxpacketsize if gadget</i></td></tr>
<tr><th id="445">445</th><td><i class="doc"> *	requires quirk_ep_out_aligned_size, otherwise returns len.</i></td></tr>
<tr><th id="446">446</th><td><i class="doc"> *<span class="command"> @g</span>: controller to check for quirk</i></td></tr>
<tr><th id="447">447</th><td><i class="doc"> *<span class="command"> @ep</span>: the endpoint whose maxpacketsize is used to align<span class="command"> @len</span></i></td></tr>
<tr><th id="448">448</th><td><i class="doc"> *<span class="command"> @len</span>: buffer size's length to align to<span class="command"> @ep</span>'s maxpacketsize</i></td></tr>
<tr><th id="449">449</th><td><i class="doc"> *</i></td></tr>
<tr><th id="450">450</th><td><i class="doc"> * This helper is used in case it's required for any reason to check and maybe</i></td></tr>
<tr><th id="451">451</th><td><i class="doc"> * align buffer's size to an ep's maxpacketsize.</i></td></tr>
<tr><th id="452">452</th><td><i class="doc"> */</i></td></tr>
<tr><th id="453">453</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <a class="typedef" href="../types.h.html#size_t" title='size_t' data-type='__kernel_size_t' data-ref="size_t">size_t</a></td></tr>
<tr><th id="454">454</th><td><dfn class="decl def fn" id="usb_ep_align_maybe" title='usb_ep_align_maybe' data-ref="usb_ep_align_maybe">usb_ep_align_maybe</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col1 decl" id="51g" title='g' data-type='struct usb_gadget *' data-ref="51g">g</dfn>, <b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col2 decl" id="52ep" title='ep' data-type='struct usb_ep *' data-ref="52ep">ep</dfn>, <a class="typedef" href="../types.h.html#size_t" title='size_t' data-type='__kernel_size_t' data-ref="size_t">size_t</a> <dfn class="local col3 decl" id="53len" title='len' data-type='size_t' data-ref="53len">len</dfn>)</td></tr>
<tr><th id="455">455</th><td>{</td></tr>
<tr><th id="456">456</th><td>	<b>return</b> <a class="local col1 ref" href="#51g" title='g' data-ref="51g">g</a>-&gt;<a class="ref field" href="#usb_gadget::quirk_ep_out_aligned_size" title='usb_gadget::quirk_ep_out_aligned_size' data-ref="usb_gadget::quirk_ep_out_aligned_size">quirk_ep_out_aligned_size</a> ? <a class="ref fn" href="#usb_ep_align" title='usb_ep_align' data-ref="usb_ep_align">usb_ep_align</a>(<a class="local col2 ref" href="#52ep" title='ep' data-ref="52ep">ep</a>, <a class="local col3 ref" href="#53len" title='len' data-ref="53len">len</a>) : <a class="local col3 ref" href="#53len" title='len' data-ref="53len">len</a>;</td></tr>
<tr><th id="457">457</th><td>}</td></tr>
<tr><th id="458">458</th><td></td></tr>
<tr><th id="459">459</th><td><i class="doc">/**</i></td></tr>
<tr><th id="460">460</th><td><i class="doc"> * gadget_is_altset_supported - return true iff the hardware supports</i></td></tr>
<tr><th id="461">461</th><td><i class="doc"> *	altsettings</i></td></tr>
<tr><th id="462">462</th><td><i class="doc"> *<span class="command"> @g</span>: controller to check for quirk</i></td></tr>
<tr><th id="463">463</th><td><i class="doc"> */</i></td></tr>
<tr><th id="464">464</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_altset_supported" title='gadget_is_altset_supported' data-ref="gadget_is_altset_supported">gadget_is_altset_supported</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col4 decl" id="54g" title='g' data-type='struct usb_gadget *' data-ref="54g">g</dfn>)</td></tr>
<tr><th id="465">465</th><td>{</td></tr>
<tr><th id="466">466</th><td>	<b>return</b> !<a class="local col4 ref" href="#54g" title='g' data-ref="54g">g</a>-&gt;<a class="ref field" href="#usb_gadget::quirk_altset_not_supp" title='usb_gadget::quirk_altset_not_supp' data-ref="usb_gadget::quirk_altset_not_supp">quirk_altset_not_supp</a>;</td></tr>
<tr><th id="467">467</th><td>}</td></tr>
<tr><th id="468">468</th><td></td></tr>
<tr><th id="469">469</th><td><i class="doc">/**</i></td></tr>
<tr><th id="470">470</th><td><i class="doc"> * gadget_is_stall_supported - return true iff the hardware supports stalling</i></td></tr>
<tr><th id="471">471</th><td><i class="doc"> *<span class="command"> @g</span>: controller to check for quirk</i></td></tr>
<tr><th id="472">472</th><td><i class="doc"> */</i></td></tr>
<tr><th id="473">473</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_stall_supported" title='gadget_is_stall_supported' data-ref="gadget_is_stall_supported">gadget_is_stall_supported</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col5 decl" id="55g" title='g' data-type='struct usb_gadget *' data-ref="55g">g</dfn>)</td></tr>
<tr><th id="474">474</th><td>{</td></tr>
<tr><th id="475">475</th><td>	<b>return</b> !<a class="local col5 ref" href="#55g" title='g' data-ref="55g">g</a>-&gt;<a class="ref field" href="#usb_gadget::quirk_stall_not_supp" title='usb_gadget::quirk_stall_not_supp' data-ref="usb_gadget::quirk_stall_not_supp">quirk_stall_not_supp</a>;</td></tr>
<tr><th id="476">476</th><td>}</td></tr>
<tr><th id="477">477</th><td></td></tr>
<tr><th id="478">478</th><td><i class="doc">/**</i></td></tr>
<tr><th id="479">479</th><td><i class="doc"> * gadget_is_zlp_supported - return true iff the hardware supports zlp</i></td></tr>
<tr><th id="480">480</th><td><i class="doc"> *<span class="command"> @g</span>: controller to check for quirk</i></td></tr>
<tr><th id="481">481</th><td><i class="doc"> */</i></td></tr>
<tr><th id="482">482</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_zlp_supported" title='gadget_is_zlp_supported' data-ref="gadget_is_zlp_supported">gadget_is_zlp_supported</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col6 decl" id="56g" title='g' data-type='struct usb_gadget *' data-ref="56g">g</dfn>)</td></tr>
<tr><th id="483">483</th><td>{</td></tr>
<tr><th id="484">484</th><td>	<b>return</b> !<a class="local col6 ref" href="#56g" title='g' data-ref="56g">g</a>-&gt;<a class="ref field" href="#usb_gadget::quirk_zlp_not_supp" title='usb_gadget::quirk_zlp_not_supp' data-ref="usb_gadget::quirk_zlp_not_supp">quirk_zlp_not_supp</a>;</td></tr>
<tr><th id="485">485</th><td>}</td></tr>
<tr><th id="486">486</th><td></td></tr>
<tr><th id="487">487</th><td><i class="doc">/**</i></td></tr>
<tr><th id="488">488</th><td><i class="doc"> * gadget_avoids_skb_reserve - return true iff the hardware would like to avoid</i></td></tr>
<tr><th id="489">489</th><td><i class="doc"> *	skb_reserve to improve performance.</i></td></tr>
<tr><th id="490">490</th><td><i class="doc"> *<span class="command"> @g</span>: controller to check for quirk</i></td></tr>
<tr><th id="491">491</th><td><i class="doc"> */</i></td></tr>
<tr><th id="492">492</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_avoids_skb_reserve" title='gadget_avoids_skb_reserve' data-ref="gadget_avoids_skb_reserve">gadget_avoids_skb_reserve</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col7 decl" id="57g" title='g' data-type='struct usb_gadget *' data-ref="57g">g</dfn>)</td></tr>
<tr><th id="493">493</th><td>{</td></tr>
<tr><th id="494">494</th><td>	<b>return</b> <a class="local col7 ref" href="#57g" title='g' data-ref="57g">g</a>-&gt;<a class="ref field" href="#usb_gadget::quirk_avoids_skb_reserve" title='usb_gadget::quirk_avoids_skb_reserve' data-ref="usb_gadget::quirk_avoids_skb_reserve">quirk_avoids_skb_reserve</a>;</td></tr>
<tr><th id="495">495</th><td>}</td></tr>
<tr><th id="496">496</th><td></td></tr>
<tr><th id="497">497</th><td><i class="doc">/**</i></td></tr>
<tr><th id="498">498</th><td><i class="doc"> * gadget_is_dualspeed - return true iff the hardware handles high speed</i></td></tr>
<tr><th id="499">499</th><td><i class="doc"> *<span class="command"> @g</span>: controller that might support both high and full speeds</i></td></tr>
<tr><th id="500">500</th><td><i class="doc"> */</i></td></tr>
<tr><th id="501">501</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_dualspeed" title='gadget_is_dualspeed' data-ref="gadget_is_dualspeed">gadget_is_dualspeed</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col8 decl" id="58g" title='g' data-type='struct usb_gadget *' data-ref="58g">g</dfn>)</td></tr>
<tr><th id="502">502</th><td>{</td></tr>
<tr><th id="503">503</th><td>	<b>return</b> <a class="local col8 ref" href="#58g" title='g' data-ref="58g">g</a>-&gt;<a class="ref field" href="#usb_gadget::max_speed" title='usb_gadget::max_speed' data-ref="usb_gadget::max_speed">max_speed</a> &gt;= <a class="enum" href="../../uapi/linux/usb/ch9.h.html#USB_SPEED_HIGH" title='USB_SPEED_HIGH' data-ref="USB_SPEED_HIGH">USB_SPEED_HIGH</a>;</td></tr>
<tr><th id="504">504</th><td>}</td></tr>
<tr><th id="505">505</th><td></td></tr>
<tr><th id="506">506</th><td><i class="doc">/**</i></td></tr>
<tr><th id="507">507</th><td><i class="doc"> * gadget_is_superspeed() - return true if the hardware handles superspeed</i></td></tr>
<tr><th id="508">508</th><td><i class="doc"> *<span class="command"> @g</span>: controller that might support superspeed</i></td></tr>
<tr><th id="509">509</th><td><i class="doc"> */</i></td></tr>
<tr><th id="510">510</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_superspeed" title='gadget_is_superspeed' data-ref="gadget_is_superspeed">gadget_is_superspeed</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col9 decl" id="59g" title='g' data-type='struct usb_gadget *' data-ref="59g">g</dfn>)</td></tr>
<tr><th id="511">511</th><td>{</td></tr>
<tr><th id="512">512</th><td>	<b>return</b> <a class="local col9 ref" href="#59g" title='g' data-ref="59g">g</a>-&gt;<a class="ref field" href="#usb_gadget::max_speed" title='usb_gadget::max_speed' data-ref="usb_gadget::max_speed">max_speed</a> &gt;= <a class="enum" href="../../uapi/linux/usb/ch9.h.html#USB_SPEED_SUPER" title='USB_SPEED_SUPER' data-ref="USB_SPEED_SUPER">USB_SPEED_SUPER</a>;</td></tr>
<tr><th id="513">513</th><td>}</td></tr>
<tr><th id="514">514</th><td></td></tr>
<tr><th id="515">515</th><td><i class="doc">/**</i></td></tr>
<tr><th id="516">516</th><td><i class="doc"> * gadget_is_superspeed_plus() - return true if the hardware handles</i></td></tr>
<tr><th id="517">517</th><td><i class="doc"> *	superspeed plus</i></td></tr>
<tr><th id="518">518</th><td><i class="doc"> *<span class="command"> @g</span>: controller that might support superspeed plus</i></td></tr>
<tr><th id="519">519</th><td><i class="doc"> */</i></td></tr>
<tr><th id="520">520</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_superspeed_plus" title='gadget_is_superspeed_plus' data-ref="gadget_is_superspeed_plus">gadget_is_superspeed_plus</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col0 decl" id="60g" title='g' data-type='struct usb_gadget *' data-ref="60g">g</dfn>)</td></tr>
<tr><th id="521">521</th><td>{</td></tr>
<tr><th id="522">522</th><td>	<b>return</b> <a class="local col0 ref" href="#60g" title='g' data-ref="60g">g</a>-&gt;<a class="ref field" href="#usb_gadget::max_speed" title='usb_gadget::max_speed' data-ref="usb_gadget::max_speed">max_speed</a> &gt;= <a class="enum" href="../../uapi/linux/usb/ch9.h.html#USB_SPEED_SUPER_PLUS" title='USB_SPEED_SUPER_PLUS' data-ref="USB_SPEED_SUPER_PLUS">USB_SPEED_SUPER_PLUS</a>;</td></tr>
<tr><th id="523">523</th><td>}</td></tr>
<tr><th id="524">524</th><td></td></tr>
<tr><th id="525">525</th><td><i class="doc">/**</i></td></tr>
<tr><th id="526">526</th><td><i class="doc"> * gadget_is_otg - return true iff the hardware is OTG-ready</i></td></tr>
<tr><th id="527">527</th><td><i class="doc"> *<span class="command"> @g</span>: controller that might have a Mini-AB connector</i></td></tr>
<tr><th id="528">528</th><td><i class="doc"> *</i></td></tr>
<tr><th id="529">529</th><td><i class="doc"> * This is a runtime test, since kernels with a USB-OTG stack sometimes</i></td></tr>
<tr><th id="530">530</th><td><i class="doc"> * run on boards which only have a Mini-B (or Mini-A) connector.</i></td></tr>
<tr><th id="531">531</th><td><i class="doc"> */</i></td></tr>
<tr><th id="532">532</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="gadget_is_otg" title='gadget_is_otg' data-ref="gadget_is_otg">gadget_is_otg</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col1 decl" id="61g" title='g' data-type='struct usb_gadget *' data-ref="61g">g</dfn>)</td></tr>
<tr><th id="533">533</th><td>{</td></tr>
<tr><th id="534">534</th><td><u>#<span data-ppcond="534">ifdef</span> <span class="macro" data-ref="_M/CONFIG_USB_OTG">CONFIG_USB_OTG</span></u></td></tr>
<tr><th id="535">535</th><td>	<b>return</b> g-&gt;is_otg;</td></tr>
<tr><th id="536">536</th><td><u>#<span data-ppcond="534">else</span></u></td></tr>
<tr><th id="537">537</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="538">538</th><td><u>#<span data-ppcond="534">endif</span></u></td></tr>
<tr><th id="539">539</th><td>}</td></tr>
<tr><th id="540">540</th><td></td></tr>
<tr><th id="541">541</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="542">542</th><td></td></tr>
<tr><th id="543">543</th><td><u>#<span data-ppcond="543">if</span> <a class="macro" href="../kconfig.h.html#71" title="1" data-ref="_M/IS_ENABLED">IS_ENABLED</a>(<a class="macro" href="../../generated/autoconf.h.html#554" title="1" data-ref="_M/CONFIG_USB_GADGET">CONFIG_USB_GADGET</a>)</u></td></tr>
<tr><th id="544">544</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_frame_number" title='usb_gadget_frame_number' data-ref="usb_gadget_frame_number">usb_gadget_frame_number</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col2 decl" id="62gadget" title='gadget' data-type='struct usb_gadget *' data-ref="62gadget">gadget</dfn>);</td></tr>
<tr><th id="545">545</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_wakeup" title='usb_gadget_wakeup' data-ref="usb_gadget_wakeup">usb_gadget_wakeup</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col3 decl" id="63gadget" title='gadget' data-type='struct usb_gadget *' data-ref="63gadget">gadget</dfn>);</td></tr>
<tr><th id="546">546</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_set_selfpowered" title='usb_gadget_set_selfpowered' data-ref="usb_gadget_set_selfpowered">usb_gadget_set_selfpowered</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col4 decl" id="64gadget" title='gadget' data-type='struct usb_gadget *' data-ref="64gadget">gadget</dfn>);</td></tr>
<tr><th id="547">547</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_clear_selfpowered" title='usb_gadget_clear_selfpowered' data-ref="usb_gadget_clear_selfpowered">usb_gadget_clear_selfpowered</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col5 decl" id="65gadget" title='gadget' data-type='struct usb_gadget *' data-ref="65gadget">gadget</dfn>);</td></tr>
<tr><th id="548">548</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_vbus_connect" title='usb_gadget_vbus_connect' data-ref="usb_gadget_vbus_connect">usb_gadget_vbus_connect</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col6 decl" id="66gadget" title='gadget' data-type='struct usb_gadget *' data-ref="66gadget">gadget</dfn>);</td></tr>
<tr><th id="549">549</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_vbus_draw" title='usb_gadget_vbus_draw' data-ref="usb_gadget_vbus_draw">usb_gadget_vbus_draw</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col7 decl" id="67gadget" title='gadget' data-type='struct usb_gadget *' data-ref="67gadget">gadget</dfn>, <em>unsigned</em> <dfn class="local col8 decl" id="68mA" title='mA' data-type='unsigned int' data-ref="68mA">mA</dfn>);</td></tr>
<tr><th id="550">550</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_vbus_disconnect" title='usb_gadget_vbus_disconnect' data-ref="usb_gadget_vbus_disconnect">usb_gadget_vbus_disconnect</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col9 decl" id="69gadget" title='gadget' data-type='struct usb_gadget *' data-ref="69gadget">gadget</dfn>);</td></tr>
<tr><th id="551">551</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_connect" title='usb_gadget_connect' data-ref="usb_gadget_connect">usb_gadget_connect</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col0 decl" id="70gadget" title='gadget' data-type='struct usb_gadget *' data-ref="70gadget">gadget</dfn>);</td></tr>
<tr><th id="552">552</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_disconnect" title='usb_gadget_disconnect' data-ref="usb_gadget_disconnect">usb_gadget_disconnect</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col1 decl" id="71gadget" title='gadget' data-type='struct usb_gadget *' data-ref="71gadget">gadget</dfn>);</td></tr>
<tr><th id="553">553</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_deactivate" title='usb_gadget_deactivate' data-ref="usb_gadget_deactivate">usb_gadget_deactivate</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col2 decl" id="72gadget" title='gadget' data-type='struct usb_gadget *' data-ref="72gadget">gadget</dfn>);</td></tr>
<tr><th id="554">554</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_activate" title='usb_gadget_activate' data-ref="usb_gadget_activate">usb_gadget_activate</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col3 decl" id="73gadget" title='gadget' data-type='struct usb_gadget *' data-ref="73gadget">gadget</dfn>);</td></tr>
<tr><th id="555">555</th><td><u>#<span data-ppcond="543">else</span></u></td></tr>
<tr><th id="556">556</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_frame_number(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="557">557</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="558">558</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_wakeup(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="559">559</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="560">560</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_set_selfpowered(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="561">561</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="562">562</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_clear_selfpowered(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="563">563</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="564">564</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_vbus_connect(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="565">565</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="566">566</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_vbus_draw(<b>struct</b> usb_gadget *gadget, <em>unsigned</em> mA)</td></tr>
<tr><th id="567">567</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="568">568</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_vbus_disconnect(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="569">569</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="570">570</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_connect(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="571">571</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="572">572</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_disconnect(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="573">573</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="574">574</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_deactivate(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="575">575</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="576">576</th><td><em>static</em> <b>inline</b> <em>int</em> usb_gadget_activate(<b>struct</b> usb_gadget *gadget)</td></tr>
<tr><th id="577">577</th><td>{ <b>return</b> <var>0</var>; }</td></tr>
<tr><th id="578">578</th><td><u>#<span data-ppcond="543">endif</span> /* CONFIG_USB_GADGET */</u></td></tr>
<tr><th id="579">579</th><td></td></tr>
<tr><th id="580">580</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="581">581</th><td></td></tr>
<tr><th id="582">582</th><td><i class="doc">/**</i></td></tr>
<tr><th id="583">583</th><td><i class="doc"> * struct usb_gadget_driver - driver for usb 'slave' devices</i></td></tr>
<tr><th id="584">584</th><td><i class="doc"> * <span class="command">@function</span>:<span class="verb"> String describing the gadget's function</span></i></td></tr>
<tr><th id="585">585</th><td><i class="doc"> *<span class="command"> @max</span>_speed: Highest speed the driver handles.</i></td></tr>
<tr><th id="586">586</th><td><i class="doc"> *<span class="command"> @setup</span>: Invoked for ep0 control requests that aren't handled by</i></td></tr>
<tr><th id="587">587</th><td><i class="doc"> *	the hardware level driver. Most calls must be handled by</i></td></tr>
<tr><th id="588">588</th><td><i class="doc"> *	the gadget driver, including descriptor and configuration</i></td></tr>
<tr><th id="589">589</th><td><i class="doc"> *	management.  The 16 bit members of the setup data are in</i></td></tr>
<tr><th id="590">590</th><td><i class="doc"> *	USB byte order. Called in_interrupt; this may not sleep.  Driver</i></td></tr>
<tr><th id="591">591</th><td><i class="doc"> *	queues a response to ep0, or returns negative to stall.</i></td></tr>
<tr><th id="592">592</th><td><i class="doc"> *<span class="command"> @disconnect</span>: Invoked after all transfers have been stopped,</i></td></tr>
<tr><th id="593">593</th><td><i class="doc"> *	when the host is disconnected.  May be called in_interrupt; this</i></td></tr>
<tr><th id="594">594</th><td><i class="doc"> *	may not sleep.  Some devices can't detect disconnect, so this might</i></td></tr>
<tr><th id="595">595</th><td><i class="doc"> *	not be called except as part of controller shutdown.</i></td></tr>
<tr><th id="596">596</th><td><i class="doc"> *<span class="command"> @bind</span>: the driver's bind callback</i></td></tr>
<tr><th id="597">597</th><td><i class="doc"> *<span class="command"> @unbind</span>: Invoked when the driver is unbound from a gadget,</i></td></tr>
<tr><th id="598">598</th><td><i class="doc"> *	usually from rmmod (after a disconnect is reported).</i></td></tr>
<tr><th id="599">599</th><td><i class="doc"> *	Called in a context that permits sleeping.</i></td></tr>
<tr><th id="600">600</th><td><i class="doc"> *<span class="command"> @suspend</span>: Invoked on USB suspend.  May be called in_interrupt.</i></td></tr>
<tr><th id="601">601</th><td><i class="doc"> *<span class="command"> @resume</span>: Invoked on USB resume.  May be called in_interrupt.</i></td></tr>
<tr><th id="602">602</th><td><i class="doc"> *<span class="command"> @reset</span>: Invoked on USB bus reset. It is mandatory for all gadget drivers</i></td></tr>
<tr><th id="603">603</th><td><i class="doc"> *	and should be called in_interrupt.</i></td></tr>
<tr><th id="604">604</th><td><i class="doc"> *<span class="command"> @driver</span>: Driver model state for this driver.</i></td></tr>
<tr><th id="605">605</th><td><i class="doc"> *<span class="command"> @udc</span>_name: A name of UDC this driver should be bound to. If udc_name is NULL,</i></td></tr>
<tr><th id="606">606</th><td><i class="doc"> *	this driver will be bound to any available UDC.</i></td></tr>
<tr><th id="607">607</th><td><i class="doc"> *<span class="command"> @pending</span>: UDC core private data used for deferred probe of this driver.</i></td></tr>
<tr><th id="608">608</th><td><i class="doc"> *<span class="command"> @match</span>_existing_only: If udc is not found, return an error and don't add this</i></td></tr>
<tr><th id="609">609</th><td><i class="doc"> *      gadget driver to list of pending driver</i></td></tr>
<tr><th id="610">610</th><td><i class="doc"> *</i></td></tr>
<tr><th id="611">611</th><td><i class="doc"> * Devices are disabled till a gadget driver successfully bind()s, which</i></td></tr>
<tr><th id="612">612</th><td><i class="doc"> * means the driver will handle setup() requests needed to enumerate (and</i></td></tr>
<tr><th id="613">613</th><td><i class="doc"> * meet "chapter 9" requirements) then do some useful work.</i></td></tr>
<tr><th id="614">614</th><td><i class="doc"> *</i></td></tr>
<tr><th id="615">615</th><td><i class="doc"> * If gadget-&gt;is_otg is true, the gadget driver must provide an OTG</i></td></tr>
<tr><th id="616">616</th><td><i class="doc"> * descriptor during enumeration, or else fail the bind() call.  In such</i></td></tr>
<tr><th id="617">617</th><td><i class="doc"> * cases, no USB traffic may flow until both bind() returns without</i></td></tr>
<tr><th id="618">618</th><td><i class="doc"> * having called usb_gadget_disconnect(), and the USB host stack has</i></td></tr>
<tr><th id="619">619</th><td><i class="doc"> * initialized.</i></td></tr>
<tr><th id="620">620</th><td><i class="doc"> *</i></td></tr>
<tr><th id="621">621</th><td><i class="doc"> * Drivers use hardware-specific knowledge to configure the usb hardware.</i></td></tr>
<tr><th id="622">622</th><td><i class="doc"> * endpoint addressing is only one of several hardware characteristics that</i></td></tr>
<tr><th id="623">623</th><td><i class="doc"> * are in descriptors the ep0 implementation returns from setup() calls.</i></td></tr>
<tr><th id="624">624</th><td><i class="doc"> *</i></td></tr>
<tr><th id="625">625</th><td><i class="doc"> * Except for ep0 implementation, most driver code shouldn't need change to</i></td></tr>
<tr><th id="626">626</th><td><i class="doc"> * run on top of different usb controllers.  It'll use endpoints set up by</i></td></tr>
<tr><th id="627">627</th><td><i class="doc"> * that ep0 implementation.</i></td></tr>
<tr><th id="628">628</th><td><i class="doc"> *</i></td></tr>
<tr><th id="629">629</th><td><i class="doc"> * The usb controller driver handles a few standard usb requests.  Those</i></td></tr>
<tr><th id="630">630</th><td><i class="doc"> * include set_address, and feature flags for devices, interfaces, and</i></td></tr>
<tr><th id="631">631</th><td><i class="doc"> * endpoints (the get_status, set_feature, and clear_feature requests).</i></td></tr>
<tr><th id="632">632</th><td><i class="doc"> *</i></td></tr>
<tr><th id="633">633</th><td><i class="doc"> * Accordingly, the driver's setup() callback must always implement all</i></td></tr>
<tr><th id="634">634</th><td><i class="doc"> * get_descriptor requests, returning at least a device descriptor and</i></td></tr>
<tr><th id="635">635</th><td><i class="doc"> * a configuration descriptor.  Drivers must make sure the endpoint</i></td></tr>
<tr><th id="636">636</th><td><i class="doc"> * descriptors match any hardware constraints. Some hardware also constrains</i></td></tr>
<tr><th id="637">637</th><td><i class="doc"> * other descriptors. (The pxa250 allows only configurations 1, 2, or 3).</i></td></tr>
<tr><th id="638">638</th><td><i class="doc"> *</i></td></tr>
<tr><th id="639">639</th><td><i class="doc"> * The driver's setup() callback must also implement set_configuration,</i></td></tr>
<tr><th id="640">640</th><td><i class="doc"> * and should also implement set_interface, get_configuration, and</i></td></tr>
<tr><th id="641">641</th><td><i class="doc"> * get_interface.  Setting a configuration (or interface) is where</i></td></tr>
<tr><th id="642">642</th><td><i class="doc"> * endpoints should be activated or (config 0) shut down.</i></td></tr>
<tr><th id="643">643</th><td><i class="doc"> *</i></td></tr>
<tr><th id="644">644</th><td><i class="doc"> * (Note that only the default control endpoint is supported.  Neither</i></td></tr>
<tr><th id="645">645</th><td><i class="doc"> * hosts nor devices generally support control traffic except to ep0.)</i></td></tr>
<tr><th id="646">646</th><td><i class="doc"> *</i></td></tr>
<tr><th id="647">647</th><td><i class="doc"> * Most devices will ignore USB suspend/resume operations, and so will</i></td></tr>
<tr><th id="648">648</th><td><i class="doc"> * not provide those callbacks.  However, some may need to change modes</i></td></tr>
<tr><th id="649">649</th><td><i class="doc"> * when the host is not longer directing those activities.  For example,</i></td></tr>
<tr><th id="650">650</th><td><i class="doc"> * local controls (buttons, dials, etc) may need to be re-enabled since</i></td></tr>
<tr><th id="651">651</th><td><i class="doc"> * the (remote) host can't do that any longer; or an error state might</i></td></tr>
<tr><th id="652">652</th><td><i class="doc"> * be cleared, to make the device behave identically whether or not</i></td></tr>
<tr><th id="653">653</th><td><i class="doc"> * power is maintained.</i></td></tr>
<tr><th id="654">654</th><td><i class="doc"> */</i></td></tr>
<tr><th id="655">655</th><td><b>struct</b> <dfn class="type def" id="usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</dfn> {</td></tr>
<tr><th id="656">656</th><td>	<em>char</em>			*<dfn class="decl field" id="usb_gadget_driver::function" title='usb_gadget_driver::function' data-ref="usb_gadget_driver::function">function</dfn>;</td></tr>
<tr><th id="657">657</th><td>	<b>enum</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_device_speed" title='usb_device_speed' data-ref="usb_device_speed">usb_device_speed</a>	<dfn class="decl field" id="usb_gadget_driver::max_speed" title='usb_gadget_driver::max_speed' data-ref="usb_gadget_driver::max_speed">max_speed</dfn>;</td></tr>
<tr><th id="658">658</th><td>	<em>int</em>			(*<dfn class="decl field" id="usb_gadget_driver::bind" title='usb_gadget_driver::bind' data-ref="usb_gadget_driver::bind">bind</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col4 decl" id="74gadget" title='gadget' data-type='struct usb_gadget *' data-ref="74gadget">gadget</dfn>,</td></tr>
<tr><th id="659">659</th><td>					<b>struct</b> <a class="type" href="#usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</a> *<dfn class="local col5 decl" id="75driver" title='driver' data-type='struct usb_gadget_driver *' data-ref="75driver">driver</dfn>);</td></tr>
<tr><th id="660">660</th><td>	<em>void</em>			(*<dfn class="decl field" id="usb_gadget_driver::unbind" title='usb_gadget_driver::unbind' data-ref="usb_gadget_driver::unbind">unbind</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="661">661</th><td>	<em>int</em>			(*<dfn class="decl field" id="usb_gadget_driver::setup" title='usb_gadget_driver::setup' data-ref="usb_gadget_driver::setup">setup</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *,</td></tr>
<tr><th id="662">662</th><td>					<em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_ctrlrequest" title='usb_ctrlrequest' data-ref="usb_ctrlrequest">usb_ctrlrequest</a> *);</td></tr>
<tr><th id="663">663</th><td>	<em>void</em>			(*<dfn class="decl field" id="usb_gadget_driver::disconnect" title='usb_gadget_driver::disconnect' data-ref="usb_gadget_driver::disconnect">disconnect</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="664">664</th><td>	<em>void</em>			(*<dfn class="decl field" id="usb_gadget_driver::suspend" title='usb_gadget_driver::suspend' data-ref="usb_gadget_driver::suspend">suspend</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="665">665</th><td>	<em>void</em>			(*<dfn class="decl field" id="usb_gadget_driver::resume" title='usb_gadget_driver::resume' data-ref="usb_gadget_driver::resume">resume</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="666">666</th><td>	<em>void</em>			(*<dfn class="decl field" id="usb_gadget_driver::reset" title='usb_gadget_driver::reset' data-ref="usb_gadget_driver::reset">reset</dfn>)(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="667">667</th><td></td></tr>
<tr><th id="668">668</th><td>	<i>/* FIXME support safe rmmod */</i></td></tr>
<tr><th id="669">669</th><td>	<b>struct</b> <a class="type" href="../device.h.html#device_driver" title='device_driver' data-ref="device_driver">device_driver</a>	<dfn class="decl field" id="usb_gadget_driver::driver" title='usb_gadget_driver::driver' data-ref="usb_gadget_driver::driver">driver</dfn>;</td></tr>
<tr><th id="670">670</th><td></td></tr>
<tr><th id="671">671</th><td>	<em>char</em>			*<dfn class="decl field" id="usb_gadget_driver::udc_name" title='usb_gadget_driver::udc_name' data-ref="usb_gadget_driver::udc_name">udc_name</dfn>;</td></tr>
<tr><th id="672">672</th><td>	<b>struct</b> <a class="type" href="../types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a>	<dfn class="decl field" id="usb_gadget_driver::pending" title='usb_gadget_driver::pending' data-ref="usb_gadget_driver::pending">pending</dfn>;</td></tr>
<tr><th id="673">673</th><td>	<em>unsigned</em>                <dfn class="decl field" id="usb_gadget_driver::match_existing_only" title='usb_gadget_driver::match_existing_only' data-ref="usb_gadget_driver::match_existing_only">match_existing_only</dfn>:<var>1</var>;</td></tr>
<tr><th id="674">674</th><td>};</td></tr>
<tr><th id="675">675</th><td></td></tr>
<tr><th id="676">676</th><td></td></tr>
<tr><th id="677">677</th><td></td></tr>
<tr><th id="678">678</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="679">679</th><td></td></tr>
<tr><th id="680">680</th><td><i>/* driver modules register and unregister, as usual.</i></td></tr>
<tr><th id="681">681</th><td><i> * these calls must be made in a context that can sleep.</i></td></tr>
<tr><th id="682">682</th><td><i> *</i></td></tr>
<tr><th id="683">683</th><td><i> * these will usually be implemented directly by the hardware-dependent</i></td></tr>
<tr><th id="684">684</th><td><i> * usb bus interface driver, which will only support a single driver.</i></td></tr>
<tr><th id="685">685</th><td><i> */</i></td></tr>
<tr><th id="686">686</th><td></td></tr>
<tr><th id="687">687</th><td><i class="doc">/**</i></td></tr>
<tr><th id="688">688</th><td><i class="doc"> * usb_gadget_probe_driver - probe a gadget driver</i></td></tr>
<tr><th id="689">689</th><td><i class="doc"> *<span class="command"> @driver</span>: the driver being registered</i></td></tr>
<tr><th id="690">690</th><td><i class="doc"> * Context: can sleep</i></td></tr>
<tr><th id="691">691</th><td><i class="doc"> *</i></td></tr>
<tr><th id="692">692</th><td><i class="doc"> * Call this in your gadget driver's module initialization function,</i></td></tr>
<tr><th id="693">693</th><td><i class="doc"> * to tell the underlying usb controller driver about your driver.</i></td></tr>
<tr><th id="694">694</th><td><i class="doc"> * The<span class="command"> @bind</span>() function will be called to bind it to a gadget before this</i></td></tr>
<tr><th id="695">695</th><td><i class="doc"> * registration call returns.  It's expected that the<span class="command"> @bind</span>() function will</i></td></tr>
<tr><th id="696">696</th><td><i class="doc"> * be in init sections.</i></td></tr>
<tr><th id="697">697</th><td><i class="doc"> */</i></td></tr>
<tr><th id="698">698</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_probe_driver" title='usb_gadget_probe_driver' data-ref="usb_gadget_probe_driver">usb_gadget_probe_driver</dfn>(<b>struct</b> <a class="type" href="#usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</a> *<dfn class="local col6 decl" id="76driver" title='driver' data-type='struct usb_gadget_driver *' data-ref="76driver">driver</dfn>);</td></tr>
<tr><th id="699">699</th><td></td></tr>
<tr><th id="700">700</th><td><i class="doc">/**</i></td></tr>
<tr><th id="701">701</th><td><i class="doc"> * usb_gadget_unregister_driver - unregister a gadget driver</i></td></tr>
<tr><th id="702">702</th><td><i class="doc"> *<span class="command"> @driver</span>:the driver being unregistered</i></td></tr>
<tr><th id="703">703</th><td><i class="doc"> * Context: can sleep</i></td></tr>
<tr><th id="704">704</th><td><i class="doc"> *</i></td></tr>
<tr><th id="705">705</th><td><i class="doc"> * Call this in your gadget driver's module cleanup function,</i></td></tr>
<tr><th id="706">706</th><td><i class="doc"> * to tell the underlying usb controller that your driver is</i></td></tr>
<tr><th id="707">707</th><td><i class="doc"> * going away.  If the controller is connected to a USB host,</i></td></tr>
<tr><th id="708">708</th><td><i class="doc"> * it will first disconnect().  The driver is also requested</i></td></tr>
<tr><th id="709">709</th><td><i class="doc"> * to unbind() and clean up any device state, before this procedure</i></td></tr>
<tr><th id="710">710</th><td><i class="doc"> * finally returns.  It's expected that the unbind() functions</i></td></tr>
<tr><th id="711">711</th><td><i class="doc"> * will in in exit sections, so may not be linked in some kernels.</i></td></tr>
<tr><th id="712">712</th><td><i class="doc"> */</i></td></tr>
<tr><th id="713">713</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_unregister_driver" title='usb_gadget_unregister_driver' data-ref="usb_gadget_unregister_driver">usb_gadget_unregister_driver</dfn>(<b>struct</b> <a class="type" href="#usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</a> *<dfn class="local col7 decl" id="77driver" title='driver' data-type='struct usb_gadget_driver *' data-ref="77driver">driver</dfn>);</td></tr>
<tr><th id="714">714</th><td></td></tr>
<tr><th id="715">715</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="usb_add_gadget_udc_release" title='usb_add_gadget_udc_release' data-ref="usb_add_gadget_udc_release">usb_add_gadget_udc_release</dfn>(<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a> *<dfn class="local col8 decl" id="78parent" title='parent' data-type='struct device *' data-ref="78parent">parent</dfn>,</td></tr>
<tr><th id="716">716</th><td>		<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col9 decl" id="79gadget" title='gadget' data-type='struct usb_gadget *' data-ref="79gadget">gadget</dfn>, <em>void</em> (*<dfn class="local col0 decl" id="80release" title='release' data-type='void (*)(struct device *)' data-ref="80release">release</dfn>)(<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a> *<dfn class="local col1 decl" id="81dev" title='dev' data-type='struct device *' data-ref="81dev">dev</dfn>));</td></tr>
<tr><th id="717">717</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="usb_add_gadget_udc" title='usb_add_gadget_udc' data-ref="usb_add_gadget_udc">usb_add_gadget_udc</dfn>(<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a> *<dfn class="local col2 decl" id="82parent" title='parent' data-type='struct device *' data-ref="82parent">parent</dfn>, <b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col3 decl" id="83gadget" title='gadget' data-type='struct usb_gadget *' data-ref="83gadget">gadget</dfn>);</td></tr>
<tr><th id="718">718</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_del_gadget_udc" title='usb_del_gadget_udc' data-ref="usb_del_gadget_udc">usb_del_gadget_udc</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col4 decl" id="84gadget" title='gadget' data-type='struct usb_gadget *' data-ref="84gadget">gadget</dfn>);</td></tr>
<tr><th id="719">719</th><td><b>extern</b> <em>char</em> *<dfn class="decl fn" id="usb_get_gadget_udc_name" title='usb_get_gadget_udc_name' data-ref="usb_get_gadget_udc_name">usb_get_gadget_udc_name</dfn>(<em>void</em>);</td></tr>
<tr><th id="720">720</th><td></td></tr>
<tr><th id="721">721</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="722">722</th><td></td></tr>
<tr><th id="723">723</th><td><i>/* utility to simplify dealing with string descriptors */</i></td></tr>
<tr><th id="724">724</th><td></td></tr>
<tr><th id="725">725</th><td><i class="doc">/**</i></td></tr>
<tr><th id="726">726</th><td><i class="doc"> * struct usb_string - wraps a C string and its USB id</i></td></tr>
<tr><th id="727">727</th><td><i class="doc"> *<span class="command"> @id</span>:the (nonzero) ID for this string</i></td></tr>
<tr><th id="728">728</th><td><i class="doc"> *<span class="command"> @s</span>:the string, in UTF-8 encoding</i></td></tr>
<tr><th id="729">729</th><td><i class="doc"> *</i></td></tr>
<tr><th id="730">730</th><td><i class="doc"> * If you're using usb_gadget_get_string(), use this to wrap a string</i></td></tr>
<tr><th id="731">731</th><td><i class="doc"> * together with its ID.</i></td></tr>
<tr><th id="732">732</th><td><i class="doc"> */</i></td></tr>
<tr><th id="733">733</th><td><b>struct</b> <dfn class="type def" id="usb_string" title='usb_string' data-ref="usb_string">usb_string</dfn> {</td></tr>
<tr><th id="734">734</th><td>	<a class="typedef" href="../../asm-generic/int-ll64.h.html#u8" title='u8' data-type='unsigned char' data-ref="u8">u8</a>			<dfn class="decl field" id="usb_string::id" title='usb_string::id' data-ref="usb_string::id">id</dfn>;</td></tr>
<tr><th id="735">735</th><td>	<em>const</em> <em>char</em>		*<dfn class="decl field" id="usb_string::s" title='usb_string::s' data-ref="usb_string::s">s</dfn>;</td></tr>
<tr><th id="736">736</th><td>};</td></tr>
<tr><th id="737">737</th><td></td></tr>
<tr><th id="738">738</th><td><i class="doc">/**</i></td></tr>
<tr><th id="739">739</th><td><i class="doc"> * struct usb_gadget_strings - a set of USB strings in a given language</i></td></tr>
<tr><th id="740">740</th><td><i class="doc"> *<span class="command"> @language</span>:identifies the strings' language (0x0409 for en-us)</i></td></tr>
<tr><th id="741">741</th><td><i class="doc"> *<span class="command"> @strings</span>:array of strings with their ids</i></td></tr>
<tr><th id="742">742</th><td><i class="doc"> *</i></td></tr>
<tr><th id="743">743</th><td><i class="doc"> * If you're using usb_gadget_get_string(), use this to wrap all the</i></td></tr>
<tr><th id="744">744</th><td><i class="doc"> * strings for a given language.</i></td></tr>
<tr><th id="745">745</th><td><i class="doc"> */</i></td></tr>
<tr><th id="746">746</th><td><b>struct</b> <dfn class="type def" id="usb_gadget_strings" title='usb_gadget_strings' data-ref="usb_gadget_strings">usb_gadget_strings</dfn> {</td></tr>
<tr><th id="747">747</th><td>	<a class="typedef" href="../../asm-generic/int-ll64.h.html#u16" title='u16' data-type='unsigned short' data-ref="u16">u16</a>			<dfn class="decl field" id="usb_gadget_strings::language" title='usb_gadget_strings::language' data-ref="usb_gadget_strings::language">language</dfn>;	<i>/* 0x0409 for en-us */</i></td></tr>
<tr><th id="748">748</th><td>	<b>struct</b> <a class="type" href="#usb_string" title='usb_string' data-ref="usb_string">usb_string</a>	*<dfn class="decl field" id="usb_gadget_strings::strings" title='usb_gadget_strings::strings' data-ref="usb_gadget_strings::strings">strings</dfn>;</td></tr>
<tr><th id="749">749</th><td>};</td></tr>
<tr><th id="750">750</th><td></td></tr>
<tr><th id="751">751</th><td><b>struct</b> <dfn class="type def" id="usb_gadget_string_container" title='usb_gadget_string_container' data-ref="usb_gadget_string_container">usb_gadget_string_container</dfn> {</td></tr>
<tr><th id="752">752</th><td>	<b>struct</b> <a class="type" href="../types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a>        <dfn class="decl field" id="usb_gadget_string_container::list" title='usb_gadget_string_container::list' data-ref="usb_gadget_string_container::list">list</dfn>;</td></tr>
<tr><th id="753">753</th><td>	<a class="typedef" href="../../asm-generic/int-ll64.h.html#u8" title='u8' data-type='unsigned char' data-ref="u8">u8</a>                      *<dfn class="decl field" id="usb_gadget_string_container::stash" title='usb_gadget_string_container::stash' data-ref="usb_gadget_string_container::stash">stash</dfn>[<var>0</var>];</td></tr>
<tr><th id="754">754</th><td>};</td></tr>
<tr><th id="755">755</th><td></td></tr>
<tr><th id="756">756</th><td><i>/* put descriptor for string with that id into buf (buflen &gt;= 256) */</i></td></tr>
<tr><th id="757">757</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_get_string" title='usb_gadget_get_string' data-ref="usb_gadget_get_string">usb_gadget_get_string</dfn>(<b>struct</b> <a class="type" href="#usb_gadget_strings" title='usb_gadget_strings' data-ref="usb_gadget_strings">usb_gadget_strings</a> *<dfn class="local col5 decl" id="85table" title='table' data-type='struct usb_gadget_strings *' data-ref="85table">table</dfn>, <em>int</em> <dfn class="local col6 decl" id="86id" title='id' data-type='int' data-ref="86id">id</dfn>, <a class="typedef" href="../../asm-generic/int-ll64.h.html#u8" title='u8' data-type='unsigned char' data-ref="u8">u8</a> *<dfn class="local col7 decl" id="87buf" title='buf' data-type='u8 *' data-ref="87buf">buf</dfn>);</td></tr>
<tr><th id="758">758</th><td></td></tr>
<tr><th id="759">759</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="760">760</th><td></td></tr>
<tr><th id="761">761</th><td><i>/* utility to simplify managing config descriptors */</i></td></tr>
<tr><th id="762">762</th><td></td></tr>
<tr><th id="763">763</th><td><i>/* write vector of descriptors into buffer */</i></td></tr>
<tr><th id="764">764</th><td><em>int</em> <dfn class="decl fn" id="usb_descriptor_fillbuf" title='usb_descriptor_fillbuf' data-ref="usb_descriptor_fillbuf">usb_descriptor_fillbuf</dfn>(<em>void</em> *, <em>unsigned</em>,</td></tr>
<tr><th id="765">765</th><td>		<em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **);</td></tr>
<tr><th id="766">766</th><td></td></tr>
<tr><th id="767">767</th><td><i>/* build config descriptor from single descriptor vector */</i></td></tr>
<tr><th id="768">768</th><td><em>int</em> <dfn class="decl fn" id="usb_gadget_config_buf" title='usb_gadget_config_buf' data-ref="usb_gadget_config_buf">usb_gadget_config_buf</dfn>(<em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_config_descriptor" title='usb_config_descriptor' data-ref="usb_config_descriptor">usb_config_descriptor</a> *<dfn class="local col8 decl" id="88config" title='config' data-type='const struct usb_config_descriptor *' data-ref="88config">config</dfn>,</td></tr>
<tr><th id="769">769</th><td>	<em>void</em> *<dfn class="local col9 decl" id="89buf" title='buf' data-type='void *' data-ref="89buf">buf</dfn>, <em>unsigned</em> <dfn class="local col0 decl" id="90buflen" title='buflen' data-type='unsigned int' data-ref="90buflen">buflen</dfn>, <em>const</em> <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="local col1 decl" id="91desc" title='desc' data-type='const struct usb_descriptor_header **' data-ref="91desc">desc</dfn>);</td></tr>
<tr><th id="770">770</th><td></td></tr>
<tr><th id="771">771</th><td><i>/* copy a NULL-terminated vector of descriptors */</i></td></tr>
<tr><th id="772">772</th><td><b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="decl fn" id="usb_copy_descriptors" title='usb_copy_descriptors' data-ref="usb_copy_descriptors">usb_copy_descriptors</dfn>(</td></tr>
<tr><th id="773">773</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **);</td></tr>
<tr><th id="774">774</th><td></td></tr>
<tr><th id="775">775</th><td><i class="doc">/**</i></td></tr>
<tr><th id="776">776</th><td><i class="doc"> * usb_free_descriptors - free descriptors returned by usb_copy_descriptors()</i></td></tr>
<tr><th id="777">777</th><td><i class="doc"> *<span class="command"> @v</span>: vector of descriptors</i></td></tr>
<tr><th id="778">778</th><td><i class="doc"> */</i></td></tr>
<tr><th id="779">779</th><td><em>static</em> <a class="macro" href="../compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> <dfn class="decl def fn" id="usb_free_descriptors" title='usb_free_descriptors' data-ref="usb_free_descriptors">usb_free_descriptors</dfn>(<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="local col2 decl" id="92v" title='v' data-type='struct usb_descriptor_header **' data-ref="92v">v</dfn>)</td></tr>
<tr><th id="780">780</th><td>{</td></tr>
<tr><th id="781">781</th><td>	<a class="ref fn" href="../slab.h.html#kfree" title='kfree' data-ref="kfree">kfree</a>(<a class="local col2 ref" href="#92v" title='v' data-ref="92v">v</a>);</td></tr>
<tr><th id="782">782</th><td>}</td></tr>
<tr><th id="783">783</th><td></td></tr>
<tr><th id="784">784</th><td><b>struct</b> <a class="type" href="composite.h.html#usb_function" title='usb_function' data-ref="usb_function" id="usb_function">usb_function</a>;</td></tr>
<tr><th id="785">785</th><td><em>int</em> <dfn class="decl fn" id="usb_assign_descriptors" title='usb_assign_descriptors' data-ref="usb_assign_descriptors">usb_assign_descriptors</dfn>(<b>struct</b> <a class="type" href="composite.h.html#usb_function" title='usb_function' data-ref="usb_function">usb_function</a> *<dfn class="local col3 decl" id="93f" title='f' data-type='struct usb_function *' data-ref="93f">f</dfn>,</td></tr>
<tr><th id="786">786</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="local col4 decl" id="94fs" title='fs' data-type='struct usb_descriptor_header **' data-ref="94fs">fs</dfn>,</td></tr>
<tr><th id="787">787</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="local col5 decl" id="95hs" title='hs' data-type='struct usb_descriptor_header **' data-ref="95hs">hs</dfn>,</td></tr>
<tr><th id="788">788</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="local col6 decl" id="96ss" title='ss' data-type='struct usb_descriptor_header **' data-ref="96ss">ss</dfn>,</td></tr>
<tr><th id="789">789</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> **<dfn class="local col7 decl" id="97ssp" title='ssp' data-type='struct usb_descriptor_header **' data-ref="97ssp">ssp</dfn>);</td></tr>
<tr><th id="790">790</th><td><em>void</em> <dfn class="decl fn" id="usb_free_all_descriptors" title='usb_free_all_descriptors' data-ref="usb_free_all_descriptors">usb_free_all_descriptors</dfn>(<b>struct</b> <a class="type" href="composite.h.html#usb_function" title='usb_function' data-ref="usb_function">usb_function</a> *<dfn class="local col8 decl" id="98f" title='f' data-type='struct usb_function *' data-ref="98f">f</dfn>);</td></tr>
<tr><th id="791">791</th><td></td></tr>
<tr><th id="792">792</th><td><b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> *<dfn class="decl fn" id="usb_otg_descriptor_alloc" title='usb_otg_descriptor_alloc' data-ref="usb_otg_descriptor_alloc">usb_otg_descriptor_alloc</dfn>(</td></tr>
<tr><th id="793">793</th><td>				<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col9 decl" id="99gadget" title='gadget' data-type='struct usb_gadget *' data-ref="99gadget">gadget</dfn>);</td></tr>
<tr><th id="794">794</th><td><em>int</em> <dfn class="decl fn" id="usb_otg_descriptor_init" title='usb_otg_descriptor_init' data-ref="usb_otg_descriptor_init">usb_otg_descriptor_init</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col0 decl" id="100gadget" title='gadget' data-type='struct usb_gadget *' data-ref="100gadget">gadget</dfn>,</td></tr>
<tr><th id="795">795</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_descriptor_header" title='usb_descriptor_header' data-ref="usb_descriptor_header">usb_descriptor_header</a> *<dfn class="local col1 decl" id="101otg_desc" title='otg_desc' data-type='struct usb_descriptor_header *' data-ref="101otg_desc">otg_desc</dfn>);</td></tr>
<tr><th id="796">796</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="797">797</th><td></td></tr>
<tr><th id="798">798</th><td><i>/* utility to simplify map/unmap of usb_requests to/from DMA */</i></td></tr>
<tr><th id="799">799</th><td></td></tr>
<tr><th id="800">800</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="usb_gadget_map_request_by_dev" title='usb_gadget_map_request_by_dev' data-ref="usb_gadget_map_request_by_dev">usb_gadget_map_request_by_dev</dfn>(<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a> *<dfn class="local col2 decl" id="102dev" title='dev' data-type='struct device *' data-ref="102dev">dev</dfn>,</td></tr>
<tr><th id="801">801</th><td>		<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col3 decl" id="103req" title='req' data-type='struct usb_request *' data-ref="103req">req</dfn>, <em>int</em> <dfn class="local col4 decl" id="104is_in" title='is_in' data-type='int' data-ref="104is_in">is_in</dfn>);</td></tr>
<tr><th id="802">802</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="usb_gadget_map_request" title='usb_gadget_map_request' data-ref="usb_gadget_map_request">usb_gadget_map_request</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col5 decl" id="105gadget" title='gadget' data-type='struct usb_gadget *' data-ref="105gadget">gadget</dfn>,</td></tr>
<tr><th id="803">803</th><td>		<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col6 decl" id="106req" title='req' data-type='struct usb_request *' data-ref="106req">req</dfn>, <em>int</em> <dfn class="local col7 decl" id="107is_in" title='is_in' data-type='int' data-ref="107is_in">is_in</dfn>);</td></tr>
<tr><th id="804">804</th><td></td></tr>
<tr><th id="805">805</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_gadget_unmap_request_by_dev" title='usb_gadget_unmap_request_by_dev' data-ref="usb_gadget_unmap_request_by_dev">usb_gadget_unmap_request_by_dev</dfn>(<b>struct</b> <a class="type" href="../device.h.html#device" title='device' data-ref="device">device</a> *<dfn class="local col8 decl" id="108dev" title='dev' data-type='struct device *' data-ref="108dev">dev</dfn>,</td></tr>
<tr><th id="806">806</th><td>		<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col9 decl" id="109req" title='req' data-type='struct usb_request *' data-ref="109req">req</dfn>, <em>int</em> <dfn class="local col0 decl" id="110is_in" title='is_in' data-type='int' data-ref="110is_in">is_in</dfn>);</td></tr>
<tr><th id="807">807</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_gadget_unmap_request" title='usb_gadget_unmap_request' data-ref="usb_gadget_unmap_request">usb_gadget_unmap_request</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col1 decl" id="111gadget" title='gadget' data-type='struct usb_gadget *' data-ref="111gadget">gadget</dfn>,</td></tr>
<tr><th id="808">808</th><td>		<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col2 decl" id="112req" title='req' data-type='struct usb_request *' data-ref="112req">req</dfn>, <em>int</em> <dfn class="local col3 decl" id="113is_in" title='is_in' data-type='int' data-ref="113is_in">is_in</dfn>);</td></tr>
<tr><th id="809">809</th><td></td></tr>
<tr><th id="810">810</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="811">811</th><td></td></tr>
<tr><th id="812">812</th><td><i>/* utility to set gadget state properly */</i></td></tr>
<tr><th id="813">813</th><td></td></tr>
<tr><th id="814">814</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_gadget_set_state" title='usb_gadget_set_state' data-ref="usb_gadget_set_state">usb_gadget_set_state</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col4 decl" id="114gadget" title='gadget' data-type='struct usb_gadget *' data-ref="114gadget">gadget</dfn>,</td></tr>
<tr><th id="815">815</th><td>		<b>enum</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_device_state" title='usb_device_state' data-ref="usb_device_state">usb_device_state</a> <dfn class="local col5 decl" id="115state" title='state' data-type='enum usb_device_state' data-ref="115state">state</dfn>);</td></tr>
<tr><th id="816">816</th><td></td></tr>
<tr><th id="817">817</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="818">818</th><td></td></tr>
<tr><th id="819">819</th><td><i>/* utility to tell udc core that the bus reset occurs */</i></td></tr>
<tr><th id="820">820</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_gadget_udc_reset" title='usb_gadget_udc_reset' data-ref="usb_gadget_udc_reset">usb_gadget_udc_reset</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col6 decl" id="116gadget" title='gadget' data-type='struct usb_gadget *' data-ref="116gadget">gadget</dfn>,</td></tr>
<tr><th id="821">821</th><td>		<b>struct</b> <a class="type" href="#usb_gadget_driver" title='usb_gadget_driver' data-ref="usb_gadget_driver">usb_gadget_driver</a> *<dfn class="local col7 decl" id="117driver" title='driver' data-type='struct usb_gadget_driver *' data-ref="117driver">driver</dfn>);</td></tr>
<tr><th id="822">822</th><td></td></tr>
<tr><th id="823">823</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="824">824</th><td></td></tr>
<tr><th id="825">825</th><td><i>/* utility to give requests back to the gadget layer */</i></td></tr>
<tr><th id="826">826</th><td></td></tr>
<tr><th id="827">827</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_gadget_giveback_request" title='usb_gadget_giveback_request' data-ref="usb_gadget_giveback_request">usb_gadget_giveback_request</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col8 decl" id="118ep" title='ep' data-type='struct usb_ep *' data-ref="118ep">ep</dfn>,</td></tr>
<tr><th id="828">828</th><td>		<b>struct</b> <a class="type" href="#usb_request" title='usb_request' data-ref="usb_request">usb_request</a> *<dfn class="local col9 decl" id="119req" title='req' data-type='struct usb_request *' data-ref="119req">req</dfn>);</td></tr>
<tr><th id="829">829</th><td></td></tr>
<tr><th id="830">830</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="831">831</th><td></td></tr>
<tr><th id="832">832</th><td><i>/* utility to find endpoint by name */</i></td></tr>
<tr><th id="833">833</th><td></td></tr>
<tr><th id="834">834</th><td><b>extern</b> <b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="decl fn" id="gadget_find_ep_by_name" title='gadget_find_ep_by_name' data-ref="gadget_find_ep_by_name">gadget_find_ep_by_name</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col0 decl" id="120g" title='g' data-type='struct usb_gadget *' data-ref="120g">g</dfn>,</td></tr>
<tr><th id="835">835</th><td>		<em>const</em> <em>char</em> *<dfn class="local col1 decl" id="121name" title='name' data-type='const char *' data-ref="121name">name</dfn>);</td></tr>
<tr><th id="836">836</th><td></td></tr>
<tr><th id="837">837</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="838">838</th><td></td></tr>
<tr><th id="839">839</th><td><i>/* utility to check if endpoint caps match descriptor needs */</i></td></tr>
<tr><th id="840">840</th><td></td></tr>
<tr><th id="841">841</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="usb_gadget_ep_match_desc" title='usb_gadget_ep_match_desc' data-ref="usb_gadget_ep_match_desc">usb_gadget_ep_match_desc</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col2 decl" id="122gadget" title='gadget' data-type='struct usb_gadget *' data-ref="122gadget">gadget</dfn>,</td></tr>
<tr><th id="842">842</th><td>		<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="local col3 decl" id="123ep" title='ep' data-type='struct usb_ep *' data-ref="123ep">ep</dfn>, <b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_descriptor" title='usb_endpoint_descriptor' data-ref="usb_endpoint_descriptor">usb_endpoint_descriptor</a> *<dfn class="local col4 decl" id="124desc" title='desc' data-type='struct usb_endpoint_descriptor *' data-ref="124desc">desc</dfn>,</td></tr>
<tr><th id="843">843</th><td>		<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_ss_ep_comp_descriptor" title='usb_ss_ep_comp_descriptor' data-ref="usb_ss_ep_comp_descriptor">usb_ss_ep_comp_descriptor</a> *<dfn class="local col5 decl" id="125ep_comp" title='ep_comp' data-type='struct usb_ss_ep_comp_descriptor *' data-ref="125ep_comp">ep_comp</dfn>);</td></tr>
<tr><th id="844">844</th><td></td></tr>
<tr><th id="845">845</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="846">846</th><td></td></tr>
<tr><th id="847">847</th><td><i>/* utility to update vbus status for udc core, it may be scheduled */</i></td></tr>
<tr><th id="848">848</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_udc_vbus_handler" title='usb_udc_vbus_handler' data-ref="usb_udc_vbus_handler">usb_udc_vbus_handler</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *<dfn class="local col6 decl" id="126gadget" title='gadget' data-type='struct usb_gadget *' data-ref="126gadget">gadget</dfn>, <a class="typedef" href="../types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="local col7 decl" id="127status" title='status' data-type='bool' data-ref="127status">status</dfn>);</td></tr>
<tr><th id="849">849</th><td></td></tr>
<tr><th id="850">850</th><td><i>/*-------------------------------------------------------------------------*/</i></td></tr>
<tr><th id="851">851</th><td></td></tr>
<tr><th id="852">852</th><td><i>/* utility wrapping a simple endpoint selection policy */</i></td></tr>
<tr><th id="853">853</th><td></td></tr>
<tr><th id="854">854</th><td><b>extern</b> <b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="decl fn" id="usb_ep_autoconfig" title='usb_ep_autoconfig' data-ref="usb_ep_autoconfig">usb_ep_autoconfig</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *,</td></tr>
<tr><th id="855">855</th><td>			<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_descriptor" title='usb_endpoint_descriptor' data-ref="usb_endpoint_descriptor">usb_endpoint_descriptor</a> *);</td></tr>
<tr><th id="856">856</th><td></td></tr>
<tr><th id="857">857</th><td></td></tr>
<tr><th id="858">858</th><td><b>extern</b> <b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *<dfn class="decl fn" id="usb_ep_autoconfig_ss" title='usb_ep_autoconfig_ss' data-ref="usb_ep_autoconfig_ss">usb_ep_autoconfig_ss</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *,</td></tr>
<tr><th id="859">859</th><td>			<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_endpoint_descriptor" title='usb_endpoint_descriptor' data-ref="usb_endpoint_descriptor">usb_endpoint_descriptor</a> *,</td></tr>
<tr><th id="860">860</th><td>			<b>struct</b> <a class="type" href="../../uapi/linux/usb/ch9.h.html#usb_ss_ep_comp_descriptor" title='usb_ss_ep_comp_descriptor' data-ref="usb_ss_ep_comp_descriptor">usb_ss_ep_comp_descriptor</a> *);</td></tr>
<tr><th id="861">861</th><td></td></tr>
<tr><th id="862">862</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_ep_autoconfig_release" title='usb_ep_autoconfig_release' data-ref="usb_ep_autoconfig_release">usb_ep_autoconfig_release</dfn>(<b>struct</b> <a class="type" href="#usb_ep" title='usb_ep' data-ref="usb_ep">usb_ep</a> *);</td></tr>
<tr><th id="863">863</th><td></td></tr>
<tr><th id="864">864</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="usb_ep_autoconfig_reset" title='usb_ep_autoconfig_reset' data-ref="usb_ep_autoconfig_reset">usb_ep_autoconfig_reset</dfn>(<b>struct</b> <a class="type" href="#usb_gadget" title='usb_gadget' data-ref="usb_gadget">usb_gadget</a> *);</td></tr>
<tr><th id="865">865</th><td></td></tr>
<tr><th id="866">866</th><td><u>#<span data-ppcond="15">endif</span> /* __LINUX_USB_GADGET_H */</u></td></tr>
<tr><th id="867">867</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../drivers/usb/gadget/composite.c.html'>linux-4.14.y/drivers/usb/gadget/composite.c</a><br/>Generated on <em>2018-Aug-13</em> from project linux-4.14.y revision <em>linux-4.14.y</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
