<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>swap.h source code [linux-4.14.y/include/linux/swap.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="percpu_cluster,reclaim_state,swap_cluster_info,swap_cluster_list,swap_extent,swap_header,swap_info_struct,vma_swap_readahead "/>
<link rel="stylesheet" href="../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'linux-4.14.y/include/linux/swap.h'; var root_path = '../../..'; var data_path = '../../../../data';</script>
<script src='../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>linux-4.14.y</a>/<a href='..'>include</a>/<a href='./'>linux</a>/<a href='swap.h.html'>swap.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* SPDX-License-Identifier: GPL-2.0 */</i></td></tr>
<tr><th id="2">2</th><td><u>#<span data-ppcond="2">ifndef</span> <span class="macro" data-ref="_M/_LINUX_SWAP_H">_LINUX_SWAP_H</span></u></td></tr>
<tr><th id="3">3</th><td><u>#define <dfn class="macro" id="_M/_LINUX_SWAP_H" data-ref="_M/_LINUX_SWAP_H">_LINUX_SWAP_H</dfn></u></td></tr>
<tr><th id="4">4</th><td></td></tr>
<tr><th id="5">5</th><td><u>#include <a href="spinlock.h.html">&lt;linux/spinlock.h&gt;</a></u></td></tr>
<tr><th id="6">6</th><td><u>#include <a href="linkage.h.html">&lt;linux/linkage.h&gt;</a></u></td></tr>
<tr><th id="7">7</th><td><u>#include <a href="mmzone.h.html">&lt;linux/mmzone.h&gt;</a></u></td></tr>
<tr><th id="8">8</th><td><u>#include <a href="list.h.html">&lt;linux/list.h&gt;</a></u></td></tr>
<tr><th id="9">9</th><td><u>#include <a href="memcontrol.h.html">&lt;linux/memcontrol.h&gt;</a></u></td></tr>
<tr><th id="10">10</th><td><u>#include <a href="sched.h.html">&lt;linux/sched.h&gt;</a></u></td></tr>
<tr><th id="11">11</th><td><u>#include <a href="node.h.html">&lt;linux/node.h&gt;</a></u></td></tr>
<tr><th id="12">12</th><td><u>#include <a href="fs.h.html">&lt;linux/fs.h&gt;</a></u></td></tr>
<tr><th id="13">13</th><td><u>#include <a href="atomic.h.html">&lt;linux/atomic.h&gt;</a></u></td></tr>
<tr><th id="14">14</th><td><u>#include <a href="page-flags.h.html">&lt;linux/page-flags.h&gt;</a></u></td></tr>
<tr><th id="15">15</th><td><u>#include <a href="../../arch/x86/include/asm/page.h.html">&lt;asm/page.h&gt;</a></u></td></tr>
<tr><th id="16">16</th><td></td></tr>
<tr><th id="17">17</th><td><b>struct</b> <a class="type" href="notifier.h.html#notifier_block" title='notifier_block' data-ref="notifier_block" id="notifier_block">notifier_block</a>;</td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><b>struct</b> <a class="type" href="blk_types.h.html#bio" title='bio' data-ref="bio" id="bio">bio</a>;</td></tr>
<tr><th id="20">20</th><td></td></tr>
<tr><th id="21">21</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAG_PREFER" data-ref="_M/SWAP_FLAG_PREFER">SWAP_FLAG_PREFER</dfn>	0x8000	/* set if swap priority specified */</u></td></tr>
<tr><th id="22">22</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAG_PRIO_MASK" data-ref="_M/SWAP_FLAG_PRIO_MASK">SWAP_FLAG_PRIO_MASK</dfn>	0x7fff</u></td></tr>
<tr><th id="23">23</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAG_PRIO_SHIFT" data-ref="_M/SWAP_FLAG_PRIO_SHIFT">SWAP_FLAG_PRIO_SHIFT</dfn>	0</u></td></tr>
<tr><th id="24">24</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAG_DISCARD" data-ref="_M/SWAP_FLAG_DISCARD">SWAP_FLAG_DISCARD</dfn>	0x10000 /* enable discard for swap */</u></td></tr>
<tr><th id="25">25</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAG_DISCARD_ONCE" data-ref="_M/SWAP_FLAG_DISCARD_ONCE">SWAP_FLAG_DISCARD_ONCE</dfn>	0x20000 /* discard swap area at swapon-time */</u></td></tr>
<tr><th id="26">26</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAG_DISCARD_PAGES" data-ref="_M/SWAP_FLAG_DISCARD_PAGES">SWAP_FLAG_DISCARD_PAGES</dfn> 0x40000 /* discard page-clusters after use */</u></td></tr>
<tr><th id="27">27</th><td></td></tr>
<tr><th id="28">28</th><td><u>#define <dfn class="macro" id="_M/SWAP_FLAGS_VALID" data-ref="_M/SWAP_FLAGS_VALID">SWAP_FLAGS_VALID</dfn>	(SWAP_FLAG_PRIO_MASK | SWAP_FLAG_PREFER | \</u></td></tr>
<tr><th id="29">29</th><td><u>				 SWAP_FLAG_DISCARD | SWAP_FLAG_DISCARD_ONCE | \</u></td></tr>
<tr><th id="30">30</th><td><u>				 SWAP_FLAG_DISCARD_PAGES)</u></td></tr>
<tr><th id="31">31</th><td><u>#define <dfn class="macro" id="_M/SWAP_BATCH" data-ref="_M/SWAP_BATCH">SWAP_BATCH</dfn> 64</u></td></tr>
<tr><th id="32">32</th><td></td></tr>
<tr><th id="33">33</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="current_is_kswapd" title='current_is_kswapd' data-ref="current_is_kswapd">current_is_kswapd</dfn>(<em>void</em>)</td></tr>
<tr><th id="34">34</th><td>{</td></tr>
<tr><th id="35">35</th><td>	<b>return</b> <a class="macro" href="../../arch/x86/include/asm/current.h.html#18" title="get_current()" data-ref="_M/current">current</a>-&gt;<a class="ref field" href="sched.h.html#task_struct::flags" title='task_struct::flags' data-ref="task_struct::flags">flags</a> &amp; <a class="macro" href="sched.h.html#1351" title="0x00020000" data-ref="_M/PF_KSWAPD">PF_KSWAPD</a>;</td></tr>
<tr><th id="36">36</th><td>}</td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><i>/*</i></td></tr>
<tr><th id="39">39</th><td><i> * MAX_SWAPFILES defines the maximum number of swaptypes: things which can</i></td></tr>
<tr><th id="40">40</th><td><i> * be swapped to.  The swap type and the offset into that swap type are</i></td></tr>
<tr><th id="41">41</th><td><i> * encoded into pte's and into pgoff_t's in the swapcache.  Using five bits</i></td></tr>
<tr><th id="42">42</th><td><i> * for the type means that the maximum number of swapcache pages is 27 bits</i></td></tr>
<tr><th id="43">43</th><td><i> * on 32-bit-pgoff_t architectures.  And that assumes that the architecture packs</i></td></tr>
<tr><th id="44">44</th><td><i> * the type/offset into the pte as 5/27 as well.</i></td></tr>
<tr><th id="45">45</th><td><i> */</i></td></tr>
<tr><th id="46">46</th><td><u>#define <dfn class="macro" id="_M/MAX_SWAPFILES_SHIFT" data-ref="_M/MAX_SWAPFILES_SHIFT">MAX_SWAPFILES_SHIFT</dfn>	5</u></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><i>/*</i></td></tr>
<tr><th id="49">49</th><td><i> * Use some of the swap files numbers for other purposes. This</i></td></tr>
<tr><th id="50">50</th><td><i> * is a convenient way to hook into the VM to trigger special</i></td></tr>
<tr><th id="51">51</th><td><i> * actions on faults.</i></td></tr>
<tr><th id="52">52</th><td><i> */</i></td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td><i>/*</i></td></tr>
<tr><th id="55">55</th><td><i> * Unaddressable device memory support. See include/linux/hmm.h and</i></td></tr>
<tr><th id="56">56</th><td><i> * Documentation/vm/hmm.txt. Short description is we need struct pages for</i></td></tr>
<tr><th id="57">57</th><td><i> * device memory that is unaddressable (inaccessible) by CPU, so that we can</i></td></tr>
<tr><th id="58">58</th><td><i> * migrate part of a process memory to device memory.</i></td></tr>
<tr><th id="59">59</th><td><i> *</i></td></tr>
<tr><th id="60">60</th><td><i> * When a page is migrated from CPU to device, we set the CPU page table entry</i></td></tr>
<tr><th id="61">61</th><td><i> * to a special SWP_DEVICE_* entry.</i></td></tr>
<tr><th id="62">62</th><td><i> */</i></td></tr>
<tr><th id="63">63</th><td><u>#<span data-ppcond="63">ifdef</span> <span class="macro" data-ref="_M/CONFIG_DEVICE_PRIVATE">CONFIG_DEVICE_PRIVATE</span></u></td></tr>
<tr><th id="64">64</th><td><u>#define SWP_DEVICE_NUM 2</u></td></tr>
<tr><th id="65">65</th><td><u>#define SWP_DEVICE_WRITE (MAX_SWAPFILES+SWP_HWPOISON_NUM+SWP_MIGRATION_NUM)</u></td></tr>
<tr><th id="66">66</th><td><u>#define SWP_DEVICE_READ (MAX_SWAPFILES+SWP_HWPOISON_NUM+SWP_MIGRATION_NUM+1)</u></td></tr>
<tr><th id="67">67</th><td><u>#<span data-ppcond="63">else</span></u></td></tr>
<tr><th id="68">68</th><td><u>#define <dfn class="macro" id="_M/SWP_DEVICE_NUM" data-ref="_M/SWP_DEVICE_NUM">SWP_DEVICE_NUM</dfn> 0</u></td></tr>
<tr><th id="69">69</th><td><u>#<span data-ppcond="63">endif</span></u></td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><i>/*</i></td></tr>
<tr><th id="72">72</th><td><i> * NUMA node memory migration support</i></td></tr>
<tr><th id="73">73</th><td><i> */</i></td></tr>
<tr><th id="74">74</th><td><u>#<span data-ppcond="74">ifdef</span> <span class="macro" data-ref="_M/CONFIG_MIGRATION">CONFIG_MIGRATION</span></u></td></tr>
<tr><th id="75">75</th><td><u>#define SWP_MIGRATION_NUM 2</u></td></tr>
<tr><th id="76">76</th><td><u>#define SWP_MIGRATION_READ	(MAX_SWAPFILES + SWP_HWPOISON_NUM)</u></td></tr>
<tr><th id="77">77</th><td><u>#define SWP_MIGRATION_WRITE	(MAX_SWAPFILES + SWP_HWPOISON_NUM + 1)</u></td></tr>
<tr><th id="78">78</th><td><u>#<span data-ppcond="74">else</span></u></td></tr>
<tr><th id="79">79</th><td><u>#define <dfn class="macro" id="_M/SWP_MIGRATION_NUM" data-ref="_M/SWP_MIGRATION_NUM">SWP_MIGRATION_NUM</dfn> 0</u></td></tr>
<tr><th id="80">80</th><td><u>#<span data-ppcond="74">endif</span></u></td></tr>
<tr><th id="81">81</th><td></td></tr>
<tr><th id="82">82</th><td><i>/*</i></td></tr>
<tr><th id="83">83</th><td><i> * Handling of hardware poisoned pages with memory corruption.</i></td></tr>
<tr><th id="84">84</th><td><i> */</i></td></tr>
<tr><th id="85">85</th><td><u>#<span data-ppcond="85">ifdef</span> <span class="macro" data-ref="_M/CONFIG_MEMORY_FAILURE">CONFIG_MEMORY_FAILURE</span></u></td></tr>
<tr><th id="86">86</th><td><u>#define SWP_HWPOISON_NUM 1</u></td></tr>
<tr><th id="87">87</th><td><u>#define SWP_HWPOISON		MAX_SWAPFILES</u></td></tr>
<tr><th id="88">88</th><td><u>#<span data-ppcond="85">else</span></u></td></tr>
<tr><th id="89">89</th><td><u>#define <dfn class="macro" id="_M/SWP_HWPOISON_NUM" data-ref="_M/SWP_HWPOISON_NUM">SWP_HWPOISON_NUM</dfn> 0</u></td></tr>
<tr><th id="90">90</th><td><u>#<span data-ppcond="85">endif</span></u></td></tr>
<tr><th id="91">91</th><td></td></tr>
<tr><th id="92">92</th><td><u>#define <dfn class="macro" id="_M/MAX_SWAPFILES" data-ref="_M/MAX_SWAPFILES">MAX_SWAPFILES</dfn> \</u></td></tr>
<tr><th id="93">93</th><td><u>	((1 &lt;&lt; MAX_SWAPFILES_SHIFT) - SWP_DEVICE_NUM - \</u></td></tr>
<tr><th id="94">94</th><td><u>	SWP_MIGRATION_NUM - SWP_HWPOISON_NUM)</u></td></tr>
<tr><th id="95">95</th><td></td></tr>
<tr><th id="96">96</th><td><i>/*</i></td></tr>
<tr><th id="97">97</th><td><i> * Magic header for a swap area. The first part of the union is</i></td></tr>
<tr><th id="98">98</th><td><i> * what the swap magic looks like for the old (limited to 128MB)</i></td></tr>
<tr><th id="99">99</th><td><i> * swap area format, the second part of the union adds - in the</i></td></tr>
<tr><th id="100">100</th><td><i> * old reserved area - some extra information. Note that the first</i></td></tr>
<tr><th id="101">101</th><td><i> * kilobyte is reserved for boot loader or disk label stuff...</i></td></tr>
<tr><th id="102">102</th><td><i> *</i></td></tr>
<tr><th id="103">103</th><td><i> * Having the magic at the end of the PAGE_SIZE makes detecting swap</i></td></tr>
<tr><th id="104">104</th><td><i> * areas somewhat tricky on machines that support multiple page sizes.</i></td></tr>
<tr><th id="105">105</th><td><i> * For 2.5 we'll probably want to move the magic to just beyond the</i></td></tr>
<tr><th id="106">106</th><td><i> * bootbits...</i></td></tr>
<tr><th id="107">107</th><td><i> */</i></td></tr>
<tr><th id="108">108</th><td><b>union</b> <dfn class="type def" id="swap_header" title='swap_header' data-ref="swap_header">swap_header</dfn> {</td></tr>
<tr><th id="109">109</th><td>	<b>struct</b> {</td></tr>
<tr><th id="110">110</th><td>		<em>char</em> <dfn class="decl field" id="swap_header::(anonymous)::reserved" title='swap_header::(anonymous struct)::reserved' data-ref="swap_header::(anonymous)::reserved">reserved</dfn>[<a class="macro" href="../../arch/x86/include/asm/page_types.h.html#11" title="((1UL) &lt;&lt; 12)" data-ref="_M/PAGE_SIZE">PAGE_SIZE</a> - <var>10</var>];</td></tr>
<tr><th id="111">111</th><td>		<em>char</em> <dfn class="decl field" id="swap_header::(anonymous)::magic" title='swap_header::(anonymous struct)::magic' data-ref="swap_header::(anonymous)::magic">magic</dfn>[<var>10</var>];			<i>/* SWAP-SPACE or SWAPSPACE2 */</i></td></tr>
<tr><th id="112">112</th><td>	} <dfn class="decl field" id="swap_header::magic" title='swap_header::magic' data-ref="swap_header::magic">magic</dfn>;</td></tr>
<tr><th id="113">113</th><td>	<b>struct</b> {</td></tr>
<tr><th id="114">114</th><td>		<em>char</em>		<dfn class="decl field" id="swap_header::(anonymous)::bootbits" title='swap_header::(anonymous struct)::bootbits' data-ref="swap_header::(anonymous)::bootbits">bootbits</dfn>[<var>1024</var>];	<i>/* Space for disklabel etc. */</i></td></tr>
<tr><th id="115">115</th><td>		<a class="typedef" href="../uapi/asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="swap_header::(anonymous)::version" title='swap_header::(anonymous struct)::version' data-ref="swap_header::(anonymous)::version">version</dfn>;</td></tr>
<tr><th id="116">116</th><td>		<a class="typedef" href="../uapi/asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="swap_header::(anonymous)::last_page" title='swap_header::(anonymous struct)::last_page' data-ref="swap_header::(anonymous)::last_page">last_page</dfn>;</td></tr>
<tr><th id="117">117</th><td>		<a class="typedef" href="../uapi/asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="swap_header::(anonymous)::nr_badpages" title='swap_header::(anonymous struct)::nr_badpages' data-ref="swap_header::(anonymous)::nr_badpages">nr_badpages</dfn>;</td></tr>
<tr><th id="118">118</th><td>		<em>unsigned</em> <em>char</em>	<dfn class="decl field" id="swap_header::(anonymous)::sws_uuid" title='swap_header::(anonymous struct)::sws_uuid' data-ref="swap_header::(anonymous)::sws_uuid">sws_uuid</dfn>[<var>16</var>];</td></tr>
<tr><th id="119">119</th><td>		<em>unsigned</em> <em>char</em>	<dfn class="decl field" id="swap_header::(anonymous)::sws_volume" title='swap_header::(anonymous struct)::sws_volume' data-ref="swap_header::(anonymous)::sws_volume">sws_volume</dfn>[<var>16</var>];</td></tr>
<tr><th id="120">120</th><td>		<a class="typedef" href="../uapi/asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="swap_header::(anonymous)::padding" title='swap_header::(anonymous struct)::padding' data-ref="swap_header::(anonymous)::padding">padding</dfn>[<var>117</var>];</td></tr>
<tr><th id="121">121</th><td>		<a class="typedef" href="../uapi/asm-generic/int-ll64.h.html#__u32" title='__u32' data-type='unsigned int' data-ref="__u32">__u32</a>		<dfn class="decl field" id="swap_header::(anonymous)::badpages" title='swap_header::(anonymous struct)::badpages' data-ref="swap_header::(anonymous)::badpages">badpages</dfn>[<var>1</var>];</td></tr>
<tr><th id="122">122</th><td>	} <dfn class="decl field" id="swap_header::info" title='swap_header::info' data-ref="swap_header::info">info</dfn>;</td></tr>
<tr><th id="123">123</th><td>};</td></tr>
<tr><th id="124">124</th><td></td></tr>
<tr><th id="125">125</th><td><i>/*</i></td></tr>
<tr><th id="126">126</th><td><i> * current-&gt;reclaim_state points to one of these when a task is running</i></td></tr>
<tr><th id="127">127</th><td><i> * memory reclaim</i></td></tr>
<tr><th id="128">128</th><td><i> */</i></td></tr>
<tr><th id="129">129</th><td><b>struct</b> <dfn class="type def" id="reclaim_state" title='reclaim_state' data-ref="reclaim_state">reclaim_state</dfn> {</td></tr>
<tr><th id="130">130</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="reclaim_state::reclaimed_slab" title='reclaim_state::reclaimed_slab' data-ref="reclaim_state::reclaimed_slab">reclaimed_slab</dfn>;</td></tr>
<tr><th id="131">131</th><td>};</td></tr>
<tr><th id="132">132</th><td></td></tr>
<tr><th id="133">133</th><td><u>#<span data-ppcond="133">ifdef</span> <span class="macro" data-ref="_M/__KERNEL__">__KERNEL__</span></u></td></tr>
<tr><th id="134">134</th><td></td></tr>
<tr><th id="135">135</th><td><b>struct</b> <a class="type" href="fs.h.html#address_space" title='address_space' data-ref="address_space" id="address_space">address_space</a>;</td></tr>
<tr><th id="136">136</th><td><b>struct</b> <a class="type" href="../uapi/linux/sysinfo.h.html#sysinfo" title='sysinfo' data-ref="sysinfo" id="sysinfo">sysinfo</a>;</td></tr>
<tr><th id="137">137</th><td><b>struct</b> <a class="type" href="writeback.h.html#writeback_control" title='writeback_control' data-ref="writeback_control" id="writeback_control">writeback_control</a>;</td></tr>
<tr><th id="138">138</th><td><b>struct</b> <a class="type" href="mmzone.h.html#zone" title='zone' data-ref="zone" id="zone">zone</a>;</td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td><i>/*</i></td></tr>
<tr><th id="141">141</th><td><i> * A swap extent maps a range of a swapfile's PAGE_SIZE pages onto a range of</i></td></tr>
<tr><th id="142">142</th><td><i> * disk blocks.  A list of swap extents maps the entire swapfile.  (Where the</i></td></tr>
<tr><th id="143">143</th><td><i> * term `swapfile' refers to either a blockdevice or an IS_REG file.  Apart</i></td></tr>
<tr><th id="144">144</th><td><i> * from setup, they're handled identically.</i></td></tr>
<tr><th id="145">145</th><td><i> *</i></td></tr>
<tr><th id="146">146</th><td><i> * We always assume that blocks are of size PAGE_SIZE.</i></td></tr>
<tr><th id="147">147</th><td><i> */</i></td></tr>
<tr><th id="148">148</th><td><b>struct</b> <dfn class="type def" id="swap_extent" title='swap_extent' data-ref="swap_extent">swap_extent</dfn> {</td></tr>
<tr><th id="149">149</th><td>	<b>struct</b> <a class="type" href="types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a> <dfn class="decl field" id="swap_extent::list" title='swap_extent::list' data-ref="swap_extent::list">list</dfn>;</td></tr>
<tr><th id="150">150</th><td>	<a class="macro" href="types.h.html#141" title="unsigned long" data-ref="_M/pgoff_t">pgoff_t</a> <dfn class="decl field" id="swap_extent::start_page" title='swap_extent::start_page' data-ref="swap_extent::start_page">start_page</dfn>;</td></tr>
<tr><th id="151">151</th><td>	<a class="macro" href="types.h.html#141" title="unsigned long" data-ref="_M/pgoff_t">pgoff_t</a> <dfn class="decl field" id="swap_extent::nr_pages" title='swap_extent::nr_pages' data-ref="swap_extent::nr_pages">nr_pages</dfn>;</td></tr>
<tr><th id="152">152</th><td>	<a class="typedef" href="types.h.html#sector_t" title='sector_t' data-type='unsigned long' data-ref="sector_t">sector_t</a> <dfn class="decl field" id="swap_extent::start_block" title='swap_extent::start_block' data-ref="swap_extent::start_block">start_block</dfn>;</td></tr>
<tr><th id="153">153</th><td>};</td></tr>
<tr><th id="154">154</th><td></td></tr>
<tr><th id="155">155</th><td><i>/*</i></td></tr>
<tr><th id="156">156</th><td><i> * Max bad pages in the new format..</i></td></tr>
<tr><th id="157">157</th><td><i> */</i></td></tr>
<tr><th id="158">158</th><td><u>#define <dfn class="macro" id="_M/__swapoffset" data-ref="_M/__swapoffset">__swapoffset</dfn>(x) ((unsigned long)&amp;((union swap_header *)0)-&gt;x)</u></td></tr>
<tr><th id="159">159</th><td><u>#define <dfn class="macro" id="_M/MAX_SWAP_BADPAGES" data-ref="_M/MAX_SWAP_BADPAGES">MAX_SWAP_BADPAGES</dfn> \</u></td></tr>
<tr><th id="160">160</th><td><u>	((__swapoffset(magic.magic) - __swapoffset(info.badpages)) / sizeof(int))</u></td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td><b>enum</b> {</td></tr>
<tr><th id="163">163</th><td>	<dfn class="enum" id="SWP_USED" title='SWP_USED' data-ref="SWP_USED">SWP_USED</dfn>	= (<var>1</var> &lt;&lt; <var>0</var>),	<i>/* is slot in swap_info[] used? */</i></td></tr>
<tr><th id="164">164</th><td>	<dfn class="enum" id="SWP_WRITEOK" title='SWP_WRITEOK' data-ref="SWP_WRITEOK">SWP_WRITEOK</dfn>	= (<var>1</var> &lt;&lt; <var>1</var>),	<i>/* ok to write to this swap?	*/</i></td></tr>
<tr><th id="165">165</th><td>	<dfn class="enum" id="SWP_DISCARDABLE" title='SWP_DISCARDABLE' data-ref="SWP_DISCARDABLE">SWP_DISCARDABLE</dfn> = (<var>1</var> &lt;&lt; <var>2</var>),	<i>/* blkdev support discard */</i></td></tr>
<tr><th id="166">166</th><td>	<dfn class="enum" id="SWP_DISCARDING" title='SWP_DISCARDING' data-ref="SWP_DISCARDING">SWP_DISCARDING</dfn>	= (<var>1</var> &lt;&lt; <var>3</var>),	<i>/* now discarding a free cluster */</i></td></tr>
<tr><th id="167">167</th><td>	<dfn class="enum" id="SWP_SOLIDSTATE" title='SWP_SOLIDSTATE' data-ref="SWP_SOLIDSTATE">SWP_SOLIDSTATE</dfn>	= (<var>1</var> &lt;&lt; <var>4</var>),	<i>/* blkdev seeks are cheap */</i></td></tr>
<tr><th id="168">168</th><td>	<dfn class="enum" id="SWP_CONTINUED" title='SWP_CONTINUED' data-ref="SWP_CONTINUED">SWP_CONTINUED</dfn>	= (<var>1</var> &lt;&lt; <var>5</var>),	<i>/* swap_map has count continuation */</i></td></tr>
<tr><th id="169">169</th><td>	<dfn class="enum" id="SWP_BLKDEV" title='SWP_BLKDEV' data-ref="SWP_BLKDEV">SWP_BLKDEV</dfn>	= (<var>1</var> &lt;&lt; <var>6</var>),	<i>/* its a block device */</i></td></tr>
<tr><th id="170">170</th><td>	<dfn class="enum" id="SWP_FILE" title='SWP_FILE' data-ref="SWP_FILE">SWP_FILE</dfn>	= (<var>1</var> &lt;&lt; <var>7</var>),	<i>/* set after swap_activate success */</i></td></tr>
<tr><th id="171">171</th><td>	<dfn class="enum" id="SWP_AREA_DISCARD" title='SWP_AREA_DISCARD' data-ref="SWP_AREA_DISCARD">SWP_AREA_DISCARD</dfn> = (<var>1</var> &lt;&lt; <var>8</var>),	<i>/* single-time swap area discards */</i></td></tr>
<tr><th id="172">172</th><td>	<dfn class="enum" id="SWP_PAGE_DISCARD" title='SWP_PAGE_DISCARD' data-ref="SWP_PAGE_DISCARD">SWP_PAGE_DISCARD</dfn> = (<var>1</var> &lt;&lt; <var>9</var>),	<i>/* freed swap page-cluster discards */</i></td></tr>
<tr><th id="173">173</th><td>	<dfn class="enum" id="SWP_STABLE_WRITES" title='SWP_STABLE_WRITES' data-ref="SWP_STABLE_WRITES">SWP_STABLE_WRITES</dfn> = (<var>1</var> &lt;&lt; <var>10</var>),	<i>/* no overwrite PG_writeback pages */</i></td></tr>
<tr><th id="174">174</th><td>					<i>/* add others here before... */</i></td></tr>
<tr><th id="175">175</th><td>	<dfn class="enum" id="SWP_SCANNING" title='SWP_SCANNING' data-ref="SWP_SCANNING">SWP_SCANNING</dfn>	= (<var>1</var> &lt;&lt; <var>11</var>),	<i>/* refcount in scan_swap_map */</i></td></tr>
<tr><th id="176">176</th><td>};</td></tr>
<tr><th id="177">177</th><td></td></tr>
<tr><th id="178">178</th><td><u>#define <dfn class="macro" id="_M/SWAP_CLUSTER_MAX" data-ref="_M/SWAP_CLUSTER_MAX">SWAP_CLUSTER_MAX</dfn> 32UL</u></td></tr>
<tr><th id="179">179</th><td><u>#define <dfn class="macro" id="_M/COMPACT_CLUSTER_MAX" data-ref="_M/COMPACT_CLUSTER_MAX">COMPACT_CLUSTER_MAX</dfn> SWAP_CLUSTER_MAX</u></td></tr>
<tr><th id="180">180</th><td></td></tr>
<tr><th id="181">181</th><td><u>#define <dfn class="macro" id="_M/SWAP_MAP_MAX" data-ref="_M/SWAP_MAP_MAX">SWAP_MAP_MAX</dfn>	0x3e	/* Max duplication count, in first swap_map */</u></td></tr>
<tr><th id="182">182</th><td><u>#define <dfn class="macro" id="_M/SWAP_MAP_BAD" data-ref="_M/SWAP_MAP_BAD">SWAP_MAP_BAD</dfn>	0x3f	/* Note pageblock is bad, in first swap_map */</u></td></tr>
<tr><th id="183">183</th><td><u>#define <dfn class="macro" id="_M/SWAP_HAS_CACHE" data-ref="_M/SWAP_HAS_CACHE">SWAP_HAS_CACHE</dfn>	0x40	/* Flag page is cached, in first swap_map */</u></td></tr>
<tr><th id="184">184</th><td><u>#define <dfn class="macro" id="_M/SWAP_CONT_MAX" data-ref="_M/SWAP_CONT_MAX">SWAP_CONT_MAX</dfn>	0x7f	/* Max count, in each swap_map continuation */</u></td></tr>
<tr><th id="185">185</th><td><u>#define <dfn class="macro" id="_M/COUNT_CONTINUED" data-ref="_M/COUNT_CONTINUED">COUNT_CONTINUED</dfn>	0x80	/* See swap_map continuation for full count */</u></td></tr>
<tr><th id="186">186</th><td><u>#define <dfn class="macro" id="_M/SWAP_MAP_SHMEM" data-ref="_M/SWAP_MAP_SHMEM">SWAP_MAP_SHMEM</dfn>	0xbf	/* Owned by shmem/tmpfs, in first swap_map */</u></td></tr>
<tr><th id="187">187</th><td></td></tr>
<tr><th id="188">188</th><td><i>/*</i></td></tr>
<tr><th id="189">189</th><td><i> * We use this to track usage of a cluster. A cluster is a block of swap disk</i></td></tr>
<tr><th id="190">190</th><td><i> * space with SWAPFILE_CLUSTER pages long and naturally aligns in disk. All</i></td></tr>
<tr><th id="191">191</th><td><i> * free clusters are organized into a list. We fetch an entry from the list to</i></td></tr>
<tr><th id="192">192</th><td><i> * get a free cluster.</i></td></tr>
<tr><th id="193">193</th><td><i> *</i></td></tr>
<tr><th id="194">194</th><td><i> * The data field stores next cluster if the cluster is free or cluster usage</i></td></tr>
<tr><th id="195">195</th><td><i> * counter otherwise. The flags field determines if a cluster is free. This is</i></td></tr>
<tr><th id="196">196</th><td><i> * protected by swap_info_struct.lock.</i></td></tr>
<tr><th id="197">197</th><td><i> */</i></td></tr>
<tr><th id="198">198</th><td><b>struct</b> <dfn class="type def" id="swap_cluster_info" title='swap_cluster_info' data-ref="swap_cluster_info">swap_cluster_info</dfn> {</td></tr>
<tr><th id="199">199</th><td>	<a class="typedef" href="spinlock_types.h.html#spinlock_t" title='spinlock_t' data-type='struct spinlock' data-ref="spinlock_t">spinlock_t</a> <dfn class="decl field" id="swap_cluster_info::lock" title='swap_cluster_info::lock' data-ref="swap_cluster_info::lock">lock</dfn>;	<i>/*</i></td></tr>
<tr><th id="200">200</th><td><i>				 * Protect swap_cluster_info fields</i></td></tr>
<tr><th id="201">201</th><td><i>				 * and swap_info_struct-&gt;swap_map</i></td></tr>
<tr><th id="202">202</th><td><i>				 * elements correspond to the swap</i></td></tr>
<tr><th id="203">203</th><td><i>				 * cluster</i></td></tr>
<tr><th id="204">204</th><td><i>				 */</i></td></tr>
<tr><th id="205">205</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_cluster_info::data" title='swap_cluster_info::data' data-ref="swap_cluster_info::data">data</dfn>:<var>24</var>;</td></tr>
<tr><th id="206">206</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_cluster_info::flags" title='swap_cluster_info::flags' data-ref="swap_cluster_info::flags">flags</dfn>:<var>8</var>;</td></tr>
<tr><th id="207">207</th><td>};</td></tr>
<tr><th id="208">208</th><td><u>#define <dfn class="macro" id="_M/CLUSTER_FLAG_FREE" data-ref="_M/CLUSTER_FLAG_FREE">CLUSTER_FLAG_FREE</dfn> 1 /* This cluster is free */</u></td></tr>
<tr><th id="209">209</th><td><u>#define <dfn class="macro" id="_M/CLUSTER_FLAG_NEXT_NULL" data-ref="_M/CLUSTER_FLAG_NEXT_NULL">CLUSTER_FLAG_NEXT_NULL</dfn> 2 /* This cluster has no next cluster */</u></td></tr>
<tr><th id="210">210</th><td><u>#define <dfn class="macro" id="_M/CLUSTER_FLAG_HUGE" data-ref="_M/CLUSTER_FLAG_HUGE">CLUSTER_FLAG_HUGE</dfn> 4 /* This cluster is backing a transparent huge page */</u></td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td><i>/*</i></td></tr>
<tr><th id="213">213</th><td><i> * We assign a cluster to each CPU, so each CPU can allocate swap entry from</i></td></tr>
<tr><th id="214">214</th><td><i> * its own cluster and swapout sequentially. The purpose is to optimize swapout</i></td></tr>
<tr><th id="215">215</th><td><i> * throughput.</i></td></tr>
<tr><th id="216">216</th><td><i> */</i></td></tr>
<tr><th id="217">217</th><td><b>struct</b> <dfn class="type def" id="percpu_cluster" title='percpu_cluster' data-ref="percpu_cluster">percpu_cluster</dfn> {</td></tr>
<tr><th id="218">218</th><td>	<b>struct</b> <a class="type" href="#swap_cluster_info" title='swap_cluster_info' data-ref="swap_cluster_info">swap_cluster_info</a> <dfn class="decl field" id="percpu_cluster::index" title='percpu_cluster::index' data-ref="percpu_cluster::index">index</dfn>; <i>/* Current cluster index */</i></td></tr>
<tr><th id="219">219</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="percpu_cluster::next" title='percpu_cluster::next' data-ref="percpu_cluster::next">next</dfn>; <i>/* Likely next allocation offset */</i></td></tr>
<tr><th id="220">220</th><td>};</td></tr>
<tr><th id="221">221</th><td></td></tr>
<tr><th id="222">222</th><td><b>struct</b> <dfn class="type def" id="swap_cluster_list" title='swap_cluster_list' data-ref="swap_cluster_list">swap_cluster_list</dfn> {</td></tr>
<tr><th id="223">223</th><td>	<b>struct</b> <a class="type" href="#swap_cluster_info" title='swap_cluster_info' data-ref="swap_cluster_info">swap_cluster_info</a> <dfn class="decl field" id="swap_cluster_list::head" title='swap_cluster_list::head' data-ref="swap_cluster_list::head">head</dfn>;</td></tr>
<tr><th id="224">224</th><td>	<b>struct</b> <a class="type" href="#swap_cluster_info" title='swap_cluster_info' data-ref="swap_cluster_info">swap_cluster_info</a> <dfn class="decl field" id="swap_cluster_list::tail" title='swap_cluster_list::tail' data-ref="swap_cluster_list::tail">tail</dfn>;</td></tr>
<tr><th id="225">225</th><td>};</td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td><i>/*</i></td></tr>
<tr><th id="228">228</th><td><i> * The in-memory structure used to track swap areas.</i></td></tr>
<tr><th id="229">229</th><td><i> */</i></td></tr>
<tr><th id="230">230</th><td><b>struct</b> <dfn class="type def" id="swap_info_struct" title='swap_info_struct' data-ref="swap_info_struct">swap_info_struct</dfn> {</td></tr>
<tr><th id="231">231</th><td>	<em>unsigned</em> <em>long</em>	<dfn class="decl field" id="swap_info_struct::flags" title='swap_info_struct::flags' data-ref="swap_info_struct::flags">flags</dfn>;		<i>/* SWP_USED etc: see above */</i></td></tr>
<tr><th id="232">232</th><td>	<em>signed</em> <em>short</em>	<dfn class="decl field" id="swap_info_struct::prio" title='swap_info_struct::prio' data-ref="swap_info_struct::prio">prio</dfn>;		<i>/* swap priority of this type */</i></td></tr>
<tr><th id="233">233</th><td>	<b>struct</b> <a class="type" href="plist.h.html#plist_node" title='plist_node' data-ref="plist_node">plist_node</a> <dfn class="decl field" id="swap_info_struct::list" title='swap_info_struct::list' data-ref="swap_info_struct::list">list</dfn>;		<i>/* entry in swap_active_head */</i></td></tr>
<tr><th id="234">234</th><td>	<b>struct</b> <a class="type" href="plist.h.html#plist_node" title='plist_node' data-ref="plist_node">plist_node</a> <dfn class="decl field" id="swap_info_struct::avail_lists" title='swap_info_struct::avail_lists' data-ref="swap_info_struct::avail_lists">avail_lists</dfn>[<a class="macro" href="numa.h.html#12" title="(1 &lt;&lt; 0)" data-ref="_M/MAX_NUMNODES">MAX_NUMNODES</a>];<i>/* entry in swap_avail_heads */</i></td></tr>
<tr><th id="235">235</th><td>	<em>signed</em> <em>char</em>	<dfn class="decl field" id="swap_info_struct::type" title='swap_info_struct::type' data-ref="swap_info_struct::type">type</dfn>;		<i>/* strange name for an index */</i></td></tr>
<tr><th id="236">236</th><td>	<em>unsigned</em> <em>int</em>	<dfn class="decl field" id="swap_info_struct::max" title='swap_info_struct::max' data-ref="swap_info_struct::max">max</dfn>;		<i>/* extent of the swap_map */</i></td></tr>
<tr><th id="237">237</th><td>	<em>unsigned</em> <em>char</em> *<dfn class="decl field" id="swap_info_struct::swap_map" title='swap_info_struct::swap_map' data-ref="swap_info_struct::swap_map">swap_map</dfn>;	<i>/* vmalloc'ed array of usage counts */</i></td></tr>
<tr><th id="238">238</th><td>	<b>struct</b> <a class="type" href="#swap_cluster_info" title='swap_cluster_info' data-ref="swap_cluster_info">swap_cluster_info</a> *<dfn class="decl field" id="swap_info_struct::cluster_info" title='swap_info_struct::cluster_info' data-ref="swap_info_struct::cluster_info">cluster_info</dfn>; <i>/* cluster info. Only for SSD */</i></td></tr>
<tr><th id="239">239</th><td>	<b>struct</b> <a class="type" href="#swap_cluster_list" title='swap_cluster_list' data-ref="swap_cluster_list">swap_cluster_list</a> <dfn class="decl field" id="swap_info_struct::free_clusters" title='swap_info_struct::free_clusters' data-ref="swap_info_struct::free_clusters">free_clusters</dfn>; <i>/* free clusters list */</i></td></tr>
<tr><th id="240">240</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::lowest_bit" title='swap_info_struct::lowest_bit' data-ref="swap_info_struct::lowest_bit">lowest_bit</dfn>;	<i>/* index of first free in swap_map */</i></td></tr>
<tr><th id="241">241</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::highest_bit" title='swap_info_struct::highest_bit' data-ref="swap_info_struct::highest_bit">highest_bit</dfn>;	<i>/* index of last free in swap_map */</i></td></tr>
<tr><th id="242">242</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::pages" title='swap_info_struct::pages' data-ref="swap_info_struct::pages">pages</dfn>;		<i>/* total of usable pages of swap */</i></td></tr>
<tr><th id="243">243</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::inuse_pages" title='swap_info_struct::inuse_pages' data-ref="swap_info_struct::inuse_pages">inuse_pages</dfn>;	<i>/* number of those currently in use */</i></td></tr>
<tr><th id="244">244</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::cluster_next" title='swap_info_struct::cluster_next' data-ref="swap_info_struct::cluster_next">cluster_next</dfn>;	<i>/* likely index for next allocation */</i></td></tr>
<tr><th id="245">245</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::cluster_nr" title='swap_info_struct::cluster_nr' data-ref="swap_info_struct::cluster_nr">cluster_nr</dfn>;	<i>/* countdown to next cluster search */</i></td></tr>
<tr><th id="246">246</th><td>	<b>struct</b> <a class="type" href="#percpu_cluster" title='percpu_cluster' data-ref="percpu_cluster">percpu_cluster</a> <a class="macro" href="compiler_types.h.html#45" title="" data-ref="_M/__percpu">__percpu</a> *<dfn class="decl field" id="swap_info_struct::percpu_cluster" title='swap_info_struct::percpu_cluster' data-ref="swap_info_struct::percpu_cluster">percpu_cluster</dfn>; <i>/* per cpu's swap location */</i></td></tr>
<tr><th id="247">247</th><td>	<b>struct</b> <a class="type" href="#swap_extent" title='swap_extent' data-ref="swap_extent">swap_extent</a> *<dfn class="decl field" id="swap_info_struct::curr_swap_extent" title='swap_info_struct::curr_swap_extent' data-ref="swap_info_struct::curr_swap_extent">curr_swap_extent</dfn>;</td></tr>
<tr><th id="248">248</th><td>	<b>struct</b> <a class="type" href="#swap_extent" title='swap_extent' data-ref="swap_extent">swap_extent</a> <dfn class="decl field" id="swap_info_struct::first_swap_extent" title='swap_info_struct::first_swap_extent' data-ref="swap_info_struct::first_swap_extent">first_swap_extent</dfn>;</td></tr>
<tr><th id="249">249</th><td>	<b>struct</b> <a class="type" href="fs.h.html#block_device" title='block_device' data-ref="block_device">block_device</a> *<dfn class="decl field" id="swap_info_struct::bdev" title='swap_info_struct::bdev' data-ref="swap_info_struct::bdev">bdev</dfn>;	<i>/* swap device or bdev of swap file */</i></td></tr>
<tr><th id="250">250</th><td>	<b>struct</b> <a class="type" href="fs.h.html#file" title='file' data-ref="file">file</a> *<dfn class="decl field" id="swap_info_struct::swap_file" title='swap_info_struct::swap_file' data-ref="swap_info_struct::swap_file">swap_file</dfn>;		<i>/* seldom referenced */</i></td></tr>
<tr><th id="251">251</th><td>	<em>unsigned</em> <em>int</em> <dfn class="decl field" id="swap_info_struct::old_block_size" title='swap_info_struct::old_block_size' data-ref="swap_info_struct::old_block_size">old_block_size</dfn>;	<i>/* seldom referenced */</i></td></tr>
<tr><th id="252">252</th><td><u>#<span data-ppcond="252">ifdef</span> <span class="macro" data-ref="_M/CONFIG_FRONTSWAP">CONFIG_FRONTSWAP</span></u></td></tr>
<tr><th id="253">253</th><td>	<em>unsigned</em> <em>long</em> *frontswap_map;	<i>/* frontswap in-use, one bit per page */</i></td></tr>
<tr><th id="254">254</th><td>	atomic_t frontswap_pages;	<i>/* frontswap pages in-use counter */</i></td></tr>
<tr><th id="255">255</th><td><u>#<span data-ppcond="252">endif</span></u></td></tr>
<tr><th id="256">256</th><td>	<a class="typedef" href="spinlock_types.h.html#spinlock_t" title='spinlock_t' data-type='struct spinlock' data-ref="spinlock_t">spinlock_t</a> <dfn class="decl field" id="swap_info_struct::lock" title='swap_info_struct::lock' data-ref="swap_info_struct::lock">lock</dfn>;		<i>/*</i></td></tr>
<tr><th id="257">257</th><td><i>					 * protect map scan related fields like</i></td></tr>
<tr><th id="258">258</th><td><i>					 * swap_map, lowest_bit, highest_bit,</i></td></tr>
<tr><th id="259">259</th><td><i>					 * inuse_pages, cluster_next,</i></td></tr>
<tr><th id="260">260</th><td><i>					 * cluster_nr, lowest_alloc,</i></td></tr>
<tr><th id="261">261</th><td><i>					 * highest_alloc, free/discard cluster</i></td></tr>
<tr><th id="262">262</th><td><i>					 * list. other fields are only changed</i></td></tr>
<tr><th id="263">263</th><td><i>					 * at swapon/swapoff, so are protected</i></td></tr>
<tr><th id="264">264</th><td><i>					 * by swap_lock. changing flags need</i></td></tr>
<tr><th id="265">265</th><td><i>					 * hold this lock and swap_lock. If</i></td></tr>
<tr><th id="266">266</th><td><i>					 * both locks need hold, hold swap_lock</i></td></tr>
<tr><th id="267">267</th><td><i>					 * first.</i></td></tr>
<tr><th id="268">268</th><td><i>					 */</i></td></tr>
<tr><th id="269">269</th><td>	<a class="typedef" href="spinlock_types.h.html#spinlock_t" title='spinlock_t' data-type='struct spinlock' data-ref="spinlock_t">spinlock_t</a> <dfn class="decl field" id="swap_info_struct::cont_lock" title='swap_info_struct::cont_lock' data-ref="swap_info_struct::cont_lock">cont_lock</dfn>;		<i>/*</i></td></tr>
<tr><th id="270">270</th><td><i>					 * protect swap count continuation page</i></td></tr>
<tr><th id="271">271</th><td><i>					 * list.</i></td></tr>
<tr><th id="272">272</th><td><i>					 */</i></td></tr>
<tr><th id="273">273</th><td>	<b>struct</b> <a class="type" href="workqueue.h.html#work_struct" title='work_struct' data-ref="work_struct">work_struct</a> <dfn class="decl field" id="swap_info_struct::discard_work" title='swap_info_struct::discard_work' data-ref="swap_info_struct::discard_work">discard_work</dfn>; <i>/* discard worker */</i></td></tr>
<tr><th id="274">274</th><td>	<b>struct</b> <a class="type" href="#swap_cluster_list" title='swap_cluster_list' data-ref="swap_cluster_list">swap_cluster_list</a> <dfn class="decl field" id="swap_info_struct::discard_clusters" title='swap_info_struct::discard_clusters' data-ref="swap_info_struct::discard_clusters">discard_clusters</dfn>; <i>/* discard clusters list */</i></td></tr>
<tr><th id="275">275</th><td>};</td></tr>
<tr><th id="276">276</th><td></td></tr>
<tr><th id="277">277</th><td><u>#<span data-ppcond="277">ifdef</span> <a class="macro" href="../generated/autoconf.h.html#1112" data-ref="_M/CONFIG_64BIT">CONFIG_64BIT</a></u></td></tr>
<tr><th id="278">278</th><td><u>#define <dfn class="macro" id="_M/SWAP_RA_ORDER_CEILING" data-ref="_M/SWAP_RA_ORDER_CEILING">SWAP_RA_ORDER_CEILING</dfn>	5</u></td></tr>
<tr><th id="279">279</th><td><u>#<span data-ppcond="277">else</span></u></td></tr>
<tr><th id="280">280</th><td><i>/* Avoid stack overflow, because we need to save part of page table */</i></td></tr>
<tr><th id="281">281</th><td><u>#define SWAP_RA_ORDER_CEILING	3</u></td></tr>
<tr><th id="282">282</th><td><u>#define SWAP_RA_PTE_CACHE_SIZE	(1 &lt;&lt; SWAP_RA_ORDER_CEILING)</u></td></tr>
<tr><th id="283">283</th><td><u>#<span data-ppcond="277">endif</span></u></td></tr>
<tr><th id="284">284</th><td></td></tr>
<tr><th id="285">285</th><td><b>struct</b> <dfn class="type def" id="vma_swap_readahead" title='vma_swap_readahead' data-ref="vma_swap_readahead">vma_swap_readahead</dfn> {</td></tr>
<tr><th id="286">286</th><td>	<em>unsigned</em> <em>short</em> <dfn class="decl field" id="vma_swap_readahead::win" title='vma_swap_readahead::win' data-ref="vma_swap_readahead::win">win</dfn>;</td></tr>
<tr><th id="287">287</th><td>	<em>unsigned</em> <em>short</em> <dfn class="decl field" id="vma_swap_readahead::offset" title='vma_swap_readahead::offset' data-ref="vma_swap_readahead::offset">offset</dfn>;</td></tr>
<tr><th id="288">288</th><td>	<em>unsigned</em> <em>short</em> <dfn class="decl field" id="vma_swap_readahead::nr_pte" title='vma_swap_readahead::nr_pte' data-ref="vma_swap_readahead::nr_pte">nr_pte</dfn>;</td></tr>
<tr><th id="289">289</th><td><u>#<span data-ppcond="289">ifdef</span> <a class="macro" href="../generated/autoconf.h.html#1112" data-ref="_M/CONFIG_64BIT">CONFIG_64BIT</a></u></td></tr>
<tr><th id="290">290</th><td>	<a class="typedef" href="../../arch/x86/include/asm/pgtable_64_types.h.html#pte_t" title='pte_t' data-type='struct pte_t' data-ref="pte_t">pte_t</a> *<dfn class="decl field" id="vma_swap_readahead::ptes" title='vma_swap_readahead::ptes' data-ref="vma_swap_readahead::ptes">ptes</dfn>;</td></tr>
<tr><th id="291">291</th><td><u>#<span data-ppcond="289">else</span></u></td></tr>
<tr><th id="292">292</th><td>	pte_t ptes[SWAP_RA_PTE_CACHE_SIZE];</td></tr>
<tr><th id="293">293</th><td><u>#<span data-ppcond="289">endif</span></u></td></tr>
<tr><th id="294">294</th><td>};</td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td><i>/* linux/mm/workingset.c */</i></td></tr>
<tr><th id="297">297</th><td><em>void</em> *<dfn class="decl fn" id="workingset_eviction" title='workingset_eviction' data-ref="workingset_eviction">workingset_eviction</dfn>(<b>struct</b> <a class="type" href="fs.h.html#address_space" title='address_space' data-ref="address_space">address_space</a> *<dfn class="local col6 decl" id="256mapping" title='mapping' data-type='struct address_space *' data-ref="256mapping">mapping</dfn>, <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col7 decl" id="257page" title='page' data-type='struct page *' data-ref="257page">page</dfn>);</td></tr>
<tr><th id="298">298</th><td><a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl fn" id="workingset_refault" title='workingset_refault' data-ref="workingset_refault">workingset_refault</dfn>(<em>void</em> *<dfn class="local col8 decl" id="258shadow" title='shadow' data-type='void *' data-ref="258shadow">shadow</dfn>);</td></tr>
<tr><th id="299">299</th><td><em>void</em> <dfn class="decl fn" id="workingset_activation" title='workingset_activation' data-ref="workingset_activation">workingset_activation</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col9 decl" id="259page" title='page' data-type='struct page *' data-ref="259page">page</dfn>);</td></tr>
<tr><th id="300">300</th><td><em>void</em> <dfn class="decl fn" id="workingset_update_node" title='workingset_update_node' data-ref="workingset_update_node">workingset_update_node</dfn>(<b>struct</b> <a class="type" href="radix-tree.h.html#radix_tree_node" title='radix_tree_node' data-ref="radix_tree_node">radix_tree_node</a> *<dfn class="local col0 decl" id="260node" title='node' data-type='struct radix_tree_node *' data-ref="260node">node</dfn>, <em>void</em> *<dfn class="local col1 decl" id="261private" title='private' data-type='void *' data-ref="261private">private</dfn>);</td></tr>
<tr><th id="301">301</th><td></td></tr>
<tr><th id="302">302</th><td><i>/* linux/mm/page_alloc.c */</i></td></tr>
<tr><th id="303">303</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <a class="decl" href="mm.h.html#totalram_pages" title='totalram_pages' data-ref="totalram_pages" id="totalram_pages">totalram_pages</a>;</td></tr>
<tr><th id="304">304</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl" id="totalreserve_pages" title='totalreserve_pages' data-ref="totalreserve_pages">totalreserve_pages</dfn>;</td></tr>
<tr><th id="305">305</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="nr_free_buffer_pages" title='nr_free_buffer_pages' data-ref="nr_free_buffer_pages">nr_free_buffer_pages</dfn>(<em>void</em>);</td></tr>
<tr><th id="306">306</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="nr_free_pagecache_pages" title='nr_free_pagecache_pages' data-ref="nr_free_pagecache_pages">nr_free_pagecache_pages</dfn>(<em>void</em>);</td></tr>
<tr><th id="307">307</th><td></td></tr>
<tr><th id="308">308</th><td><i>/* Definition of global_zone_page_state not available yet */</i></td></tr>
<tr><th id="309">309</th><td><u>#define <dfn class="macro" id="_M/nr_free_pages" data-ref="_M/nr_free_pages">nr_free_pages</dfn>() global_zone_page_state(NR_FREE_PAGES)</u></td></tr>
<tr><th id="310">310</th><td></td></tr>
<tr><th id="311">311</th><td></td></tr>
<tr><th id="312">312</th><td><i>/* linux/mm/swap.c */</i></td></tr>
<tr><th id="313">313</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_cache_add" title='lru_cache_add' data-ref="lru_cache_add">lru_cache_add</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="314">314</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_cache_add_anon" title='lru_cache_add_anon' data-ref="lru_cache_add_anon">lru_cache_add_anon</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col2 decl" id="262page" title='page' data-type='struct page *' data-ref="262page">page</dfn>);</td></tr>
<tr><th id="315">315</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_cache_add_file" title='lru_cache_add_file' data-ref="lru_cache_add_file">lru_cache_add_file</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col3 decl" id="263page" title='page' data-type='struct page *' data-ref="263page">page</dfn>);</td></tr>
<tr><th id="316">316</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_add_page_tail" title='lru_add_page_tail' data-ref="lru_add_page_tail">lru_add_page_tail</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col4 decl" id="264page" title='page' data-type='struct page *' data-ref="264page">page</dfn>, <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col5 decl" id="265page_tail" title='page_tail' data-type='struct page *' data-ref="265page_tail">page_tail</dfn>,</td></tr>
<tr><th id="317">317</th><td>			 <b>struct</b> <a class="type" href="mmzone.h.html#lruvec" title='lruvec' data-ref="lruvec">lruvec</a> *<dfn class="local col6 decl" id="266lruvec" title='lruvec' data-type='struct lruvec *' data-ref="266lruvec">lruvec</dfn>, <b>struct</b> <a class="type" href="types.h.html#list_head" title='list_head' data-ref="list_head">list_head</a> *<dfn class="local col7 decl" id="267head" title='head' data-type='struct list_head *' data-ref="267head">head</dfn>);</td></tr>
<tr><th id="318">318</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="activate_page" title='activate_page' data-ref="activate_page">activate_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="319">319</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="mark_page_accessed" title='mark_page_accessed' data-ref="mark_page_accessed">mark_page_accessed</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="320">320</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_add_drain" title='lru_add_drain' data-ref="lru_add_drain">lru_add_drain</dfn>(<em>void</em>);</td></tr>
<tr><th id="321">321</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_add_drain_cpu" title='lru_add_drain_cpu' data-ref="lru_add_drain_cpu">lru_add_drain_cpu</dfn>(<em>int</em> <dfn class="local col8 decl" id="268cpu" title='cpu' data-type='int' data-ref="268cpu">cpu</dfn>);</td></tr>
<tr><th id="322">322</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_add_drain_all" title='lru_add_drain_all' data-ref="lru_add_drain_all">lru_add_drain_all</dfn>(<em>void</em>);</td></tr>
<tr><th id="323">323</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_add_drain_all_cpuslocked" title='lru_add_drain_all_cpuslocked' data-ref="lru_add_drain_all_cpuslocked">lru_add_drain_all_cpuslocked</dfn>(<em>void</em>);</td></tr>
<tr><th id="324">324</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="rotate_reclaimable_page" title='rotate_reclaimable_page' data-ref="rotate_reclaimable_page">rotate_reclaimable_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col9 decl" id="269page" title='page' data-type='struct page *' data-ref="269page">page</dfn>);</td></tr>
<tr><th id="325">325</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="deactivate_file_page" title='deactivate_file_page' data-ref="deactivate_file_page">deactivate_file_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col0 decl" id="270page" title='page' data-type='struct page *' data-ref="270page">page</dfn>);</td></tr>
<tr><th id="326">326</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="mark_page_lazyfree" title='mark_page_lazyfree' data-ref="mark_page_lazyfree">mark_page_lazyfree</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col1 decl" id="271page" title='page' data-type='struct page *' data-ref="271page">page</dfn>);</td></tr>
<tr><th id="327">327</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="swap_setup" title='swap_setup' data-ref="swap_setup">swap_setup</dfn>(<em>void</em>);</td></tr>
<tr><th id="328">328</th><td></td></tr>
<tr><th id="329">329</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="add_page_to_unevictable_list" title='add_page_to_unevictable_list' data-ref="add_page_to_unevictable_list">add_page_to_unevictable_list</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col2 decl" id="272page" title='page' data-type='struct page *' data-ref="272page">page</dfn>);</td></tr>
<tr><th id="330">330</th><td></td></tr>
<tr><th id="331">331</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="lru_cache_add_active_or_unevictable" title='lru_cache_add_active_or_unevictable' data-ref="lru_cache_add_active_or_unevictable">lru_cache_add_active_or_unevictable</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col3 decl" id="273page" title='page' data-type='struct page *' data-ref="273page">page</dfn>,</td></tr>
<tr><th id="332">332</th><td>						<b>struct</b> <a class="type" href="mm_types.h.html#vm_area_struct" title='vm_area_struct' data-ref="vm_area_struct">vm_area_struct</a> *<dfn class="local col4 decl" id="274vma" title='vma' data-type='struct vm_area_struct *' data-ref="274vma">vma</dfn>);</td></tr>
<tr><th id="333">333</th><td></td></tr>
<tr><th id="334">334</th><td><i>/* linux/mm/vmscan.c */</i></td></tr>
<tr><th id="335">335</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="zone_reclaimable_pages" title='zone_reclaimable_pages' data-ref="zone_reclaimable_pages">zone_reclaimable_pages</dfn>(<b>struct</b> <a class="type" href="mmzone.h.html#zone" title='zone' data-ref="zone">zone</a> *<dfn class="local col5 decl" id="275zone" title='zone' data-type='struct zone *' data-ref="275zone">zone</dfn>);</td></tr>
<tr><th id="336">336</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="pgdat_reclaimable_pages" title='pgdat_reclaimable_pages' data-ref="pgdat_reclaimable_pages">pgdat_reclaimable_pages</dfn>(<b>struct</b> <a class="type" href="mmzone.h.html#pglist_data" title='pglist_data' data-ref="pglist_data">pglist_data</a> *<dfn class="local col6 decl" id="276pgdat" title='pgdat' data-type='struct pglist_data *' data-ref="276pgdat">pgdat</dfn>);</td></tr>
<tr><th id="337">337</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="try_to_free_pages" title='try_to_free_pages' data-ref="try_to_free_pages">try_to_free_pages</dfn>(<b>struct</b> <a class="type" href="mmzone.h.html#zonelist" title='zonelist' data-ref="zonelist">zonelist</a> *<dfn class="local col7 decl" id="277zonelist" title='zonelist' data-type='struct zonelist *' data-ref="277zonelist">zonelist</dfn>, <em>int</em> <dfn class="local col8 decl" id="278order" title='order' data-type='int' data-ref="278order">order</dfn>,</td></tr>
<tr><th id="338">338</th><td>					<a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col9 decl" id="279gfp_mask" title='gfp_mask' data-type='gfp_t' data-ref="279gfp_mask">gfp_mask</dfn>, <a class="typedef" href="nodemask.h.html#nodemask_t" title='nodemask_t' data-type='struct nodemask_t' data-ref="nodemask_t">nodemask_t</a> *<dfn class="local col0 decl" id="280mask" title='mask' data-type='nodemask_t *' data-ref="280mask">mask</dfn>);</td></tr>
<tr><th id="339">339</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="__isolate_lru_page" title='__isolate_lru_page' data-ref="__isolate_lru_page">__isolate_lru_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col1 decl" id="281page" title='page' data-type='struct page *' data-ref="281page">page</dfn>, <a class="typedef" href="mmzone.h.html#isolate_mode_t" title='isolate_mode_t' data-type='unsigned int' data-ref="isolate_mode_t">isolate_mode_t</a> <dfn class="local col2 decl" id="282mode" title='mode' data-type='isolate_mode_t' data-ref="282mode">mode</dfn>);</td></tr>
<tr><th id="340">340</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="try_to_free_mem_cgroup_pages" title='try_to_free_mem_cgroup_pages' data-ref="try_to_free_mem_cgroup_pages">try_to_free_mem_cgroup_pages</dfn>(<b>struct</b> <a class="type" href="slab.h.html#mem_cgroup" title='mem_cgroup' data-ref="mem_cgroup">mem_cgroup</a> *<dfn class="local col3 decl" id="283memcg" title='memcg' data-type='struct mem_cgroup *' data-ref="283memcg">memcg</dfn>,</td></tr>
<tr><th id="341">341</th><td>						  <em>unsigned</em> <em>long</em> <dfn class="local col4 decl" id="284nr_pages" title='nr_pages' data-type='unsigned long' data-ref="284nr_pages">nr_pages</dfn>,</td></tr>
<tr><th id="342">342</th><td>						  <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col5 decl" id="285gfp_mask" title='gfp_mask' data-type='gfp_t' data-ref="285gfp_mask">gfp_mask</dfn>,</td></tr>
<tr><th id="343">343</th><td>						  <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="local col6 decl" id="286may_swap" title='may_swap' data-type='bool' data-ref="286may_swap">may_swap</dfn>);</td></tr>
<tr><th id="344">344</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="mem_cgroup_shrink_node" title='mem_cgroup_shrink_node' data-ref="mem_cgroup_shrink_node">mem_cgroup_shrink_node</dfn>(<b>struct</b> <a class="type" href="slab.h.html#mem_cgroup" title='mem_cgroup' data-ref="mem_cgroup">mem_cgroup</a> *<dfn class="local col7 decl" id="287mem" title='mem' data-type='struct mem_cgroup *' data-ref="287mem">mem</dfn>,</td></tr>
<tr><th id="345">345</th><td>						<a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col8 decl" id="288gfp_mask" title='gfp_mask' data-type='gfp_t' data-ref="288gfp_mask">gfp_mask</dfn>, <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="local col9 decl" id="289noswap" title='noswap' data-type='bool' data-ref="289noswap">noswap</dfn>,</td></tr>
<tr><th id="346">346</th><td>						<a class="typedef" href="mmzone.h.html#pg_data_t" title='pg_data_t' data-type='struct pglist_data' data-ref="pg_data_t">pg_data_t</a> *<dfn class="local col0 decl" id="290pgdat" title='pgdat' data-type='pg_data_t *' data-ref="290pgdat">pgdat</dfn>,</td></tr>
<tr><th id="347">347</th><td>						<em>unsigned</em> <em>long</em> *<dfn class="local col1 decl" id="291nr_scanned" title='nr_scanned' data-type='unsigned long *' data-ref="291nr_scanned">nr_scanned</dfn>);</td></tr>
<tr><th id="348">348</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="shrink_all_memory" title='shrink_all_memory' data-ref="shrink_all_memory">shrink_all_memory</dfn>(<em>unsigned</em> <em>long</em> <dfn class="local col2 decl" id="292nr_pages" title='nr_pages' data-type='unsigned long' data-ref="292nr_pages">nr_pages</dfn>);</td></tr>
<tr><th id="349">349</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="vm_swappiness" title='vm_swappiness' data-ref="vm_swappiness">vm_swappiness</dfn>;</td></tr>
<tr><th id="350">350</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="remove_mapping" title='remove_mapping' data-ref="remove_mapping">remove_mapping</dfn>(<b>struct</b> <a class="type" href="fs.h.html#address_space" title='address_space' data-ref="address_space">address_space</a> *<dfn class="local col3 decl" id="293mapping" title='mapping' data-type='struct address_space *' data-ref="293mapping">mapping</dfn>, <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col4 decl" id="294page" title='page' data-type='struct page *' data-ref="294page">page</dfn>);</td></tr>
<tr><th id="351">351</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl" id="vm_total_pages" title='vm_total_pages' data-ref="vm_total_pages">vm_total_pages</dfn>;</td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td><u>#<span data-ppcond="353">ifdef</span> <span class="macro" data-ref="_M/CONFIG_NUMA">CONFIG_NUMA</span></u></td></tr>
<tr><th id="354">354</th><td><b>extern</b> <em>int</em> node_reclaim_mode;</td></tr>
<tr><th id="355">355</th><td><b>extern</b> <em>int</em> sysctl_min_unmapped_ratio;</td></tr>
<tr><th id="356">356</th><td><b>extern</b> <em>int</em> sysctl_min_slab_ratio;</td></tr>
<tr><th id="357">357</th><td><b>extern</b> <em>int</em> node_reclaim(<b>struct</b> pglist_data *, gfp_t, <em>unsigned</em> <em>int</em>);</td></tr>
<tr><th id="358">358</th><td><u>#<span data-ppcond="353">else</span></u></td></tr>
<tr><th id="359">359</th><td><u>#define <dfn class="macro" id="_M/node_reclaim_mode" data-ref="_M/node_reclaim_mode">node_reclaim_mode</dfn> 0</u></td></tr>
<tr><th id="360">360</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="node_reclaim" title='node_reclaim' data-ref="node_reclaim">node_reclaim</dfn>(<b>struct</b> <a class="type" href="mmzone.h.html#pglist_data" title='pglist_data' data-ref="pglist_data">pglist_data</a> *<dfn class="local col5 decl" id="295pgdat" title='pgdat' data-type='struct pglist_data *' data-ref="295pgdat">pgdat</dfn>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col6 decl" id="296mask" title='mask' data-type='gfp_t' data-ref="296mask">mask</dfn>,</td></tr>
<tr><th id="361">361</th><td>				<em>unsigned</em> <em>int</em> <dfn class="local col7 decl" id="297order" title='order' data-type='unsigned int' data-ref="297order">order</dfn>)</td></tr>
<tr><th id="362">362</th><td>{</td></tr>
<tr><th id="363">363</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="364">364</th><td>}</td></tr>
<tr><th id="365">365</th><td><u>#<span data-ppcond="353">endif</span></u></td></tr>
<tr><th id="366">366</th><td></td></tr>
<tr><th id="367">367</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="page_evictable" title='page_evictable' data-ref="page_evictable">page_evictable</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col8 decl" id="298page" title='page' data-type='struct page *' data-ref="298page">page</dfn>);</td></tr>
<tr><th id="368">368</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="check_move_unevictable_pages" title='check_move_unevictable_pages' data-ref="check_move_unevictable_pages">check_move_unevictable_pages</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> **, <em>int</em> <dfn class="local col9 decl" id="299nr_pages" title='nr_pages' data-type='int' data-ref="299nr_pages">nr_pages</dfn>);</td></tr>
<tr><th id="369">369</th><td></td></tr>
<tr><th id="370">370</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="kswapd_run" title='kswapd_run' data-ref="kswapd_run">kswapd_run</dfn>(<em>int</em> <dfn class="local col0 decl" id="300nid" title='nid' data-type='int' data-ref="300nid">nid</dfn>);</td></tr>
<tr><th id="371">371</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="kswapd_stop" title='kswapd_stop' data-ref="kswapd_stop">kswapd_stop</dfn>(<em>int</em> <dfn class="local col1 decl" id="301nid" title='nid' data-type='int' data-ref="301nid">nid</dfn>);</td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td><u>#<span data-ppcond="373">ifdef</span> <a class="macro" href="../generated/autoconf.h.html#1136" data-ref="_M/CONFIG_SWAP">CONFIG_SWAP</a></u></td></tr>
<tr><th id="374">374</th><td></td></tr>
<tr><th id="375">375</th><td><u>#include <a href="blk_types.h.html">&lt;linux/blk_types.h&gt;</a> /* for bio_end_io_t */</u></td></tr>
<tr><th id="376">376</th><td></td></tr>
<tr><th id="377">377</th><td><i>/* linux/mm/page_io.c */</i></td></tr>
<tr><th id="378">378</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swap_readpage" title='swap_readpage' data-ref="swap_readpage">swap_readpage</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col2 decl" id="302page" title='page' data-type='struct page *' data-ref="302page">page</dfn>, <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="local col3 decl" id="303do_poll" title='do_poll' data-type='bool' data-ref="303do_poll">do_poll</dfn>);</td></tr>
<tr><th id="379">379</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swap_writepage" title='swap_writepage' data-ref="swap_writepage">swap_writepage</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col4 decl" id="304page" title='page' data-type='struct page *' data-ref="304page">page</dfn>, <b>struct</b> <a class="type" href="writeback.h.html#writeback_control" title='writeback_control' data-ref="writeback_control">writeback_control</a> *<dfn class="local col5 decl" id="305wbc" title='wbc' data-type='struct writeback_control *' data-ref="305wbc">wbc</dfn>);</td></tr>
<tr><th id="380">380</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="end_swap_bio_write" title='end_swap_bio_write' data-ref="end_swap_bio_write">end_swap_bio_write</dfn>(<b>struct</b> <a class="type" href="blk_types.h.html#bio" title='bio' data-ref="bio">bio</a> *<dfn class="local col6 decl" id="306bio" title='bio' data-type='struct bio *' data-ref="306bio">bio</dfn>);</td></tr>
<tr><th id="381">381</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="__swap_writepage" title='__swap_writepage' data-ref="__swap_writepage">__swap_writepage</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col7 decl" id="307page" title='page' data-type='struct page *' data-ref="307page">page</dfn>, <b>struct</b> <a class="type" href="writeback.h.html#writeback_control" title='writeback_control' data-ref="writeback_control">writeback_control</a> *<dfn class="local col8 decl" id="308wbc" title='wbc' data-type='struct writeback_control *' data-ref="308wbc">wbc</dfn>,</td></tr>
<tr><th id="382">382</th><td>	<a class="typedef" href="blk_types.h.html#bio_end_io_t" title='bio_end_io_t' data-type='void (struct bio *)' data-ref="bio_end_io_t">bio_end_io_t</a> <dfn class="local col9 decl" id="309end_write_func" title='end_write_func' data-type='bio_end_io_t *' data-ref="309end_write_func">end_write_func</dfn>);</td></tr>
<tr><th id="383">383</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swap_set_page_dirty" title='swap_set_page_dirty' data-ref="swap_set_page_dirty">swap_set_page_dirty</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col0 decl" id="310page" title='page' data-type='struct page *' data-ref="310page">page</dfn>);</td></tr>
<tr><th id="384">384</th><td></td></tr>
<tr><th id="385">385</th><td><em>int</em> <dfn class="decl fn" id="add_swap_extent" title='add_swap_extent' data-ref="add_swap_extent">add_swap_extent</dfn>(<b>struct</b> <a class="type" href="#swap_info_struct" title='swap_info_struct' data-ref="swap_info_struct">swap_info_struct</a> *<dfn class="local col1 decl" id="311sis" title='sis' data-type='struct swap_info_struct *' data-ref="311sis">sis</dfn>, <em>unsigned</em> <em>long</em> <dfn class="local col2 decl" id="312start_page" title='start_page' data-type='unsigned long' data-ref="312start_page">start_page</dfn>,</td></tr>
<tr><th id="386">386</th><td>		<em>unsigned</em> <em>long</em> <dfn class="local col3 decl" id="313nr_pages" title='nr_pages' data-type='unsigned long' data-ref="313nr_pages">nr_pages</dfn>, <a class="typedef" href="types.h.html#sector_t" title='sector_t' data-type='unsigned long' data-ref="sector_t">sector_t</a> <dfn class="local col4 decl" id="314start_block" title='start_block' data-type='sector_t' data-ref="314start_block">start_block</dfn>);</td></tr>
<tr><th id="387">387</th><td><em>int</em> <dfn class="decl fn" id="generic_swapfile_activate" title='generic_swapfile_activate' data-ref="generic_swapfile_activate">generic_swapfile_activate</dfn>(<b>struct</b> <a class="type" href="#swap_info_struct" title='swap_info_struct' data-ref="swap_info_struct">swap_info_struct</a> *, <b>struct</b> <a class="type" href="fs.h.html#file" title='file' data-ref="file">file</a> *,</td></tr>
<tr><th id="388">388</th><td>		<a class="typedef" href="types.h.html#sector_t" title='sector_t' data-type='unsigned long' data-ref="sector_t">sector_t</a> *);</td></tr>
<tr><th id="389">389</th><td></td></tr>
<tr><th id="390">390</th><td><i>/* linux/mm/swap_state.c */</i></td></tr>
<tr><th id="391">391</th><td><i>/* One swap address space for each 64M swap space */</i></td></tr>
<tr><th id="392">392</th><td><u>#define <dfn class="macro" id="_M/SWAP_ADDRESS_SPACE_SHIFT" data-ref="_M/SWAP_ADDRESS_SPACE_SHIFT">SWAP_ADDRESS_SPACE_SHIFT</dfn>	14</u></td></tr>
<tr><th id="393">393</th><td><u>#define <dfn class="macro" id="_M/SWAP_ADDRESS_SPACE_PAGES" data-ref="_M/SWAP_ADDRESS_SPACE_PAGES">SWAP_ADDRESS_SPACE_PAGES</dfn>	(1 &lt;&lt; SWAP_ADDRESS_SPACE_SHIFT)</u></td></tr>
<tr><th id="394">394</th><td><b>extern</b> <b>struct</b> <a class="type" href="fs.h.html#address_space" title='address_space' data-ref="address_space">address_space</a> *<dfn class="decl" id="swapper_spaces" title='swapper_spaces' data-ref="swapper_spaces">swapper_spaces</dfn>[];</td></tr>
<tr><th id="395">395</th><td><b>extern</b> <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl" id="swap_vma_readahead" title='swap_vma_readahead' data-ref="swap_vma_readahead">swap_vma_readahead</dfn>;</td></tr>
<tr><th id="396">396</th><td><u>#define <dfn class="macro" id="_M/swap_address_space" data-ref="_M/swap_address_space">swap_address_space</dfn>(entry)			    \</u></td></tr>
<tr><th id="397">397</th><td><u>	(&amp;swapper_spaces[swp_type(entry)][swp_offset(entry) \</u></td></tr>
<tr><th id="398">398</th><td><u>		&gt;&gt; SWAP_ADDRESS_SPACE_SHIFT])</u></td></tr>
<tr><th id="399">399</th><td><b>extern</b> <em>unsigned</em> <em>long</em> <dfn class="decl fn" id="total_swapcache_pages" title='total_swapcache_pages' data-ref="total_swapcache_pages">total_swapcache_pages</dfn>(<em>void</em>);</td></tr>
<tr><th id="400">400</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="show_swap_cache_info" title='show_swap_cache_info' data-ref="show_swap_cache_info">show_swap_cache_info</dfn>(<em>void</em>);</td></tr>
<tr><th id="401">401</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="add_to_swap" title='add_to_swap' data-ref="add_to_swap">add_to_swap</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col5 decl" id="315page" title='page' data-type='struct page *' data-ref="315page">page</dfn>);</td></tr>
<tr><th id="402">402</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="add_to_swap_cache" title='add_to_swap_cache' data-ref="add_to_swap_cache">add_to_swap_cache</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *, <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a>);</td></tr>
<tr><th id="403">403</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="__add_to_swap_cache" title='__add_to_swap_cache' data-ref="__add_to_swap_cache">__add_to_swap_cache</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col6 decl" id="316page" title='page' data-type='struct page *' data-ref="316page">page</dfn>, <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col7 decl" id="317entry" title='entry' data-type='swp_entry_t' data-ref="317entry">entry</dfn>);</td></tr>
<tr><th id="404">404</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="__delete_from_swap_cache" title='__delete_from_swap_cache' data-ref="__delete_from_swap_cache">__delete_from_swap_cache</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="405">405</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="delete_from_swap_cache" title='delete_from_swap_cache' data-ref="delete_from_swap_cache">delete_from_swap_cache</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="406">406</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="free_page_and_swap_cache" title='free_page_and_swap_cache' data-ref="free_page_and_swap_cache">free_page_and_swap_cache</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="407">407</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="free_pages_and_swap_cache" title='free_pages_and_swap_cache' data-ref="free_pages_and_swap_cache">free_pages_and_swap_cache</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> **, <em>int</em>);</td></tr>
<tr><th id="408">408</th><td><b>extern</b> <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="decl fn" id="lookup_swap_cache" title='lookup_swap_cache' data-ref="lookup_swap_cache">lookup_swap_cache</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col8 decl" id="318entry" title='entry' data-type='swp_entry_t' data-ref="318entry">entry</dfn>,</td></tr>
<tr><th id="409">409</th><td>				      <b>struct</b> <a class="type" href="mm_types.h.html#vm_area_struct" title='vm_area_struct' data-ref="vm_area_struct">vm_area_struct</a> *<dfn class="local col9 decl" id="319vma" title='vma' data-type='struct vm_area_struct *' data-ref="319vma">vma</dfn>,</td></tr>
<tr><th id="410">410</th><td>				      <em>unsigned</em> <em>long</em> <dfn class="local col0 decl" id="320addr" title='addr' data-type='unsigned long' data-ref="320addr">addr</dfn>);</td></tr>
<tr><th id="411">411</th><td><b>extern</b> <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="decl fn" id="read_swap_cache_async" title='read_swap_cache_async' data-ref="read_swap_cache_async">read_swap_cache_async</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a>,</td></tr>
<tr><th id="412">412</th><td>			<b>struct</b> <a class="type" href="mm_types.h.html#vm_area_struct" title='vm_area_struct' data-ref="vm_area_struct">vm_area_struct</a> *<dfn class="local col1 decl" id="321vma" title='vma' data-type='struct vm_area_struct *' data-ref="321vma">vma</dfn>, <em>unsigned</em> <em>long</em> <dfn class="local col2 decl" id="322addr" title='addr' data-type='unsigned long' data-ref="322addr">addr</dfn>,</td></tr>
<tr><th id="413">413</th><td>			<a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="local col3 decl" id="323do_poll" title='do_poll' data-type='bool' data-ref="323do_poll">do_poll</dfn>);</td></tr>
<tr><th id="414">414</th><td><b>extern</b> <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="decl fn" id="__read_swap_cache_async" title='__read_swap_cache_async' data-ref="__read_swap_cache_async">__read_swap_cache_async</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a>,</td></tr>
<tr><th id="415">415</th><td>			<b>struct</b> <a class="type" href="mm_types.h.html#vm_area_struct" title='vm_area_struct' data-ref="vm_area_struct">vm_area_struct</a> *<dfn class="local col4 decl" id="324vma" title='vma' data-type='struct vm_area_struct *' data-ref="324vma">vma</dfn>, <em>unsigned</em> <em>long</em> <dfn class="local col5 decl" id="325addr" title='addr' data-type='unsigned long' data-ref="325addr">addr</dfn>,</td></tr>
<tr><th id="416">416</th><td>			<a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> *<dfn class="local col6 decl" id="326new_page_allocated" title='new_page_allocated' data-type='bool *' data-ref="326new_page_allocated">new_page_allocated</dfn>);</td></tr>
<tr><th id="417">417</th><td><b>extern</b> <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="decl fn" id="swapin_readahead" title='swapin_readahead' data-ref="swapin_readahead">swapin_readahead</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a>,</td></tr>
<tr><th id="418">418</th><td>			<b>struct</b> <a class="type" href="mm_types.h.html#vm_area_struct" title='vm_area_struct' data-ref="vm_area_struct">vm_area_struct</a> *<dfn class="local col7 decl" id="327vma" title='vma' data-type='struct vm_area_struct *' data-ref="327vma">vma</dfn>, <em>unsigned</em> <em>long</em> <dfn class="local col8 decl" id="328addr" title='addr' data-type='unsigned long' data-ref="328addr">addr</dfn>);</td></tr>
<tr><th id="419">419</th><td></td></tr>
<tr><th id="420">420</th><td><b>extern</b> <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="decl fn" id="swap_readahead_detect" title='swap_readahead_detect' data-ref="swap_readahead_detect">swap_readahead_detect</dfn>(<b>struct</b> <a class="type" href="mm.h.html#vm_fault" title='vm_fault' data-ref="vm_fault">vm_fault</a> *<dfn class="local col9 decl" id="329vmf" title='vmf' data-type='struct vm_fault *' data-ref="329vmf">vmf</dfn>,</td></tr>
<tr><th id="421">421</th><td>					  <b>struct</b> <a class="type" href="#vma_swap_readahead" title='vma_swap_readahead' data-ref="vma_swap_readahead">vma_swap_readahead</a> *<dfn class="local col0 decl" id="330swap_ra" title='swap_ra' data-type='struct vma_swap_readahead *' data-ref="330swap_ra">swap_ra</dfn>);</td></tr>
<tr><th id="422">422</th><td><b>extern</b> <b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="decl fn" id="do_swap_page_readahead" title='do_swap_page_readahead' data-ref="do_swap_page_readahead">do_swap_page_readahead</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col1 decl" id="331fentry" title='fentry' data-type='swp_entry_t' data-ref="331fentry">fentry</dfn>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a> <dfn class="local col2 decl" id="332gfp_mask" title='gfp_mask' data-type='gfp_t' data-ref="332gfp_mask">gfp_mask</dfn>,</td></tr>
<tr><th id="423">423</th><td>					   <b>struct</b> <a class="type" href="mm.h.html#vm_fault" title='vm_fault' data-ref="vm_fault">vm_fault</a> *<dfn class="local col3 decl" id="333vmf" title='vmf' data-type='struct vm_fault *' data-ref="333vmf">vmf</dfn>,</td></tr>
<tr><th id="424">424</th><td>					   <b>struct</b> <a class="type" href="#vma_swap_readahead" title='vma_swap_readahead' data-ref="vma_swap_readahead">vma_swap_readahead</a> *<dfn class="local col4 decl" id="334swap_ra" title='swap_ra' data-type='struct vma_swap_readahead *' data-ref="334swap_ra">swap_ra</dfn>);</td></tr>
<tr><th id="425">425</th><td></td></tr>
<tr><th id="426">426</th><td><i>/* linux/mm/swapfile.c */</i></td></tr>
<tr><th id="427">427</th><td><b>extern</b> <a class="typedef" href="../asm-generic/atomic-long.h.html#atomic_long_t" title='atomic_long_t' data-type='atomic64_t' data-ref="atomic_long_t">atomic_long_t</a> <dfn class="decl" id="nr_swap_pages" title='nr_swap_pages' data-ref="nr_swap_pages">nr_swap_pages</dfn>;</td></tr>
<tr><th id="428">428</th><td><b>extern</b> <em>long</em> <dfn class="decl" id="total_swap_pages" title='total_swap_pages' data-ref="total_swap_pages">total_swap_pages</dfn>;</td></tr>
<tr><th id="429">429</th><td><b>extern</b> <a class="typedef" href="types.h.html#atomic_t" title='atomic_t' data-type='struct atomic_t' data-ref="atomic_t">atomic_t</a> <dfn class="decl" id="nr_rotate_swap" title='nr_rotate_swap' data-ref="nr_rotate_swap">nr_rotate_swap</dfn>;</td></tr>
<tr><th id="430">430</th><td><b>extern</b> <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl fn" id="has_usable_swap" title='has_usable_swap' data-ref="has_usable_swap">has_usable_swap</dfn>(<em>void</em>);</td></tr>
<tr><th id="431">431</th><td></td></tr>
<tr><th id="432">432</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl def fn" id="swap_use_vma_readahead" title='swap_use_vma_readahead' data-ref="swap_use_vma_readahead">swap_use_vma_readahead</dfn>(<em>void</em>)</td></tr>
<tr><th id="433">433</th><td>{</td></tr>
<tr><th id="434">434</th><td>	<b>return</b> <a class="macro" href="compiler.h.html#254" title="({ union { typeof(swap_vma_readahead) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(swap_vma_readahead), __u.__c, sizeof(swap_vma_readahead)); else __read_once_size_nocheck(&amp;(swap_vma_readahead), __u.__c, sizeof(swap_vma_readahead)); do { } while (0); __u.__val; })" data-ref="_M/READ_ONCE">READ_ONCE</a>(<a class="ref" href="#swap_vma_readahead" title='swap_vma_readahead' data-ref="swap_vma_readahead">swap_vma_readahead</a>) &amp;&amp; !<a class="ref fn" href="../../arch/x86/include/asm/atomic.h.html#atomic_read" title='atomic_read' data-ref="atomic_read">atomic_read</a>(&amp;<a class="ref" href="#nr_rotate_swap" title='nr_rotate_swap' data-ref="nr_rotate_swap">nr_rotate_swap</a>);</td></tr>
<tr><th id="435">435</th><td>}</td></tr>
<tr><th id="436">436</th><td></td></tr>
<tr><th id="437">437</th><td><i>/* Swap 50% full? Release swapcache more aggressively.. */</i></td></tr>
<tr><th id="438">438</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl def fn" id="vm_swap_full" title='vm_swap_full' data-ref="vm_swap_full">vm_swap_full</dfn>(<em>void</em>)</td></tr>
<tr><th id="439">439</th><td>{</td></tr>
<tr><th id="440">440</th><td>	<b>return</b> <a class="ref fn" href="../asm-generic/atomic-long.h.html#45" title='atomic_long_read' data-ref="atomic_long_read">atomic_long_read</a>(&amp;<a class="ref" href="#nr_swap_pages" title='nr_swap_pages' data-ref="nr_swap_pages">nr_swap_pages</a>) * <var>2</var> &lt; <a class="ref" href="#total_swap_pages" title='total_swap_pages' data-ref="total_swap_pages">total_swap_pages</a>;</td></tr>
<tr><th id="441">441</th><td>}</td></tr>
<tr><th id="442">442</th><td></td></tr>
<tr><th id="443">443</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>long</em> <dfn class="decl def fn" id="get_nr_swap_pages" title='get_nr_swap_pages' data-ref="get_nr_swap_pages">get_nr_swap_pages</dfn>(<em>void</em>)</td></tr>
<tr><th id="444">444</th><td>{</td></tr>
<tr><th id="445">445</th><td>	<b>return</b> <a class="ref fn" href="../asm-generic/atomic-long.h.html#45" title='atomic_long_read' data-ref="atomic_long_read">atomic_long_read</a>(&amp;<a class="ref" href="#nr_swap_pages" title='nr_swap_pages' data-ref="nr_swap_pages">nr_swap_pages</a>);</td></tr>
<tr><th id="446">446</th><td>}</td></tr>
<tr><th id="447">447</th><td></td></tr>
<tr><th id="448">448</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="si_swapinfo" title='si_swapinfo' data-ref="si_swapinfo">si_swapinfo</dfn>(<b>struct</b> <a class="type" href="../uapi/linux/sysinfo.h.html#sysinfo" title='sysinfo' data-ref="sysinfo">sysinfo</a> *);</td></tr>
<tr><th id="449">449</th><td><b>extern</b> <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="decl fn" id="get_swap_page" title='get_swap_page' data-ref="get_swap_page">get_swap_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col5 decl" id="335page" title='page' data-type='struct page *' data-ref="335page">page</dfn>);</td></tr>
<tr><th id="450">450</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="put_swap_page" title='put_swap_page' data-ref="put_swap_page">put_swap_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col6 decl" id="336page" title='page' data-type='struct page *' data-ref="336page">page</dfn>, <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col7 decl" id="337entry" title='entry' data-type='swp_entry_t' data-ref="337entry">entry</dfn>);</td></tr>
<tr><th id="451">451</th><td><b>extern</b> <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="decl fn" id="get_swap_page_of_type" title='get_swap_page_of_type' data-ref="get_swap_page_of_type">get_swap_page_of_type</dfn>(<em>int</em>);</td></tr>
<tr><th id="452">452</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="get_swap_pages" title='get_swap_pages' data-ref="get_swap_pages">get_swap_pages</dfn>(<em>int</em> <dfn class="local col8 decl" id="338n" title='n' data-type='int' data-ref="338n">n</dfn>, <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="local col9 decl" id="339cluster" title='cluster' data-type='bool' data-ref="339cluster">cluster</dfn>, <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col0 decl" id="340swp_entries" title='swp_entries' data-type='swp_entry_t *' data-ref="340swp_entries">swp_entries</dfn>[]);</td></tr>
<tr><th id="453">453</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="add_swap_count_continuation" title='add_swap_count_continuation' data-ref="add_swap_count_continuation">add_swap_count_continuation</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>, <a class="typedef" href="types.h.html#gfp_t" title='gfp_t' data-type='unsigned int' data-ref="gfp_t">gfp_t</a>);</td></tr>
<tr><th id="454">454</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="swap_shmem_alloc" title='swap_shmem_alloc' data-ref="swap_shmem_alloc">swap_shmem_alloc</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>);</td></tr>
<tr><th id="455">455</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swap_duplicate" title='swap_duplicate' data-ref="swap_duplicate">swap_duplicate</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>);</td></tr>
<tr><th id="456">456</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swapcache_prepare" title='swapcache_prepare' data-ref="swapcache_prepare">swapcache_prepare</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>);</td></tr>
<tr><th id="457">457</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="swap_free" title='swap_free' data-ref="swap_free">swap_free</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>);</td></tr>
<tr><th id="458">458</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="swapcache_free_entries" title='swapcache_free_entries' data-ref="swapcache_free_entries">swapcache_free_entries</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> *<dfn class="local col1 decl" id="341entries" title='entries' data-type='swp_entry_t *' data-ref="341entries">entries</dfn>, <em>int</em> <dfn class="local col2 decl" id="342n" title='n' data-type='int' data-ref="342n">n</dfn>);</td></tr>
<tr><th id="459">459</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="free_swap_and_cache" title='free_swap_and_cache' data-ref="free_swap_and_cache">free_swap_and_cache</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a>);</td></tr>
<tr><th id="460">460</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swap_type_of" title='swap_type_of' data-ref="swap_type_of">swap_type_of</dfn>(<a class="typedef" href="types.h.html#dev_t" title='dev_t' data-type='__kernel_dev_t' data-ref="dev_t">dev_t</a>, <a class="typedef" href="types.h.html#sector_t" title='sector_t' data-type='unsigned long' data-ref="sector_t">sector_t</a>, <b>struct</b> <a class="type" href="fs.h.html#block_device" title='block_device' data-ref="block_device">block_device</a> **);</td></tr>
<tr><th id="461">461</th><td><b>extern</b> <em>unsigned</em> <em>int</em> <dfn class="decl fn" id="count_swap_pages" title='count_swap_pages' data-ref="count_swap_pages">count_swap_pages</dfn>(<em>int</em>, <em>int</em>);</td></tr>
<tr><th id="462">462</th><td><b>extern</b> <a class="typedef" href="types.h.html#sector_t" title='sector_t' data-type='unsigned long' data-ref="sector_t">sector_t</a> <dfn class="decl fn" id="map_swap_page" title='map_swap_page' data-ref="map_swap_page">map_swap_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *, <b>struct</b> <a class="type" href="fs.h.html#block_device" title='block_device' data-ref="block_device">block_device</a> **);</td></tr>
<tr><th id="463">463</th><td><b>extern</b> <a class="typedef" href="types.h.html#sector_t" title='sector_t' data-type='unsigned long' data-ref="sector_t">sector_t</a> <dfn class="decl fn" id="swapdev_block" title='swapdev_block' data-ref="swapdev_block">swapdev_block</dfn>(<em>int</em>, <a class="macro" href="types.h.html#141" title="unsigned long" data-ref="_M/pgoff_t">pgoff_t</a>);</td></tr>
<tr><th id="464">464</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="page_swapcount" title='page_swapcount' data-ref="page_swapcount">page_swapcount</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="465">465</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="__swp_swapcount" title='__swp_swapcount' data-ref="__swp_swapcount">__swp_swapcount</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col3 decl" id="343entry" title='entry' data-type='swp_entry_t' data-ref="343entry">entry</dfn>);</td></tr>
<tr><th id="466">466</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="swp_swapcount" title='swp_swapcount' data-ref="swp_swapcount">swp_swapcount</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col4 decl" id="344entry" title='entry' data-type='swp_entry_t' data-ref="344entry">entry</dfn>);</td></tr>
<tr><th id="467">467</th><td><b>extern</b> <b>struct</b> <a class="type" href="#swap_info_struct" title='swap_info_struct' data-ref="swap_info_struct">swap_info_struct</a> *<dfn class="decl fn" id="page_swap_info" title='page_swap_info' data-ref="page_swap_info">page_swap_info</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="468">468</th><td><b>extern</b> <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl fn" id="reuse_swap_page" title='reuse_swap_page' data-ref="reuse_swap_page">reuse_swap_page</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *, <em>int</em> *);</td></tr>
<tr><th id="469">469</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="try_to_free_swap" title='try_to_free_swap' data-ref="try_to_free_swap">try_to_free_swap</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *);</td></tr>
<tr><th id="470">470</th><td><b>struct</b> <a class="type" href="backing-dev-defs.h.html#backing_dev_info" title='backing_dev_info' data-ref="backing_dev_info" id="backing_dev_info">backing_dev_info</a>;</td></tr>
<tr><th id="471">471</th><td><b>extern</b> <em>int</em> <dfn class="decl fn" id="init_swap_address_space" title='init_swap_address_space' data-ref="init_swap_address_space">init_swap_address_space</dfn>(<em>unsigned</em> <em>int</em> <dfn class="local col5 decl" id="345type" title='type' data-type='unsigned int' data-ref="345type">type</dfn>, <em>unsigned</em> <em>long</em> <dfn class="local col6 decl" id="346nr_pages" title='nr_pages' data-type='unsigned long' data-ref="346nr_pages">nr_pages</dfn>);</td></tr>
<tr><th id="472">472</th><td><b>extern</b> <em>void</em> <dfn class="decl fn" id="exit_swap_address_space" title='exit_swap_address_space' data-ref="exit_swap_address_space">exit_swap_address_space</dfn>(<em>unsigned</em> <em>int</em> <dfn class="local col7 decl" id="347type" title='type' data-type='unsigned int' data-ref="347type">type</dfn>);</td></tr>
<tr><th id="473">473</th><td></td></tr>
<tr><th id="474">474</th><td><u>#<span data-ppcond="373">else</span> /* CONFIG_SWAP */</u></td></tr>
<tr><th id="475">475</th><td></td></tr>
<tr><th id="476">476</th><td><u>#define swap_address_space(entry)		(NULL)</u></td></tr>
<tr><th id="477">477</th><td><u>#define get_nr_swap_pages()			0L</u></td></tr>
<tr><th id="478">478</th><td><u>#define total_swap_pages			0L</u></td></tr>
<tr><th id="479">479</th><td><u>#define total_swapcache_pages()			0UL</u></td></tr>
<tr><th id="480">480</th><td><u>#define vm_swap_full()				0</u></td></tr>
<tr><th id="481">481</th><td></td></tr>
<tr><th id="482">482</th><td><u>#define si_swapinfo(val) \</u></td></tr>
<tr><th id="483">483</th><td><u>	do { (val)-&gt;freeswap = (val)-&gt;totalswap = 0; } while (0)</u></td></tr>
<tr><th id="484">484</th><td><i>/* only sparc can not include linux/pagemap.h in this file</i></td></tr>
<tr><th id="485">485</th><td><i> * so leave put_page and release_pages undeclared... */</i></td></tr>
<tr><th id="486">486</th><td><u>#define free_page_and_swap_cache(page) \</u></td></tr>
<tr><th id="487">487</th><td><u>	put_page(page)</u></td></tr>
<tr><th id="488">488</th><td><u>#define free_pages_and_swap_cache(pages, nr) \</u></td></tr>
<tr><th id="489">489</th><td><u>	release_pages((pages), (nr), false);</u></td></tr>
<tr><th id="490">490</th><td></td></tr>
<tr><th id="491">491</th><td><em>static</em> <b>inline</b> <em>void</em> show_swap_cache_info(<em>void</em>)</td></tr>
<tr><th id="492">492</th><td>{</td></tr>
<tr><th id="493">493</th><td>}</td></tr>
<tr><th id="494">494</th><td></td></tr>
<tr><th id="495">495</th><td><u>#define free_swap_and_cache(e) ({(is_migration_entry(e) || is_device_private_entry(e));})</u></td></tr>
<tr><th id="496">496</th><td><u>#define swapcache_prepare(e) ({(is_migration_entry(e) || is_device_private_entry(e));})</u></td></tr>
<tr><th id="497">497</th><td></td></tr>
<tr><th id="498">498</th><td><em>static</em> <b>inline</b> <em>int</em> add_swap_count_continuation(swp_entry_t swp, gfp_t gfp_mask)</td></tr>
<tr><th id="499">499</th><td>{</td></tr>
<tr><th id="500">500</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="501">501</th><td>}</td></tr>
<tr><th id="502">502</th><td></td></tr>
<tr><th id="503">503</th><td><em>static</em> <b>inline</b> <em>void</em> swap_shmem_alloc(swp_entry_t swp)</td></tr>
<tr><th id="504">504</th><td>{</td></tr>
<tr><th id="505">505</th><td>}</td></tr>
<tr><th id="506">506</th><td></td></tr>
<tr><th id="507">507</th><td><em>static</em> <b>inline</b> <em>int</em> swap_duplicate(swp_entry_t swp)</td></tr>
<tr><th id="508">508</th><td>{</td></tr>
<tr><th id="509">509</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="510">510</th><td>}</td></tr>
<tr><th id="511">511</th><td></td></tr>
<tr><th id="512">512</th><td><em>static</em> <b>inline</b> <em>void</em> swap_free(swp_entry_t swp)</td></tr>
<tr><th id="513">513</th><td>{</td></tr>
<tr><th id="514">514</th><td>}</td></tr>
<tr><th id="515">515</th><td></td></tr>
<tr><th id="516">516</th><td><em>static</em> <b>inline</b> <em>void</em> put_swap_page(<b>struct</b> page *page, swp_entry_t swp)</td></tr>
<tr><th id="517">517</th><td>{</td></tr>
<tr><th id="518">518</th><td>}</td></tr>
<tr><th id="519">519</th><td></td></tr>
<tr><th id="520">520</th><td><em>static</em> <b>inline</b> <b>struct</b> page *swapin_readahead(swp_entry_t swp, gfp_t gfp_mask,</td></tr>
<tr><th id="521">521</th><td>			<b>struct</b> vm_area_struct *vma, <em>unsigned</em> <em>long</em> addr)</td></tr>
<tr><th id="522">522</th><td>{</td></tr>
<tr><th id="523">523</th><td>	<b>return</b> NULL;</td></tr>
<tr><th id="524">524</th><td>}</td></tr>
<tr><th id="525">525</th><td></td></tr>
<tr><th id="526">526</th><td><em>static</em> <b>inline</b> bool swap_use_vma_readahead(<em>void</em>)</td></tr>
<tr><th id="527">527</th><td>{</td></tr>
<tr><th id="528">528</th><td>	<b>return</b> false;</td></tr>
<tr><th id="529">529</th><td>}</td></tr>
<tr><th id="530">530</th><td></td></tr>
<tr><th id="531">531</th><td><em>static</em> <b>inline</b> <b>struct</b> page *swap_readahead_detect(</td></tr>
<tr><th id="532">532</th><td>	<b>struct</b> vm_fault *vmf, <b>struct</b> vma_swap_readahead *swap_ra)</td></tr>
<tr><th id="533">533</th><td>{</td></tr>
<tr><th id="534">534</th><td>	<b>return</b> NULL;</td></tr>
<tr><th id="535">535</th><td>}</td></tr>
<tr><th id="536">536</th><td></td></tr>
<tr><th id="537">537</th><td><em>static</em> <b>inline</b> <b>struct</b> page *do_swap_page_readahead(</td></tr>
<tr><th id="538">538</th><td>	swp_entry_t fentry, gfp_t gfp_mask,</td></tr>
<tr><th id="539">539</th><td>	<b>struct</b> vm_fault *vmf, <b>struct</b> vma_swap_readahead *swap_ra)</td></tr>
<tr><th id="540">540</th><td>{</td></tr>
<tr><th id="541">541</th><td>	<b>return</b> NULL;</td></tr>
<tr><th id="542">542</th><td>}</td></tr>
<tr><th id="543">543</th><td></td></tr>
<tr><th id="544">544</th><td><em>static</em> <b>inline</b> <em>int</em> swap_writepage(<b>struct</b> page *p, <b>struct</b> writeback_control *wbc)</td></tr>
<tr><th id="545">545</th><td>{</td></tr>
<tr><th id="546">546</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="547">547</th><td>}</td></tr>
<tr><th id="548">548</th><td></td></tr>
<tr><th id="549">549</th><td><em>static</em> <b>inline</b> <b>struct</b> page *lookup_swap_cache(swp_entry_t swp,</td></tr>
<tr><th id="550">550</th><td>					     <b>struct</b> vm_area_struct *vma,</td></tr>
<tr><th id="551">551</th><td>					     <em>unsigned</em> <em>long</em> addr)</td></tr>
<tr><th id="552">552</th><td>{</td></tr>
<tr><th id="553">553</th><td>	<b>return</b> NULL;</td></tr>
<tr><th id="554">554</th><td>}</td></tr>
<tr><th id="555">555</th><td></td></tr>
<tr><th id="556">556</th><td><em>static</em> <b>inline</b> <em>int</em> add_to_swap(<b>struct</b> page *page)</td></tr>
<tr><th id="557">557</th><td>{</td></tr>
<tr><th id="558">558</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="559">559</th><td>}</td></tr>
<tr><th id="560">560</th><td></td></tr>
<tr><th id="561">561</th><td><em>static</em> <b>inline</b> <em>int</em> add_to_swap_cache(<b>struct</b> page *page, swp_entry_t entry,</td></tr>
<tr><th id="562">562</th><td>							gfp_t gfp_mask)</td></tr>
<tr><th id="563">563</th><td>{</td></tr>
<tr><th id="564">564</th><td>	<b>return</b> -<var>1</var>;</td></tr>
<tr><th id="565">565</th><td>}</td></tr>
<tr><th id="566">566</th><td></td></tr>
<tr><th id="567">567</th><td><em>static</em> <b>inline</b> <em>void</em> __delete_from_swap_cache(<b>struct</b> page *page)</td></tr>
<tr><th id="568">568</th><td>{</td></tr>
<tr><th id="569">569</th><td>}</td></tr>
<tr><th id="570">570</th><td></td></tr>
<tr><th id="571">571</th><td><em>static</em> <b>inline</b> <em>void</em> delete_from_swap_cache(<b>struct</b> page *page)</td></tr>
<tr><th id="572">572</th><td>{</td></tr>
<tr><th id="573">573</th><td>}</td></tr>
<tr><th id="574">574</th><td></td></tr>
<tr><th id="575">575</th><td><em>static</em> <b>inline</b> <em>int</em> page_swapcount(<b>struct</b> page *page)</td></tr>
<tr><th id="576">576</th><td>{</td></tr>
<tr><th id="577">577</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="578">578</th><td>}</td></tr>
<tr><th id="579">579</th><td></td></tr>
<tr><th id="580">580</th><td><em>static</em> <b>inline</b> <em>int</em> __swp_swapcount(swp_entry_t entry)</td></tr>
<tr><th id="581">581</th><td>{</td></tr>
<tr><th id="582">582</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="583">583</th><td>}</td></tr>
<tr><th id="584">584</th><td></td></tr>
<tr><th id="585">585</th><td><em>static</em> <b>inline</b> <em>int</em> swp_swapcount(swp_entry_t entry)</td></tr>
<tr><th id="586">586</th><td>{</td></tr>
<tr><th id="587">587</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="588">588</th><td>}</td></tr>
<tr><th id="589">589</th><td></td></tr>
<tr><th id="590">590</th><td><u>#define reuse_swap_page(page, total_map_swapcount) \</u></td></tr>
<tr><th id="591">591</th><td><u>	(page_trans_huge_mapcount(page, total_map_swapcount) == 1)</u></td></tr>
<tr><th id="592">592</th><td></td></tr>
<tr><th id="593">593</th><td><em>static</em> <b>inline</b> <em>int</em> try_to_free_swap(<b>struct</b> page *page)</td></tr>
<tr><th id="594">594</th><td>{</td></tr>
<tr><th id="595">595</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="596">596</th><td>}</td></tr>
<tr><th id="597">597</th><td></td></tr>
<tr><th id="598">598</th><td><em>static</em> <b>inline</b> swp_entry_t get_swap_page(<b>struct</b> page *page)</td></tr>
<tr><th id="599">599</th><td>{</td></tr>
<tr><th id="600">600</th><td>	swp_entry_t entry;</td></tr>
<tr><th id="601">601</th><td>	entry.val = <var>0</var>;</td></tr>
<tr><th id="602">602</th><td>	<b>return</b> entry;</td></tr>
<tr><th id="603">603</th><td>}</td></tr>
<tr><th id="604">604</th><td></td></tr>
<tr><th id="605">605</th><td><u>#<span data-ppcond="373">endif</span> /* CONFIG_SWAP */</u></td></tr>
<tr><th id="606">606</th><td></td></tr>
<tr><th id="607">607</th><td><u>#<span data-ppcond="607">ifdef</span> <span class="macro" data-ref="_M/CONFIG_THP_SWAP">CONFIG_THP_SWAP</span></u></td></tr>
<tr><th id="608">608</th><td><b>extern</b> <em>int</em> split_swap_cluster(swp_entry_t entry);</td></tr>
<tr><th id="609">609</th><td><u>#<span data-ppcond="607">else</span></u></td></tr>
<tr><th id="610">610</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="split_swap_cluster" title='split_swap_cluster' data-ref="split_swap_cluster">split_swap_cluster</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col8 decl" id="348entry" title='entry' data-type='swp_entry_t' data-ref="348entry">entry</dfn>)</td></tr>
<tr><th id="611">611</th><td>{</td></tr>
<tr><th id="612">612</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="613">613</th><td>}</td></tr>
<tr><th id="614">614</th><td><u>#<span data-ppcond="607">endif</span></u></td></tr>
<tr><th id="615">615</th><td></td></tr>
<tr><th id="616">616</th><td><u>#<span data-ppcond="616">ifdef</span> <span class="macro" data-ref="_M/CONFIG_MEMCG">CONFIG_MEMCG</span></u></td></tr>
<tr><th id="617">617</th><td><em>static</em> <b>inline</b> <em>int</em> mem_cgroup_swappiness(<b>struct</b> mem_cgroup *memcg)</td></tr>
<tr><th id="618">618</th><td>{</td></tr>
<tr><th id="619">619</th><td>	<i>/* Cgroup2 doesn't have per-cgroup swappiness */</i></td></tr>
<tr><th id="620">620</th><td>	<b>if</b> (cgroup_subsys_on_dfl(memory_cgrp_subsys))</td></tr>
<tr><th id="621">621</th><td>		<b>return</b> vm_swappiness;</td></tr>
<tr><th id="622">622</th><td></td></tr>
<tr><th id="623">623</th><td>	<i>/* root ? */</i></td></tr>
<tr><th id="624">624</th><td>	<b>if</b> (mem_cgroup_disabled() || !memcg-&gt;css.parent)</td></tr>
<tr><th id="625">625</th><td>		<b>return</b> vm_swappiness;</td></tr>
<tr><th id="626">626</th><td></td></tr>
<tr><th id="627">627</th><td>	<b>return</b> memcg-&gt;swappiness;</td></tr>
<tr><th id="628">628</th><td>}</td></tr>
<tr><th id="629">629</th><td></td></tr>
<tr><th id="630">630</th><td><u>#<span data-ppcond="616">else</span></u></td></tr>
<tr><th id="631">631</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="mem_cgroup_swappiness" title='mem_cgroup_swappiness' data-ref="mem_cgroup_swappiness">mem_cgroup_swappiness</dfn>(<b>struct</b> <a class="type" href="slab.h.html#mem_cgroup" title='mem_cgroup' data-ref="mem_cgroup">mem_cgroup</a> *<dfn class="local col9 decl" id="349mem" title='mem' data-type='struct mem_cgroup *' data-ref="349mem">mem</dfn>)</td></tr>
<tr><th id="632">632</th><td>{</td></tr>
<tr><th id="633">633</th><td>	<b>return</b> <a class="ref" href="#vm_swappiness" title='vm_swappiness' data-ref="vm_swappiness">vm_swappiness</a>;</td></tr>
<tr><th id="634">634</th><td>}</td></tr>
<tr><th id="635">635</th><td><u>#<span data-ppcond="616">endif</span></u></td></tr>
<tr><th id="636">636</th><td></td></tr>
<tr><th id="637">637</th><td><u>#<span data-ppcond="637">ifdef</span> <span class="macro" data-ref="_M/CONFIG_MEMCG_SWAP">CONFIG_MEMCG_SWAP</span></u></td></tr>
<tr><th id="638">638</th><td><b>extern</b> <em>void</em> mem_cgroup_swapout(<b>struct</b> page *page, swp_entry_t entry);</td></tr>
<tr><th id="639">639</th><td><b>extern</b> <em>int</em> mem_cgroup_try_charge_swap(<b>struct</b> page *page, swp_entry_t entry);</td></tr>
<tr><th id="640">640</th><td><b>extern</b> <em>void</em> mem_cgroup_uncharge_swap(swp_entry_t entry, <em>unsigned</em> <em>int</em> nr_pages);</td></tr>
<tr><th id="641">641</th><td><b>extern</b> <em>long</em> mem_cgroup_get_nr_swap_pages(<b>struct</b> mem_cgroup *memcg);</td></tr>
<tr><th id="642">642</th><td><b>extern</b> bool mem_cgroup_swap_full(<b>struct</b> page *page);</td></tr>
<tr><th id="643">643</th><td><u>#<span data-ppcond="637">else</span></u></td></tr>
<tr><th id="644">644</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> <dfn class="decl def fn" id="mem_cgroup_swapout" title='mem_cgroup_swapout' data-ref="mem_cgroup_swapout">mem_cgroup_swapout</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col0 decl" id="350page" title='page' data-type='struct page *' data-ref="350page">page</dfn>, <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col1 decl" id="351entry" title='entry' data-type='swp_entry_t' data-ref="351entry">entry</dfn>)</td></tr>
<tr><th id="645">645</th><td>{</td></tr>
<tr><th id="646">646</th><td>}</td></tr>
<tr><th id="647">647</th><td></td></tr>
<tr><th id="648">648</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>int</em> <dfn class="decl def fn" id="mem_cgroup_try_charge_swap" title='mem_cgroup_try_charge_swap' data-ref="mem_cgroup_try_charge_swap">mem_cgroup_try_charge_swap</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col2 decl" id="352page" title='page' data-type='struct page *' data-ref="352page">page</dfn>,</td></tr>
<tr><th id="649">649</th><td>					     <a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col3 decl" id="353entry" title='entry' data-type='swp_entry_t' data-ref="353entry">entry</dfn>)</td></tr>
<tr><th id="650">650</th><td>{</td></tr>
<tr><th id="651">651</th><td>	<b>return</b> <var>0</var>;</td></tr>
<tr><th id="652">652</th><td>}</td></tr>
<tr><th id="653">653</th><td></td></tr>
<tr><th id="654">654</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> <dfn class="decl def fn" id="mem_cgroup_uncharge_swap" title='mem_cgroup_uncharge_swap' data-ref="mem_cgroup_uncharge_swap">mem_cgroup_uncharge_swap</dfn>(<a class="typedef" href="mm_types.h.html#swp_entry_t" title='swp_entry_t' data-type='struct swp_entry_t' data-ref="swp_entry_t">swp_entry_t</a> <dfn class="local col4 decl" id="354entry" title='entry' data-type='swp_entry_t' data-ref="354entry">entry</dfn>,</td></tr>
<tr><th id="655">655</th><td>					    <em>unsigned</em> <em>int</em> <dfn class="local col5 decl" id="355nr_pages" title='nr_pages' data-type='unsigned int' data-ref="355nr_pages">nr_pages</dfn>)</td></tr>
<tr><th id="656">656</th><td>{</td></tr>
<tr><th id="657">657</th><td>}</td></tr>
<tr><th id="658">658</th><td></td></tr>
<tr><th id="659">659</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>long</em> <dfn class="decl def fn" id="mem_cgroup_get_nr_swap_pages" title='mem_cgroup_get_nr_swap_pages' data-ref="mem_cgroup_get_nr_swap_pages">mem_cgroup_get_nr_swap_pages</dfn>(<b>struct</b> <a class="type" href="slab.h.html#mem_cgroup" title='mem_cgroup' data-ref="mem_cgroup">mem_cgroup</a> *<dfn class="local col6 decl" id="356memcg" title='memcg' data-type='struct mem_cgroup *' data-ref="356memcg">memcg</dfn>)</td></tr>
<tr><th id="660">660</th><td>{</td></tr>
<tr><th id="661">661</th><td>	<b>return</b> <a class="ref fn" href="#get_nr_swap_pages" title='get_nr_swap_pages' data-ref="get_nr_swap_pages">get_nr_swap_pages</a>();</td></tr>
<tr><th id="662">662</th><td>}</td></tr>
<tr><th id="663">663</th><td></td></tr>
<tr><th id="664">664</th><td><em>static</em> <a class="macro" href="compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <a class="typedef" href="types.h.html#bool" title='bool' data-type='_Bool' data-ref="bool">bool</a> <dfn class="decl def fn" id="mem_cgroup_swap_full" title='mem_cgroup_swap_full' data-ref="mem_cgroup_swap_full">mem_cgroup_swap_full</dfn>(<b>struct</b> <a class="type" href="mm_types.h.html#page" title='page' data-ref="page">page</a> *<dfn class="local col7 decl" id="357page" title='page' data-type='struct page *' data-ref="357page">page</dfn>)</td></tr>
<tr><th id="665">665</th><td>{</td></tr>
<tr><th id="666">666</th><td>	<b>return</b> <a class="ref fn" href="#vm_swap_full" title='vm_swap_full' data-ref="vm_swap_full">vm_swap_full</a>();</td></tr>
<tr><th id="667">667</th><td>}</td></tr>
<tr><th id="668">668</th><td><u>#<span data-ppcond="637">endif</span></u></td></tr>
<tr><th id="669">669</th><td></td></tr>
<tr><th id="670">670</th><td><u>#<span data-ppcond="133">endif</span> /* __KERNEL__*/</u></td></tr>
<tr><th id="671">671</th><td><u>#<span data-ppcond="2">endif</span> /* _LINUX_SWAP_H */</u></td></tr>
<tr><th id="672">672</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../arch/x86/kernel/asm-offsets.c.html'>linux-4.14.y/arch/x86/kernel/asm-offsets.c</a><br/>Generated on <em>2018-Jul-30</em> from project linux-4.14.y revision <em>linux-4.14.y</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
