<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>lockref.c source code [linux-4.14.y/lib/lockref.c] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'linux-4.14.y/lib/lockref.c'; var root_path = '../..'; var data_path = '../../../data';</script>
<script src='../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='..'>linux-4.14.y</a>/<a href='./'>lib</a>/<a href='lockref.c.html'>lockref.c</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>// SPDX-License-Identifier: GPL-2.0</i></td></tr>
<tr><th id="2">2</th><td><u>#include <a href="../include/linux/export.h.html">&lt;linux/export.h&gt;</a></u></td></tr>
<tr><th id="3">3</th><td><u>#include <a href="../include/linux/lockref.h.html">&lt;linux/lockref.h&gt;</a></u></td></tr>
<tr><th id="4">4</th><td></td></tr>
<tr><th id="5">5</th><td><u>#<span data-ppcond="5">if</span> <a class="macro" href="../include/linux/lockref.h.html#21" title="(1 &amp;&amp; 1 &amp;&amp; 4 &lt;= 4)" data-ref="_M/USE_CMPXCHG_LOCKREF">USE_CMPXCHG_LOCKREF</a></u></td></tr>
<tr><th id="6">6</th><td></td></tr>
<tr><th id="7">7</th><td><i>/*</i></td></tr>
<tr><th id="8">8</th><td><i> * Note that the "cmpxchg()" reloads the "old" value for the</i></td></tr>
<tr><th id="9">9</th><td><i> * failure case.</i></td></tr>
<tr><th id="10">10</th><td><i> */</i></td></tr>
<tr><th id="11">11</th><td><u>#define <dfn class="macro" id="_M/CMPXCHG_LOOP" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</dfn>(CODE, SUCCESS) do {					\</u></td></tr>
<tr><th id="12">12</th><td><u>	struct <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> <dfn class="local col2 decl" id="2old" title='old' data-type='struct lockref' data-ref="2old"><dfn class="local col7 decl" id="7old" title='old' data-type='struct lockref' data-ref="7old"><dfn class="local col1 decl" id="11old" title='old' data-type='struct lockref' data-ref="11old"><dfn class="local col5 decl" id="15old" title='old' data-type='struct lockref' data-ref="15old"><dfn class="local col9 decl" id="19old" title='old' data-type='struct lockref' data-ref="19old"><dfn class="local col5 decl" id="25old" title='old' data-type='struct lockref' data-ref="25old">old</dfn></dfn></dfn></dfn></dfn></dfn>;							\</u></td></tr>
<tr><th id="13">13</th><td><u>	BUILD_BUG_ON(sizeof(<a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>) != 8);						\</u></td></tr>
<tr><th id="14">14</th><td><u>	<a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a> = READ_ONCE(<a class="local col1 ref" href="#1lockref" title='lockref' data-ref="1lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref">lockref</a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a>);			\</u></td></tr>
<tr><th id="15">15</th><td><u>	while (likely(arch_spin_value_unlocked(<a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>.<a class="ref field" href="../include/linux/spinlock_types.h.html#spinlock::(anonymous)::rlock" title='spinlock::(anonymous union)::rlock' data-ref="spinlock::(anonymous)::rlock">rlock</a>.<a class="ref field" href="../include/linux/spinlock_types.h.html#raw_spinlock::raw_lock" title='raw_spinlock::raw_lock' data-ref="raw_spinlock::raw_lock">raw_lock</a>))) {  	\</u></td></tr>
<tr><th id="16">16</th><td><u>		struct <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> <dfn class="local col3 decl" id="3new" title='new' data-type='struct lockref' data-ref="3new"><dfn class="local col8 decl" id="8new" title='new' data-type='struct lockref' data-ref="8new"><dfn class="local col2 decl" id="12new" title='new' data-type='struct lockref' data-ref="12new"><dfn class="local col6 decl" id="16new" title='new' data-type='struct lockref' data-ref="16new"><dfn class="local col0 decl" id="20new" title='new' data-type='struct lockref' data-ref="20new"><dfn class="local col6 decl" id="26new" title='new' data-type='struct lockref' data-ref="26new">new</dfn></dfn></dfn></dfn></dfn></dfn> = <a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>, <dfn class="local col4 decl" id="4prev" title='prev' data-type='struct lockref' data-ref="4prev"><dfn class="local col9 decl" id="9prev" title='prev' data-type='struct lockref' data-ref="9prev"><dfn class="local col3 decl" id="13prev" title='prev' data-type='struct lockref' data-ref="13prev"><dfn class="local col7 decl" id="17prev" title='prev' data-type='struct lockref' data-ref="17prev"><dfn class="local col1 decl" id="21prev" title='prev' data-type='struct lockref' data-ref="21prev"><dfn class="local col7 decl" id="27prev" title='prev' data-type='struct lockref' data-ref="27prev">prev</dfn></dfn></dfn></dfn></dfn></dfn> = <a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>;				\</u></td></tr>
<tr><th id="17">17</th><td><u>		CODE								\</u></td></tr>
<tr><th id="18">18</th><td><u>		<a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a> = cmpxchg64_relaxed(&amp;<a class="local col1 ref" href="#1lockref" title='lockref' data-ref="1lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col4 ref" href="#14lockref" title='lockref' data-ref="14lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref"><a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref">lockref</a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a></a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a>,	\</u></td></tr>
<tr><th id="19">19</th><td><u>						   <a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a>,		\</u></td></tr>
<tr><th id="20">20</th><td><u>						   <a class="local col3 ref" href="#43" title='new' data-ref="3new"><a class="local col8 ref" href="#64" title='new' data-ref="8new"><a class="local col2 ref" href="#91" title='new' data-ref="12new"><a class="local col6 ref" href="#117" title='new' data-ref="16new"><a class="local col0 ref" href="#135" title='new' data-ref="20new"><a class="local col6 ref" href="#172" title='new' data-ref="26new">new</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a>);		\</u></td></tr>
<tr><th id="21">21</th><td><u>		if (likely(<a class="local col2 ref" href="#43" title='old' data-ref="2old"><a class="local col7 ref" href="#64" title='old' data-ref="7old"><a class="local col1 ref" href="#91" title='old' data-ref="11old"><a class="local col5 ref" href="#117" title='old' data-ref="15old"><a class="local col9 ref" href="#135" title='old' data-ref="19old"><a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a> == <a class="local col4 ref" href="#43" title='prev' data-ref="4prev"><a class="local col9 ref" href="#64" title='prev' data-ref="9prev"><a class="local col3 ref" href="#91" title='prev' data-ref="13prev"><a class="local col7 ref" href="#117" title='prev' data-ref="17prev"><a class="local col1 ref" href="#135" title='prev' data-ref="21prev"><a class="local col7 ref" href="#172" title='prev' data-ref="27prev">prev</a></a></a></a></a></a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymous)::lock_count" title='lockref::(anonymous union)::lock_count' data-ref="lockref::(anonymous)::lock_count">lock_count</a>)) {		\</u></td></tr>
<tr><th id="22">22</th><td><u>			SUCCESS;						\</u></td></tr>
<tr><th id="23">23</th><td><u>		}								\</u></td></tr>
<tr><th id="24">24</th><td><u>		<a class="ref fn" href="../arch/x86/include/asm/processor.h.html#cpu_relax" title='cpu_relax' data-ref="cpu_relax">cpu_relax</a>();							\</u></td></tr>
<tr><th id="25">25</th><td><u>	}									\</u></td></tr>
<tr><th id="26">26</th><td><u>} while (0)</u></td></tr>
<tr><th id="27">27</th><td></td></tr>
<tr><th id="28">28</th><td><u>#<span data-ppcond="5">else</span></u></td></tr>
<tr><th id="29">29</th><td></td></tr>
<tr><th id="30">30</th><td><u>#define CMPXCHG_LOOP(CODE, SUCCESS) do { } while (0)</u></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><u>#<span data-ppcond="5">endif</span></u></td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td><i class="doc">/**</i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> * lockref_get - Increments reference count unconditionally</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> *</i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * This operation is only valid if you already hold a reference</i></td></tr>
<tr><th id="39">39</th><td><i class="doc"> * to the object, so you know the count cannot be zero.</i></td></tr>
<tr><th id="40">40</th><td><i class="doc"> */</i></td></tr>
<tr><th id="41">41</th><td><em>void</em> <dfn class="decl def fn" id="lockref_get" title='lockref_get' data-ref="lockref_get">lockref_get</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col1 decl" id="1lockref" title='lockref' data-type='struct lockref *' data-ref="1lockref">lockref</dfn>)</td></tr>
<tr><th id="42">42</th><td>{</td></tr>
<tr><th id="43">43</th><td>	<a class="macro" href="#11" title="do { struct lockref old; do { bool __cond = !(!(sizeof(old) != 8)); extern void __compiletime_assert_47(void) ; if (__cond) __compiletime_assert_47(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); old.lock_count = ({ union { typeof(lockref-&gt;lock_count) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); else __read_once_size_nocheck(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); do { } while (0); __u.__val; }); while (__builtin_expect(!!(queued_spin_value_unlocked(old.lock.rlock.raw_lock)), 1)) { struct lockref new = old, prev = old; new.count++; old.lock_count = ({ do { bool __cond = !(!(sizeof(*(&amp;lockref-&gt;lock_count)) != 8)); extern void __compiletime_assert_47(void) ; if (__cond) __compiletime_assert_47(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ({ __typeof__(*(((&amp;lockref-&gt;lock_count)))) __ret; __typeof__(*(((&amp;lockref-&gt;lock_count)))) __old = (((old.lock_count))); __typeof__(*(((&amp;lockref-&gt;lock_count)))) __new = (((new.lock_count))); switch ((sizeof(*((&amp;lockref-&gt;lock_count))))) { case 1: { volatile u8 *__ptr = (volatile u8 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgb %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;q&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 2: { volatile u16 *__ptr = (volatile u16 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgw %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 4: { volatile u32 *__ptr = (volatile u32 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgl %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 8: { volatile u64 *__ptr = (volatile u64 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgq %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } default: __cmpxchg_wrong_size(); } __ret; }); }); if (__builtin_expect(!!(old.lock_count == prev.lock_count), 1)) { return;; } cpu_relax(); } } while (0)" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</a>(</td></tr>
<tr><th id="44">44</th><td>		<a class="local col3 ref" href="#43" title='new' data-ref="3new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="45">45</th><td>	,</td></tr>
<tr><th id="46">46</th><td>		<b>return</b>;</td></tr>
<tr><th id="47">47</th><td>	);</td></tr>
<tr><th id="48">48</th><td></td></tr>
<tr><th id="49">49</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_lock" title='spin_lock' data-ref="spin_lock">spin_lock</a>(&amp;<a class="local col1 ref" href="#1lockref" title='lockref' data-ref="1lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="50">50</th><td>	<a class="local col1 ref" href="#1lockref" title='lockref' data-ref="1lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="51">51</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_unlock" title='spin_unlock' data-ref="spin_unlock">spin_unlock</a>(&amp;<a class="local col1 ref" href="#1lockref" title='lockref' data-ref="1lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="52">52</th><td>}</td></tr>
<tr><th id="53">53</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_get) lockref_get; static const char __kstrtab_lockref_get[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_get&quot;; static const struct kernel_symbol __ksymtab_lockref_get __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_get&quot;), used)) = { (unsigned long)&amp;lockref_get, __kstrtab_lockref_get }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_get" title='lockref_get' data-ref="lockref_get"><a class="ref fn" href="#lockref_get" title='lockref_get' data-ref="lockref_get"><a class="ref fn" href="#lockref_get" title='lockref_get' data-ref="lockref_get"><a class="ref fn" href="#lockref_get" title='lockref_get' data-ref="lockref_get">lockref_get</a></a></a></a>);</td></tr>
<tr><th id="54">54</th><td></td></tr>
<tr><th id="55">55</th><td><i class="doc">/**</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> * lockref_get_not_zero - Increments count unless the count is 0 or dead</i></td></tr>
<tr><th id="57">57</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="58">58</th><td><i class="doc"> * Return: 1 if count updated successfully or 0 if count was zero</i></td></tr>
<tr><th id="59">59</th><td><i class="doc"> */</i></td></tr>
<tr><th id="60">60</th><td><em>int</em> <dfn class="decl def fn" id="lockref_get_not_zero" title='lockref_get_not_zero' data-ref="lockref_get_not_zero">lockref_get_not_zero</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col5 decl" id="5lockref" title='lockref' data-type='struct lockref *' data-ref="5lockref">lockref</dfn>)</td></tr>
<tr><th id="61">61</th><td>{</td></tr>
<tr><th id="62">62</th><td>	<em>int</em> <dfn class="local col6 decl" id="6retval" title='retval' data-type='int' data-ref="6retval">retval</dfn>;</td></tr>
<tr><th id="63">63</th><td></td></tr>
<tr><th id="64">64</th><td>	<a class="macro" href="#11" title="do { struct lockref old; do { bool __cond = !(!(sizeof(old) != 8)); extern void __compiletime_assert_70(void) ; if (__cond) __compiletime_assert_70(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); old.lock_count = ({ union { typeof(lockref-&gt;lock_count) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); else __read_once_size_nocheck(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); do { } while (0); __u.__val; }); while (__builtin_expect(!!(queued_spin_value_unlocked(old.lock.rlock.raw_lock)), 1)) { struct lockref new = old, prev = old; new.count++; if (old.count &lt;= 0) return 0; old.lock_count = ({ do { bool __cond = !(!(sizeof(*(&amp;lockref-&gt;lock_count)) != 8)); extern void __compiletime_assert_70(void) ; if (__cond) __compiletime_assert_70(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ({ __typeof__(*(((&amp;lockref-&gt;lock_count)))) __ret; __typeof__(*(((&amp;lockref-&gt;lock_count)))) __old = (((old.lock_count))); __typeof__(*(((&amp;lockref-&gt;lock_count)))) __new = (((new.lock_count))); switch ((sizeof(*((&amp;lockref-&gt;lock_count))))) { case 1: { volatile u8 *__ptr = (volatile u8 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgb %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;q&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 2: { volatile u16 *__ptr = (volatile u16 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgw %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 4: { volatile u32 *__ptr = (volatile u32 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgl %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 8: { volatile u64 *__ptr = (volatile u64 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgq %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } default: __cmpxchg_wrong_size(); } __ret; }); }); if (__builtin_expect(!!(old.lock_count == prev.lock_count), 1)) { return 1;; } cpu_relax(); } } while (0)" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</a>(</td></tr>
<tr><th id="65">65</th><td>		<a class="local col8 ref" href="#64" title='new' data-ref="8new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="66">66</th><td>		<b>if</b> (<a class="local col7 ref" href="#64" title='old' data-ref="7old">old</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt;= <var>0</var>)</td></tr>
<tr><th id="67">67</th><td>			<b>return</b> <var>0</var>;</td></tr>
<tr><th id="68">68</th><td>	,</td></tr>
<tr><th id="69">69</th><td>		<b>return</b> <var>1</var>;</td></tr>
<tr><th id="70">70</th><td>	);</td></tr>
<tr><th id="71">71</th><td></td></tr>
<tr><th id="72">72</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_lock" title='spin_lock' data-ref="spin_lock">spin_lock</a>(&amp;<a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="73">73</th><td>	<a class="local col6 ref" href="#6retval" title='retval' data-ref="6retval">retval</a> = <var>0</var>;</td></tr>
<tr><th id="74">74</th><td>	<b>if</b> (<a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &gt; <var>0</var>) {</td></tr>
<tr><th id="75">75</th><td>		<a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="76">76</th><td>		<a class="local col6 ref" href="#6retval" title='retval' data-ref="6retval">retval</a> = <var>1</var>;</td></tr>
<tr><th id="77">77</th><td>	}</td></tr>
<tr><th id="78">78</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_unlock" title='spin_unlock' data-ref="spin_unlock">spin_unlock</a>(&amp;<a class="local col5 ref" href="#5lockref" title='lockref' data-ref="5lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="79">79</th><td>	<b>return</b> <a class="local col6 ref" href="#6retval" title='retval' data-ref="6retval">retval</a>;</td></tr>
<tr><th id="80">80</th><td>}</td></tr>
<tr><th id="81">81</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_get_not_zero) lockref_get_not_zero; static const char __kstrtab_lockref_get_not_zero[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_get_not_zero&quot;; static const struct kernel_symbol __ksymtab_lockref_get_not_zero __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_get_not_zero&quot;), used)) = { (unsigned long)&amp;lockref_get_not_zero, __kstrtab_lockref_get_not_zero }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_get_not_zero" title='lockref_get_not_zero' data-ref="lockref_get_not_zero"><a class="ref fn" href="#lockref_get_not_zero" title='lockref_get_not_zero' data-ref="lockref_get_not_zero"><a class="ref fn" href="#lockref_get_not_zero" title='lockref_get_not_zero' data-ref="lockref_get_not_zero"><a class="ref fn" href="#lockref_get_not_zero" title='lockref_get_not_zero' data-ref="lockref_get_not_zero">lockref_get_not_zero</a></a></a></a>);</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td><i class="doc">/**</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * lockref_get_or_lock - Increments count unless the count is 0 or dead</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> * Return: 1 if count updated successfully or 0 if count was zero</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> * and we got the lock instead.</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> */</i></td></tr>
<tr><th id="89">89</th><td><em>int</em> <dfn class="decl def fn" id="lockref_get_or_lock" title='lockref_get_or_lock' data-ref="lockref_get_or_lock">lockref_get_or_lock</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col0 decl" id="10lockref" title='lockref' data-type='struct lockref *' data-ref="10lockref">lockref</dfn>)</td></tr>
<tr><th id="90">90</th><td>{</td></tr>
<tr><th id="91">91</th><td>	<a class="macro" href="#11" title="do { struct lockref old; do { bool __cond = !(!(sizeof(old) != 8)); extern void __compiletime_assert_97(void) ; if (__cond) __compiletime_assert_97(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); old.lock_count = ({ union { typeof(lockref-&gt;lock_count) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); else __read_once_size_nocheck(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); do { } while (0); __u.__val; }); while (__builtin_expect(!!(queued_spin_value_unlocked(old.lock.rlock.raw_lock)), 1)) { struct lockref new = old, prev = old; new.count++; if (old.count &lt;= 0) break; old.lock_count = ({ do { bool __cond = !(!(sizeof(*(&amp;lockref-&gt;lock_count)) != 8)); extern void __compiletime_assert_97(void) ; if (__cond) __compiletime_assert_97(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ({ __typeof__(*(((&amp;lockref-&gt;lock_count)))) __ret; __typeof__(*(((&amp;lockref-&gt;lock_count)))) __old = (((old.lock_count))); __typeof__(*(((&amp;lockref-&gt;lock_count)))) __new = (((new.lock_count))); switch ((sizeof(*((&amp;lockref-&gt;lock_count))))) { case 1: { volatile u8 *__ptr = (volatile u8 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgb %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;q&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 2: { volatile u16 *__ptr = (volatile u16 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgw %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 4: { volatile u32 *__ptr = (volatile u32 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgl %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 8: { volatile u64 *__ptr = (volatile u64 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgq %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } default: __cmpxchg_wrong_size(); } __ret; }); }); if (__builtin_expect(!!(old.lock_count == prev.lock_count), 1)) { return 1;; } cpu_relax(); } } while (0)" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</a>(</td></tr>
<tr><th id="92">92</th><td>		<a class="local col2 ref" href="#91" title='new' data-ref="12new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="93">93</th><td>		<b>if</b> (<a class="local col1 ref" href="#91" title='old' data-ref="11old">old</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt;= <var>0</var>)</td></tr>
<tr><th id="94">94</th><td>			<b>break</b>;</td></tr>
<tr><th id="95">95</th><td>	,</td></tr>
<tr><th id="96">96</th><td>		<b>return</b> <var>1</var>;</td></tr>
<tr><th id="97">97</th><td>	);</td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_lock" title='spin_lock' data-ref="spin_lock">spin_lock</a>(&amp;<a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="100">100</th><td>	<b>if</b> (<a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt;= <var>0</var>)</td></tr>
<tr><th id="101">101</th><td>		<b>return</b> <var>0</var>;</td></tr>
<tr><th id="102">102</th><td>	<a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="103">103</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_unlock" title='spin_unlock' data-ref="spin_unlock">spin_unlock</a>(&amp;<a class="local col0 ref" href="#10lockref" title='lockref' data-ref="10lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="104">104</th><td>	<b>return</b> <var>1</var>;</td></tr>
<tr><th id="105">105</th><td>}</td></tr>
<tr><th id="106">106</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_get_or_lock) lockref_get_or_lock; static const char __kstrtab_lockref_get_or_lock[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_get_or_lock&quot;; static const struct kernel_symbol __ksymtab_lockref_get_or_lock __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_get_or_lock&quot;), used)) = { (unsigned long)&amp;lockref_get_or_lock, __kstrtab_lockref_get_or_lock }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_get_or_lock" title='lockref_get_or_lock' data-ref="lockref_get_or_lock"><a class="ref fn" href="#lockref_get_or_lock" title='lockref_get_or_lock' data-ref="lockref_get_or_lock"><a class="ref fn" href="#lockref_get_or_lock" title='lockref_get_or_lock' data-ref="lockref_get_or_lock"><a class="ref fn" href="#lockref_get_or_lock" title='lockref_get_or_lock' data-ref="lockref_get_or_lock">lockref_get_or_lock</a></a></a></a>);</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td><i class="doc">/**</i></td></tr>
<tr><th id="109">109</th><td><i class="doc"> * lockref_put_return - Decrement reference count if possible</i></td></tr>
<tr><th id="110">110</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="111">111</th><td><i class="doc"> *</i></td></tr>
<tr><th id="112">112</th><td><i class="doc"> * Decrement the reference count and return the new value.</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * If the lockref was dead or locked, return an error.</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> */</i></td></tr>
<tr><th id="115">115</th><td><em>int</em> <dfn class="decl def fn" id="lockref_put_return" title='lockref_put_return' data-ref="lockref_put_return">lockref_put_return</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col4 decl" id="14lockref" title='lockref' data-type='struct lockref *' data-ref="14lockref">lockref</dfn>)</td></tr>
<tr><th id="116">116</th><td>{</td></tr>
<tr><th id="117">117</th><td>	<a class="macro" href="#11" title="do { struct lockref old; do { bool __cond = !(!(sizeof(old) != 8)); extern void __compiletime_assert_123(void) ; if (__cond) __compiletime_assert_123(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); old.lock_count = ({ union { typeof(lockref-&gt;lock_count) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); else __read_once_size_nocheck(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); do { } while (0); __u.__val; }); while (__builtin_expect(!!(queued_spin_value_unlocked(old.lock.rlock.raw_lock)), 1)) { struct lockref new = old, prev = old; new.count--; if (old.count &lt;= 0) return -1; old.lock_count = ({ do { bool __cond = !(!(sizeof(*(&amp;lockref-&gt;lock_count)) != 8)); extern void __compiletime_assert_123(void) ; if (__cond) __compiletime_assert_123(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ({ __typeof__(*(((&amp;lockref-&gt;lock_count)))) __ret; __typeof__(*(((&amp;lockref-&gt;lock_count)))) __old = (((old.lock_count))); __typeof__(*(((&amp;lockref-&gt;lock_count)))) __new = (((new.lock_count))); switch ((sizeof(*((&amp;lockref-&gt;lock_count))))) { case 1: { volatile u8 *__ptr = (volatile u8 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgb %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;q&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 2: { volatile u16 *__ptr = (volatile u16 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgw %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 4: { volatile u32 *__ptr = (volatile u32 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgl %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 8: { volatile u64 *__ptr = (volatile u64 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgq %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } default: __cmpxchg_wrong_size(); } __ret; }); }); if (__builtin_expect(!!(old.lock_count == prev.lock_count), 1)) { return new.count;; } cpu_relax(); } } while (0)" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</a>(</td></tr>
<tr><th id="118">118</th><td>		<a class="local col6 ref" href="#117" title='new' data-ref="16new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>--;</td></tr>
<tr><th id="119">119</th><td>		<b>if</b> (<a class="local col5 ref" href="#117" title='old' data-ref="15old">old</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt;= <var>0</var>)</td></tr>
<tr><th id="120">120</th><td>			<b>return</b> -<var>1</var>;</td></tr>
<tr><th id="121">121</th><td>	,</td></tr>
<tr><th id="122">122</th><td>		<b>return</b> <a class="local col6 ref" href="#117" title='new' data-ref="16new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>;</td></tr>
<tr><th id="123">123</th><td>	);</td></tr>
<tr><th id="124">124</th><td>	<b>return</b> -<var>1</var>;</td></tr>
<tr><th id="125">125</th><td>}</td></tr>
<tr><th id="126">126</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_put_return) lockref_put_return; static const char __kstrtab_lockref_put_return[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_put_return&quot;; static const struct kernel_symbol __ksymtab_lockref_put_return __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_put_return&quot;), used)) = { (unsigned long)&amp;lockref_put_return, __kstrtab_lockref_put_return }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_put_return" title='lockref_put_return' data-ref="lockref_put_return"><a class="ref fn" href="#lockref_put_return" title='lockref_put_return' data-ref="lockref_put_return"><a class="ref fn" href="#lockref_put_return" title='lockref_put_return' data-ref="lockref_put_return"><a class="ref fn" href="#lockref_put_return" title='lockref_put_return' data-ref="lockref_put_return">lockref_put_return</a></a></a></a>);</td></tr>
<tr><th id="127">127</th><td></td></tr>
<tr><th id="128">128</th><td><i class="doc">/**</i></td></tr>
<tr><th id="129">129</th><td><i class="doc"> * lockref_put_or_lock - decrements count unless count &lt;= 1 before decrement</i></td></tr>
<tr><th id="130">130</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="131">131</th><td><i class="doc"> * Return: 1 if count updated successfully or 0 if count &lt;= 1 and lock taken</i></td></tr>
<tr><th id="132">132</th><td><i class="doc"> */</i></td></tr>
<tr><th id="133">133</th><td><em>int</em> <dfn class="decl def fn" id="lockref_put_or_lock" title='lockref_put_or_lock' data-ref="lockref_put_or_lock">lockref_put_or_lock</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col8 decl" id="18lockref" title='lockref' data-type='struct lockref *' data-ref="18lockref">lockref</dfn>)</td></tr>
<tr><th id="134">134</th><td>{</td></tr>
<tr><th id="135">135</th><td>	<a class="macro" href="#11" title="do { struct lockref old; do { bool __cond = !(!(sizeof(old) != 8)); extern void __compiletime_assert_141(void) ; if (__cond) __compiletime_assert_141(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); old.lock_count = ({ union { typeof(lockref-&gt;lock_count) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); else __read_once_size_nocheck(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); do { } while (0); __u.__val; }); while (__builtin_expect(!!(queued_spin_value_unlocked(old.lock.rlock.raw_lock)), 1)) { struct lockref new = old, prev = old; new.count--; if (old.count &lt;= 1) break; old.lock_count = ({ do { bool __cond = !(!(sizeof(*(&amp;lockref-&gt;lock_count)) != 8)); extern void __compiletime_assert_141(void) ; if (__cond) __compiletime_assert_141(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ({ __typeof__(*(((&amp;lockref-&gt;lock_count)))) __ret; __typeof__(*(((&amp;lockref-&gt;lock_count)))) __old = (((old.lock_count))); __typeof__(*(((&amp;lockref-&gt;lock_count)))) __new = (((new.lock_count))); switch ((sizeof(*((&amp;lockref-&gt;lock_count))))) { case 1: { volatile u8 *__ptr = (volatile u8 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgb %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;q&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 2: { volatile u16 *__ptr = (volatile u16 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgw %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 4: { volatile u32 *__ptr = (volatile u32 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgl %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 8: { volatile u64 *__ptr = (volatile u64 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgq %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } default: __cmpxchg_wrong_size(); } __ret; }); }); if (__builtin_expect(!!(old.lock_count == prev.lock_count), 1)) { return 1;; } cpu_relax(); } } while (0)" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</a>(</td></tr>
<tr><th id="136">136</th><td>		<a class="local col0 ref" href="#135" title='new' data-ref="20new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>--;</td></tr>
<tr><th id="137">137</th><td>		<b>if</b> (<a class="local col9 ref" href="#135" title='old' data-ref="19old">old</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt;= <var>1</var>)</td></tr>
<tr><th id="138">138</th><td>			<b>break</b>;</td></tr>
<tr><th id="139">139</th><td>	,</td></tr>
<tr><th id="140">140</th><td>		<b>return</b> <var>1</var>;</td></tr>
<tr><th id="141">141</th><td>	);</td></tr>
<tr><th id="142">142</th><td></td></tr>
<tr><th id="143">143</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_lock" title='spin_lock' data-ref="spin_lock">spin_lock</a>(&amp;<a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="144">144</th><td>	<b>if</b> (<a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt;= <var>1</var>)</td></tr>
<tr><th id="145">145</th><td>		<b>return</b> <var>0</var>;</td></tr>
<tr><th id="146">146</th><td>	<a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>--;</td></tr>
<tr><th id="147">147</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_unlock" title='spin_unlock' data-ref="spin_unlock">spin_unlock</a>(&amp;<a class="local col8 ref" href="#18lockref" title='lockref' data-ref="18lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="148">148</th><td>	<b>return</b> <var>1</var>;</td></tr>
<tr><th id="149">149</th><td>}</td></tr>
<tr><th id="150">150</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_put_or_lock) lockref_put_or_lock; static const char __kstrtab_lockref_put_or_lock[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_put_or_lock&quot;; static const struct kernel_symbol __ksymtab_lockref_put_or_lock __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_put_or_lock&quot;), used)) = { (unsigned long)&amp;lockref_put_or_lock, __kstrtab_lockref_put_or_lock }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_put_or_lock" title='lockref_put_or_lock' data-ref="lockref_put_or_lock"><a class="ref fn" href="#lockref_put_or_lock" title='lockref_put_or_lock' data-ref="lockref_put_or_lock"><a class="ref fn" href="#lockref_put_or_lock" title='lockref_put_or_lock' data-ref="lockref_put_or_lock"><a class="ref fn" href="#lockref_put_or_lock" title='lockref_put_or_lock' data-ref="lockref_put_or_lock">lockref_put_or_lock</a></a></a></a>);</td></tr>
<tr><th id="151">151</th><td></td></tr>
<tr><th id="152">152</th><td><i class="doc">/**</i></td></tr>
<tr><th id="153">153</th><td><i class="doc"> * lockref_mark_dead - mark lockref dead</i></td></tr>
<tr><th id="154">154</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="155">155</th><td><i class="doc"> */</i></td></tr>
<tr><th id="156">156</th><td><em>void</em> <dfn class="decl def fn" id="lockref_mark_dead" title='lockref_mark_dead' data-ref="lockref_mark_dead">lockref_mark_dead</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col2 decl" id="22lockref" title='lockref' data-type='struct lockref *' data-ref="22lockref">lockref</dfn>)</td></tr>
<tr><th id="157">157</th><td>{</td></tr>
<tr><th id="158">158</th><td>	<a class="macro" href="../include/linux/spinlock.h.html#405" title="do { if (__builtin_expect(!!(!queued_spin_is_locked(&amp;(&amp;(&amp;lockref-&gt;lock)-&gt;rlock)-&gt;raw_lock)), 0)) do { do { asm volatile(&quot;1:\t&quot; &quot;.byte 0x0f, 0x0b&quot; &quot;\n&quot; &quot;.pushsection __bug_table,\&quot;aw\&quot;\n&quot; &quot;2:\t&quot; &quot;.long &quot; &quot;1b&quot; &quot; - 2b&quot; &quot;\t# bug_entry::bug_addr\n&quot; &quot;\t&quot; &quot;.long &quot; &quot;%c0&quot; &quot; - 2b&quot; &quot;\t# bug_entry::file\n&quot; &quot;\t.word %c1&quot; &quot;\t# bug_entry::line\n&quot; &quot;\t.word %c2&quot; &quot;\t# bug_entry::flags\n&quot; &quot;\t.org 2b+%c3\n&quot; &quot;.popsection&quot; : : &quot;i&quot; (&quot;/home/tempdban/kernel/stable/lib/lockref.c&quot;), &quot;i&quot; (158), &quot;i&quot; (0), &quot;i&quot; (sizeof(struct bug_entry))); } while (0); do { ({ asm(&quot;%c0:\n\t&quot; &quot;.pushsection .discard.reachable\n\t&quot; &quot;.long %c0b - .\n\t&quot; &quot;.popsection\n\t&quot; : : &quot;i&quot; (7)); }); do { } while (1); } while (0); } while (0); } while (0)" data-ref="_M/assert_spin_locked">assert_spin_locked</a>(&amp;<a class="local col2 ref" href="#22lockref" title='lockref' data-ref="22lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="159">159</th><td>	<a class="local col2 ref" href="#22lockref" title='lockref' data-ref="22lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> = -<var>128</var>;</td></tr>
<tr><th id="160">160</th><td>}</td></tr>
<tr><th id="161">161</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_mark_dead) lockref_mark_dead; static const char __kstrtab_lockref_mark_dead[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_mark_dead&quot;; static const struct kernel_symbol __ksymtab_lockref_mark_dead __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_mark_dead&quot;), used)) = { (unsigned long)&amp;lockref_mark_dead, __kstrtab_lockref_mark_dead }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_mark_dead" title='lockref_mark_dead' data-ref="lockref_mark_dead"><a class="ref fn" href="#lockref_mark_dead" title='lockref_mark_dead' data-ref="lockref_mark_dead"><a class="ref fn" href="#lockref_mark_dead" title='lockref_mark_dead' data-ref="lockref_mark_dead"><a class="ref fn" href="#lockref_mark_dead" title='lockref_mark_dead' data-ref="lockref_mark_dead">lockref_mark_dead</a></a></a></a>);</td></tr>
<tr><th id="162">162</th><td></td></tr>
<tr><th id="163">163</th><td><i class="doc">/**</i></td></tr>
<tr><th id="164">164</th><td><i class="doc"> * lockref_get_not_dead - Increments count unless the ref is dead</i></td></tr>
<tr><th id="165">165</th><td><i class="doc"> *<span class="command"> @lockref</span>: pointer to lockref structure</i></td></tr>
<tr><th id="166">166</th><td><i class="doc"> * Return: 1 if count updated successfully or 0 if lockref was dead</i></td></tr>
<tr><th id="167">167</th><td><i class="doc"> */</i></td></tr>
<tr><th id="168">168</th><td><em>int</em> <dfn class="decl def fn" id="lockref_get_not_dead" title='lockref_get_not_dead' data-ref="lockref_get_not_dead">lockref_get_not_dead</dfn>(<b>struct</b> <a class="type" href="../include/linux/lockref.h.html#lockref" title='lockref' data-ref="lockref">lockref</a> *<dfn class="local col3 decl" id="23lockref" title='lockref' data-type='struct lockref *' data-ref="23lockref">lockref</dfn>)</td></tr>
<tr><th id="169">169</th><td>{</td></tr>
<tr><th id="170">170</th><td>	<em>int</em> <dfn class="local col4 decl" id="24retval" title='retval' data-type='int' data-ref="24retval">retval</dfn>;</td></tr>
<tr><th id="171">171</th><td></td></tr>
<tr><th id="172">172</th><td>	<a class="macro" href="#11" title="do { struct lockref old; do { bool __cond = !(!(sizeof(old) != 8)); extern void __compiletime_assert_178(void) ; if (__cond) __compiletime_assert_178(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); old.lock_count = ({ union { typeof(lockref-&gt;lock_count) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); else __read_once_size_nocheck(&amp;(lockref-&gt;lock_count), __u.__c, sizeof(lockref-&gt;lock_count)); do { } while (0); __u.__val; }); while (__builtin_expect(!!(queued_spin_value_unlocked(old.lock.rlock.raw_lock)), 1)) { struct lockref new = old, prev = old; new.count++; if (old.count &lt; 0) return 0; old.lock_count = ({ do { bool __cond = !(!(sizeof(*(&amp;lockref-&gt;lock_count)) != 8)); extern void __compiletime_assert_178(void) ; if (__cond) __compiletime_assert_178(); do { ((void)sizeof(char[1 - 2 * __cond])); } while (0); } while (0); ({ __typeof__(*(((&amp;lockref-&gt;lock_count)))) __ret; __typeof__(*(((&amp;lockref-&gt;lock_count)))) __old = (((old.lock_count))); __typeof__(*(((&amp;lockref-&gt;lock_count)))) __new = (((new.lock_count))); switch ((sizeof(*((&amp;lockref-&gt;lock_count))))) { case 1: { volatile u8 *__ptr = (volatile u8 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgb %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;q&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 2: { volatile u16 *__ptr = (volatile u16 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgw %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 4: { volatile u32 *__ptr = (volatile u32 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgl %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } case 8: { volatile u64 *__ptr = (volatile u64 *)(((&amp;lockref-&gt;lock_count))); asm volatile(&quot;.pushsection .smp_locks,\&quot;a\&quot;\n&quot; &quot;.balign 4\n&quot; &quot;.long 671f - .\n&quot; &quot;.popsection\n&quot; &quot;671:&quot; &quot;\n\tlock; &quot; &quot;cmpxchgq %2,%1&quot; : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr) : &quot;r&quot; (__new), &quot;0&quot; (__old) : &quot;memory&quot;); break; } default: __cmpxchg_wrong_size(); } __ret; }); }); if (__builtin_expect(!!(old.lock_count == prev.lock_count), 1)) { return 1;; } cpu_relax(); } } while (0)" data-ref="_M/CMPXCHG_LOOP">CMPXCHG_LOOP</a>(</td></tr>
<tr><th id="173">173</th><td>		<a class="local col6 ref" href="#172" title='new' data-ref="26new">new</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="174">174</th><td>		<b>if</b> (<a class="local col5 ref" href="#172" title='old' data-ref="25old">old</a>.<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &lt; <var>0</var>)</td></tr>
<tr><th id="175">175</th><td>			<b>return</b> <var>0</var>;</td></tr>
<tr><th id="176">176</th><td>	,</td></tr>
<tr><th id="177">177</th><td>		<b>return</b> <var>1</var>;</td></tr>
<tr><th id="178">178</th><td>	);</td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_lock" title='spin_lock' data-ref="spin_lock">spin_lock</a>(&amp;<a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="181">181</th><td>	<a class="local col4 ref" href="#24retval" title='retval' data-ref="24retval">retval</a> = <var>0</var>;</td></tr>
<tr><th id="182">182</th><td>	<b>if</b> (<a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a> &gt;= <var>0</var>) {</td></tr>
<tr><th id="183">183</th><td>		<a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::count" title='lockref::(anonymous union)::(anonymous struct)::count' data-ref="lockref::(anonymousunion)::(anonymous)::count">count</a>++;</td></tr>
<tr><th id="184">184</th><td>		<a class="local col4 ref" href="#24retval" title='retval' data-ref="24retval">retval</a> = <var>1</var>;</td></tr>
<tr><th id="185">185</th><td>	}</td></tr>
<tr><th id="186">186</th><td>	<a class="ref fn" href="../include/linux/spinlock.h.html#spin_unlock" title='spin_unlock' data-ref="spin_unlock">spin_unlock</a>(&amp;<a class="local col3 ref" href="#23lockref" title='lockref' data-ref="23lockref">lockref</a>-&gt;<a class="ref field" href="../include/linux/lockref.h.html#lockref::(anonymousunion)::(anonymous)::lock" title='lockref::(anonymous union)::(anonymous struct)::lock' data-ref="lockref::(anonymousunion)::(anonymous)::lock">lock</a>);</td></tr>
<tr><th id="187">187</th><td>	<b>return</b> <a class="local col4 ref" href="#24retval" title='retval' data-ref="24retval">retval</a>;</td></tr>
<tr><th id="188">188</th><td>}</td></tr>
<tr><th id="189">189</th><td><a class="macro" href="../include/linux/export.h.html#103" title="extern typeof(lockref_get_not_dead) lockref_get_not_dead; static const char __kstrtab_lockref_get_not_dead[] __attribute__((section(&quot;__ksymtab_strings&quot;), aligned(1))) = &quot;lockref_get_not_dead&quot;; static const struct kernel_symbol __ksymtab_lockref_get_not_dead __attribute__((__used__)) __attribute__((section(&quot;___ksymtab&quot; &quot;&quot; &quot;+&quot; &quot;lockref_get_not_dead&quot;), used)) = { (unsigned long)&amp;lockref_get_not_dead, __kstrtab_lockref_get_not_dead }" data-ref="_M/EXPORT_SYMBOL">EXPORT_SYMBOL</a>(<a class="decl fn" href="#lockref_get_not_dead" title='lockref_get_not_dead' data-ref="lockref_get_not_dead"><a class="ref fn" href="#lockref_get_not_dead" title='lockref_get_not_dead' data-ref="lockref_get_not_dead"><a class="ref fn" href="#lockref_get_not_dead" title='lockref_get_not_dead' data-ref="lockref_get_not_dead"><a class="ref fn" href="#lockref_get_not_dead" title='lockref_get_not_dead' data-ref="lockref_get_not_dead">lockref_get_not_dead</a></a></a></a>);</td></tr>
<tr><th id="190">190</th><td></td></tr>
</table><hr/><p id='footer'>
Generated on <em>2018-Aug-13</em> from project linux-4.14.y revision <em>linux-4.14.y</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
