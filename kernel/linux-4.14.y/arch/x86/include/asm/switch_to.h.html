<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>switch_to.h source code [linux-4.14.y/arch/x86/include/asm/switch_to.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="fork_frame,inactive_task_frame "/>
<link rel="stylesheet" href="../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'linux-4.14.y/arch/x86/include/asm/switch_to.h'; var root_path = '../../../../..'; var data_path = '../../../../../../data';</script>
<script src='../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>linux-4.14.y</a>/<a href='../../..'>arch</a>/<a href='../..'>x86</a>/<a href='..'>include</a>/<a href='./'>asm</a>/<a href='switch_to.h.html'>switch_to.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* SPDX-License-Identifier: GPL-2.0 */</i></td></tr>
<tr><th id="2">2</th><td><u>#<span data-ppcond="2">ifndef</span> <span class="macro" data-ref="_M/_ASM_X86_SWITCH_TO_H">_ASM_X86_SWITCH_TO_H</span></u></td></tr>
<tr><th id="3">3</th><td><u>#define <dfn class="macro" id="_M/_ASM_X86_SWITCH_TO_H" data-ref="_M/_ASM_X86_SWITCH_TO_H">_ASM_X86_SWITCH_TO_H</dfn></u></td></tr>
<tr><th id="4">4</th><td></td></tr>
<tr><th id="5">5</th><td><u>#include <a href="../../../../include/linux/sched/task_stack.h.html">&lt;linux/sched/task_stack.h&gt;</a></u></td></tr>
<tr><th id="6">6</th><td></td></tr>
<tr><th id="7">7</th><td><b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct" id="task_struct">task_struct</a>; <i>/* one of the stranger aspects of C forward declarations */</i></td></tr>
<tr><th id="8">8</th><td></td></tr>
<tr><th id="9">9</th><td><b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="decl fn" id="__switch_to_asm" title='__switch_to_asm' data-ref="__switch_to_asm">__switch_to_asm</dfn>(<b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col6 decl" id="7506prev" title='prev' data-type='struct task_struct *' data-ref="7506prev">prev</dfn>,</td></tr>
<tr><th id="10">10</th><td>				    <b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col7 decl" id="7507next" title='next' data-type='struct task_struct *' data-ref="7507next">next</dfn>);</td></tr>
<tr><th id="11">11</th><td></td></tr>
<tr><th id="12">12</th><td><a class="macro" href="../../../../include/linux/compiler_types.h.html#249" title="" data-ref="_M/__visible">__visible</a> <b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="decl fn" id="__switch_to" title='__switch_to' data-ref="__switch_to">__switch_to</dfn>(<b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col8 decl" id="7508prev" title='prev' data-type='struct task_struct *' data-ref="7508prev">prev</dfn>,</td></tr>
<tr><th id="13">13</th><td>					  <b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col9 decl" id="7509next" title='next' data-type='struct task_struct *' data-ref="7509next">next</dfn>);</td></tr>
<tr><th id="14">14</th><td><b>struct</b> <a class="type" href="processor.h.html#tss_struct" title='tss_struct' data-ref="tss_struct" id="tss_struct">tss_struct</a>;</td></tr>
<tr><th id="15">15</th><td><em>void</em> <dfn class="decl fn" id="__switch_to_xtra" title='__switch_to_xtra' data-ref="__switch_to_xtra">__switch_to_xtra</dfn>(<b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col0 decl" id="7510prev_p" title='prev_p' data-type='struct task_struct *' data-ref="7510prev_p">prev_p</dfn>, <b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col1 decl" id="7511next_p" title='next_p' data-type='struct task_struct *' data-ref="7511next_p">next_p</dfn>,</td></tr>
<tr><th id="16">16</th><td>		      <b>struct</b> <a class="type" href="processor.h.html#tss_struct" title='tss_struct' data-ref="tss_struct">tss_struct</a> *<dfn class="local col2 decl" id="7512tss" title='tss' data-type='struct tss_struct *' data-ref="7512tss">tss</dfn>);</td></tr>
<tr><th id="17">17</th><td></td></tr>
<tr><th id="18">18</th><td><i>/* This runs runs on the previous thread's stack. */</i></td></tr>
<tr><th id="19">19</th><td><em>static</em> <a class="macro" href="../../../../include/linux/compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> <dfn class="decl def fn" id="prepare_switch_to" title='prepare_switch_to' data-ref="prepare_switch_to">prepare_switch_to</dfn>(<b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col3 decl" id="7513prev" title='prev' data-type='struct task_struct *' data-ref="7513prev">prev</dfn>,</td></tr>
<tr><th id="20">20</th><td>				     <b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col4 decl" id="7514next" title='next' data-type='struct task_struct *' data-ref="7514next">next</dfn>)</td></tr>
<tr><th id="21">21</th><td>{</td></tr>
<tr><th id="22">22</th><td><u>#<span data-ppcond="22">ifdef</span> <a class="macro" href="../../../../include/generated/autoconf.h.html#223" data-ref="_M/CONFIG_VMAP_STACK">CONFIG_VMAP_STACK</a></u></td></tr>
<tr><th id="23">23</th><td>	<i>/*</i></td></tr>
<tr><th id="24">24</th><td><i>	 * If we switch to a stack that has a top-level paging entry</i></td></tr>
<tr><th id="25">25</th><td><i>	 * that is not present in the current mm, the resulting #PF will</i></td></tr>
<tr><th id="26">26</th><td><i>	 * will be promoted to a double-fault and we'll panic.  Probe</i></td></tr>
<tr><th id="27">27</th><td><i>	 * the new stack now so that vmalloc_fault can fix up the page</i></td></tr>
<tr><th id="28">28</th><td><i>	 * tables if needed.  This can only happen if we use a stack</i></td></tr>
<tr><th id="29">29</th><td><i>	 * in vmap space.</i></td></tr>
<tr><th id="30">30</th><td><i>	 *</i></td></tr>
<tr><th id="31">31</th><td><i>	 * We assume that the stack is aligned so that it never spans</i></td></tr>
<tr><th id="32">32</th><td><i>	 * more than one top-level paging entry.</i></td></tr>
<tr><th id="33">33</th><td><i>	 *</i></td></tr>
<tr><th id="34">34</th><td><i>	 * To minimize cache pollution, just follow the stack pointer.</i></td></tr>
<tr><th id="35">35</th><td><i>	 */</i></td></tr>
<tr><th id="36">36</th><td>	<a class="macro" href="../../../../include/linux/compiler.h.html#254" title="({ union { typeof(*(unsigned char *)next-&gt;thread.sp) __val; char __c[1]; } __u; if (1) __read_once_size(&amp;(*(unsigned char *)next-&gt;thread.sp), __u.__c, sizeof(*(unsigned char *)next-&gt;thread.sp)); else __read_once_size_nocheck(&amp;(*(unsigned char *)next-&gt;thread.sp), __u.__c, sizeof(*(unsigned char *)next-&gt;thread.sp)); do { } while (0); __u.__val; })" data-ref="_M/READ_ONCE">READ_ONCE</a>(*(<em>unsigned</em> <em>char</em> *)<a class="local col4 ref" href="#7514next" title='next' data-ref="7514next">next</a>-&gt;<a class="ref field" href="../../../../include/linux/sched.h.html#task_struct::thread" title='task_struct::thread' data-ref="task_struct::thread">thread</a>.<a class="ref field" href="processor.h.html#thread_struct::sp" title='thread_struct::sp' data-ref="thread_struct::sp">sp</a>);</td></tr>
<tr><th id="37">37</th><td><u>#<span data-ppcond="22">endif</span></u></td></tr>
<tr><th id="38">38</th><td>}</td></tr>
<tr><th id="39">39</th><td></td></tr>
<tr><th id="40">40</th><td><a class="macro" href="../../../../include/linux/linkage.h.html#22" title="" data-ref="_M/asmlinkage">asmlinkage</a> <em>void</em> <dfn class="decl fn" id="ret_from_fork" title='ret_from_fork' data-ref="ret_from_fork">ret_from_fork</dfn>(<em>void</em>);</td></tr>
<tr><th id="41">41</th><td></td></tr>
<tr><th id="42">42</th><td><i>/*</i></td></tr>
<tr><th id="43">43</th><td><i> * This is the structure pointed to by thread.sp for an inactive task.  The</i></td></tr>
<tr><th id="44">44</th><td><i> * order of the fields must match the code in __switch_to_asm().</i></td></tr>
<tr><th id="45">45</th><td><i> */</i></td></tr>
<tr><th id="46">46</th><td><b>struct</b> <dfn class="type def" id="inactive_task_frame" title='inactive_task_frame' data-ref="inactive_task_frame">inactive_task_frame</dfn> {</td></tr>
<tr><th id="47">47</th><td><u>#<span data-ppcond="47">ifdef</span> <a class="macro" href="../../../../include/generated/autoconf.h.html#818" data-ref="_M/CONFIG_X86_64">CONFIG_X86_64</a></u></td></tr>
<tr><th id="48">48</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::r15" title='inactive_task_frame::r15' data-ref="inactive_task_frame::r15">r15</dfn>;</td></tr>
<tr><th id="49">49</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::r14" title='inactive_task_frame::r14' data-ref="inactive_task_frame::r14">r14</dfn>;</td></tr>
<tr><th id="50">50</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::r13" title='inactive_task_frame::r13' data-ref="inactive_task_frame::r13">r13</dfn>;</td></tr>
<tr><th id="51">51</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::r12" title='inactive_task_frame::r12' data-ref="inactive_task_frame::r12">r12</dfn>;</td></tr>
<tr><th id="52">52</th><td><u>#<span data-ppcond="47">else</span></u></td></tr>
<tr><th id="53">53</th><td>	<em>unsigned</em> <em>long</em> si;</td></tr>
<tr><th id="54">54</th><td>	<em>unsigned</em> <em>long</em> di;</td></tr>
<tr><th id="55">55</th><td><u>#<span data-ppcond="47">endif</span></u></td></tr>
<tr><th id="56">56</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::bx" title='inactive_task_frame::bx' data-ref="inactive_task_frame::bx">bx</dfn>;</td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td>	<i>/*</i></td></tr>
<tr><th id="59">59</th><td><i>	 * These two fields must be together.  They form a stack frame header,</i></td></tr>
<tr><th id="60">60</th><td><i>	 * needed by get_frame_pointer().</i></td></tr>
<tr><th id="61">61</th><td><i>	 */</i></td></tr>
<tr><th id="62">62</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::bp" title='inactive_task_frame::bp' data-ref="inactive_task_frame::bp">bp</dfn>;</td></tr>
<tr><th id="63">63</th><td>	<em>unsigned</em> <em>long</em> <dfn class="decl field" id="inactive_task_frame::ret_addr" title='inactive_task_frame::ret_addr' data-ref="inactive_task_frame::ret_addr">ret_addr</dfn>;</td></tr>
<tr><th id="64">64</th><td>};</td></tr>
<tr><th id="65">65</th><td></td></tr>
<tr><th id="66">66</th><td><b>struct</b> <dfn class="type def" id="fork_frame" title='fork_frame' data-ref="fork_frame">fork_frame</dfn> {</td></tr>
<tr><th id="67">67</th><td>	<b>struct</b> <a class="type" href="#inactive_task_frame" title='inactive_task_frame' data-ref="inactive_task_frame">inactive_task_frame</a> <dfn class="decl field" id="fork_frame::frame" title='fork_frame::frame' data-ref="fork_frame::frame">frame</dfn>;</td></tr>
<tr><th id="68">68</th><td>	<b>struct</b> <a class="type" href="ptrace.h.html#pt_regs" title='pt_regs' data-ref="pt_regs">pt_regs</a> <dfn class="decl field" id="fork_frame::regs" title='fork_frame::regs' data-ref="fork_frame::regs">regs</dfn>;</td></tr>
<tr><th id="69">69</th><td>};</td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><u>#define <dfn class="macro" id="_M/switch_to" data-ref="_M/switch_to">switch_to</dfn>(prev, next, last)					\</u></td></tr>
<tr><th id="72">72</th><td><u>do {									\</u></td></tr>
<tr><th id="73">73</th><td><u>	prepare_switch_to(prev, next);					\</u></td></tr>
<tr><th id="74">74</th><td><u>									\</u></td></tr>
<tr><th id="75">75</th><td><u>	((last) = __switch_to_asm((prev), (next)));			\</u></td></tr>
<tr><th id="76">76</th><td><u>} while (0)</u></td></tr>
<tr><th id="77">77</th><td></td></tr>
<tr><th id="78">78</th><td><u>#<span data-ppcond="78">ifdef</span> <span class="macro" data-ref="_M/CONFIG_X86_32">CONFIG_X86_32</span></u></td></tr>
<tr><th id="79">79</th><td><em>static</em> <b>inline</b> <em>void</em> refresh_sysenter_cs(<b>struct</b> thread_struct *thread)</td></tr>
<tr><th id="80">80</th><td>{</td></tr>
<tr><th id="81">81</th><td>	<i>/* Only happens when SEP is enabled, no need to test "SEP"arately: */</i></td></tr>
<tr><th id="82">82</th><td>	<b>if</b> (unlikely(this_cpu_read(cpu_tss_rw.x86_tss.ss1) == thread-&gt;sysenter_cs))</td></tr>
<tr><th id="83">83</th><td>		<b>return</b>;</td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td>	this_cpu_write(cpu_tss_rw.x86_tss.ss1, thread-&gt;sysenter_cs);</td></tr>
<tr><th id="86">86</th><td>	wrmsr(MSR_IA32_SYSENTER_CS, thread-&gt;sysenter_cs, <var>0</var>);</td></tr>
<tr><th id="87">87</th><td>}</td></tr>
<tr><th id="88">88</th><td><u>#<span data-ppcond="78">endif</span></u></td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td><i>/* This is used when switching tasks or entering/exiting vm86 mode. */</i></td></tr>
<tr><th id="91">91</th><td><em>static</em> <a class="macro" href="../../../../include/linux/compiler-gcc.h.html#95" title="inline __attribute__((always_inline, unused)) __attribute__((no_instrument_function))" data-ref="_M/inline"><b>inline</b></a> <em>void</em> <dfn class="decl def fn" id="update_sp0" title='update_sp0' data-ref="update_sp0">update_sp0</dfn>(<b>struct</b> <a class="type" href="../../../../include/linux/sched.h.html#task_struct" title='task_struct' data-ref="task_struct">task_struct</a> *<dfn class="local col5 decl" id="7515task" title='task' data-type='struct task_struct *' data-ref="7515task">task</dfn>)</td></tr>
<tr><th id="92">92</th><td>{</td></tr>
<tr><th id="93">93</th><td>	<i>/* On x86_64, sp0 always points to the entry trampoline stack, which is constant: */</i></td></tr>
<tr><th id="94">94</th><td><u>#<span data-ppcond="94">ifdef</span> <span class="macro" data-ref="_M/CONFIG_X86_32">CONFIG_X86_32</span></u></td></tr>
<tr><th id="95">95</th><td>	load_sp0(task-&gt;thread.sp0);</td></tr>
<tr><th id="96">96</th><td><u>#<span data-ppcond="94">else</span></u></td></tr>
<tr><th id="97">97</th><td>	<b>if</b> (<a class="macro" href="cpufeature.h.html#192" title="( __builtin_constant_p((__builtin_constant_p(( 8*32+16)) &amp;&amp; ( (((( 8*32+16))&gt;&gt;5)==(0) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; ((1&lt;&lt;(( 0*32+ 0) &amp; 31))|(1&lt;&lt;(( 0*32+ 3)) &amp; 31)|(1&lt;&lt;(( 0*32+ 5) &amp; 31))|(1&lt;&lt;(( 0*32+ 6) &amp; 31))| (1&lt;&lt;(( 0*32+ 8) &amp; 31))|(1&lt;&lt;(( 0*32+13)) &amp; 31)|(1&lt;&lt;(( 0*32+24) &amp; 31))|(1&lt;&lt;(( 0*32+15) &amp; 31))| (1&lt;&lt;(( 0*32+25) &amp; 31))|(1&lt;&lt;(( 0*32+26) &amp; 31))) )) || (((( 8*32+16))&gt;&gt;5)==(1) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; ((1&lt;&lt;(( 1*32+29) &amp; 31))|0) )) || (((( 8*32+16))&gt;&gt;5)==(2) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(3) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; ((1&lt;&lt;(( 3*32+20) &amp; 31))) )) || (((( 8*32+16))&gt;&gt;5)==(4) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; (0) )) || (((( 8*32+16))&gt;&gt;5)==(5) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(6) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(7) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(8) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(9) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(10) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(11) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(12) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(13) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(14) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(15) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(16) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; (0) )) || (((( 8*32+16))&gt;&gt;5)==(17) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(18) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (sizeof(struct { int:(-!!(19 != 19)); })) || (sizeof(struct { int:(-!!(19 != 19)); }))) ? 1 : (__builtin_constant_p((( 8*32+16))) ? constant_test_bit((( 8*32+16)), ((unsigned long *)((&amp;boot_cpu_data)-&gt;x86_capability))) : variable_test_bit((( 8*32+16)), ((unsigned long *)((&amp;boot_cpu_data)-&gt;x86_capability)))))) ? (__builtin_constant_p(( 8*32+16)) &amp;&amp; ( (((( 8*32+16))&gt;&gt;5)==(0) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; ((1&lt;&lt;(( 0*32+ 0) &amp; 31))|(1&lt;&lt;(( 0*32+ 3)) &amp; 31)|(1&lt;&lt;(( 0*32+ 5) &amp; 31))|(1&lt;&lt;(( 0*32+ 6) &amp; 31))| (1&lt;&lt;(( 0*32+ 8) &amp; 31))|(1&lt;&lt;(( 0*32+13)) &amp; 31)|(1&lt;&lt;(( 0*32+24) &amp; 31))|(1&lt;&lt;(( 0*32+15) &amp; 31))| (1&lt;&lt;(( 0*32+25) &amp; 31))|(1&lt;&lt;(( 0*32+26) &amp; 31))) )) || (((( 8*32+16))&gt;&gt;5)==(1) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; ((1&lt;&lt;(( 1*32+29) &amp; 31))|0) )) || (((( 8*32+16))&gt;&gt;5)==(2) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(3) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; ((1&lt;&lt;(( 3*32+20) &amp; 31))) )) || (((( 8*32+16))&gt;&gt;5)==(4) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; (0) )) || (((( 8*32+16))&gt;&gt;5)==(5) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(6) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(7) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(8) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(9) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(10) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(11) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(12) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(13) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(14) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(15) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(16) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; (0) )) || (((( 8*32+16))&gt;&gt;5)==(17) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (((( 8*32+16))&gt;&gt;5)==(18) &amp;&amp; (1UL&lt;&lt;((( 8*32+16))&amp;31) &amp; 0 )) || (sizeof(struct { int:(-!!(19 != 19)); })) || (sizeof(struct { int:(-!!(19 != 19)); }))) ? 1 : (__builtin_constant_p((( 8*32+16))) ? constant_test_bit((( 8*32+16)), ((unsigned long *)((&amp;boot_cpu_data)-&gt;x86_capability))) : variable_test_bit((( 8*32+16)), ((unsigned long *)((&amp;boot_cpu_data)-&gt;x86_capability))))) : _static_cpu_has(( 8*32+16)) )" data-ref="_M/static_cpu_has">static_cpu_has</a>(<a class="macro" href="cpufeatures.h.html#231" title="( 8*32+16)" data-ref="_M/X86_FEATURE_XENPV">X86_FEATURE_XENPV</a>))</td></tr>
<tr><th id="98">98</th><td>		<a class="ref fn" href="processor.h.html#load_sp0" title='load_sp0' data-ref="load_sp0">load_sp0</a>(<a class="macro" href="processor.h.html#820" title="((unsigned long)(({ unsigned long __ptr = (unsigned long)task_stack_page(task); __ptr += (((1UL) &lt;&lt; 12) &lt;&lt; (2 + 0)) - 0; ((struct pt_regs *)__ptr) - 1; }) + 1))" data-ref="_M/task_top_of_stack">task_top_of_stack</a>(<a class="local col5 ref" href="#7515task" title='task' data-ref="7515task">task</a>));</td></tr>
<tr><th id="99">99</th><td><u>#<span data-ppcond="94">endif</span></u></td></tr>
<tr><th id="100">100</th><td>}</td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td><u>#<span data-ppcond="2">endif</span> /* _ASM_X86_SWITCH_TO_H */</u></td></tr>
<tr><th id="103">103</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../entry/common.c.html'>linux-4.14.y/arch/x86/entry/common.c</a><br/>Generated on <em>2018-Jul-30</em> from project linux-4.14.y revision <em>linux-4.14.y</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
