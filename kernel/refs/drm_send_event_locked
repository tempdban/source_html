<dec f='linux-4.14.y/include/drm/drm_file.h' l='378' type='void drm_send_event_locked(struct drm_device * dev, struct drm_pending_event * e)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='700' ll='724' type='void drm_send_event_locked(struct drm_device * dev, struct drm_pending_event * e)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' type='void drm_send_event_locked(struct drm_device * , struct drm_pending_event * )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' c='drm_send_event_locked'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='747' u='c' c='drm_send_event'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='686'>/**
 * drm_send_event_locked - send DRM event to file descriptor
 * @dev: DRM device
 * @e: DRM event to deliver
 *
 * This function sends the event @e, initialized with drm_event_reserve_init(),
 * to its associated userspace DRM file. Callers must already hold
 * &amp;drm_device.event_lock, see drm_send_event() for the unlocked version.
 *
 * Note that the core will take care of unlinking and disarming events when the
 * corresponding DRM file is closed. Drivers need not worry about whether the
 * DRM file for this event still exists and can call this function upon
 * completion of the asynchronous work unconditionally.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_vblank.c' l='822' u='c' c='send_vblank_event'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='907' u='c' c='vmw_event_fence_action_seq_passed'/>
<dec f='linux-4.14.y/include/drm/drm_file.h' l='378' type='void drm_send_event_locked(struct drm_device * dev, struct drm_pending_event * e)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='700' ll='724' type='void drm_send_event_locked(struct drm_device * dev, struct drm_pending_event * e)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' type='void drm_send_event_locked(struct drm_device * , struct drm_pending_event * )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' c='drm_send_event_locked'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='725' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='747' u='c' c='drm_send_event'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='686'>/**
 * drm_send_event_locked - send DRM event to file descriptor
 * @dev: DRM device
 * @e: DRM event to deliver
 *
 * This function sends the event @e, initialized with drm_event_reserve_init(),
 * to its associated userspace DRM file. Callers must already hold
 * &amp;drm_device.event_lock, see drm_send_event() for the unlocked version.
 *
 * Note that the core will take care of unlinking and disarming events when the
 * corresponding DRM file is closed. Drivers need not worry about whether the
 * DRM file for this event still exists and can call this function upon
 * completion of the asynchronous work unconditionally.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_vblank.c' l='822' u='c' c='send_vblank_event'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='907' u='c' c='vmw_event_fence_action_seq_passed'/>
