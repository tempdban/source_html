<dec f='linux-4.18.y/include/linux/irqdomain.h' l='432' type='struct irq_domain * irq_domain_create_hierarchy(struct irq_domain * parent, unsigned int flags, unsigned int size, struct fwnode_handle * fwnode, const struct irq_domain_ops * ops, void * host_data)'/>
<use f='linux-4.18.y/include/linux/irqdomain.h' l='444' u='c' c='irq_domain_add_hierarchy'/>
<use f='linux-4.18.y/drivers/base/platform-msi.c' l='339' u='c' c='platform_msi_create_device_domain'/>
<use f='linux-4.18.y/drivers/iommu/intel_irq_remapping.c' l='535' u='c' c='intel_setup_irq_remapping'/>
<def f='linux-4.18.y/kernel/irq/irqdomain.c' l='1010' ll='1029' type='struct irq_domain * irq_domain_create_hierarchy(struct irq_domain * parent, unsigned int flags, unsigned int size, struct fwnode_handle * fwnode, const struct irq_domain_ops * ops, void * host_data)'/>
<dec f='linux-4.18.y/kernel/irq/irqdomain.c' l='1030' type='struct irq_domain * irq_domain_create_hierarchy(struct irq_domain * , unsigned int , unsigned int , struct fwnode_handle * , const struct irq_domain_ops * , void * )'/>
<use f='linux-4.18.y/kernel/irq/irqdomain.c' l='1030' c='irq_domain_create_hierarchy'/>
<use f='linux-4.18.y/kernel/irq/irqdomain.c' l='1030' u='a'/>
<use f='linux-4.18.y/kernel/irq/irqdomain.c' l='1030' u='a'/>
<doc f='linux-4.18.y/kernel/irq/irqdomain.c' l='995'>/**
 * irq_domain_create_hierarchy - Add a irqdomain into the hierarchy
 * @parent:	Parent irq domain to associate with the new domain
 * @flags:	Irq domain flags associated to the domain
 * @size:	Size of the domain. See below
 * @fwnode:	Optional fwnode of the interrupt controller
 * @ops:	Pointer to the interrupt domain callbacks
 * @host_data:	Controller private data pointer
 *
 * If @size is 0 a tree domain is created, otherwise a linear domain.
 *
 * If successful the parent is associated to the new domain and the
 * domain flags are set.
 * Returns pointer to IRQ domain, or NULL on failure.
 */</doc>
<use f='linux-4.18.y/kernel/irq/msi.c' l='292' u='c' c='msi_create_irq_domain'/>
