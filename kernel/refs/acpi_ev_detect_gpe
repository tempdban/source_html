<dec f='linux-4.18.y/drivers/acpi/acpica/acevents.h' l='87' type='u32 acpi_ev_detect_gpe(struct acpi_namespace_node * gpe_device, struct acpi_gpe_event_info * gpe_event_info, u32 gpe_number)'/>
<use f='linux-4.18.y/drivers/acpi/acpica/evgpe.c' l='419' u='c' c='acpi_ev_gpe_detect'/>
<def f='linux-4.18.y/drivers/acpi/acpica/evgpe.c' l='619' ll='724' type='u32 acpi_ev_detect_gpe(struct acpi_namespace_node * gpe_device, struct acpi_gpe_event_info * gpe_event_info, u32 gpe_number)'/>
<doc f='linux-4.18.y/drivers/acpi/acpica/evgpe.c' l='599'>/*******************************************************************************
 *
 * FUNCTION:    acpi_ev_detect_gpe
 *
 * PARAMETERS:  gpe_device          - Device node. NULL for GPE0/GPE1
 *              gpe_event_info      - Info for this GPE
 *              gpe_number          - Number relative to the parent GPE block
 *
 * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED
 *
 * DESCRIPTION: Detect and dispatch a General Purpose Event to either a function
 *              (e.g. EC) or method (e.g. _Lxx/_Exx) handler.
 * NOTE:        GPE is W1C, so it is possible to handle a single GPE from both
 *              task and irq context in parallel as long as the process to
 *              detect and mask the GPE is atomic.
 *              However the atomicity of ACPI_GPE_DISPATCH_RAW_HANDLER is
 *              dependent on the raw handler itself.
 *
 ******************************************************************************/</doc>
<use f='linux-4.18.y/drivers/acpi/acpica/evxface.c' l='980' u='c' c='acpi_remove_gpe_handler'/>
<use f='linux-4.18.y/drivers/acpi/acpica/evxfgpe.c' l='118' u='c' c='acpi_enable_gpe'/>
<use f='linux-4.18.y/drivers/acpi/acpica/evxfgpe.c' l='657' u='c' c='acpi_dispatch_gpe'/>
