<dec f='linux-4.18.y/include/linux/smp.h' l='56' type='int smp_call_function_single_async(int cpu, call_single_data_t * csd)'/>
<use f='linux-4.18.y/arch/x86/kernel/cpuid.c' l='90' u='c' c='cpuid_read'/>
<use f='linux-4.18.y/arch/x86/lib/msr-smp.c' l='182' u='c' c='rdmsr_safe_on_cpu'/>
<use f='linux-4.18.y/block/blk-mq.c' l='581' u='c' c='__blk_mq_complete_request'/>
<use f='linux-4.18.y/block/blk-softirq.c' l='70' u='c' c='raise_blk_irq'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='291' u='c' c='hrtick_start'/>
<def f='linux-4.18.y/kernel/smp.c' l='326' ll='343' type='int smp_call_function_single_async(int cpu, call_single_data_t * csd)'/>
<dec f='linux-4.18.y/kernel/smp.c' l='344' type='int smp_call_function_single_async(int , call_single_data_t * )'/>
<use f='linux-4.18.y/kernel/smp.c' l='344' c='smp_call_function_single_async'/>
<use f='linux-4.18.y/kernel/smp.c' l='344' u='a'/>
<use f='linux-4.18.y/kernel/smp.c' l='344' u='a'/>
<doc f='linux-4.18.y/kernel/smp.c' l='310'>/**
 * smp_call_function_single_async(): Run an asynchronous function on a
 * 			         specific CPU.
 * @cpu: The CPU to run on.
 * @csd: Pre-allocated and setup data structure
 *
 * Like smp_call_function_single(), but the call is asynchonous and
 * can thus be done from contexts with disabled interrupts.
 *
 * The caller passes his own pre-allocated data structure
 * (ie: embedded in an object) and is responsible for synchronizing it
 * such that the IPIs performed on the @csd are strictly serialized.
 *
 * NOTE: Be careful, there is unfortunately no current debugging facility to
 * validate the correctness of this serialization.
 */</doc>
<use f='linux-4.18.y/net/core/dev.c' l='5317' u='c' c='net_rps_send_ipi'/>
