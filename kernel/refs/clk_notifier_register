<dec f='linux-4.14.y/include/linux/clk.h' l='106' type='int clk_notifier_register(struct clk * clk, struct notifier_block * nb)'/>
<doc f='linux-4.14.y/include/linux/clk.h' l='97'>/**
 * clk_notifier_register: register a clock rate-change notifier callback
 * @clk: clock whose rate we are interested in
 * @nb: notifier block with callback function pointer
 *
 * ProTip: debugging across notifier chains can be frustrating. Make sure that
 * your notifier callback function prints a nice big warning in case of
 * failure.
 */</doc>
<def f='linux-4.14.y/drivers/clk/clk.c' l='2971' ll='3006' type='int clk_notifier_register(struct clk * clk, struct notifier_block * nb)'/>
<dec f='linux-4.14.y/drivers/clk/clk.c' l='3007' type='int clk_notifier_register(struct clk * , struct notifier_block * )'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='3007' c='clk_notifier_register'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='3007' u='a'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='3007' u='a'/>
<doc f='linux-4.14.y/drivers/clk/clk.c' l='2951'>/**
 * clk_notifier_register - add a clk rate change notifier
 * @clk: struct clk * to watch
 * @nb: struct notifier_block * with callback info
 *
 * Request notification when clk&apos;s rate changes.  This uses an SRCU
 * notifier because we want it to block and notifier unregistrations are
 * uncommon.  The callbacks associated with the notifier must not
 * re-enter into the clk framework by calling any top-level clk APIs;
 * this will cause a nested prepare_lock mutex.
 *
 * In all notification cases (pre, post and abort rate change) the original
 * clock rate is passed to the callback via struct clk_notifier_data.old_rate
 * and the new frequency is passed via struct clk_notifier_data.new_rate.
 *
 * clk_notifier_register() must be called from non-atomic context.
 * Returns -EINVAL if called with null arguments, -ENOMEM upon
 * allocation failure; otherwise, passes along the return value of
 * srcu_notifier_chain_register().
 */</doc>
