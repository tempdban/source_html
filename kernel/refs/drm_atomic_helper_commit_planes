<dec f='linux-4.14.y/include/drm/drm_atomic_helper.h' l='80' type='void drm_atomic_helper_commit_planes(struct drm_device * dev, struct drm_atomic_state * state, uint32_t flags)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1303' u='c' c='drm_atomic_helper_commit_tail'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1333' u='c' c='drm_atomic_helper_commit_tail_rpm'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2018' ll='2101' type='void drm_atomic_helper_commit_planes(struct drm_device * dev, struct drm_atomic_state * old_state, uint32_t flags)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2102' type='void drm_atomic_helper_commit_planes(struct drm_device * , struct drm_atomic_state * , uint32_t )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2102' c='drm_atomic_helper_commit_planes'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2102' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2102' u='a'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1977'>/**
 * drm_atomic_helper_commit_planes - commit plane state
 * @dev: DRM device
 * @old_state: atomic state object with old state structures
 * @flags: flags for committing plane state
 *
 * This function commits the new plane state using the plane and atomic helper
 * functions for planes and crtcs. It assumes that the atomic state has already
 * been pushed into the relevant object state pointers, since this step can no
 * longer fail.
 *
 * It still requires the global state object @old_state to know which planes and
 * crtcs need to be updated though.
 *
 * Note that this function does all plane updates across all CRTCs in one step.
 * If the hardware can&apos;t support this approach look at
 * drm_atomic_helper_commit_planes_on_crtc() instead.
 *
 * Plane parameters can be updated by applications while the associated CRTC is
 * disabled. The DRM/KMS core will store the parameters in the plane state,
 * which will be available to the driver when the CRTC is turned on. As a result
 * most drivers don&apos;t need to be immediately notified of plane updates for a
 * disabled CRTC.
 *
 * Unless otherwise needed, drivers are advised to set the ACTIVE_ONLY flag in
 * @flags in order not to receive plane update notifications related to a
 * disabled CRTC. This avoids the need to manually ignore plane updates in
 * driver code when the driver and/or hardware can&apos;t or just don&apos;t need to deal
 * with updates on disabled CRTCs, for example when supporting runtime PM.
 *
 * Drivers may set the NO_DISABLE_AFTER_MODESET flag in @flags if the relevant
 * display controllers require to disable a CRTC&apos;s planes when the CRTC is
 * disabled. This function would skip the &amp;drm_plane_helper_funcs.atomic_disable
 * call for a plane if the CRTC of the old plane state needs a modesetting
 * operation. Of course, the drivers need to disable the planes in their CRTC
 * disable callbacks since no one else would do that.
 *
 * The drm_atomic_helper_commit() default implementation doesn&apos;t set the
 * ACTIVE_ONLY flag to most closely match the behaviour of the legacy helpers.
 * This should not be copied blindly by drivers.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='343' u='c' c='vgdev_atomic_commit_tail'/>
