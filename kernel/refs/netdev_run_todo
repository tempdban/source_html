<dec f='linux-4.14.y/include/linux/netdevice.h' l='3344' type='void netdev_run_todo()'/>
<doc f='linux-4.14.y/include/linux/netdevice.h' l='3343'>/* Called by rtnetlink.c:rtnl_unlock() */</doc>
<def f='linux-4.14.y/net/core/dev.c' l='7853' ll='7909' type='void netdev_run_todo()'/>
<doc f='linux-4.14.y/net/core/dev.c' l='7829'>/* The sequence is:
 *
 *	rtnl_lock();
 *	...
 *	register_netdevice(x1);
 *	register_netdevice(x2);
 *	...
 *	unregister_netdevice(y1);
 *	unregister_netdevice(y2);
 *      ...
 *	rtnl_unlock();
 *	free_netdev(y1);
 *	free_netdev(y2);
 *
 * We are invoked by rtnl_unlock().
 * This allows us to deal with problems:
 * 1) We can delete sysfs objects which invoke hotplug
 *    without deadlocking with linkwatch via keventd.
 * 2) Since we run with the RTNL semaphore not held, we can sleep
 *    safely in order to wait for the netdev refcnt to drop to zero.
 *
 * We must not return until all unregister events added during
 * the interval the lock was held have been completed.
 */</doc>
<use f='linux-4.14.y/net/core/rtnetlink.c' l='106' u='c' c='rtnl_unlock'/>
