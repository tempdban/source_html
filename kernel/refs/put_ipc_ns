<dec f='linux-4.18.y/include/linux/ipc_namespace.h' l='133' type='void put_ipc_ns(struct ipc_namespace * ns)'/>
<use f='linux-4.18.y/ipc/mqueue.c' l='433' u='c' c='mqueue_evict_inode'/>
<use f='linux-4.18.y/ipc/mqueue.c' l='467' u='c' c='mqueue_create_attr'/>
<use f='linux-4.18.y/ipc/mqueue.c' l='477' u='c' c='mqueue_create_attr'/>
<def f='linux-4.18.y/ipc/namespace.c' l='158' ll='166' type='void put_ipc_ns(struct ipc_namespace * ns)'/>
<use f='linux-4.18.y/ipc/namespace.c' l='189' u='c' c='ipcns_put'/>
<use f='linux-4.18.y/ipc/namespace.c' l='201' u='c' c='ipcns_install'/>
<doc f='linux-4.18.y/ipc/namespace.c' l='142'>/*
 * put_ipc_ns - drop a reference to an ipc namespace.
 * @ns: the namespace to put
 *
 * If this is the last task in the namespace exiting, and
 * it is dropping the refcount to 0, then it can race with
 * a task in another ipc namespace but in a mounts namespace
 * which has this ipcns&apos;s mqueuefs mounted, doing some action
 * with one of the mqueuefs files.  That can raise the refcount.
 * So dropping the refcount, and raising the refcount when
 * accessing it through the VFS, are protected with mq_lock.
 *
 * (Clearly, a task raising the refcount on its own ipc_ns
 * needn&apos;t take mq_lock since it can&apos;t race with the last task
 * in the ipcns exiting).
 */</doc>
<use f='linux-4.18.y/ipc/shm.c' l='500' u='c' c='shm_release'/>
<use f='linux-4.18.y/ipc/util.c' l='892' u='c' c='sysvipc_proc_release'/>
<use f='linux-4.18.y/kernel/nsproxy.c' l='122' u='c' c='create_new_namespaces'/>
<use f='linux-4.18.y/kernel/nsproxy.c' l='180' u='c' c='free_nsproxy'/>
