<dec f='linux-4.18.y/include/linux/rcutree.h' l='79' type='void cond_synchronize_rcu(unsigned long oldstate)'/>
<use f='linux-4.18.y/kernel/events/core.c' l='5335' u='c' c='ring_buffer_attach'/>
<def f='linux-4.18.y/kernel/rcu/tree.c' l='3166' ll='3177' type='void cond_synchronize_rcu(unsigned long oldstate)'/>
<dec f='linux-4.18.y/kernel/rcu/tree.c' l='3178' type='void cond_synchronize_rcu(unsigned long )'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3178' c='cond_synchronize_rcu'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3178' u='a'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3178' u='a'/>
<doc f='linux-4.18.y/kernel/rcu/tree.c' l='3152'>/**
 * cond_synchronize_rcu - Conditionally wait for an RCU grace period
 *
 * @oldstate: return value from earlier call to get_state_synchronize_rcu()
 *
 * If a full RCU grace period has elapsed since the earlier call to
 * get_state_synchronize_rcu(), just return.  Otherwise, invoke
 * synchronize_rcu() to wait for a full grace period.
 *
 * Yes, this function does not take counter wrap into account.  But
 * counter wrap is harmless.  If the counter wraps, we have waited for
 * more than 2 billion grace periods (and way more on a 64-bit system!),
 * so waiting for one additional grace period should be just fine.
 */</doc>
