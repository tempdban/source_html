<dec f='linux-4.14.y/include/linux/rcutree.h' l='78' type='void cond_synchronize_rcu(unsigned long oldstate)'/>
<use f='linux-4.14.y/kernel/events/core.c' l='5087' u='c' c='ring_buffer_attach'/>
<def f='linux-4.14.y/kernel/rcu/tree.c' l='3293' ll='3304' type='void cond_synchronize_rcu(unsigned long oldstate)'/>
<dec f='linux-4.14.y/kernel/rcu/tree.c' l='3305' type='void cond_synchronize_rcu(unsigned long )'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3305' c='cond_synchronize_rcu'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3305' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3305' u='a'/>
<doc f='linux-4.14.y/kernel/rcu/tree.c' l='3279'>/**
 * cond_synchronize_rcu - Conditionally wait for an RCU grace period
 *
 * @oldstate: return value from earlier call to get_state_synchronize_rcu()
 *
 * If a full RCU grace period has elapsed since the earlier call to
 * get_state_synchronize_rcu(), just return.  Otherwise, invoke
 * synchronize_rcu() to wait for a full grace period.
 *
 * Yes, this function does not take counter wrap into account.  But
 * counter wrap is harmless.  If the counter wraps, we have waited for
 * more than 2 billion grace periods (and way more on a 64-bit system!),
 * so waiting for one additional grace period should be just fine.
 */</doc>
<dec f='linux-4.14.y/include/linux/rcutree.h' l='78' type='void cond_synchronize_rcu(unsigned long oldstate)'/>
<use f='linux-4.14.y/kernel/events/core.c' l='5087' u='c' c='ring_buffer_attach'/>
<def f='linux-4.14.y/kernel/rcu/tree.c' l='3293' ll='3304' type='void cond_synchronize_rcu(unsigned long oldstate)'/>
<dec f='linux-4.14.y/kernel/rcu/tree.c' l='3305' type='void cond_synchronize_rcu(unsigned long )'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3305' c='cond_synchronize_rcu'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3305' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3305' u='a'/>
<doc f='linux-4.14.y/kernel/rcu/tree.c' l='3279'>/**
 * cond_synchronize_rcu - Conditionally wait for an RCU grace period
 *
 * @oldstate: return value from earlier call to get_state_synchronize_rcu()
 *
 * If a full RCU grace period has elapsed since the earlier call to
 * get_state_synchronize_rcu(), just return.  Otherwise, invoke
 * synchronize_rcu() to wait for a full grace period.
 *
 * Yes, this function does not take counter wrap into account.  But
 * counter wrap is harmless.  If the counter wraps, we have waited for
 * more than 2 billion grace periods (and way more on a 64-bit system!),
 * so waiting for one additional grace period should be just fine.
 */</doc>
