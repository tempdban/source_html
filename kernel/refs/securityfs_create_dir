<dec f='linux-4.18.y/include/linux/security.h' l='1712' type='struct dentry * securityfs_create_dir(const char * name, struct dentry * parent)'/>
<use f='linux-4.18.y/security/apparmor/apparmorfs.c' l='2338' u='c' c='entry_create_dir'/>
<def f='linux-4.18.y/security/inode.c' l='222' ll='225' type='struct dentry * securityfs_create_dir(const char * name, struct dentry * parent)'/>
<dec f='linux-4.18.y/security/inode.c' l='226' type='struct dentry * securityfs_create_dir(const char * , struct dentry * )'/>
<use f='linux-4.18.y/security/inode.c' l='226' c='securityfs_create_dir'/>
<use f='linux-4.18.y/security/inode.c' l='226' u='a'/>
<use f='linux-4.18.y/security/inode.c' l='226' u='a'/>
<doc f='linux-4.18.y/security/inode.c' l='202'>/**
 * securityfs_create_dir - create a directory in the securityfs filesystem
 *
 * @name: a pointer to a string containing the name of the directory to
 *        create.
 * @parent: a pointer to the parent dentry for this file.  This should be a
 *          directory dentry if set.  If this parameter is %NULL, then the
 *          directory will be created in the root of the securityfs filesystem.
 *
 * This function creates a directory in securityfs with the given @name.
 *
 * This function returns a pointer to a dentry if it succeeds.  This
 * pointer must be passed to the securityfs_remove() function when the file is
 * to be removed (no automatic cleanup happens if your module is unloaded,
 * you are responsible here).  If an error occurs, the function will return
 * the error value (via ERR_PTR).
 *
 * If securityfs is not enabled in the kernel, the value %-ENODEV is
 * returned.
 */</doc>
<use f='linux-4.18.y/security/integrity/iint.c' l='220' u='c' c='integrity_fs_init'/>
<use f='linux-4.18.y/security/tomoyo/securityfs_if.c' l='243' u='c' c='tomoyo_initerface_init'/>
