<dec f='linux-4.14.y/include/linux/mpage.h' l='17' type='int mpage_readpages(struct address_space * mapping, struct list_head * pages, unsigned int nr_pages, get_block_t * get_block)'/>
<use f='linux-4.14.y/fs/block_dev.c' l='589' u='c' c='blkdev_readpages'/>
<use f='linux-4.14.y/fs/fat/inode.c' l='202' u='c' c='fat_readpages'/>
<use f='linux-4.14.y/fs/isofs/inode.c' l='1182' u='c' c='isofs_readpages'/>
<def f='linux-4.14.y/fs/mpage.c' l='362' ll='395' type='int mpage_readpages(struct address_space * mapping, struct list_head * pages, unsigned int nr_pages, get_block_t * get_block)'/>
<dec f='linux-4.14.y/fs/mpage.c' l='396' type='int mpage_readpages(struct address_space * , struct list_head * , unsigned int , get_block_t * )'/>
<use f='linux-4.14.y/fs/mpage.c' l='396' c='mpage_readpages'/>
<use f='linux-4.14.y/fs/mpage.c' l='396' u='a'/>
<use f='linux-4.14.y/fs/mpage.c' l='396' u='a'/>
<doc f='linux-4.14.y/fs/mpage.c' l='318'>/**
 * mpage_readpages - populate an address space with some pages &amp; start reads against them
 * @mapping: the address_space
 * @pages: The address of a list_head which contains the target pages.  These
 *   pages have their -&gt;index populated and are otherwise uninitialised.
 *   The page at @pages-&gt;prev has the lowest file offset, and reads should be
 *   issued in @pages-&gt;prev to @pages-&gt;next order.
 * @nr_pages: The number of pages at *@pages
 * @get_block: The filesystem&apos;s block mapper function.
 *
 * This function walks the pages and the blocks within each page, building and
 * emitting large BIOs.
 *
 * If anything unusual happens, such as:
 *
 * - encountering a page which has buffers
 * - encountering a page which has a non-hole after a hole
 * - encountering a page with non-contiguous blocks
 *
 * then this code just gives up and calls the buffer_head-based read function.
 * It does handle a page which has holes at the end - that is a common case:
 * the end-of-file on blocksize &lt; PAGE_SIZE setups.
 *
 * BH_Boundary explanation:
 *
 * There is a problem.  The mpage read code assembles several pages, gets all
 * their disk mappings, and then submits them all.  That&apos;s fine, but obtaining
 * the disk mappings may require I/O.  Reads of indirect blocks, for example.
 *
 * So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be
 * submitted in the following order:
 *
 * 	12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16
 *
 * because the indirect block has to be read to get the mappings of blocks
 * 13,14,15,16.  Obviously, this impacts performance.
 *
 * So what we do it to allow the filesystem&apos;s get_block() function to set
 * BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block
 * after this one will require I/O against a block which is probably close to
 * this one.  So you should push what I/O you have currently accumulated.
 *
 * This all causes the disk requests to be issued in the correct order.
 */</doc>
<use f='linux-4.14.y/fs/udf/inode.c' l='194' u='c' c='udf_readpages'/>
