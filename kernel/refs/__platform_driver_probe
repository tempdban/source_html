<dec f='linux-4.18.y/include/linux/platform_device.h' l='208' type='int __platform_driver_probe(struct platform_driver * driver, int (*)(struct platform_device *) probe, struct module * module)'/>
<def f='linux-4.18.y/drivers/base/platform.c' l='668' ll='715' type='int __platform_driver_probe(struct platform_driver * drv, int (*)(struct platform_device *) probe, struct module * module)'/>
<dec f='linux-4.18.y/drivers/base/platform.c' l='716' type='int __platform_driver_probe(struct platform_driver * , int (*)(struct platform_device *) , struct module * )'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='716' c='__platform_driver_probe'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='716' u='a'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='716' u='a'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='760' u='c' c='__platform_create_bundle'/>
<doc f='linux-4.18.y/drivers/base/platform.c' l='648'>/**
 * __platform_driver_probe - register driver for non-hotpluggable device
 * @drv: platform driver structure
 * @probe: the driver probe routine, probably from an __init section
 * @module: module which will be the owner of the driver
 *
 * Use this instead of platform_driver_register() when you know the device
 * is not hotpluggable and has already been registered, and you want to
 * remove its run-once probe() infrastructure from memory after the driver
 * has bound to the device.
 *
 * One typical use for this would be with drivers for controllers integrated
 * into system-on-chip processors, where the controller devices have been
 * configured as part of board setup.
 *
 * Note that this is incompatible with deferred probing.
 *
 * Returns zero if the driver registered and bound to a device, else returns
 * a negative error code and with the driver not registered.
 */</doc>
<use f='linux-4.18.y/drivers/rtc/rtc-cmos.c' l='1449' macro='1' u='c'/>
