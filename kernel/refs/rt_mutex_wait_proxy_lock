<dec f='linux-4.18.y/kernel/locking/rtmutex_common.h' l='145' type='int rt_mutex_wait_proxy_lock(struct rt_mutex * lock, struct hrtimer_sleeper * to, struct rt_mutex_waiter * waiter)'/>
<use f='linux-4.18.y/kernel/futex.c' l='2817' u='c' c='futex_lock_pi'/>
<use f='linux-4.18.y/kernel/futex.c' l='3216' u='c' c='futex_wait_requeue_pi'/>
<def f='linux-4.18.y/kernel/locking/rtmutex.c' l='1823' ll='1841' type='int rt_mutex_wait_proxy_lock(struct rt_mutex * lock, struct hrtimer_sleeper * to, struct rt_mutex_waiter * waiter)'/>
<doc f='linux-4.18.y/kernel/locking/rtmutex.c' l='1806'>/**
 * rt_mutex_wait_proxy_lock() - Wait for lock acquisition
 * @lock:		the rt_mutex we were woken on
 * @to:			the timeout, null if none. hrtimer should already have
 *			been started.
 * @waiter:		the pre-initialized rt_mutex_waiter
 *
 * Wait for the the lock acquisition started on our behalf by
 * rt_mutex_start_proxy_lock(). Upon failure, the caller must call
 * rt_mutex_cleanup_proxy_lock().
 *
 * Returns:
 *  0 - success
 * &lt;0 - error, one of -EINTR, -ETIMEDOUT
 *
 * Special API call for PI-futex support
 */</doc>
