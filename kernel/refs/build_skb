<dec f='linux-4.18.y/include/linux/skbuff.h' l='983' type='struct sk_buff * build_skb(void * data, unsigned int frag_size)'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/e1000/e1000_main.c' l='4385' u='c' c='e1000_clean_rx_irq'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/i40e/i40e_txrx.c' l='2121' u='c' c='i40e_build_skb'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/i40evf/i40e_txrx.c' l='1373' u='c' c='i40e_build_skb'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/igb/igb_main.c' l='7992' u='c' c='igb_build_skb'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='2165' u='c' c='ixgbe_build_skb'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c' l='951' u='c' c='ixgbevf_build_skb'/>
<use f='linux-4.18.y/drivers/net/tun.c' l='1711' u='c' c='tun_build_skb'/>
<use f='linux-4.18.y/drivers/net/virtio_net.c' l='683' u='c' c='receive_small'/>
<use f='linux-4.18.y/net/bpf/test_run.c' l='123' u='c' c='bpf_prog_test_run_skb'/>
<def f='linux-4.18.y/net/core/skbuff.c' l='310' ll='320' type='struct sk_buff * build_skb(void * data, unsigned int frag_size)'/>
<dec f='linux-4.18.y/net/core/skbuff.c' l='321' type='struct sk_buff * build_skb(void * , unsigned int )'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='321' c='build_skb'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='321' u='a'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='321' u='a'/>
<doc f='linux-4.18.y/net/core/skbuff.c' l='305'>/* build_skb() is wrapper over __build_skb(), that specifically
 * takes care of skb-&gt;head and skb-&gt;pfmemalloc
 * This means that if @frag_size is not zero, then @data must be backed
 * by a page fragment, not kmalloc() or vmalloc()
 */</doc>
