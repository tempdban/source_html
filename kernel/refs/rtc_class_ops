<def f='linux-4.14.y/include/linux/rtc.h' l='75' ll='88'/>
<size>96</size>
<doc f='linux-4.14.y/include/linux/rtc.h' l='59'>/*
 * For these RTC methods the device parameter is the physical device
 * on whatever bus holds the hardware (I2C, Platform, SPI, etc), which
 * was passed to rtc_device_register().  Its driver_data normally holds
 * device state, including the rtc_device pointer for the RTC.
 *
 * Most of these methods are called with rtc_device.ops_lock held,
 * through the rtc_*(struct rtc_device *, ...) calls.
 *
 * The (current) exceptions are mostly filesystem hooks:
 *   - the proc() hook for procfs
 *   - non-ioctl() chardev hooks:  open(), release(), read_callback()
 *
 * REVISIT those periodic irq calls *do* have ops_lock when they&apos;re
 * issued through ioctl() ...
 */</doc>
<mbr r='rtc_class_ops::ioctl' o='0' t='int (*)(struct device *, unsigned int, unsigned long)'/>
<mbr r='rtc_class_ops::read_time' o='64' t='int (*)(struct device *, struct rtc_time *)'/>
<mbr r='rtc_class_ops::set_time' o='128' t='int (*)(struct device *, struct rtc_time *)'/>
<mbr r='rtc_class_ops::read_alarm' o='192' t='int (*)(struct device *, struct rtc_wkalrm *)'/>
<mbr r='rtc_class_ops::set_alarm' o='256' t='int (*)(struct device *, struct rtc_wkalrm *)'/>
<mbr r='rtc_class_ops::proc' o='320' t='int (*)(struct device *, struct seq_file *)'/>
<mbr r='rtc_class_ops::set_mmss64' o='384' t='int (*)(struct device *, time64_t)'/>
<mbr r='rtc_class_ops::set_mmss' o='448' t='int (*)(struct device *, unsigned long)'/>
<mbr r='rtc_class_ops::read_callback' o='512' t='int (*)(struct device *, int)'/>
<mbr r='rtc_class_ops::alarm_irq_enable' o='576' t='int (*)(struct device *, unsigned int)'/>
<mbr r='rtc_class_ops::read_offset' o='640' t='int (*)(struct device *, long *)'/>
<mbr r='rtc_class_ops::set_offset' o='704' t='int (*)(struct device *, long)'/>
