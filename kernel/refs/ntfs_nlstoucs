<dec f='linux-4.14.y/fs/ntfs/ntfs.h' l='127' type='int ntfs_nlstoucs(const ntfs_volume * vol, const char * ins, const int ins_len, ntfschar ** outs)'/>
<use f='linux-4.14.y/fs/ntfs/namei.c' l='117' u='c' c='ntfs_lookup'/>
<def f='linux-4.14.y/fs/ntfs/unistr.c' l='259' ll='309' type='int ntfs_nlstoucs(const ntfs_volume * vol, const char * ins, const int ins_len, ntfschar ** outs)'/>
<doc f='linux-4.14.y/fs/ntfs/unistr.c' l='236'>/**
 * ntfs_nlstoucs - convert NLS string to little endian Unicode string
 * @vol:	ntfs volume which we are working with
 * @ins:	input NLS string buffer
 * @ins_len:	length of input string in bytes
 * @outs:	on return contains the allocated output Unicode string buffer
 *
 * Convert the input string @ins, which is in whatever format the loaded NLS
 * map dictates, into a little endian, 2-byte Unicode string.
 *
 * This function allocates the string and the caller is responsible for
 * calling kmem_cache_free(ntfs_name_cache, *@outs); when finished with it.
 *
 * On success the function returns the number of Unicode characters written to
 * the output string *@outs (&gt;= 0), not counting the terminating Unicode NULL
 * character. *@outs is set to the allocated output string buffer.
 *
 * On error, a negative number corresponding to the error code is returned. In
 * that case the output string is not allocated. Both *@outs and *@outs_len
 * are then undefined.
 *
 * This might look a bit odd due to fast path optimization...
 */</doc>
