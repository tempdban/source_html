<dec f='linux-4.18.y/include/scsi/scsi_transport_fc.h' l='794' type='void fc_remote_port_delete(struct fc_rport * rport)'/>
<def f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='2957' ll='3008' type='void fc_remote_port_delete(struct fc_rport * rport)'/>
<dec f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3009' type='void fc_remote_port_delete(struct fc_rport * )'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3009' c='fc_remote_port_delete'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3009' u='a'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3009' u='a'/>
<doc f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='2905'>/**
 * fc_remote_port_delete - notifies the fc transport that a remote port is no longer in existence.
 * @rport:	The remote port that no longer exists
 *
 * The LLDD calls this routine to notify the transport that a remote
 * port is no longer part of the topology. Note: Although a port
 * may no longer be part of the topology, it may persist in the remote
 * ports displayed by the fc_host. We do this under 2 conditions:
 *
 * 1) If the port was a scsi target, we delay its deletion by &quot;blocking&quot; it.
 *    This allows the port to temporarily disappear, then reappear without
 *    disrupting the SCSI device tree attached to it. During the &quot;blocked&quot;
 *    period the port will still exist.
 *
 * 2) If the port was a scsi target and disappears for longer than we
 *    expect, we&apos;ll delete the port and the tear down the SCSI device tree
 *    attached to it. However, we want to semi-persist the target id assigned
 *    to that port if it eventually does exist. The port structure will
 *    remain (although with minimal information) so that the target id
 *    bindings also remain.
 *
 * If the remote port is not an FCP Target, it will be fully torn down
 * and deallocated, including the fc_remote_port class device.
 *
 * If the remote port is an FCP Target, the port will be placed in a
 * temporary blocked state. From the LLDD&apos;s perspective, the rport no
 * longer exists. From the SCSI midlayer&apos;s perspective, the SCSI target
 * exists, but all sdevs on it are blocked from further I/O. The following
 * is then expected.
 *
 *   If the remote port does not return (signaled by a LLDD call to
 *   fc_remote_port_add()) within the dev_loss_tmo timeout, then the
 *   scsi target is removed - killing all outstanding i/o and removing the
 *   scsi devices attached to it. The port structure will be marked Not
 *   Present and be partially cleared, leaving only enough information to
 *   recognize the remote port relative to the scsi target id binding if
 *   it later appears.  The port will remain as long as there is a valid
 *   binding (e.g. until the user changes the binding type or unloads the
 *   scsi host with the binding).
 *
 *   If the remote port returns within the dev_loss_tmo value (and matches
 *   according to the target id binding type), the port structure will be
 *   reused. If it is no longer a SCSI target, the target will be torn
 *   down. If it continues to be a SCSI target, then the target will be
 *   unblocked (allowing i/o to be resumed), and a scan will be activated
 *   to ensure that all luns are detected.
 *
 * Called from normal process context only - cannot be called from interrupt.
 *
 * Notes:
 *	This routine assumes no locks are held on entry.
 */</doc>
