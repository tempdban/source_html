<dec f='linux-4.18.y/fs/ntfs/mft.h' l='32' type='MFT_RECORD * map_mft_record(ntfs_inode * ni)'/>
<use f='linux-4.18.y/fs/ntfs/aops.c' l='475' u='c' c='ntfs_readpage'/>
<use f='linux-4.18.y/fs/ntfs/aops.c' l='1453' u='c' c='ntfs_writepage'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='105' u='c' c='ntfs_map_runlist_nolock'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='230' u='c' c='ntfs_map_runlist_nolock'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='1612' u='c' c='ntfs_attr_make_non_resident'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='1992' u='c' c='ntfs_attr_extend_allocation'/>
<use f='linux-4.18.y/fs/ntfs/dir.c' l='102' u='c' c='ntfs_lookup_inode_by_name'/>
<use f='linux-4.18.y/fs/ntfs/dir.c' l='1143' u='c' c='ntfs_readdir'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='145' u='c' c='ntfs_attr_extend_initialized'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='189' u='c' c='ntfs_attr_extend_initialized'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='286' u='c' c='ntfs_attr_extend_initialized'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='1028' u='c' c='ntfs_prepare_pages_for_non_resident_write'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='1466' u='c' c='ntfs_commit_pages_after_non_resident_write'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='1593' u='c' c='ntfs_commit_pages_after_write'/>
<use f='linux-4.18.y/fs/ntfs/index.c' l='152' u='c' c='ntfs_index_lookup'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='575' u='c' c='ntfs_read_locked_inode'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='1247' u='c' c='ntfs_read_locked_attr_inode'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='1512' u='c' c='ntfs_read_locked_index_inode'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='2383' u='c' c='ntfs_truncate'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='2980' u='c' c='__ntfs_write_inode'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='3064' u='c' c='__ntfs_write_inode'/>
<def f='linux-4.18.y/fs/ntfs/mft.c' l='156' ll='176' type='MFT_RECORD * map_mft_record(ntfs_inode * ni)'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='283' u='c' c='map_extent_mft_record'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='316' u='c' c='map_extent_mft_record'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1389' u='c' c='ntfs_mft_bitmap_extend_allocation_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1594' u='c' c='ntfs_mft_bitmap_extend_initialized_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1646' u='c' c='ntfs_mft_bitmap_extend_initialized_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1822' u='c' c='ntfs_mft_data_extend_allocation_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='2460' u='c' c='ntfs_mft_record_alloc'/>
<doc f='linux-4.18.y/fs/ntfs/mft.c' l='106'>/**
 * map_mft_record - map, pin and lock an mft record
 * @ni:		ntfs inode whose MFT record to map
 *
 * First, take the mrec_lock mutex.  We might now be sleeping, while waiting
 * for the mutex if it was already locked by someone else.
 *
 * The page of the record is mapped using map_mft_record_page() before being
 * returned to the caller.
 *
 * This in turn uses ntfs_map_page() to get the page containing the wanted mft
 * record (it in turn calls read_cache_page() which reads it in from disk if
 * necessary, increments the use count on the page so that it cannot disappear
 * under us and returns a reference to the page cache page).
 *
 * If read_cache_page() invokes ntfs_readpage() to load the page from disk, it
 * sets PG_locked and clears PG_uptodate on the page. Once I/O has completed
 * and the post-read mst fixups on each mft record in the page have been
 * performed, the page gets PG_uptodate set and PG_locked cleared (this is done
 * in our asynchronous I/O completion handler end_buffer_read_mft_async()).
 * ntfs_map_page() waits for PG_locked to become clear and checks if
 * PG_uptodate is set and returns an error code if not. This provides
 * sufficient protection against races when reading/using the page.
 *
 * However there is the write mapping to think about. Doing the above described
 * checking here will be fine, because when initiating the write we will set
 * PG_locked and clear PG_uptodate making sure nobody is touching the page
 * contents. Doing the locking this way means that the commit to disk code in
 * the page cache code paths is automatically sufficiently locked with us as
 * we will not touch a page that has been locked or is not uptodate. The only
 * locking problem then is them locking the page while we are accessing it.
 *
 * So that code will end up having to own the mrec_lock of all mft
 * records/inodes present in the page before I/O can proceed. In that case we
 * wouldn&apos;t need to bother with PG_locked and PG_uptodate as nobody will be
 * accessing anything without owning the mrec_lock mutex.  But we do need to
 * use them because of the read_cache_page() invocation and the code becomes so
 * much simpler this way that it is well worth it.
 *
 * The mft record is now ours and we return a pointer to it. You need to check
 * the returned pointer with IS_ERR() and if that is true, PTR_ERR() will return
 * the error code.
 *
 * NOTE: Caller is responsible for setting the mft record dirty before calling
 * unmap_mft_record(). This is obviously only necessary if the caller really
 * modified the mft record...
 * Q: Do we want to recycle one of the VFS inode state bits instead?
 * A: No, the inode ones mean we want to change the mft record, not we want to
 * write it out.
 */</doc>
<use f='linux-4.18.y/fs/ntfs/namei.c' l='199' u='c' c='ntfs_lookup'/>
<use f='linux-4.18.y/fs/ntfs/namei.c' l='313' u='c' c='ntfs_get_parent'/>
<use f='linux-4.18.y/fs/ntfs/super.c' l='388' u='c' c='ntfs_write_volume_flags'/>
<use f='linux-4.18.y/fs/ntfs/super.c' l='1869' u='c' c='load_system_files'/>
