<dec f='linux-4.18.y/drivers/bus/fslmc/qbman/include/fsl_qbman_portal.h' l='35' type='struct qbman_swp * qbman_swp_init(const struct qbman_swp_desc * d)'/>
<doc f='linux-4.18.y/drivers/bus/fslmc/qbman/include/fsl_qbman_portal.h' l='27'>/**
 * qbman_swp_init() - Create a functional object representing the given
 * QBMan portal descriptor.
 * @d: the given qbman swp descriptor
 *
 * Return qbman_swp portal object for success, NULL if the object cannot
 * be created.
 */</doc>
<use f='linux-4.18.y/drivers/bus/fslmc/portal/dpaa2_hw_dpio.c' l='231' u='c' c='configure_dpio_qbman_swp'/>
<def f='linux-4.18.y/drivers/bus/fslmc/qbman/qbman_portal.c' l='103' ll='154' type='struct qbman_swp * qbman_swp_init(const struct qbman_swp_desc * d)'/>
<doc f='linux-4.18.y/drivers/bus/fslmc/qbman/qbman_portal.c' l='90'>/* Software portals should always be in the power-on state when we initialise,
 * due to the CCSR-based portal reset functionality that MC has.
 *
 * Erk! Turns out that QMan versions prior to 4.1 do not correctly reset DQRR
 * valid-bits, so we need to support a workaround where we don&apos;t trust
 * valid-bits when detecting new entries until any stale ring entries have been
 * overwritten at least once. The idea is that we read PI for the first few
 * entries, then switch to valid-bit after that. The trick is to clear the
 * bug-work-around boolean once the PI wraps around the ring for the first time.
 *
 * Note: this still carries a slight additional cost once the decrementer hits
 * zero.
 */</doc>
