<dec f='linux-4.14.y/include/drm/drm_modes.h' l='462' type='struct drm_display_mode * drm_cvt_mode(struct drm_device * dev, int hdisplay, int vdisplay, int vrefresh, bool reduced, bool interlaced, bool margins)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_edid.c' l='2067' u='c' c='drm_mode_std'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_edid.c' l='2113' u='c' c='drm_mode_std'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_edid.c' l='2208' u='c' c='drm_mode_detailed'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_edid.c' l='2441' u='c' c='drm_cvt_modes_for_range'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_edid.c' l='2686' u='c' c='drm_cvt_modes'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='143' ll='341' type='struct drm_display_mode * drm_cvt_mode(struct drm_device * dev, int hdisplay, int vdisplay, int vrefresh, bool reduced, bool interlaced, bool margins)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='342' type='struct drm_display_mode * drm_cvt_mode(struct drm_device * , int , int , int , bool , bool , bool )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='342' c='drm_cvt_mode'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='342' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='342' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='1497' u='c' c='drm_mode_create_from_cmdline_mode'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_modes.c' l='119'>/**
 * drm_cvt_mode -create a modeline based on the CVT algorithm
 * @dev: drm device
 * @hdisplay: hdisplay size
 * @vdisplay: vdisplay size
 * @vrefresh: vrefresh rate
 * @reduced: whether to use reduced blanking
 * @interlaced: whether to compute an interlaced mode
 * @margins: whether to add margins (borders)
 *
 * This function is called to generate the modeline based on CVT algorithm
 * according to the hdisplay, vdisplay, vrefresh.
 * It is based from the VESA(TM) Coordinated Video Timing Generator by
 * Graham Loveridge April 9, 2003 available at
 * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls 
 *
 * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
 * What I have done is to translate it by using integer calculation.
 *
 * Returns:
 * The modeline based on the CVT algorithm stored in a drm_display_mode object.
 * The display mode object is allocated with drm_mode_create(). Returns NULL
 * when no mode could be allocated.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='216' u='c' c='qxl_add_monitors_config_modes'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='262' u='c' c='qxl_add_common_modes'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='188' u='c' c='virtio_gpu_conn_get_modes'/>
