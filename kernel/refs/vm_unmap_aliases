<dec f='linux-4.18.y/include/linux/vmalloc.h' l='62' type='void vm_unmap_aliases()'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='1474' u='c' c='change_page_attr_set_clr'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='1831' u='c' c='__set_memory_enc_dec'/>
<def f='linux-4.18.y/mm/vmalloc.c' l='1071' ll='1111' type='void vm_unmap_aliases()'/>
<dec f='linux-4.18.y/mm/vmalloc.c' l='1112' type='void vm_unmap_aliases()'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='1112' c='vm_unmap_aliases'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='1112' u='a'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='1112' u='a'/>
<doc f='linux-4.18.y/mm/vmalloc.c' l='1058'>/**
 * vm_unmap_aliases - unmap outstanding lazy aliases in the vmap layer
 *
 * The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
 * to amortize TLB flushing overheads. What this means is that any page you
 * have now, may, in a former life, have been mapped into kernel virtual
 * address by the vmap layer and so there might be some CPUs with TLB entries
 * still referencing that page (additional to the regular 1:1 kernel mapping).
 *
 * vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
 * be sure that none of the pages we have control over will have any aliases
 * from the vmap layer.
 */</doc>
<use f='linux-4.18.y/security/apparmor/match.c' l='128' u='c' c='unpack_table'/>
