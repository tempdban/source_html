<dec f='linux-4.14.y/include/linux/jbd2.h' l='1402' type='int jbd2_journal_begin_ordered_truncate(journal_t * journal, struct jbd2_inode * inode, loff_t new_size)'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='134' u='c' c='ext4_begin_ordered_truncate'/>
<dec f='linux-4.14.y/fs/jbd2/journal.c' l='102' type='int jbd2_journal_begin_ordered_truncate(journal_t * , struct jbd2_inode * , loff_t )'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='102' c='jbd2_journal_begin_ordered_truncate'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='102' u='a'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='102' u='a'/>
<def f='linux-4.14.y/fs/jbd2/transaction.c' l='2593' ll='2620' type='int jbd2_journal_begin_ordered_truncate(journal_t * journal, struct jbd2_inode * jinode, loff_t new_size)'/>
<doc f='linux-4.14.y/fs/jbd2/transaction.c' l='2573'>/*
 * File truncate and transaction commit interact with each other in a
 * non-trivial way.  If a transaction writing data block A is
 * committing, we cannot discard the data by truncate until we have
 * written them.  Otherwise if we crashed after the transaction with
 * write has committed but before the transaction with truncate has
 * committed, we could see stale data in block A.  This function is a
 * helper to solve this problem.  It starts writeout of the truncated
 * part in case it is in the committing transaction.
 *
 * Filesystem code must call this function when inode is journaled in
 * ordered mode before truncation happens and after the inode has been
 * placed on orphan list with the new inode size. The second condition
 * avoids the race that someone writes new data and we start
 * committing the transaction after this function has been called but
 * before a transaction for truncate is started (and furthermore it
 * allows us to optimize the case where the addition to orphan list
 * happens in the same transaction as write --- we don&apos;t have to write
 * any data in such case).
 */</doc>
