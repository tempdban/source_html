<dec f='linux-4.18.y/include/linux/pagevec.h' l='24' type='void __pagevec_release(struct pagevec * pvec)'/>
<use f='linux-4.18.y/include/linux/pagevec.h' l='86' u='c' c='pagevec_release'/>
<def f='linux-4.18.y/mm/swap.c' l='806' ll='814' type='void __pagevec_release(struct pagevec * pvec)'/>
<dec f='linux-4.18.y/mm/swap.c' l='815' type='void __pagevec_release(struct pagevec * )'/>
<use f='linux-4.18.y/mm/swap.c' l='815' c='__pagevec_release'/>
<use f='linux-4.18.y/mm/swap.c' l='815' u='a'/>
<use f='linux-4.18.y/mm/swap.c' l='815' u='a'/>
<doc f='linux-4.18.y/mm/swap.c' l='796'>/*
 * The pages which we&apos;re about to release may be in the deferred lru-addition
 * queues.  That would prevent them from really being freed right now.  That&apos;s
 * OK from a correctness point of view but is inefficient - those pages may be
 * cache-warm and we want to give them back to the page allocator ASAP.
 *
 * So __pagevec_release() will drain those queues here.  __pagevec_lru_add()
 * and __pagevec_lru_add_active() call release_pages() directly to avoid
 * mutual recursion.
 */</doc>
