<dec f='linux-4.14.y/include/linux/umh.h' l='42' type='int call_usermodehelper_exec(struct subprocess_info * info, int wait)'/>
<use f='linux-4.14.y/fs/coredump.c' l='652' u='c' c='do_coredump'/>
<use f='linux-4.14.y/init/do_mounts_initrd.c' l='79' u='c' c='handle_initrd'/>
<use f='linux-4.14.y/kernel/kmod.c' l='99' u='c' c='call_modprobe'/>
<def f='linux-4.14.y/kernel/umh.c' l='408' ll='462' type='int call_usermodehelper_exec(struct subprocess_info * sub_info, int wait)'/>
<dec f='linux-4.14.y/kernel/umh.c' l='463' type='int call_usermodehelper_exec(struct subprocess_info * , int )'/>
<use f='linux-4.14.y/kernel/umh.c' l='463' c='call_usermodehelper_exec'/>
<use f='linux-4.14.y/kernel/umh.c' l='463' u='a'/>
<use f='linux-4.14.y/kernel/umh.c' l='463' u='a'/>
<use f='linux-4.14.y/kernel/umh.c' l='488' u='c' c='call_usermodehelper'/>
<doc f='linux-4.14.y/kernel/umh.c' l='396'>/**
 * call_usermodehelper_exec - start a usermode application
 * @sub_info: information about the subprocessa
 * @wait: wait for the application to finish and return status.
 *        when UMH_NO_WAIT don&apos;t wait at all, but you get no useful error back
 *        when the program couldn&apos;t be exec&apos;ed. This makes it safe to call
 *        from interrupt context.
 *
 * Runs a user-space application.  The application is started
 * asynchronously if wait is not set, and runs as a child of system workqueues.
 * (ie. it runs with full root capabilities and optimized affinity).
 */</doc>
<use f='linux-4.14.y/lib/kobject_uevent.c' l='526' u='c' c='kobject_uevent_env'/>
<use f='linux-4.14.y/security/keys/request_key.c' l='87' u='c' c='call_usermodehelper_keys'/>
