<def f='linux-4.18.y/include/linux/reservation.h' l='162' ll='167' type='int reservation_object_lock(struct reservation_object * obj, struct ww_acquire_ctx * ctx)'/>
<doc f='linux-4.18.y/include/linux/reservation.h' l='147'>/**
 * reservation_object_lock - lock the reservation object
 * @obj: the reservation object
 * @ctx: the locking context
 *
 * Locks the reservation object for exclusive access and modification. Note,
 * that the lock is only against other writers, readers will run concurrently
 * with a writer under RCU. The seqlock is used to notify readers if they
 * overlap with a writer.
 *
 * As the reservation object may be locked by multiple parties in an
 * undefined order, a #ww_acquire_ctx is passed to unwind if a cycle
 * is detected. See ww_mutex_lock() and ww_acquire_init(). A reservation
 * object may be locked by itself by passing NULL as @ctx.
 */</doc>
<use f='linux-4.18.y/include/drm/ttm/ttm_bo_driver.h' l='641' u='c' c='__ttm_bo_reserve'/>
<use f='linux-4.18.y/drivers/gpu/drm/ttm/ttm_bo.c' l='547' u='c' c='ttm_bo_delayed_delete'/>
