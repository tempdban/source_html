<dec f='linux-4.14.y/include/acpi/acpixf.h' l='865' type='acpi_status acpi_read_bit_register(u32 register_id, u32 * return_value)'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='209' u='c' c='acpi_enable_event'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='270' u='c' c='acpi_disable_event'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='370' u='c' c='acpi_get_event_status'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='384' u='c' c='acpi_get_event_status'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwacpi.c' l='169' u='c' c='acpi_hw_get_mode'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwsleep.c' l='195' u='c' c='acpi_hw_legacy_sleep'/>
<def f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='299' ll='335' type='acpi_status acpi_read_bit_register(u32 register_id, u32 * return_value)'/>
<dec f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' type='acpi_status acpi_read_bit_register(u32 , u32 * )'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' c='acpi_read_bit_register'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' u='a'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' u='a'/>
<doc f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='275'>/*******************************************************************************
 *
 * FUNCTION:    acpi_read_bit_register
 *
 * PARAMETERS:  register_id     - ID of ACPI Bit Register to access
 *              return_value    - Value that was read from the register,
 *                                normalized to bit position zero.
 *
 * RETURN:      Status and the value read from the specified Register. Value
 *              returned is normalized to bit0 (is shifted all the way right)
 *
 * DESCRIPTION: ACPI bit_register read function. Does not acquire the HW lock.
 *
 * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and
 *              PM2 Control.
 *
 * Note: The hardware lock is not required when reading the ACPI bit registers
 *       since almost all of them are single bit and it does not matter that
 *       the parent hardware register can be split across two physical
 *       registers. The only multi-bit field is SLP_TYP in the PM1 control
 *       register, but this field does not cross an 8-bit boundary (nor does
 *       it make much sense to actually read this field.)
 *
 ******************************************************************************/</doc>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxfsleep.c' l='234' u='c' c='acpi_enter_sleep_state_s4bios'/>
<use f='linux-4.14.y/drivers/acpi/processor_idle.c' l='629' u='c' c='acpi_idle_bm_check'/>
<dec f='linux-4.14.y/include/acpi/acpixf.h' l='865' type='acpi_status acpi_read_bit_register(u32 register_id, u32 * return_value)'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='209' u='c' c='acpi_enable_event'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='270' u='c' c='acpi_disable_event'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='370' u='c' c='acpi_get_event_status'/>
<use f='linux-4.14.y/drivers/acpi/acpica/evxfevnt.c' l='384' u='c' c='acpi_get_event_status'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwacpi.c' l='169' u='c' c='acpi_hw_get_mode'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwsleep.c' l='195' u='c' c='acpi_hw_legacy_sleep'/>
<def f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='299' ll='335' type='acpi_status acpi_read_bit_register(u32 register_id, u32 * return_value)'/>
<dec f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' type='acpi_status acpi_read_bit_register(u32 , u32 * )'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' c='acpi_read_bit_register'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' u='a'/>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='337' u='a'/>
<doc f='linux-4.14.y/drivers/acpi/acpica/hwxface.c' l='275'>/*******************************************************************************
 *
 * FUNCTION:    acpi_read_bit_register
 *
 * PARAMETERS:  register_id     - ID of ACPI Bit Register to access
 *              return_value    - Value that was read from the register,
 *                                normalized to bit position zero.
 *
 * RETURN:      Status and the value read from the specified Register. Value
 *              returned is normalized to bit0 (is shifted all the way right)
 *
 * DESCRIPTION: ACPI bit_register read function. Does not acquire the HW lock.
 *
 * SUPPORTS:    Bit fields in PM1 Status, PM1 Enable, PM1 Control, and
 *              PM2 Control.
 *
 * Note: The hardware lock is not required when reading the ACPI bit registers
 *       since almost all of them are single bit and it does not matter that
 *       the parent hardware register can be split across two physical
 *       registers. The only multi-bit field is SLP_TYP in the PM1 control
 *       register, but this field does not cross an 8-bit boundary (nor does
 *       it make much sense to actually read this field.)
 *
 ******************************************************************************/</doc>
<use f='linux-4.14.y/drivers/acpi/acpica/hwxfsleep.c' l='234' u='c' c='acpi_enter_sleep_state_s4bios'/>
<use f='linux-4.14.y/drivers/acpi/processor_idle.c' l='629' u='c' c='acpi_idle_bm_check'/>
