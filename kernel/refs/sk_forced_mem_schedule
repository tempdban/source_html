<dec f='linux-4.18.y/include/net/tcp.h' l='288' type='void sk_forced_mem_schedule(struct sock * sk, int size)'/>
<use f='linux-4.18.y/net/ipv4/tcp.c' l='881' u='c' c='sk_stream_alloc_skb'/>
<use f='linux-4.18.y/net/ipv4/tcp_fastopen.c' l='196' u='c' c='tcp_fastopen_add_skb'/>
<use f='linux-4.18.y/net/ipv4/tcp_input.c' l='4708' u='c' c='tcp_data_queue'/>
<def f='linux-4.18.y/net/ipv4/tcp_output.c' l='3031' ll='3043' type='void sk_forced_mem_schedule(struct sock * sk, int size)'/>
<use f='linux-4.18.y/net/ipv4/tcp_output.c' l='3085' u='c' c='tcp_send_fin'/>
<doc f='linux-4.18.y/net/ipv4/tcp_output.c' l='3024'>/* We allow to exceed memory limits for FIN packets to expedite
 * connection tear down and (memory) recovery.
 * Otherwise tcp_send_fin() could be tempted to either delay FIN
 * or even be forced to close flow without any FIN.
 * In general, we want to allow one skb per socket to avoid hangs
 * with edge trigger epoll()
 */</doc>
