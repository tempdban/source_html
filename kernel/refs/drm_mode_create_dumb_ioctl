<dec f='linux-4.18.y/drivers/gpu/drm/drm_crtc_internal.h' l='66' type='int drm_mode_create_dumb_ioctl(struct drm_device * dev, void * data, struct drm_file * file_priv)'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_crtc_internal.h' l='65'>/* IOCTLs */</doc>
<def f='linux-4.18.y/drivers/gpu/drm/drm_dumb_buffers.c' l='56' ll='93' type='int drm_mode_create_dumb_ioctl(struct drm_device * dev, void * data, struct drm_file * file_priv)'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_dumb_buffers.c' l='31'>/**
 * DOC: overview
 *
 * The KMS API doesn&apos;t standardize backing storage object creation and leaves it
 * to driver-specific ioctls. Furthermore actually creating a buffer object even
 * for GEM-based drivers is done through a driver-specific ioctl - GEM only has
 * a common userspace interface for sharing and destroying objects. While not an
 * issue for full-fledged graphics stacks that include device-specific userspace
 * components (in libdrm for instance), this limit makes DRM-based early boot
 * graphics unnecessarily complex.
 *
 * Dumb objects partly alleviate the problem by providing a standard API to
 * create dumb buffers suitable for scanout, which can then be used to create
 * KMS frame buffers.
 *
 * To support dumb objects drivers must implement the &amp;drm_driver.dumb_create
 * operation. &amp;drm_driver.dumb_destroy defaults to drm_gem_dumb_destroy() if
 * not set and &amp;drm_driver.dumb_map_offset defaults to
 * drm_gem_dumb_map_offset(). See the callbacks for further details.
 *
 * Note that dumb objects may not be used for gpu acceleration, as has been
 * attempted on some ARM embedded platforms. Such drivers really must have
 * a hardware-specific ioctl to allocate suitable buffer objects.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='645'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='645'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='645'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='645'/>
