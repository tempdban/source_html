<dec f='linux-4.14.y/include/linux/vmalloc.h' l='178' type='struct vm_struct ** pcpu_get_vm_areas(const unsigned long * offsets, const size_t * sizes, int nr_vms, size_t align)'/>
<use f='linux-4.14.y/mm/percpu-vm.c' l='341' u='c' c='pcpu_create_chunk'/>
<def f='linux-4.14.y/mm/vmalloc.c' l='2483' ll='2631' type='struct vm_struct ** pcpu_get_vm_areas(const unsigned long * offsets, const size_t * sizes, int nr_vms, size_t align)'/>
<use f='linux-4.14.y/mm/vmalloc.c' l='2617' u='r' c='pcpu_get_vm_areas'/>
<doc f='linux-4.14.y/mm/vmalloc.c' l='2459'>/**
 * pcpu_get_vm_areas - allocate vmalloc areas for percpu allocator
 * @offsets: array containing offset of each area
 * @sizes: array containing size of each area
 * @nr_vms: the number of areas to allocate
 * @align: alignment, all entries in @offsets and @sizes must be aligned to this
 *
 * Returns: kmalloc&apos;d vm_struct pointer array pointing to allocated
 *	    vm_structs on success, %NULL on failure
 *
 * Percpu allocator wants to use congruent vm areas so that it can
 * maintain the offsets among percpu areas.  This function allocates
 * congruent vmalloc areas for it with GFP_KERNEL.  These areas tend to
 * be scattered pretty far, distance between two areas easily going up
 * to gigabytes.  To avoid interacting with regular vmallocs, these
 * areas are allocated from top.
 *
 * Despite its complicated look, this allocator is rather simple.  It
 * does everything top-down and scans areas from the end looking for
 * matching slot.  While scanning, if any of the areas overlaps with
 * existing vmap_area, the base address is pulled down to fit the
 * area.  Scanning is repeated till all the areas fit and then all
 * necessary data structures are inserted and the result is returned.
 */</doc>
