<def f='linux-4.18.y/arch/x86/include/asm/iommu_table.h' l='34' ll='42'/>
<size>40</size>
<doc f='linux-4.18.y/arch/x86/include/asm/iommu_table.h' l='7'>/*
 * History lesson:
 * The execution chain of IOMMUs in 2.6.36 looks as so:
 *
 *            [xen-swiotlb]
 *                 |
 *         +----[swiotlb *]--+
 *        /         |         \
 *       /          |          \
 *    [GART]     [Calgary]  [Intel VT-d]
 *     /
 *    /
 * [AMD-Vi]
 *
 * *: if SWIOTLB detected &apos;iommu=soft&apos;/&apos;swiotlb=force&apos; it would skip
 * over the rest of IOMMUs and unconditionally initialize the SWIOTLB.
 * Also it would surreptitiously initialize set the swiotlb=1 if there were
 * more than 4GB and if the user did not pass in &apos;iommu=off&apos;. The swiotlb
 * flag would be turned off by all IOMMUs except the Calgary one.
 *
 * The IOMMU_INIT* macros allow a similar tree (or more complex if desired)
 * to be built by defining who we depend on.
 *
 * And all that needs to be done is to use one of the macros in the IOMMU
 * and the pci-dma.c will take care of the rest.
 */</doc>
<mbr r='iommu_table_entry::detect' o='0' t='initcall_t'/>
<mbr r='iommu_table_entry::depend' o='64' t='initcall_t'/>
<mbr r='iommu_table_entry::early_init' o='128' t='void (*)(void)'/>
<mbr r='iommu_table_entry::late_init' o='192' t='void (*)(void)'/>
<mbr r='iommu_table_entry::flags' o='256' t='int'/>
