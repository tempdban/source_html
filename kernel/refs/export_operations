<def f='linux-4.18.y/include/linux/exportfs.h' l='193' ll='211'/>
<size>72</size>
<doc f='linux-4.18.y/include/linux/exportfs.h' l='133'>/**
 * struct export_operations - for nfsd to communicate with file systems
 * @encode_fh:      encode a file handle fragment from a dentry
 * @fh_to_dentry:   find the implied object and get a dentry for it
 * @fh_to_parent:   find the implied object&apos;s parent and get a dentry for it
 * @get_name:       find the name for a given inode in a given directory
 * @get_parent:     find the parent of a given directory
 * @commit_metadata: commit metadata changes to stable storage
 *
 * See Documentation/filesystems/nfs/Exporting for details on how to use
 * this interface correctly.
 *
 * encode_fh:
 *    @encode_fh should store in the file handle fragment @fh (using at most
 *    @max_len bytes) information that can be used by @decode_fh to recover the
 *    file referred to by the &amp;struct dentry @de.  If the @connectable flag is
 *    set, the encode_fh() should store sufficient information so that a good
 *    attempt can be made to find not only the file but also it&apos;s place in the
 *    filesystem.   This typically means storing a reference to de-&gt;d_parent in
 *    the filehandle fragment.  encode_fh() should return the fileid_type on
 *    success and on error returns 255 (if the space needed to encode fh is
 *    greater than @max_len*4 bytes). On error @max_len contains the minimum
 *    size(in 4 byte unit) needed to encode the file handle.
 *
 * fh_to_dentry:
 *    @fh_to_dentry is given a &amp;struct super_block (@sb) and a file handle
 *    fragment (@fh, @fh_len). It should return a &amp;struct dentry which refers
 *    to the same file that the file handle fragment refers to.  If it cannot,
 *    it should return a %NULL pointer if the file cannot be found, or an
 *    %ERR_PTR error code of %ENOMEM if a memory allocation failure occurred.
 *    Any other error code is treated like %NULL, and will cause an %ESTALE error
 *    for callers of exportfs_decode_fh().
 *    Any suitable dentry can be returned including, if necessary, a new dentry
 *    created with d_alloc_root.  The caller can then find any other extant
 *    dentries by following the d_alias links.
 *
 * fh_to_parent:
 *    Same as @fh_to_dentry, except that it returns a pointer to the parent
 *    dentry if it was encoded into the filehandle fragment by @encode_fh.
 *
 * get_name:
 *    @get_name should find a name for the given @child in the given @parent
 *    directory.  The name should be stored in the @name (with the
 *    understanding that it is already pointing to a a %NAME_MAX+1 sized
 *    buffer.   get_name() should return %0 on success, a negative error code
 *    or error.  @get_name will be called without @parent-&gt;i_mutex held.
 *
 * get_parent:
 *    @get_parent should find the parent directory for the given @child which
 *    is also a directory.  In the event that it cannot be found, or storage
 *    space cannot be allocated, a %ERR_PTR should be returned.
 *
 * commit_metadata:
 *    @commit_metadata should commit metadata changes to stable storage.
 *
 * Locking rules:
 *    get_parent is called with child-&gt;d_inode-&gt;i_mutex down
 *    get_name is not (which is possibly inconsistent)
 */</doc>
<mbr r='export_operations::encode_fh' o='0' t='int (*)(struct inode *, __u32 *, int *, struct inode *)'/>
<mbr r='export_operations::fh_to_dentry' o='64' t='struct dentry *(*)(struct super_block *, struct fid *, int, int)'/>
<mbr r='export_operations::fh_to_parent' o='128' t='struct dentry *(*)(struct super_block *, struct fid *, int, int)'/>
<mbr r='export_operations::get_name' o='192' t='int (*)(struct dentry *, char *, struct dentry *)'/>
<mbr r='export_operations::get_parent' o='256' t='struct dentry *(*)(struct dentry *)'/>
<mbr r='export_operations::commit_metadata' o='320' t='int (*)(struct inode *)'/>
<mbr r='export_operations::get_uuid' o='384' t='int (*)(struct super_block *, u8 *, u32 *, u64 *)'/>
<mbr r='export_operations::map_blocks' o='448' t='int (*)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *)'/>
<mbr r='export_operations::commit_blocks' o='512' t='int (*)(struct inode *, struct iomap *, int, struct iattr *)'/>
