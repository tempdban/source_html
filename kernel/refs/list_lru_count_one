<dec f='linux-4.18.y/include/linux/list_lru.h' l='111' type='unsigned long list_lru_count_one(struct list_lru * lru, int nid, struct mem_cgroup * memcg)'/>
<use f='linux-4.18.y/include/linux/list_lru.h' l='118' u='c' c='list_lru_shrink_count'/>
<doc f='linux-4.18.y/include/linux/list_lru.h' l='101'>/**
 * list_lru_count_one: return the number of objects currently held by @lru
 * @lru: the lru pointer.
 * @nid: the node id to count from.
 * @memcg: the cgroup to count from.
 *
 * Always return a non-negative number, 0 for empty lists. There is no
 * guarantee that the list is not updated while the count is being computed.
 * Callers that want such a guarantee need to provide an outer lock.
 */</doc>
<def f='linux-4.18.y/mm/list_lru.c' l='180' ll='184' type='unsigned long list_lru_count_one(struct list_lru * lru, int nid, struct mem_cgroup * memcg)'/>
<dec f='linux-4.18.y/mm/list_lru.c' l='185' type='unsigned long list_lru_count_one(struct list_lru * , int , struct mem_cgroup * )'/>
<use f='linux-4.18.y/mm/list_lru.c' l='185' c='list_lru_count_one'/>
<use f='linux-4.18.y/mm/list_lru.c' l='185' u='a'/>
<use f='linux-4.18.y/mm/list_lru.c' l='185' u='a'/>
