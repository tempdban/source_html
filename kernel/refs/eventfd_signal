<dec f='linux-4.14.y/include/linux/eventfd.h' l='39' type='__u64 eventfd_signal(struct eventfd_ctx * ctx, __u64 n)'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci.c' l='1181' u='c' c='vfio_pci_request'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci.c' l='1297' u='c' c='vfio_pci_aer_err_detected'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='36' u='c' c='vfio_send_intx_eventfd'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='246' u='c' c='vfio_msihandler'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='538' u='c' c='vfio_pci_set_msi_trigger'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='542' u='c' c='vfio_pci_set_msi_trigger'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='556' u='c' c='vfio_pci_set_ctx_trigger_single'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='571' u='c' c='vfio_pci_set_ctx_trigger_single'/>
<use f='linux-4.14.y/fs/aio.c' l='1192' u='c' c='aio_complete'/>
<def f='linux-4.14.y/fs/eventfd.c' l='54' ll='67' type='__u64 eventfd_signal(struct eventfd_ctx * ctx, __u64 n)'/>
<dec f='linux-4.14.y/fs/eventfd.c' l='68' type='__u64 eventfd_signal(struct eventfd_ctx * , __u64 )'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' c='eventfd_signal'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' u='a'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' u='a'/>
<doc f='linux-4.14.y/fs/eventfd.c' l='40'>/**
 * eventfd_signal - Adds @n to the eventfd counter.
 * @ctx: [in] Pointer to the eventfd context.
 * @n: [in] Value of the counter to be added to the eventfd internal counter.
 *          The value cannot be negative.
 *
 * This function is supposed to be called by the kernel in paths that do not
 * allow sleeping. In this function we allow the counter to reach the ULLONG_MAX
 * value, and we signal this as overflow condition by returning a POLLERR
 * to poll(2).
 *
 * Returns the amount by which the counter was incremented.  This will be less
 * than @n if the counter has overflowed.
 */</doc>
<dec f='linux-4.14.y/include/linux/eventfd.h' l='39' type='__u64 eventfd_signal(struct eventfd_ctx * ctx, __u64 n)'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci.c' l='1181' u='c' c='vfio_pci_request'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci.c' l='1297' u='c' c='vfio_pci_aer_err_detected'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='36' u='c' c='vfio_send_intx_eventfd'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='246' u='c' c='vfio_msihandler'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='538' u='c' c='vfio_pci_set_msi_trigger'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='542' u='c' c='vfio_pci_set_msi_trigger'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='556' u='c' c='vfio_pci_set_ctx_trigger_single'/>
<use f='linux-4.14.y/drivers/vfio/pci/vfio_pci_intrs.c' l='571' u='c' c='vfio_pci_set_ctx_trigger_single'/>
<use f='linux-4.14.y/fs/aio.c' l='1192' u='c' c='aio_complete'/>
<def f='linux-4.14.y/fs/eventfd.c' l='54' ll='67' type='__u64 eventfd_signal(struct eventfd_ctx * ctx, __u64 n)'/>
<dec f='linux-4.14.y/fs/eventfd.c' l='68' type='__u64 eventfd_signal(struct eventfd_ctx * , __u64 )'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' c='eventfd_signal'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' u='a'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' u='a'/>
<doc f='linux-4.14.y/fs/eventfd.c' l='40'>/**
 * eventfd_signal - Adds @n to the eventfd counter.
 * @ctx: [in] Pointer to the eventfd context.
 * @n: [in] Value of the counter to be added to the eventfd internal counter.
 *          The value cannot be negative.
 *
 * This function is supposed to be called by the kernel in paths that do not
 * allow sleeping. In this function we allow the counter to reach the ULLONG_MAX
 * value, and we signal this as overflow condition by returning a POLLERR
 * to poll(2).
 *
 * Returns the amount by which the counter was incremented.  This will be less
 * than @n if the counter has overflowed.
 */</doc>
