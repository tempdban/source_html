<dec f='linux-4.14.y/include/linux/eventfd.h' l='39' type='__u64 eventfd_signal(struct eventfd_ctx * ctx, __u64 n)'/>
<use f='linux-4.14.y/fs/aio.c' l='1192' u='c' c='aio_complete'/>
<def f='linux-4.14.y/fs/eventfd.c' l='54' ll='67' type='__u64 eventfd_signal(struct eventfd_ctx * ctx, __u64 n)'/>
<dec f='linux-4.14.y/fs/eventfd.c' l='68' type='__u64 eventfd_signal(struct eventfd_ctx * , __u64 )'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' c='eventfd_signal'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' u='a'/>
<use f='linux-4.14.y/fs/eventfd.c' l='68' u='a'/>
<doc f='linux-4.14.y/fs/eventfd.c' l='40'>/**
 * eventfd_signal - Adds @n to the eventfd counter.
 * @ctx: [in] Pointer to the eventfd context.
 * @n: [in] Value of the counter to be added to the eventfd internal counter.
 *          The value cannot be negative.
 *
 * This function is supposed to be called by the kernel in paths that do not
 * allow sleeping. In this function we allow the counter to reach the ULLONG_MAX
 * value, and we signal this as overflow condition by returning a POLLERR
 * to poll(2).
 *
 * Returns the amount by which the counter was incremented.  This will be less
 * than @n if the counter has overflowed.
 */</doc>
