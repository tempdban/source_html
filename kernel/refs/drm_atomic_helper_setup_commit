<dec f='linux-4.18.y/include/drm/drm_atomic_helper.h' l='100' type='int drm_atomic_helper_setup_commit(struct drm_atomic_state * state, bool nonblock)'/>
<doc f='linux-4.18.y/include/drm/drm_atomic_helper.h' l='99'>/* nonblocking commit helpers */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1627' u='c' c='drm_atomic_helper_commit'/>
<def f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1856' ll='1942' type='int drm_atomic_helper_setup_commit(struct drm_atomic_state * state, bool nonblock)'/>
<dec f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1943' type='int drm_atomic_helper_setup_commit(struct drm_atomic_state * , bool )'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1943' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1943' u='a'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1943' u='a'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1813'>/**
 * drm_atomic_helper_setup_commit - setup possibly nonblocking commit
 * @state: new modeset state to be committed
 * @nonblock: whether nonblocking behavior is requested.
 *
 * This function prepares @state to be used by the atomic helper&apos;s support for
 * nonblocking commits. Drivers using the nonblocking commit infrastructure
 * should always call this function from their
 * &amp;drm_mode_config_funcs.atomic_commit hook.
 *
 * To be able to use this support drivers need to use a few more helper
 * functions. drm_atomic_helper_wait_for_dependencies() must be called before
 * actually committing the hardware state, and for nonblocking commits this call
 * must be placed in the async worker. See also drm_atomic_helper_swap_state()
 * and it&apos;s stall parameter, for when a driver&apos;s commit hooks look at the
 * &amp;drm_crtc.state, &amp;drm_plane.state or &amp;drm_connector.state pointer directly.
 *
 * Completion of the hardware commit step must be signalled using
 * drm_atomic_helper_commit_hw_done(). After this step the driver is not allowed
 * to read or change any permanent software or hardware modeset state. The only
 * exception is state protected by other means than &amp;drm_modeset_lock locks.
 * Only the free standing @state with pointers to the old state structures can
 * be inspected, e.g. to clean up old buffers using
 * drm_atomic_helper_cleanup_planes().
 *
 * At the very end, before cleaning up @state drivers must call
 * drm_atomic_helper_commit_cleanup_done().
 *
 * This is all implemented by in drm_atomic_helper_commit(), giving drivers a
 * complete and easy-to-use default implementation of the atomic_commit() hook.
 *
 * The tracking of asynchronously executed and still pending commits is done
 * using the core structure &amp;drm_crtc_commit.
 *
 * By default there&apos;s no need to clean up resources allocated by this function
 * explicitly: drm_atomic_state_default_clear() will take care of that
 * automatically.
 *
 * Returns:
 *
 * 0 on success. -EBUSY when userspace schedules nonblocking commits too fast,
 * -ENOMEM on allocation failures and -EINTR when a signal is pending.
 */</doc>
