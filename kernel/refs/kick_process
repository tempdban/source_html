<dec f='linux-4.18.y/include/linux/sched.h' l='1599' type='void kick_process(struct task_struct * tsk)'/>
<use f='linux-4.18.y/include/linux/tracehook.h' l='166' u='c' c='set_notify_resume'/>
<def f='linux-4.18.y/kernel/sched/core.c' l='1439' ll='1448' type='void kick_process(struct task_struct * p)'/>
<dec f='linux-4.18.y/kernel/sched/core.c' l='1449' type='void kick_process(struct task_struct * )'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='1449' c='kick_process'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='1449' u='a'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='1449' u='a'/>
<doc f='linux-4.18.y/kernel/sched/core.c' l='1426'>/***
 * kick_process - kick a running thread to enter/exit the kernel
 * @p: the to-be-kicked thread
 *
 * Cause a process which is running on another CPU to enter
 * kernel-mode, without any delay. (to get signals handled.)
 *
 * NOTE: this function doesn&apos;t have to take the runqueue lock,
 * because all it wants to ensure is that the remote task enters
 * the kernel. If the IPI races and the task has been migrated
 * to another CPU then no harm is done and the purpose has been
 * achieved as well.
 */</doc>
<use f='linux-4.18.y/kernel/signal.c' l='678' u='c' c='signal_wake_up_state'/>
