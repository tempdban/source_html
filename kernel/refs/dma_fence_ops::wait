<dec f='linux-4.18.y/include/linux/dma-fence.h' l='207' type='long (*)(struct dma_fence *, bool, long)'/>
<offset>256</offset>
<doc f='linux-4.18.y/include/linux/dma-fence.h' l='190'>/**
	 * @wait:
	 *
	 * Custom wait implementation, or dma_fence_default_wait.
	 *
	 * Must not be NULL, set to dma_fence_default_wait for default implementation.
	 * the dma_fence_default_wait implementation should work for any fence, as long
	 * as enable_signaling works correctly.
	 *
	 * Must return -ERESTARTSYS if the wait is intr = true and the wait was
	 * interrupted, and remaining jiffies if fence has signaled, or 0 if wait
	 * timed out. Can also return other error values on custom implementations,
	 * which should be treated as if the fence is signaled. For example a hardware
	 * lockup could be reported like that.
	 *
	 * This callback is mandatory.
	 */</doc>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence-array.c' l='107' u='w'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='161' u='r' c='dma_fence_wait_timeout'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='499' u='r' c='dma_fence_wait_any_timeout'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='563' u='r' c='dma_fence_init'/>
<use f='linux-4.18.y/include/linux/seqno-fence.h' l='102' u='r' c='seqno_fence_init'/>
<use f='linux-4.18.y/drivers/dma-buf/seqno-fence.c' l='68' u='r' c='seqno_wait'/>
<use f='linux-4.18.y/drivers/dma-buf/seqno-fence.c' l='76' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_crtc.c' l='237' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_syncobj.c' l='210' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_release.c' l='123' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_fence.c' l='72' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='231' u='w'/>
