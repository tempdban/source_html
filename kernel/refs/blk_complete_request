<dec f='linux-4.18.y/include/linux/blkdev.h' l='1187' type='void blk_complete_request(struct request * )'/>
<def f='linux-4.18.y/block/blk-softirq.c' l='160' ll='166' type='void blk_complete_request(struct request * req)'/>
<dec f='linux-4.18.y/block/blk-softirq.c' l='167' type='void blk_complete_request(struct request * )'/>
<use f='linux-4.18.y/block/blk-softirq.c' l='167' c='blk_complete_request'/>
<use f='linux-4.18.y/block/blk-softirq.c' l='167' u='a'/>
<use f='linux-4.18.y/block/blk-softirq.c' l='167' u='a'/>
<doc f='linux-4.18.y/block/blk-softirq.c' l='149'>/**
 * blk_complete_request - end I/O on a request
 * @req:      the request being processed
 *
 * Description:
 *     Ends all I/O on a request. It does not handle partial completions,
 *     unless the driver actually implements this in its completion callback
 *     through requeueing. The actual completion happens out-of-order,
 *     through a softirq handler. The user must have registered a completion
 *     callback through blk_queue_softirq_done().
 **/</doc>
<use f='linux-4.18.y/block/bsg-lib.c' l='161' u='c' c='bsg_job_done'/>
<use f='linux-4.18.y/drivers/md/dm-rq.c' l='367' u='c' c='dm_complete_request'/>
<use f='linux-4.18.y/drivers/scsi/scsi_lib.c' l='1659' u='c' c='scsi_kill_request'/>
<use f='linux-4.18.y/drivers/scsi/scsi_lib.c' l='1796' u='c' c='scsi_done'/>
