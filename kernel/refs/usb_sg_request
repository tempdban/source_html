<def f='linux-4.14.y/include/linux/usb.h' l='1815' ll='1833'/>
<size>88</size>
<doc f='linux-4.14.y/include/linux/usb.h' l='1799'>/**
 * struct usb_sg_request - support for scatter/gather I/O
 * @status: zero indicates success, else negative errno
 * @bytes: counts bytes transferred.
 *
 * These requests are initialized using usb_sg_init(), and then are used
 * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most
 * members of the request object aren&apos;t for driver access.
 *
 * The status and bytecount values are valid only after usb_sg_wait()
 * returns.  If the status is zero, then the bytecount matches the total
 * from the request.
 *
 * After an error completion, drivers may need to clear a halt condition
 * on the endpoint.
 */</doc>
<mbr r='usb_sg_request::status' o='0' t='int'/>
<mbr r='usb_sg_request::bytes' o='64' t='size_t'/>
<mbr r='usb_sg_request::lock' o='128' t='spinlock_t'/>
<mbr r='usb_sg_request::dev' o='192' t='struct usb_device *'/>
<mbr r='usb_sg_request::pipe' o='256' t='int'/>
<mbr r='usb_sg_request::entries' o='288' t='int'/>
<mbr r='usb_sg_request::urbs' o='320' t='struct urb **'/>
<mbr r='usb_sg_request::count' o='384' t='int'/>
<mbr r='usb_sg_request::complete' o='448' t='struct completion'/>
