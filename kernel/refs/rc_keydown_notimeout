<dec f='linux-4.18.y/include/media/rc-core.h' l='297' type='void rc_keydown_notimeout(struct rc_dev * dev, enum rc_proto protocol, u32 scancode, u8 toggle)'/>
<def f='linux-4.18.y/drivers/media/rc/rc-main.c' l='833' ll='842' type='void rc_keydown_notimeout(struct rc_dev * dev, enum rc_proto protocol, u32 scancode, u8 toggle)'/>
<dec f='linux-4.18.y/drivers/media/rc/rc-main.c' l='843' type='void rc_keydown_notimeout(struct rc_dev * , enum rc_proto , u32 , u8 )'/>
<use f='linux-4.18.y/drivers/media/rc/rc-main.c' l='843' c='rc_keydown_notimeout'/>
<use f='linux-4.18.y/drivers/media/rc/rc-main.c' l='843' u='a'/>
<use f='linux-4.18.y/drivers/media/rc/rc-main.c' l='843' u='a'/>
<doc f='linux-4.18.y/drivers/media/rc/rc-main.c' l='821'>/**
 * rc_keydown_notimeout() - generates input event for a key press without
 *                          an automatic keyup event at a later time
 * @dev:	the struct rc_dev descriptor of the device
 * @protocol:	the protocol for the keypress
 * @scancode:	the scancode for the keypress
 * @toggle:     the toggle value (protocol dependent, if the protocol doesn&apos;t
 *              support toggle values, this should be set to zero)
 *
 * This routine is used to signal that a key has been pressed on the
 * remote control. The driver must manually call rc_keyup() at a later stage.
 */</doc>
