<dec f='linux-4.18.y/drivers/net/ethernet/intel/i40e/i40e_prototype.h' l='136' type='i40e_status i40e_aq_add_veb(struct i40e_hw * hw, u16 uplink_seid, u16 downlink_seid, u8 enabled_tc, bool default_port, u16 * pveb_seid, bool enable_stats, struct i40e_asq_cmd_details * cmd_details)'/>
<def f='linux-4.18.y/drivers/net/ethernet/intel/i40e/i40e_common.c' l='2609' ll='2651' type='i40e_status i40e_aq_add_veb(struct i40e_hw * hw, u16 uplink_seid, u16 downlink_seid, u8 enabled_tc, bool default_port, u16 * veb_seid, bool enable_stats, struct i40e_asq_cmd_details * cmd_details)'/>
<doc f='linux-4.18.y/drivers/net/ethernet/intel/i40e/i40e_common.c' l='2595'>/**
 * i40e_aq_add_veb - Insert a VEB between the VSI and the MAC
 * @hw: pointer to the hw struct
 * @uplink_seid: the MAC or other gizmo SEID
 * @downlink_seid: the VSI SEID
 * @enabled_tc: bitmap of TCs to be enabled
 * @default_port: true for default port VSI, false for control port
 * @veb_seid: pointer to where to put the resulting VEB SEID
 * @enable_stats: true to turn on VEB stats
 * @cmd_details: pointer to command details structure or NULL
 *
 * This asks the FW to add a VEB between the uplink and downlink
 * elements.  If the uplink SEID is 0, this will be a floating VEB.
 **/</doc>
<use f='linux-4.18.y/drivers/net/ethernet/intel/i40e/i40e_main.c' l='12956' u='c' c='i40e_add_veb'/>
