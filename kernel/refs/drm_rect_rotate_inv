<dec f='linux-4.14.y/include/drm/drm_rect.h' l='197' type='void drm_rect_rotate_inv(struct drm_rect * r, int width, int height, unsigned int rotation)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='170' u='c' c='drm_plane_helper_check_state'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_rect.c' l='381' ll='428' type='void drm_rect_rotate_inv(struct drm_rect * r, int width, int height, unsigned int rotation)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_rect.c' l='429' type='void drm_rect_rotate_inv(struct drm_rect * , int , int , unsigned int )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_rect.c' l='429' c='drm_rect_rotate_inv'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_rect.c' l='429' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_rect.c' l='429' u='a'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_rect.c' l='357'>/**
 * drm_rect_rotate_inv - Inverse rotate the rectangle
 * @r: rectangle to be rotated
 * @width: Width of the coordinate space
 * @height: Height of the coordinate space
 * @rotation: Transformation whose inverse is to be applied
 *
 * Apply the inverse of @rotation to the coordinates
 * of rectangle @r.
 *
 * @width and @height combined with @rotation define
 * the location of the new origin.
 *
 * @width correcsponds to the horizontal and @height
 * to the vertical axis of the original untransformed
 * coordinate space, so that you never have to flip
 * them when doing a rotatation and its inverse.
 * That is, if you do ::
 *
 *     DRM_MODE_PROP_ROTATE(&amp;r, width, height, rotation);
 *     DRM_MODE_ROTATE_inv(&amp;r, width, height, rotation);
 *
 * you will always get back the original rectangle.
 */</doc>
