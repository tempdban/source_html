<def f='linux-4.14.y/arch/x86/include/asm/bitops.h' l='168' ll='172' type='void __clear_bit_unlock(long nr, volatile unsigned long * addr)'/>
<doc f='linux-4.14.y/arch/x86/include/asm/bitops.h' l='156'>/*
 * __clear_bit_unlock - Clears a bit in memory
 * @nr: Bit to clear
 * @addr: Address to start counting from
 *
 * __clear_bit() is non-atomic and implies release semantics before the memory
 * operation. It can be used for an unlock if no other CPUs can concurrently
 * modify other bits in the word.
 *
 * No memory barrier is required here, because x86 cannot reorder stores past
 * older loads. Same principle as spin_unlock.
 */</doc>
<use f='linux-4.14.y/include/linux/bit_spinlock.h' l='80' u='c' c='__bit_spin_unlock'/>
<def f='linux-4.14.y/arch/x86/include/asm/bitops.h' l='168' ll='172' type='void __clear_bit_unlock(long nr, volatile unsigned long * addr)'/>
<doc f='linux-4.14.y/arch/x86/include/asm/bitops.h' l='156'>/*
 * __clear_bit_unlock - Clears a bit in memory
 * @nr: Bit to clear
 * @addr: Address to start counting from
 *
 * __clear_bit() is non-atomic and implies release semantics before the memory
 * operation. It can be used for an unlock if no other CPUs can concurrently
 * modify other bits in the word.
 *
 * No memory barrier is required here, because x86 cannot reorder stores past
 * older loads. Same principle as spin_unlock.
 */</doc>
<use f='linux-4.14.y/include/linux/bit_spinlock.h' l='80' u='c' c='__bit_spin_unlock'/>
