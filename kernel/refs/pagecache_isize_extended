<dec f='linux-4.18.y/include/linux/mm.h' l='1407' type='void pagecache_isize_extended(struct inode * inode, loff_t from, loff_t to)'/>
<use f='linux-4.18.y/fs/buffer.c' l='2141' u='c' c='generic_write_end'/>
<use f='linux-4.18.y/fs/ext4/inode.c' l='1416' u='c' c='ext4_write_end'/>
<use f='linux-4.18.y/fs/ext4/inode.c' l='1534' u='c' c='ext4_journalled_write_end'/>
<use f='linux-4.18.y/fs/ext4/inode.c' l='5547' u='c' c='ext4_setattr'/>
<use f='linux-4.18.y/mm/truncate.c' l='825' u='c' c='truncate_setsize'/>
<def f='linux-4.18.y/mm/truncate.c' l='849' ll='878' type='void pagecache_isize_extended(struct inode * inode, loff_t from, loff_t to)'/>
<dec f='linux-4.18.y/mm/truncate.c' l='879' type='void pagecache_isize_extended(struct inode * , loff_t , loff_t )'/>
<use f='linux-4.18.y/mm/truncate.c' l='879' c='pagecache_isize_extended'/>
<use f='linux-4.18.y/mm/truncate.c' l='879' u='a'/>
<use f='linux-4.18.y/mm/truncate.c' l='879' u='a'/>
<doc f='linux-4.18.y/mm/truncate.c' l='830'>/**
 * pagecache_isize_extended - update pagecache after extension of i_size
 * @inode:	inode for which i_size was extended
 * @from:	original inode size
 * @to:		new inode size
 *
 * Handle extension of inode size either caused by extending truncate or by
 * write starting after current i_size. We mark the page straddling current
 * i_size RO so that page_mkwrite() is called on the nearest write access to
 * the page.  This way filesystem can be sure that page_mkwrite() is called on
 * the page before user writes to the page via mmap after the i_size has been
 * changed.
 *
 * The function must be called after i_size is updated so that page fault
 * coming after we unlock the page will already see the new i_size.
 * The function must be called while we still hold i_mutex - this not only
 * makes sure i_size is stable but also that userspace cannot observe new
 * i_size value before we are prepared to store mmap writes at new inode size.
 */</doc>
