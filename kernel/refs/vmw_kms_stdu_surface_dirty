<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h' l='426' type='int vmw_kms_stdu_surface_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, struct vmw_resource * srf, s32 dest_x, s32 dest_y, unsigned int num_clips, int inc, struct vmw_fence_obj ** out_fence)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='912' u='c' c='vmw_framebuffer_surface_dirty'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1620' u='c' c='vmw_kms_present'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='535' u='c' c='vmw_stdu_crtc_page_flip'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='970' ll='1015' type='int vmw_kms_stdu_surface_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, struct vmw_resource * srf, s32 dest_x, s32 dest_y, unsigned int num_clips, int inc, struct vmw_fence_obj ** out_fence)'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='949'>/**
 * vmw_kms_stdu_surface_dirty - Dirty part of a surface backed framebuffer
 *
 * @dev_priv: Pointer to the device private structure.
 * @framebuffer: Pointer to the surface-buffer backed framebuffer.
 * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
 * @vclips: Alternate array of clip rects. Either @clips or @vclips must
 * be NULL.
 * @srf: Pointer to surface to blit from. If NULL, the surface attached
 * to @framebuffer will be used.
 * @dest_x: X coordinate offset to align @srf with framebuffer coordinates.
 * @dest_y: Y coordinate offset to align @srf with framebuffer coordinates.
 * @num_clips: Number of clip rects in @clips.
 * @inc: Increment to use when looping over @clips.
 * @out_fence: If non-NULL, will return a ref-counted pointer to a
 * struct vmw_fence_obj. The returned fence pointer may be NULL in which
 * case the device has already synchronized.
 *
 * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
 * interrupted.
 */</doc>
<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h' l='426' type='int vmw_kms_stdu_surface_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, struct vmw_resource * srf, s32 dest_x, s32 dest_y, unsigned int num_clips, int inc, struct vmw_fence_obj ** out_fence)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='912' u='c' c='vmw_framebuffer_surface_dirty'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1620' u='c' c='vmw_kms_present'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='535' u='c' c='vmw_stdu_crtc_page_flip'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='970' ll='1015' type='int vmw_kms_stdu_surface_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, struct vmw_resource * srf, s32 dest_x, s32 dest_y, unsigned int num_clips, int inc, struct vmw_fence_obj ** out_fence)'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='949'>/**
 * vmw_kms_stdu_surface_dirty - Dirty part of a surface backed framebuffer
 *
 * @dev_priv: Pointer to the device private structure.
 * @framebuffer: Pointer to the surface-buffer backed framebuffer.
 * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
 * @vclips: Alternate array of clip rects. Either @clips or @vclips must
 * be NULL.
 * @srf: Pointer to surface to blit from. If NULL, the surface attached
 * to @framebuffer will be used.
 * @dest_x: X coordinate offset to align @srf with framebuffer coordinates.
 * @dest_y: Y coordinate offset to align @srf with framebuffer coordinates.
 * @num_clips: Number of clip rects in @clips.
 * @inc: Increment to use when looping over @clips.
 * @out_fence: If non-NULL, will return a ref-counted pointer to a
 * struct vmw_fence_obj. The returned fence pointer may be NULL in which
 * case the device has already synchronized.
 *
 * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
 * interrupted.
 */</doc>
