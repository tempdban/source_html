<dec f='linux-4.14.y/include/linux/blkdev.h' l='1192' type='int blk_stack_limits(struct queue_limits * t, struct queue_limits * b, sector_t offset)'/>
<use f='linux-4.14.y/block/blk-settings.c' l='523' u='c' c='blk_queue_stack_limits'/>
<def f='linux-4.14.y/block/blk-settings.c' l='548' ll='671' type='int blk_stack_limits(struct queue_limits * t, struct queue_limits * b, sector_t start)'/>
<dec f='linux-4.14.y/block/blk-settings.c' l='672' type='int blk_stack_limits(struct queue_limits * , struct queue_limits * , sector_t )'/>
<use f='linux-4.14.y/block/blk-settings.c' l='672' c='blk_stack_limits'/>
<use f='linux-4.14.y/block/blk-settings.c' l='672' u='a'/>
<use f='linux-4.14.y/block/blk-settings.c' l='672' u='a'/>
<use f='linux-4.14.y/block/blk-settings.c' l='692' u='c' c='bdev_stack_limits'/>
<doc f='linux-4.14.y/block/blk-settings.c' l='527'>/**
 * blk_stack_limits - adjust queue_limits for stacked devices
 * @t:	the stacking driver limits (top device)
 * @b:  the underlying queue limits (bottom, component device)
 * @start:  first data sector within component device
 *
 * Description:
 *    This function is used by stacking drivers like MD and DM to ensure
 *    that all component devices have compatible block sizes and
 *    alignments.  The stacking driver must provide a queue_limits
 *    struct (top) and then iteratively call the stacking function for
 *    all component (bottom) devices.  The stacking function will
 *    attempt to combine the values and ensure proper alignment.
 *
 *    Returns 0 if the top and bottom queue_limits are compatible.  The
 *    top device&apos;s block sizes and alignment offsets may be adjusted to
 *    ensure alignment with the bottom device. If no compatible sizes
 *    and alignments exist, -1 is returned and the resulting top
 *    queue_limits will have the misaligned flag set to indicate that
 *    the alignment_offset is undefined.
 */</doc>
<use f='linux-4.14.y/drivers/md/dm-table.c' l='1520' u='c' c='dm_calculate_queue_limits'/>
<dec f='linux-4.14.y/include/linux/blkdev.h' l='1192' type='int blk_stack_limits(struct queue_limits * t, struct queue_limits * b, sector_t offset)'/>
<use f='linux-4.14.y/block/blk-settings.c' l='523' u='c' c='blk_queue_stack_limits'/>
<def f='linux-4.14.y/block/blk-settings.c' l='548' ll='671' type='int blk_stack_limits(struct queue_limits * t, struct queue_limits * b, sector_t start)'/>
<dec f='linux-4.14.y/block/blk-settings.c' l='672' type='int blk_stack_limits(struct queue_limits * , struct queue_limits * , sector_t )'/>
<use f='linux-4.14.y/block/blk-settings.c' l='672' c='blk_stack_limits'/>
<use f='linux-4.14.y/block/blk-settings.c' l='672' u='a'/>
<use f='linux-4.14.y/block/blk-settings.c' l='672' u='a'/>
<use f='linux-4.14.y/block/blk-settings.c' l='692' u='c' c='bdev_stack_limits'/>
<doc f='linux-4.14.y/block/blk-settings.c' l='527'>/**
 * blk_stack_limits - adjust queue_limits for stacked devices
 * @t:	the stacking driver limits (top device)
 * @b:  the underlying queue limits (bottom, component device)
 * @start:  first data sector within component device
 *
 * Description:
 *    This function is used by stacking drivers like MD and DM to ensure
 *    that all component devices have compatible block sizes and
 *    alignments.  The stacking driver must provide a queue_limits
 *    struct (top) and then iteratively call the stacking function for
 *    all component (bottom) devices.  The stacking function will
 *    attempt to combine the values and ensure proper alignment.
 *
 *    Returns 0 if the top and bottom queue_limits are compatible.  The
 *    top device&apos;s block sizes and alignment offsets may be adjusted to
 *    ensure alignment with the bottom device. If no compatible sizes
 *    and alignments exist, -1 is returned and the resulting top
 *    queue_limits will have the misaligned flag set to indicate that
 *    the alignment_offset is undefined.
 */</doc>
<use f='linux-4.14.y/drivers/md/dm-table.c' l='1520' u='c' c='dm_calculate_queue_limits'/>
