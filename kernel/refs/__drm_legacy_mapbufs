<dec f='linux-4.14.y/drivers/gpu/drm/drm_legacy.h' l='79' type='int __drm_legacy_mapbufs(struct drm_device * , void * , int * , void ** , int (*)(void *, int, unsigned long, struct drm_buf *) , struct drm_file * )'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_bufs.c' l='1446' ll='1513' type='int __drm_legacy_mapbufs(struct drm_device * dev, void * data, int * p, void ** v, int (*)(void *, int, unsigned long, struct drm_buf *) f, struct drm_file * file_priv)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_bufs.c' l='1539' u='c' c='drm_legacy_mapbufs'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_bufs.c' l='1432'>/**
 * Maps all of the DMA buffers into client-virtual space (ioctl).
 *
 * \param inode device inode.
 * \param file_priv DRM file private.
 * \param cmd command.
 * \param arg pointer to a drm_buf_map structure.
 * \return zero on success or a negative number on failure.
 *
 * Maps the AGP, SG or PCI buffer region with vm_mmap(), and copies information
 * about each buffer into user space. For PCI buffers, it calls vm_mmap() with
 * offset equal to 0, which drm_mmap() interpretes as PCI buffers and calls
 * drm_mmap_dma().
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='442' u='c' c='drm_legacy_mapbufs32'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_legacy.h' l='79' type='int __drm_legacy_mapbufs(struct drm_device * , void * , int * , void ** , int (*)(void *, int, unsigned long, struct drm_buf *) , struct drm_file * )'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_bufs.c' l='1446' ll='1513' type='int __drm_legacy_mapbufs(struct drm_device * dev, void * data, int * p, void ** v, int (*)(void *, int, unsigned long, struct drm_buf *) f, struct drm_file * file_priv)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_bufs.c' l='1539' u='c' c='drm_legacy_mapbufs'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_bufs.c' l='1432'>/**
 * Maps all of the DMA buffers into client-virtual space (ioctl).
 *
 * \param inode device inode.
 * \param file_priv DRM file private.
 * \param cmd command.
 * \param arg pointer to a drm_buf_map structure.
 * \return zero on success or a negative number on failure.
 *
 * Maps the AGP, SG or PCI buffer region with vm_mmap(), and copies information
 * about each buffer into user space. For PCI buffers, it calls vm_mmap() with
 * offset equal to 0, which drm_mmap() interpretes as PCI buffers and calls
 * drm_mmap_dma().
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='442' u='c' c='drm_legacy_mapbufs32'/>
