<dec f='linux-4.14.y/include/net/ipv6.h' l='964' type='int ipv6_find_hdr(const struct sk_buff * skb, unsigned int * offset, int target, unsigned short * fragoff, int * fragflg)'/>
<doc f='linux-4.14.y/include/net/ipv6.h' l='963'>/* find specified header and get offset to it */</doc>
<use f='linux-4.14.y/drivers/net/ethernet/intel/igb/igb_main.c' l='5066' u='c' c='igb_ipv6_csum_is_sctp'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/igbvf/netdev.c' l='2095' u='c' c='igbvf_ipv6_csum_is_sctp'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='7766' u='c' c='ixgbe_ipv6_csum_is_sctp'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='8136' u='c' c='ixgbe_atr'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c' l='3395' u='c' c='ixgbevf_ipv6_csum_is_sctp'/>
<def f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='185' ll='283' type='int ipv6_find_hdr(const struct sk_buff * skb, unsigned int * offset, int target, unsigned short * fragoff, int * flags)'/>
<dec f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' type='int ipv6_find_hdr(const struct sk_buff * , unsigned int * , int , unsigned short * , int * )'/>
<use f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' c='ipv6_find_hdr'/>
<use f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' u='a'/>
<use f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' u='a'/>
<doc f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='159'>/*
 * find the offset to specified header or the protocol number of last header
 * if target &lt; 0. &quot;last header&quot; is transport protocol header, ESP, or
 * &quot;No next header&quot;.
 *
 * Note that *offset is used as input/output parameter. an if it is not zero,
 * then it must be a valid offset to an inner IPv6 header. This can be used
 * to explore inner IPv6 header, eg. ICMPv6 error messages.
 *
 * If target header is found, its offset is set in *offset and return protocol
 * number. Otherwise, return -1.
 *
 * If the first fragment doesn&apos;t contain the final protocol header or
 * NEXTHDR_NONE it is considered invalid.
 *
 * Note that non-1st fragment is special case that &quot;the protocol number
 * of last header&quot; is &quot;next header&quot; field in Fragment header. In this case,
 * *offset is meaningless and fragment offset is stored in *fragoff if fragoff
 * isn&apos;t NULL.
 *
 * if flags is not NULL and it&apos;s a fragment, then the frag flag
 * IP6_FH_F_FRAG will be set. If it&apos;s an AH header, the
 * IP6_FH_F_AUTH flag is set and target &lt; 0, then this function will
 * stop at the AH header. If IP6_FH_F_SKIP_RH flag was passed, then this
 * function will skip all those routing headers, where segements_left was 0.
 */</doc>
<use f='linux-4.14.y/include/net/netfilter/nf_tables_ipv6.h' l='19' u='c' c='nft_set_pktinfo_ipv6'/>
<use f='linux-4.14.y/net/netfilter/nft_exthdr.c' l='49' u='c' c='nft_exthdr_ipv6_eval'/>
<dec f='linux-4.14.y/include/net/ipv6.h' l='964' type='int ipv6_find_hdr(const struct sk_buff * skb, unsigned int * offset, int target, unsigned short * fragoff, int * fragflg)'/>
<doc f='linux-4.14.y/include/net/ipv6.h' l='963'>/* find specified header and get offset to it */</doc>
<use f='linux-4.14.y/drivers/net/ethernet/intel/igb/igb_main.c' l='5066' u='c' c='igb_ipv6_csum_is_sctp'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/igbvf/netdev.c' l='2095' u='c' c='igbvf_ipv6_csum_is_sctp'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='7766' u='c' c='ixgbe_ipv6_csum_is_sctp'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='8136' u='c' c='ixgbe_atr'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c' l='3395' u='c' c='ixgbevf_ipv6_csum_is_sctp'/>
<def f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='185' ll='283' type='int ipv6_find_hdr(const struct sk_buff * skb, unsigned int * offset, int target, unsigned short * fragoff, int * flags)'/>
<dec f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' type='int ipv6_find_hdr(const struct sk_buff * , unsigned int * , int , unsigned short * , int * )'/>
<use f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' c='ipv6_find_hdr'/>
<use f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' u='a'/>
<use f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='284' u='a'/>
<doc f='linux-4.14.y/net/ipv6/exthdrs_core.c' l='159'>/*
 * find the offset to specified header or the protocol number of last header
 * if target &lt; 0. &quot;last header&quot; is transport protocol header, ESP, or
 * &quot;No next header&quot;.
 *
 * Note that *offset is used as input/output parameter. an if it is not zero,
 * then it must be a valid offset to an inner IPv6 header. This can be used
 * to explore inner IPv6 header, eg. ICMPv6 error messages.
 *
 * If target header is found, its offset is set in *offset and return protocol
 * number. Otherwise, return -1.
 *
 * If the first fragment doesn&apos;t contain the final protocol header or
 * NEXTHDR_NONE it is considered invalid.
 *
 * Note that non-1st fragment is special case that &quot;the protocol number
 * of last header&quot; is &quot;next header&quot; field in Fragment header. In this case,
 * *offset is meaningless and fragment offset is stored in *fragoff if fragoff
 * isn&apos;t NULL.
 *
 * if flags is not NULL and it&apos;s a fragment, then the frag flag
 * IP6_FH_F_FRAG will be set. If it&apos;s an AH header, the
 * IP6_FH_F_AUTH flag is set and target &lt; 0, then this function will
 * stop at the AH header. If IP6_FH_F_SKIP_RH flag was passed, then this
 * function will skip all those routing headers, where segements_left was 0.
 */</doc>
<use f='linux-4.14.y/include/net/netfilter/nf_tables_ipv6.h' l='19' u='c' c='nft_set_pktinfo_ipv6'/>
<use f='linux-4.14.y/net/netfilter/nft_exthdr.c' l='49' u='c' c='nft_exthdr_ipv6_eval'/>
