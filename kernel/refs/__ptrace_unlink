<dec f='linux-4.14.y/include/linux/ptrace.h' l='60' type='void __ptrace_unlink(struct task_struct * child)'/>
<use f='linux-4.14.y/include/linux/ptrace.h' l='98' u='c' c='ptrace_unlink'/>
<def f='linux-4.14.y/kernel/ptrace.c' l='113' ll='165' type='void __ptrace_unlink(struct task_struct * child)'/>
<use f='linux-4.14.y/kernel/ptrace.c' l='508' u='c' c='__ptrace_detach'/>
<doc f='linux-4.14.y/kernel/ptrace.c' l='85'>/**
 * __ptrace_unlink - unlink ptracee and restore its execution state
 * @child: ptracee to be unlinked
 *
 * Remove @child from the ptrace list, move it back to the original parent,
 * and restore the execution state so that it conforms to the group stop
 * state.
 *
 * Unlinking can happen via two paths - explicit PTRACE_DETACH or ptracer
 * exiting.  For PTRACE_DETACH, unless the ptracee has been killed between
 * ptrace_check_attach() and here, it&apos;s guaranteed to be in TASK_TRACED.
 * If the ptracer is exiting, the ptracee can be in any state.
 *
 * After detach, the ptracee should be in a state which conforms to the
 * group stop.  If the group is stopped or in the process of stopping, the
 * ptracee should be put into TASK_STOPPED; otherwise, it should be woken
 * up from TASK_TRACED.
 *
 * If the ptracee is in TASK_TRACED and needs to be moved to TASK_STOPPED,
 * it goes through TRACED -&gt; RUNNING -&gt; STOPPED transition which is similar
 * to but in the opposite direction of what happens while attaching to a
 * stopped task.  However, in this direction, the intermediate RUNNING
 * state is not hidden even from the current ptracer and if it immediately
 * re-attaches and performs a WNOHANG wait(2), it may fail.
 *
 * CONTEXT:
 * write_lock_irq(tasklist_lock)
 */</doc>
