<dec f='linux-4.14.y/include/linux/skbuff.h' l='1035' type='struct sk_buff * skb_copy_expand(const struct sk_buff * skb, int newheadroom, int newtailroom, gfp_t priority)'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_eem.c' l='364' u='c' c='eem_wrap'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_eem.c' l='509' u='c' c='eem_unwrap'/>
<def f='linux-4.14.y/net/core/skbuff.c' l='1569' ll='1607' type='struct sk_buff * skb_copy_expand(const struct sk_buff * skb, int newheadroom, int newtailroom, gfp_t gfp_mask)'/>
<dec f='linux-4.14.y/net/core/skbuff.c' l='1608' type='struct sk_buff * skb_copy_expand(const struct sk_buff * , int , int , gfp_t )'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1608' c='skb_copy_expand'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1608' u='a'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1608' u='a'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='4113' u='c' c='skb_cow_data'/>
<doc f='linux-4.14.y/net/core/skbuff.c' l='1551'>/**
 *	skb_copy_expand	-	copy and expand sk_buff
 *	@skb: buffer to copy
 *	@newheadroom: new free bytes at head
 *	@newtailroom: new free bytes at tail
 *	@gfp_mask: allocation priority
 *
 *	Make a copy of both an &amp;sk_buff and its data and while doing so
 *	allocate additional space.
 *
 *	This is used when the caller wishes to modify the data and needs a
 *	private copy of the data to alter as well as more space for new fields.
 *	Returns %NULL on failure or the pointer to the buffer
 *	on success. The returned buffer has a reference count of 1.
 *
 *	You must pass %GFP_ATOMIC as the allocation priority if this function
 *	is called from an interrupt.
 */</doc>
<use f='linux-4.14.y/net/netfilter/nfnetlink_queue.c' l='834' u='c' c='nfqnl_mangle'/>
