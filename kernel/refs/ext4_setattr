<dec f='linux-4.18.y/fs/ext4/ext4.h' l='2450' type='int ext4_setattr(struct dentry * , struct iattr * )'/>
<use f='linux-4.18.y/fs/ext4/file.c' l='517'/>
<use f='linux-4.18.y/fs/ext4/file.c' l='517'/>
<def f='linux-4.18.y/fs/ext4/inode.c' l='5426' ll='5594' type='int ext4_setattr(struct dentry * dentry, struct iattr * attr)'/>
<doc f='linux-4.18.y/fs/ext4/inode.c' l='5402'>/*
 * ext4_setattr()
 *
 * Called from notify_change.
 *
 * We want to trap VFS attempts to truncate the file as soon as
 * possible.  In particular, we want to make sure that when the VFS
 * shrinks i_size, we put the inode on the orphan list and modify
 * i_disksize immediately, so that during the subsequent flushing of
 * dirty pages and freeing of disk blocks, we can guarantee that any
 * commit will leave the blocks being flushed in an unused state on
 * disk.  (On recovery, the inode will get truncated and the blocks will
 * be freed, so we have a strong guarantee that no future commit will
 * leave these blocks visible to the user.)
 *
 * Another thing we have to assure is that if we are in ordered mode
 * and inode is still attached to the committing transaction, we must
 * we start writeout of all the dirty pages which are being truncated.
 * This way we are sure that all the data written in the previous
 * transaction are already on disk (truncate waits for pages under
 * writeback).
 *
 * Called with inode-&gt;i_mutex down.
 */</doc>
<use f='linux-4.18.y/fs/ext4/namei.c' l='3846'/>
<use f='linux-4.18.y/fs/ext4/namei.c' l='3846'/>
<use f='linux-4.18.y/fs/ext4/namei.c' l='3855'/>
<use f='linux-4.18.y/fs/ext4/namei.c' l='3855'/>
<use f='linux-4.18.y/fs/ext4/symlink.c' l='57'/>
<use f='linux-4.18.y/fs/ext4/symlink.c' l='57'/>
<use f='linux-4.18.y/fs/ext4/symlink.c' l='64'/>
<use f='linux-4.18.y/fs/ext4/symlink.c' l='64'/>
<use f='linux-4.18.y/fs/ext4/symlink.c' l='71'/>
<use f='linux-4.18.y/fs/ext4/symlink.c' l='71'/>
