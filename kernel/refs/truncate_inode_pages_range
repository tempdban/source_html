<dec f='linux-4.18.y/include/linux/mm.h' l='2362' type='void truncate_inode_pages_range(struct address_space * , loff_t lstart, loff_t lend)'/>
<use f='linux-4.18.y/block/ioctl.c' l='228' u='c' c='blk_ioctl_discard'/>
<use f='linux-4.18.y/block/ioctl.c' l='261' u='c' c='blk_ioctl_zeroout'/>
<use f='linux-4.18.y/fs/block_dev.c' l='2007' u='c' c='blkdev_fallocate'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='955' u='c' c='punch_hole'/>
<use f='linux-4.18.y/fs/f2fs/recovery.c' l='675' u='c' c='f2fs_recover_fsync_data'/>
<def f='linux-4.18.y/mm/truncate.c' l='293' ll='461' type='void truncate_inode_pages_range(struct address_space * mapping, loff_t lstart, loff_t lend)'/>
<dec f='linux-4.18.y/mm/truncate.c' l='462' type='void truncate_inode_pages_range(struct address_space * , loff_t , loff_t )'/>
<use f='linux-4.18.y/mm/truncate.c' l='462' c='truncate_inode_pages_range'/>
<use f='linux-4.18.y/mm/truncate.c' l='462' u='a'/>
<use f='linux-4.18.y/mm/truncate.c' l='462' u='a'/>
<use f='linux-4.18.y/mm/truncate.c' l='478' u='c' c='truncate_inode_pages'/>
<use f='linux-4.18.y/mm/truncate.c' l='915' u='c' c='truncate_pagecache_range'/>
<doc f='linux-4.18.y/mm/truncate.c' l='269'>/**
 * truncate_inode_pages_range - truncate range of pages specified by start &amp; end byte offsets
 * @mapping: mapping to truncate
 * @lstart: offset from which to truncate
 * @lend: offset to which to truncate (inclusive)
 *
 * Truncate the page cache, removing the pages that are between
 * specified offsets (and zeroing out partial pages
 * if lstart or lend + 1 is not page aligned).
 *
 * Truncate takes two passes - the first pass is nonblocking.  It will not
 * block on page locks and it will not block on writeback.  The second pass
 * will wait.  This is to prevent as much IO as possible in the affected region.
 * The first pass will remove most pages, so the search cost of the second pass
 * is low.
 *
 * We pass down the cache-hot hint to the page freeing code.  Even if the
 * mapping is large, it is probably the case that the final pages are the most
 * recently touched, and freeing happens in ascending file offset order.
 *
 * Note that since -&gt;invalidatepage() accepts range to invalidate
 * truncate_inode_pages_range is able to handle cases where lend + 1 is not
 * page aligned properly.
 */</doc>
