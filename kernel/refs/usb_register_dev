<dec f='linux-4.18.y/include/linux/usb.h' l='1294' type='int usb_register_dev(struct usb_interface * intf, struct usb_class_driver * class_driver)'/>
<def f='linux-4.18.y/drivers/usb/core/file.c' l='156' ll='213' type='int usb_register_dev(struct usb_interface * intf, struct usb_class_driver * class_driver)'/>
<dec f='linux-4.18.y/drivers/usb/core/file.c' l='214' type='int usb_register_dev(struct usb_interface * , struct usb_class_driver * )'/>
<use f='linux-4.18.y/drivers/usb/core/file.c' l='214' c='usb_register_dev'/>
<use f='linux-4.18.y/drivers/usb/core/file.c' l='214' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/file.c' l='214' u='a'/>
<doc f='linux-4.18.y/drivers/usb/core/file.c' l='137'>/**
 * usb_register_dev - register a USB device, and ask for a minor number
 * @intf: pointer to the usb_interface that is being registered
 * @class_driver: pointer to the usb_class_driver for this device
 *
 * This should be called by all USB drivers that use the USB major number.
 * If CONFIG_USB_DYNAMIC_MINORS is enabled, the minor number will be
 * dynamically allocated out of the list of available ones.  If it is not
 * enabled, the minor number will be based on the next available free minor,
 * starting at the class_driver-&gt;minor_base.
 *
 * This function also creates a usb class device in the sysfs tree.
 *
 * usb_deregister_dev() must be called when the driver is done with
 * the minor numbers given out by this function.
 *
 * Return: -EINVAL if something bad happens with trying to register a
 * device, and 0 on success.
 */</doc>
