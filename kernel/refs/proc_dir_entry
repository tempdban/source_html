<def f='linux-4.18.y/fs/proc/internal.h' l='34' ll='66'/>
<size>168</size>
<doc f='linux-4.18.y/fs/proc/internal.h' l='24'>/*
 * This is not completely implemented yet. The idea is to
 * create an in-memory tree (like the actual /proc filesystem
 * tree) of these proc_dir_entries, so that we can dynamically
 * add new files to /proc.
 *
 * parent/subdir are used for the directory structure (every /proc file has a
 * parent, but &quot;subdir&quot; is empty for all non-directory entries).
 * subdir_node is used to build the rb tree &quot;subdir&quot; of the parent.
 */</doc>
<mbr r='proc_dir_entry::in_use' o='0' t='atomic_t'/>
<mbr r='proc_dir_entry::refcnt' o='32' t='refcount_t'/>
<mbr r='proc_dir_entry::pde_openers' o='64' t='struct list_head'/>
<mbr r='proc_dir_entry::pde_unload_lock' o='192' t='spinlock_t'/>
<mbr r='proc_dir_entry::pde_unload_completion' o='256' t='struct completion *'/>
<mbr r='proc_dir_entry::proc_iops' o='320' t='const struct inode_operations *'/>
<mbr r='proc_dir_entry::proc_fops' o='384' t='const struct file_operations *'/>
<mbr r='proc_dir_entry::write' o='512' t='proc_write_t'/>
<mbr r='proc_dir_entry::data' o='576' t='void *'/>
<mbr r='proc_dir_entry::state_size' o='640' t='unsigned int'/>
<mbr r='proc_dir_entry::low_ino' o='672' t='unsigned int'/>
<mbr r='proc_dir_entry::nlink' o='704' t='nlink_t'/>
<mbr r='proc_dir_entry::uid' o='736' t='kuid_t'/>
<mbr r='proc_dir_entry::gid' o='768' t='kgid_t'/>
<mbr r='proc_dir_entry::size' o='832' t='loff_t'/>
<mbr r='proc_dir_entry::parent' o='896' t='struct proc_dir_entry *'/>
<mbr r='proc_dir_entry::subdir' o='960' t='struct rb_root'/>
<mbr r='proc_dir_entry::subdir_node' o='1024' t='struct rb_node'/>
<mbr r='proc_dir_entry::name' o='1216' t='char *'/>
<mbr r='proc_dir_entry::mode' o='1280' t='umode_t'/>
<mbr r='proc_dir_entry::namelen' o='1296' t='u8'/>
<mbr r='proc_dir_entry::inline_name' o='1304' t='char []'/>
