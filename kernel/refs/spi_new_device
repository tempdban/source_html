<dec f='linux-4.18.y/include/linux/spi/spi.h' l='1299' type='struct spi_device * spi_new_device(struct spi_controller * , struct spi_board_info * )'/>
<def f='linux-4.18.y/drivers/spi/spi.c' l='583' ll='633' type='struct spi_device * spi_new_device(struct spi_controller * ctlr, struct spi_board_info * chip)'/>
<dec f='linux-4.18.y/drivers/spi/spi.c' l='634' type='struct spi_device * spi_new_device(struct spi_controller * , struct spi_board_info * )'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='634' c='spi_new_device'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='634' u='a'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='634' u='a'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='666' u='c' c='spi_match_controller_to_boardinfo'/>
<doc f='linux-4.18.y/drivers/spi/spi.c' l='569'>/**
 * spi_new_device - instantiate one new SPI device
 * @ctlr: Controller to which device is connected
 * @chip: Describes the SPI device
 * Context: can sleep
 *
 * On typical mainboards, this is purely internal; and it&apos;s not needed
 * after board init creates the hard-wired devices.  Some development
 * platforms may not be able to use spi_register_board_info though, and
 * this is exported so that for example a USB or parport based adapter
 * driver could add devices (which it would learn about out-of-band).
 *
 * Return: the new device, or NULL.
 */</doc>
