<dec f='linux-4.18.y/include/net/udp.h' l='288' type='__poll_t udp_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<use f='linux-4.18.y/net/ipv4/af_inet.c' l='1024'/>
<use f='linux-4.18.y/net/ipv4/af_inet.c' l='1024'/>
<def f='linux-4.18.y/net/ipv4/udp.c' l='2606' ll='2621' type='__poll_t udp_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<dec f='linux-4.18.y/net/ipv4/udp.c' l='2622' type='__poll_t udp_poll(struct file * , struct socket * , poll_table * )'/>
<use f='linux-4.18.y/net/ipv4/udp.c' l='2622' c='udp_poll'/>
<use f='linux-4.18.y/net/ipv4/udp.c' l='2622' u='a'/>
<use f='linux-4.18.y/net/ipv4/udp.c' l='2622' u='a'/>
<doc f='linux-4.18.y/net/ipv4/udp.c' l='2593'>/**
 * 	udp_poll - wait for a UDP event.
 *	@file - file struct
 *	@sock - socket
 *	@wait - poll table
 *
 *	This is same as datagram poll, except for the special case of
 *	blocking sockets. If application is using a blocking fd
 *	and a packet with checksum error is in the queue;
 *	then it could get return from select indicating data available
 *	but then block when reading it. Add special case code
 *	to work around these arguably broken applications.
 */</doc>
