<dec f='linux-4.18.y/include/linux/blkdev.h' l='995' type='void blk_stop_queue(struct request_queue * q)'/>
<def f='linux-4.18.y/block/blk-core.c' l='377' ll='384' type='void blk_stop_queue(struct request_queue * q)'/>
<dec f='linux-4.18.y/block/blk-core.c' l='385' type='void blk_stop_queue(struct request_queue * )'/>
<use f='linux-4.18.y/block/blk-core.c' l='385' c='blk_stop_queue'/>
<use f='linux-4.18.y/block/blk-core.c' l='385' u='a'/>
<use f='linux-4.18.y/block/blk-core.c' l='385' u='a'/>
<doc f='linux-4.18.y/block/blk-core.c' l='363'>/**
 * blk_stop_queue - stop a queue
 * @q:    The &amp;struct request_queue in question
 *
 * Description:
 *   The Linux block layer assumes that a block driver will consume all
 *   entries on the request queue when the request_fn strategy is called.
 *   Often this will not happen, because of hardware limitations (queue
 *   depth settings). If a device driver gets a &apos;queue full&apos; response,
 *   or if it simply chooses not to queue more I/O at one point, it can
 *   call this function to prevent the request_fn from being called until
 *   the driver has signalled it&apos;s ready to go again. This happens by calling
 *   blk_start_queue() to restart queue operations.
 **/</doc>
<use f='linux-4.18.y/drivers/md/dm-rq.c' l='92' u='c' c='dm_old_stop_queue'/>
<use f='linux-4.18.y/drivers/scsi/scsi_lib.c' l='3111' u='c' c='scsi_internal_device_block_nowait'/>
