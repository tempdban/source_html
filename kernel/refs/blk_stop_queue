<dec f='linux-4.14.y/include/linux/blkdev.h' l='988' type='void blk_stop_queue(struct request_queue * q)'/>
<def f='linux-4.14.y/block/blk-core.c' l='305' ll='312' type='void blk_stop_queue(struct request_queue * q)'/>
<dec f='linux-4.14.y/block/blk-core.c' l='313' type='void blk_stop_queue(struct request_queue * )'/>
<use f='linux-4.14.y/block/blk-core.c' l='313' c='blk_stop_queue'/>
<use f='linux-4.14.y/block/blk-core.c' l='313' u='a'/>
<use f='linux-4.14.y/block/blk-core.c' l='313' u='a'/>
<doc f='linux-4.14.y/block/blk-core.c' l='291'>/**
 * blk_stop_queue - stop a queue
 * @q:    The &amp;struct request_queue in question
 *
 * Description:
 *   The Linux block layer assumes that a block driver will consume all
 *   entries on the request queue when the request_fn strategy is called.
 *   Often this will not happen, because of hardware limitations (queue
 *   depth settings). If a device driver gets a &apos;queue full&apos; response,
 *   or if it simply chooses not to queue more I/O at one point, it can
 *   call this function to prevent the request_fn from being called until
 *   the driver has signalled it&apos;s ready to go again. This happens by calling
 *   blk_start_queue() to restart queue operations.
 **/</doc>
<use f='linux-4.14.y/drivers/md/dm-rq.c' l='92' u='c' c='dm_old_stop_queue'/>
<use f='linux-4.14.y/drivers/scsi/scsi_lib.c' l='3058' u='c' c='scsi_internal_device_block_nowait'/>
