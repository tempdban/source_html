<dec f='linux-4.18.y/include/linux/tty.h' l='555' type='struct tty_struct * tty_init_dev(struct tty_driver * driver, int idx)'/>
<use f='linux-4.18.y/drivers/tty/pty.c' l='835' u='c' c='ptmx_open'/>
<def f='linux-4.18.y/drivers/tty/tty_io.c' l='1310' ll='1377' type='struct tty_struct * tty_init_dev(struct tty_driver * driver, int idx)'/>
<use f='linux-4.18.y/drivers/tty/tty_io.c' l='1896' u='c' c='tty_kopen'/>
<use f='linux-4.18.y/drivers/tty/tty_io.c' l='1968' u='c' c='tty_open_by_driver'/>
<doc f='linux-4.18.y/drivers/tty/tty_io.c' l='1286'>/**
 *	tty_init_dev		-	initialise a tty device
 *	@driver: tty driver we are opening a device on
 *	@idx: device index
 *	@ret_tty: returned tty structure
 *
 *	Prepare a tty device. This may not be a &quot;new&quot; clean device but
 *	could also be an active device. The pty drivers require special
 *	handling because of this.
 *
 *	Locking:
 *		The function is called under the tty_mutex, which
 *	protects us from the tty struct or driver itself going away.
 *
 *	On exit the tty device has the line discipline attached and
 *	a reference count of 1. If a pair was created for pty/tty use
 *	and the other was a pty master then it too has a reference count of 1.
 *
 * WSH 06/09/97: Rewritten to remove races and properly clean up after a
 * failed open.  The new code protects the open with a mutex, so it&apos;s
 * really quite straightforward.  The mutex locking can probably be
 * relaxed for the (most common) case of reopening a tty.
 */</doc>
