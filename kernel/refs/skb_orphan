<def f='linux-4.18.y/include/linux/skbuff.h' l='2530' ll='2539' type='void skb_orphan(struct sk_buff * skb)'/>
<doc f='linux-4.18.y/include/linux/skbuff.h' l='2522'>/**
 *	skb_orphan - orphan a buffer
 *	@skb: buffer to orphan
 *
 *	If a buffer currently has an owner then we call the owner&apos;s
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */</doc>
<use f='linux-4.18.y/include/net/sock.h' l='2036' u='c' c='skb_set_owner_r'/>
<use f='linux-4.18.y/drivers/net/loopback.c' l='78' u='c' c='loopback_xmit'/>
<use f='linux-4.18.y/drivers/net/tun.c' l='1115' u='c' c='tun_net_xmit'/>
<use f='linux-4.18.y/drivers/net/virtio_net.c' l='1487' u='c' c='start_xmit'/>
<use f='linux-4.18.y/net/bridge/br_netfilter_hooks.c' l='461' u='c' c='setup_pre_routing'/>
<use f='linux-4.18.y/net/core/datagram.c' l='345' u='c' c='__skb_free_datagram_locked'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='4204' u='c' c='sock_queue_err_skb'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='4912' u='c' c='skb_scrub_packet'/>
<use f='linux-4.18.y/net/core/sock.c' l='1847' u='c' c='skb_set_owner_w'/>
<use f='linux-4.18.y/net/core/sock.c' l='1890' u='c' c='skb_orphan_partial'/>
<use f='linux-4.18.y/net/ipv4/ip_fragment.c' l='614' u='c' c='ip_defrag'/>
<use f='linux-4.18.y/net/ipv4/ip_input.c' l='490' u='c' c='ip_rcv'/>
<use f='linux-4.18.y/net/ipv4/tcp_output.c' l='1094' u='c' c='__tcp_transmit_skb'/>
<use f='linux-4.18.y/include/net/sctp/sctp.h' l='417' u='c' c='sctp_skb_set_owner_r'/>
<use f='linux-4.18.y/net/netfilter/xt_TPROXY.c' l='43' u='c' c='nf_tproxy_assign_sock'/>
<use f='linux-4.18.y/net/netlink/af_netlink.c' l='1449' u='c' c='do_one_broadcast'/>
