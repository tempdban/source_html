<def f='linux-4.14.y/include/linux/skbuff.h' l='2530' ll='2539' type='void skb_orphan(struct sk_buff * skb)'/>
<doc f='linux-4.14.y/include/linux/skbuff.h' l='2522'>/**
 *	skb_orphan - orphan a buffer
 *	@skb: buffer to orphan
 *
 *	If a buffer currently has an owner then we call the owner&apos;s
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */</doc>
<use f='linux-4.14.y/include/net/sock.h' l='2020' u='c' c='skb_set_owner_r'/>
<use f='linux-4.14.y/drivers/net/loopback.c' l='78' u='c' c='loopback_xmit'/>
<use f='linux-4.14.y/drivers/net/tun.c' l='922' u='c' c='tun_net_xmit'/>
<use f='linux-4.14.y/drivers/net/virtio_net.c' l='1300' u='c' c='start_xmit'/>
<use f='linux-4.14.y/net/bridge/br_netfilter_hooks.c' l='459' u='c' c='setup_pre_routing'/>
<use f='linux-4.14.y/net/core/datagram.c' l='347' u='c' c='__skb_free_datagram_locked'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='4165' u='c' c='sock_queue_err_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='4870' u='c' c='skb_scrub_packet'/>
<use f='linux-4.14.y/net/core/sock.c' l='1827' u='c' c='skb_set_owner_w'/>
<use f='linux-4.14.y/net/core/sock.c' l='1870' u='c' c='skb_orphan_partial'/>
<use f='linux-4.14.y/net/ipv4/ip_fragment.c' l='672' u='c' c='ip_defrag'/>
<use f='linux-4.14.y/net/ipv4/ip_input.c' l='491' u='c' c='ip_rcv'/>
<use f='linux-4.14.y/net/ipv4/tcp_output.c' l='1052' u='c' c='__tcp_transmit_skb'/>
<use f='linux-4.14.y/include/net/sctp/sctp.h' l='419' u='c' c='sctp_skb_set_owner_r'/>
<use f='linux-4.14.y/net/netfilter/xt_TPROXY.c' l='298' u='c' c='nf_tproxy_assign_sock'/>
<use f='linux-4.14.y/net/netlink/af_netlink.c' l='1411' u='c' c='do_one_broadcast'/>
