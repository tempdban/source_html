<dec f='linux-4.14.y/include/drm/drm_plane_helper.h' l='58' type='int drm_primary_helper_update(struct drm_plane * plane, struct drm_crtc * crtc, struct drm_framebuffer * fb, int crtc_x, int crtc_y, unsigned int crtc_w, unsigned int crtc_h, uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h, struct drm_modeset_acquire_ctx * ctx)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='302' ll='378' type='int drm_primary_helper_update(struct drm_plane * plane, struct drm_crtc * crtc, struct drm_framebuffer * fb, int crtc_x, int crtc_y, unsigned int crtc_w, unsigned int crtc_h, uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h, struct drm_modeset_acquire_ctx * ctx)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='379' type='int drm_primary_helper_update(struct drm_plane * , struct drm_crtc * , struct drm_framebuffer * , int , int , unsigned int , unsigned int , uint32_t , uint32_t , uint32_t , uint32_t , struct drm_modeset_acquire_ctx * )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='379' c='drm_primary_helper_update'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='379' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='379' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='425'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='425'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_plane_helper.c' l='265'>/**
 * drm_primary_helper_update() - Helper for primary plane update
 * @plane: plane object to update
 * @crtc: owning CRTC of owning plane
 * @fb: framebuffer to flip onto plane
 * @crtc_x: x offset of primary plane on crtc
 * @crtc_y: y offset of primary plane on crtc
 * @crtc_w: width of primary plane rectangle on crtc
 * @crtc_h: height of primary plane rectangle on crtc
 * @src_x: x offset of @fb for panning
 * @src_y: y offset of @fb for panning
 * @src_w: width of source rectangle in @fb
 * @src_h: height of source rectangle in @fb
 * @ctx: lock acquire context, not used here
 *
 * Provides a default plane update handler for primary planes.  This is handler
 * is called in response to a userspace SetPlane operation on the plane with a
 * non-NULL framebuffer.  We call the driver&apos;s modeset handler to update the
 * framebuffer.
 *
 * SetPlane() on a primary plane of a disabled CRTC is not supported, and will
 * return an error.
 *
 * Note that we make some assumptions about hardware limitations that may not be
 * true for all hardware --
 *
 * 1. Primary plane cannot be repositioned.
 * 2. Primary plane cannot be scaled.
 * 3. Primary plane must cover the entire CRTC.
 * 4. Subpixel positioning is not supported.
 *
 * Drivers for hardware that don&apos;t have these restrictions can provide their
 * own implementation rather than using this helper.
 *
 * RETURNS:
 * Zero on success, error code on failure
 */</doc>
