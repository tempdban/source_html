<dec f='linux-4.18.y/drivers/tty/serial/8250/8250.h' l='139' type='int serial8250_em485_init(struct uart_8250_port * p)'/>
<def f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='621' ll='641' type='int serial8250_em485_init(struct uart_8250_port * p)'/>
<dec f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='642' type='int serial8250_em485_init(struct uart_8250_port * )'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='642' c='serial8250_em485_init'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='642' u='a'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='642' u='a'/>
<doc f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='601'>/**
 *	serial8250_em485_init() - put uart_8250_port into rs485 emulating
 *	@p:	uart_8250_port port instance
 *
 *	The function is used to start rs485 software emulating on the
 *	&amp;struct uart_8250_port* @p. Namely, RTS is switched before/after
 *	transmission. The function is idempotent, so it is safe to call it
 *	multiple times.
 *
 *	The caller MUST enable interrupt on empty shift register before
 *	calling serial8250_em485_init(). This interrupt is not a part of
 *	8250 standard, but implementation defined.
 *
 *	The function is supposed to be called from .rs485_config callback
 *	or from any other callback protected with p-&gt;port.lock spinlock.
 *
 *	See also serial8250_em485_destroy()
 *
 *	Return 0 - success, -errno - otherwise
 */</doc>
