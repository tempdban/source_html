<dec f='linux-4.18.y/include/linux/key.h' l='283' type='struct key * request_key_async(struct key_type * type, const char * description, const void * callout_info, size_t callout_len)'/>
<def f='linux-4.18.y/security/keys/request_key.c' l='718' ll='726' type='struct key * request_key_async(struct key_type * type, const char * description, const void * callout_info, size_t callout_len)'/>
<dec f='linux-4.18.y/security/keys/request_key.c' l='727' type='struct key * request_key_async(struct key_type * , const char * , const void * , size_t )'/>
<use f='linux-4.18.y/security/keys/request_key.c' l='727' c='request_key_async'/>
<use f='linux-4.18.y/security/keys/request_key.c' l='727' u='a'/>
<use f='linux-4.18.y/security/keys/request_key.c' l='727' u='a'/>
<doc f='linux-4.18.y/security/keys/request_key.c' l='704'>/*
 * request_key_async - Request a key (allow async construction)
 * @type: Type of key.
 * @description: The searchable description of the key.
 * @callout_info: The data to pass to the instantiation upcall (or NULL).
 * @callout_len: The length of callout_info.
 *
 * As for request_key_and_link() except that it does not add the returned key
 * to a keyring if found, new keys are always allocated in the user&apos;s quota and
 * no auxiliary data can be passed.
 *
 * The caller should call wait_for_key_construction() to wait for the
 * completion of the returned key if it is still undergoing construction.
 */</doc>
