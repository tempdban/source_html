<dec f='linux-4.14.y/include/linux/pagemap.h' l='618' type='int replace_page_cache_page(struct page * old, struct page * new, gfp_t gfp_mask)'/>
<def f='linux-4.14.y/mm/filemap.c' l='683' ll='725' type='int replace_page_cache_page(struct page * old, struct page * new, gfp_t gfp_mask)'/>
<dec f='linux-4.14.y/mm/filemap.c' l='726' type='int replace_page_cache_page(struct page * , struct page * , gfp_t )'/>
<use f='linux-4.14.y/mm/filemap.c' l='726' c='replace_page_cache_page'/>
<use f='linux-4.14.y/mm/filemap.c' l='726' u='a'/>
<use f='linux-4.14.y/mm/filemap.c' l='726' u='a'/>
<doc f='linux-4.14.y/mm/filemap.c' l='668'>/**
 * replace_page_cache_page - replace a pagecache page with a new one
 * @old:	page to be replaced
 * @new:	page to replace with
 * @gfp_mask:	allocation mode
 *
 * This function replaces a page in the pagecache with a new one.  On
 * success it acquires the pagecache reference for the new page and
 * drops it for the old page.  Both the old and new pages must be
 * locked.  This function does not add the new page to the LRU, the
 * caller must do that.
 *
 * The remove + add is atomic.  The only way this function can fail is
 * memory allocation failure.
 */</doc>
<dec f='linux-4.14.y/include/linux/pagemap.h' l='618' type='int replace_page_cache_page(struct page * old, struct page * new, gfp_t gfp_mask)'/>
<use f='linux-4.14.y/fs/fuse/dev.c' l='872' u='c' c='fuse_try_move_page'/>
<def f='linux-4.14.y/mm/filemap.c' l='683' ll='725' type='int replace_page_cache_page(struct page * old, struct page * new, gfp_t gfp_mask)'/>
<dec f='linux-4.14.y/mm/filemap.c' l='726' type='int replace_page_cache_page(struct page * , struct page * , gfp_t )'/>
<use f='linux-4.14.y/mm/filemap.c' l='726' c='replace_page_cache_page'/>
<use f='linux-4.14.y/mm/filemap.c' l='726' u='a'/>
<use f='linux-4.14.y/mm/filemap.c' l='726' u='a'/>
<doc f='linux-4.14.y/mm/filemap.c' l='668'>/**
 * replace_page_cache_page - replace a pagecache page with a new one
 * @old:	page to be replaced
 * @new:	page to replace with
 * @gfp_mask:	allocation mode
 *
 * This function replaces a page in the pagecache with a new one.  On
 * success it acquires the pagecache reference for the new page and
 * drops it for the old page.  Both the old and new pages must be
 * locked.  This function does not add the new page to the LRU, the
 * caller must do that.
 *
 * The remove + add is atomic.  The only way this function can fail is
 * memory allocation failure.
 */</doc>
