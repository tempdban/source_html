<dec f='linux-4.14.y/include/linux/mpage.h' l='20' type='int mpage_writepages(struct address_space * mapping, struct writeback_control * wbc, get_block_t * get_block)'/>
<def f='linux-4.14.y/fs/mpage.c' l='697' ll='725' type='int mpage_writepages(struct address_space * mapping, struct writeback_control * wbc, get_block_t * get_block)'/>
<dec f='linux-4.14.y/fs/mpage.c' l='726' type='int mpage_writepages(struct address_space * , struct writeback_control * , get_block_t * )'/>
<use f='linux-4.14.y/fs/mpage.c' l='726' c='mpage_writepages'/>
<use f='linux-4.14.y/fs/mpage.c' l='726' u='a'/>
<use f='linux-4.14.y/fs/mpage.c' l='726' u='a'/>
<doc f='linux-4.14.y/fs/mpage.c' l='678'>/**
 * mpage_writepages - walk the list of dirty pages of the given address space &amp; writepage() all of them
 * @mapping: address space structure to write
 * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write
 * @get_block: the filesystem&apos;s block mapper function.
 *             If this is NULL then use a_ops-&gt;writepage.  Otherwise, go
 *             direct-to-BIO.
 *
 * This is a library function, which implements the writepages()
 * address_space_operation.
 *
 * If a page is already under I/O, generic_writepages() skips it, even
 * if it&apos;s dirty.  This is desirable behaviour for memory-cleaning writeback,
 * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
 * and msync() need to guarantee that all the data which was dirty at the time
 * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
 * WB_SYNC_ALL then we were called for data integrity and we must wait for
 * existing IO to complete.
 */</doc>
<use f='linux-4.14.y/fs/udf/inode.c' l='183' u='c' c='udf_writepages'/>
<dec f='linux-4.14.y/include/linux/mpage.h' l='20' type='int mpage_writepages(struct address_space * mapping, struct writeback_control * wbc, get_block_t * get_block)'/>
<use f='linux-4.14.y/fs/fat/inode.c' l='191' u='c' c='fat_writepages'/>
<def f='linux-4.14.y/fs/mpage.c' l='697' ll='725' type='int mpage_writepages(struct address_space * mapping, struct writeback_control * wbc, get_block_t * get_block)'/>
<dec f='linux-4.14.y/fs/mpage.c' l='726' type='int mpage_writepages(struct address_space * , struct writeback_control * , get_block_t * )'/>
<use f='linux-4.14.y/fs/mpage.c' l='726' c='mpage_writepages'/>
<use f='linux-4.14.y/fs/mpage.c' l='726' u='a'/>
<use f='linux-4.14.y/fs/mpage.c' l='726' u='a'/>
<doc f='linux-4.14.y/fs/mpage.c' l='678'>/**
 * mpage_writepages - walk the list of dirty pages of the given address space &amp; writepage() all of them
 * @mapping: address space structure to write
 * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write
 * @get_block: the filesystem&apos;s block mapper function.
 *             If this is NULL then use a_ops-&gt;writepage.  Otherwise, go
 *             direct-to-BIO.
 *
 * This is a library function, which implements the writepages()
 * address_space_operation.
 *
 * If a page is already under I/O, generic_writepages() skips it, even
 * if it&apos;s dirty.  This is desirable behaviour for memory-cleaning writeback,
 * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()
 * and msync() need to guarantee that all the data which was dirty at the time
 * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
 * WB_SYNC_ALL then we were called for data integrity and we must wait for
 * existing IO to complete.
 */</doc>
<use f='linux-4.14.y/fs/udf/inode.c' l='183' u='c' c='udf_writepages'/>
