<def f='linux-4.14.y/include/drm/drm_connector.h' l='720' ll='908'/>
<size>1024</size>
<doc f='linux-4.14.y/include/drm/drm_connector.h' l='673'>/**
 * struct drm_connector - central DRM connector control structure
 * @dev: parent DRM device
 * @kdev: kernel device for sysfs attributes
 * @attr: sysfs attributes
 * @head: list management
 * @base: base KMS object
 * @name: human readable name, can be overwritten by the driver
 * @connector_type: one of the DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h
 * @connector_type_id: index into connector type enum
 * @interlace_allowed: can this connector handle interlaced modes?
 * @doublescan_allowed: can this connector handle doublescan?
 * @stereo_allowed: can this connector handle stereo modes?
 * @funcs: connector control functions
 * @edid_blob_ptr: DRM property containing EDID if present
 * @properties: property tracking for this connector
 * @dpms: current dpms state
 * @helper_private: mid-layer private data
 * @cmdline_mode: mode line parsed from the kernel cmdline for this connector
 * @force: a DRM_FORCE_&lt;foo&gt; state for forced mode sets
 * @override_edid: has the EDID been overwritten through debugfs for testing?
 * @encoder_ids: valid encoders for this connector
 * @encoder: encoder driving this connector, if any
 * @eld: EDID-like data, if present
 * @latency_present: AV delay info from ELD, if found
 * @video_latency: video latency info from ELD, if found
 * @audio_latency: audio latency info from ELD, if found
 * @null_edid_counter: track sinks that give us all zeros for the EDID
 * @bad_edid_counter: track sinks that give us an EDID with invalid checksum
 * @edid_corrupt: indicates whether the last read EDID was corrupt
 * @debugfs_entry: debugfs directory for this connector
 * @has_tile: is this connector connected to a tiled monitor
 * @tile_group: tile group for the connected monitor
 * @tile_is_single_monitor: whether the tile is one monitor housing
 * @num_h_tile: number of horizontal tiles in the tile group
 * @num_v_tile: number of vertical tiles in the tile group
 * @tile_h_loc: horizontal location of this tile
 * @tile_v_loc: vertical location of this tile
 * @tile_h_size: horizontal size of this tile.
 * @tile_v_size: vertical size of this tile.
 * @scaling_mode_property:  Optional atomic property to control the upscaling.
 *
 * Each connector may be connected to one or more CRTCs, or may be clonable by
 * another connector if they can share a CRTC.  Each connector also has a specific
 * position in the broader display (referred to as a &apos;screen&apos; though it could
 * span multiple monitors).
 */</doc>
<mbr r='drm_connector::dev' o='0' t='struct drm_device *'/>
<mbr r='drm_connector::kdev' o='64' t='struct device *'/>
<mbr r='drm_connector::attr' o='128' t='struct device_attribute *'/>
<mbr r='drm_connector::head' o='192' t='struct list_head'/>
<mbr r='drm_connector::base' o='320' t='struct drm_mode_object'/>
<mbr r='drm_connector::name' o='576' t='char *'/>
<mbr r='drm_connector::mutex' o='640' t='struct mutex'/>
<mbr r='drm_connector::index' o='896' t='unsigned int'/>
<mbr r='drm_connector::connector_type' o='928' t='int'/>
<mbr r='drm_connector::connector_type_id' o='960' t='int'/>
<mbr r='drm_connector::interlace_allowed' o='992' t='bool'/>
<mbr r='drm_connector::doublescan_allowed' o='1000' t='bool'/>
<mbr r='drm_connector::stereo_allowed' o='1008' t='bool'/>
<mbr r='drm_connector::ycbcr_420_allowed' o='1016' t='bool'/>
<mbr r='drm_connector::registered' o='1024' t='bool'/>
<mbr r='drm_connector::modes' o='1088' t='struct list_head'/>
<mbr r='drm_connector::status' o='1216' t='enum drm_connector_status'/>
<mbr r='drm_connector::probed_modes' o='1280' t='struct list_head'/>
<mbr r='drm_connector::display_info' o='1408' t='struct drm_display_info'/>
<mbr r='drm_connector::funcs' o='2496' t='const struct drm_connector_funcs *'/>
<mbr r='drm_connector::edid_blob_ptr' o='2560' t='struct drm_property_blob *'/>
<mbr r='drm_connector::properties' o='2624' t='struct drm_object_properties'/>
<mbr r='drm_connector::scaling_mode_property' o='5760' t='struct drm_property *'/>
<mbr r='drm_connector::path_blob_ptr' o='5824' t='struct drm_property_blob *'/>
<mbr r='drm_connector::tile_blob_ptr' o='5888' t='struct drm_property_blob *'/>
<mbr r='drm_connector::polled' o='5952' t='uint8_t'/>
<mbr r='drm_connector::dpms' o='5984' t='int'/>
<mbr r='drm_connector::helper_private' o='6016' t='const struct drm_connector_helper_funcs *'/>
<mbr r='drm_connector::cmdline_mode' o='6080' t='struct drm_cmdline_mode'/>
<mbr r='drm_connector::force' o='6304' t='enum drm_connector_force'/>
<mbr r='drm_connector::override_edid' o='6336' t='bool'/>
<mbr r='drm_connector::encoder_ids' o='6368' t='uint32_t [3]'/>
<mbr r='drm_connector::encoder' o='6464' t='struct drm_encoder *'/>
<mbr r='drm_connector::eld' o='6528' t='uint8_t [128]'/>
<mbr r='drm_connector::latency_present' o='7552' t='bool [2]'/>
<mbr r='drm_connector::video_latency' o='7584' t='int [2]'/>
<mbr r='drm_connector::audio_latency' o='7648' t='int [2]'/>
<mbr r='drm_connector::null_edid_counter' o='7712' t='int'/>
<mbr r='drm_connector::bad_edid_counter' o='7744' t='unsigned int'/>
<mbr r='drm_connector::edid_corrupt' o='7776' t='bool'/>
<mbr r='drm_connector::debugfs_entry' o='7808' t='struct dentry *'/>
<mbr r='drm_connector::state' o='7872' t='struct drm_connector_state *'/>
<mbr r='drm_connector::has_tile' o='7936' t='bool'/>
<mbr r='drm_connector::tile_group' o='8000' t='struct drm_tile_group *'/>
<mbr r='drm_connector::tile_is_single_monitor' o='8064' t='bool'/>
<mbr r='drm_connector::num_h_tile' o='8072' t='uint8_t'/>
<mbr r='drm_connector::num_v_tile' o='8080' t='uint8_t'/>
<mbr r='drm_connector::tile_h_loc' o='8088' t='uint8_t'/>
<mbr r='drm_connector::tile_v_loc' o='8096' t='uint8_t'/>
<mbr r='drm_connector::tile_h_size' o='8112' t='uint16_t'/>
<mbr r='drm_connector::tile_v_size' o='8128' t='uint16_t'/>
