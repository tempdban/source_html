<def f='linux-4.18.y/security/selinux/include/avc.h' l='126' ll='141' type='int avc_audit(struct selinux_state * state, u32 ssid, u32 tsid, u16 tclass, u32 requested, struct av_decision * avd, int result, struct common_audit_data * a, int flags)'/>
<use f='linux-4.18.y/security/selinux/avc.c' l='1187' u='c' c='avc_has_perm'/>
<use f='linux-4.18.y/security/selinux/avc.c' l='1205' u='c' c='avc_has_perm_flags'/>
<doc f='linux-4.18.y/security/selinux/include/avc.h' l='106'>/**
 * avc_audit - Audit the granting or denial of permissions.
 * @ssid: source security identifier
 * @tsid: target security identifier
 * @tclass: target security class
 * @requested: requested permissions
 * @avd: access vector decisions
 * @result: result from avc_has_perm_noaudit
 * @a:  auxiliary audit data
 * @flags: VFS walk flags
 *
 * Audit the granting or denial of permissions in accordance
 * with the policy.  This function is typically called by
 * avc_has_perm() after a permission check, but can also be
 * called directly by callers who use avc_has_perm_noaudit()
 * in order to separate the permission check from the auditing.
 * For example, this separation is useful when the permission check must
 * be performed under a lock, to allow the lock to be released
 * before calling the auditing code.
 */</doc>
<use f='linux-4.18.y/security/selinux/hooks.c' l='1797' u='c' c='cred_has_capability'/>
