<dec f='linux-4.14.y/include/linux/netdevice.h' l='2404' type='void dev_add_offload(struct packet_offload * po)'/>
<def f='linux-4.14.y/net/core/dev.c' l='482' ll='493' type='void dev_add_offload(struct packet_offload * po)'/>
<dec f='linux-4.14.y/net/core/dev.c' l='494' type='void dev_add_offload(struct packet_offload * )'/>
<use f='linux-4.14.y/net/core/dev.c' l='494' c='dev_add_offload'/>
<use f='linux-4.14.y/net/core/dev.c' l='494' u='a'/>
<use f='linux-4.14.y/net/core/dev.c' l='494' u='a'/>
<doc f='linux-4.14.y/net/core/dev.c' l='470'>/**
 *	dev_add_offload - register offload handlers
 *	@po: protocol offload declaration
 *
 *	Add protocol offload handlers to the networking stack. The passed
 *	&amp;proto_offload is linked into kernel lists and may not be freed until
 *	it has been removed from the kernel lists.
 *
 *	This call does not sleep therefore it can not
 *	guarantee all CPU&apos;s that are in middle of receiving packets
 *	will see the new offload handlers (until the next received packet).
 */</doc>
<use f='linux-4.14.y/net/ethernet/eth.c' l='516' u='c' c='eth_offload_init'/>
<use f='linux-4.14.y/net/ipv4/af_inet.c' l='1806' u='c' c='ipv4_offload_init'/>
<use f='linux-4.14.y/net/ipv6/ip6_offload.c' l='382' u='c' c='ipv6_offload_init'/>
<use f='linux-4.14.y/net/mpls/mpls_gso.c' l='93' u='c' c='mpls_gso_init'/>
<use f='linux-4.14.y/net/mpls/mpls_gso.c' l='94' u='c' c='mpls_gso_init'/>
