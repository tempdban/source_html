<dec f='linux-4.18.y/include/linux/netdevice.h' l='2524' type='void dev_add_offload(struct packet_offload * po)'/>
<def f='linux-4.18.y/net/core/dev.c' l='484' ll='495' type='void dev_add_offload(struct packet_offload * po)'/>
<dec f='linux-4.18.y/net/core/dev.c' l='496' type='void dev_add_offload(struct packet_offload * )'/>
<use f='linux-4.18.y/net/core/dev.c' l='496' c='dev_add_offload'/>
<use f='linux-4.18.y/net/core/dev.c' l='496' u='a'/>
<use f='linux-4.18.y/net/core/dev.c' l='496' u='a'/>
<doc f='linux-4.18.y/net/core/dev.c' l='472'>/**
 *	dev_add_offload - register offload handlers
 *	@po: protocol offload declaration
 *
 *	Add protocol offload handlers to the networking stack. The passed
 *	&amp;proto_offload is linked into kernel lists and may not be freed until
 *	it has been removed from the kernel lists.
 *
 *	This call does not sleep therefore it can not
 *	guarantee all CPU&apos;s that are in middle of receiving packets
 *	will see the new offload handlers (until the next received packet).
 */</doc>
<use f='linux-4.18.y/net/ethernet/eth.c' l='516' u='c' c='eth_offload_init'/>
<use f='linux-4.18.y/net/ipv4/af_inet.c' l='1877' u='c' c='ipv4_offload_init'/>
<use f='linux-4.18.y/net/ipv6/ip6_offload.c' l='385' u='c' c='ipv6_offload_init'/>
<use f='linux-4.18.y/net/mpls/mpls_gso.c' l='93' u='c' c='mpls_gso_init'/>
<use f='linux-4.18.y/net/mpls/mpls_gso.c' l='94' u='c' c='mpls_gso_init'/>
<use f='linux-4.18.y/net/nsh/nsh.c' l='141' u='c' c='nsh_init_module'/>
