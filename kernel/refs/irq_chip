<def f='linux-4.14.y/include/linux/irq.h' l='434' ll='481'/>
<size>272</size>
<doc f='linux-4.14.y/include/linux/irq.h' l='387'>/**
 * struct irq_chip - hardware interrupt chip descriptor
 *
 * @parent_device:	pointer to parent device for irqchip
 * @name:		name for /proc/interrupts
 * @irq_startup:	start up the interrupt (defaults to -&gt;enable if NULL)
 * @irq_shutdown:	shut down the interrupt (defaults to -&gt;disable if NULL)
 * @irq_enable:		enable the interrupt (defaults to chip-&gt;unmask if NULL)
 * @irq_disable:	disable the interrupt
 * @irq_ack:		start of a new interrupt
 * @irq_mask:		mask an interrupt source
 * @irq_mask_ack:	ack and mask an interrupt source
 * @irq_unmask:		unmask an interrupt source
 * @irq_eoi:		end of interrupt
 * @irq_set_affinity:	Set the CPU affinity on SMP machines. If the force
 *			argument is true, it tells the driver to
 *			unconditionally apply the affinity setting. Sanity
 *			checks against the supplied affinity mask are not
 *			required. This is used for CPU hotplug where the
 *			target CPU is not yet set in the cpu_online_mask.
 * @irq_retrigger:	resend an IRQ to the CPU
 * @irq_set_type:	set the flow type (IRQ_TYPE_LEVEL/etc.) of an IRQ
 * @irq_set_wake:	enable/disable power-management wake-on of an IRQ
 * @irq_bus_lock:	function to lock access to slow bus (i2c) chips
 * @irq_bus_sync_unlock:function to sync and unlock slow bus (i2c) chips
 * @irq_cpu_online:	configure an interrupt source for a secondary CPU
 * @irq_cpu_offline:	un-configure an interrupt source for a secondary CPU
 * @irq_suspend:	function called from core code on suspend once per
 *			chip, when one or more interrupts are installed
 * @irq_resume:		function called from core code on resume once per chip,
 *			when one ore more interrupts are installed
 * @irq_pm_shutdown:	function called from core code on shutdown once per chip
 * @irq_calc_mask:	Optional function to set irq_data.mask for special cases
 * @irq_print_chip:	optional to print special chip info in show_interrupts
 * @irq_request_resources:	optional to request resources before calling
 *				any other callback related to this irq
 * @irq_release_resources:	optional to release resources acquired with
 *				irq_request_resources
 * @irq_compose_msi_msg:	optional to compose message content for MSI
 * @irq_write_msi_msg:	optional to write message content for MSI
 * @irq_get_irqchip_state:	return the internal state of an interrupt
 * @irq_set_irqchip_state:	set the internal state of a interrupt
 * @irq_set_vcpu_affinity:	optional to target a vCPU in a virtual machine
 * @ipi_send_single:	send a single IPI to destination cpus
 * @ipi_send_mask:	send an IPI to destination cpus in cpumask
 * @flags:		chip specific flags
 */</doc>
<mbr r='irq_chip::parent_device' o='0' t='struct device *'/>
<mbr r='irq_chip::name' o='64' t='const char *'/>
<mbr r='irq_chip::irq_startup' o='128' t='unsigned int (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_shutdown' o='192' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_enable' o='256' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_disable' o='320' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_ack' o='384' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_mask' o='448' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_mask_ack' o='512' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_unmask' o='576' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_eoi' o='640' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_set_affinity' o='704' t='int (*)(struct irq_data *, const struct cpumask *, bool)'/>
<mbr r='irq_chip::irq_retrigger' o='768' t='int (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_set_type' o='832' t='int (*)(struct irq_data *, unsigned int)'/>
<mbr r='irq_chip::irq_set_wake' o='896' t='int (*)(struct irq_data *, unsigned int)'/>
<mbr r='irq_chip::irq_bus_lock' o='960' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_bus_sync_unlock' o='1024' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_cpu_online' o='1088' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_cpu_offline' o='1152' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_suspend' o='1216' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_resume' o='1280' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_pm_shutdown' o='1344' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_calc_mask' o='1408' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_print_chip' o='1472' t='void (*)(struct irq_data *, struct seq_file *)'/>
<mbr r='irq_chip::irq_request_resources' o='1536' t='int (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_release_resources' o='1600' t='void (*)(struct irq_data *)'/>
<mbr r='irq_chip::irq_compose_msi_msg' o='1664' t='void (*)(struct irq_data *, struct msi_msg *)'/>
<mbr r='irq_chip::irq_write_msi_msg' o='1728' t='void (*)(struct irq_data *, struct msi_msg *)'/>
<mbr r='irq_chip::irq_get_irqchip_state' o='1792' t='int (*)(struct irq_data *, enum irqchip_irq_state, bool *)'/>
<mbr r='irq_chip::irq_set_irqchip_state' o='1856' t='int (*)(struct irq_data *, enum irqchip_irq_state, bool)'/>
<mbr r='irq_chip::irq_set_vcpu_affinity' o='1920' t='int (*)(struct irq_data *, void *)'/>
<mbr r='irq_chip::ipi_send_single' o='1984' t='void (*)(struct irq_data *, unsigned int)'/>
<mbr r='irq_chip::ipi_send_mask' o='2048' t='void (*)(struct irq_data *, const struct cpumask *)'/>
<mbr r='irq_chip::flags' o='2112' t='unsigned long'/>
