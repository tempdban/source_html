<dec f='linux-4.14.y/arch/x86/include/asm/mtrr.h' l='38' type='int mtrr_add(unsigned long base, unsigned long size, unsigned int type, bool increment)'/>
<use f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/if.c' l='247' u='c' c='mtrr_ioctl'/>
<def f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/main.c' l='453' ll='462' type='int mtrr_add(unsigned long base, unsigned long size, unsigned int type, bool increment)'/>
<use f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/main.c' l='574' u='c' c='arch_phys_wc_add'/>
<doc f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/main.c' l='418'>/**
 * mtrr_add - Add a memory type region
 * @base: Physical base address of region
 * @size: Physical size of region
 * @type: Type of MTRR desired
 * @increment: If this is true do usage counting on the region
 *
 * Memory type region registers control the caching on newer Intel and
 * non Intel processors. This function allows drivers to request an
 * MTRR is added. The details and hardware specifics of each processor&apos;s
 * implementation are hidden from the caller, but nevertheless the
 * caller should expect to need to provide a power of two size on an
 * equivalent power of two boundary.
 *
 * If the region cannot be added either because all regions are in use
 * or the CPU cannot support it a negative value is returned. On success
 * the register number for this entry is returned, but should be treated
 * as a cookie only.
 *
 * On a multiprocessor machine the changes are made to all processors.
 * This is required on x86 by the Intel processors.
 *
 * The available types are
 *
 * %MTRR_TYPE_UNCACHABLE - No caching
 *
 * %MTRR_TYPE_WRBACK - Write data back in bursts whenever
 *
 * %MTRR_TYPE_WRCOMB - Write data back soon but allow bursts
 *
 * %MTRR_TYPE_WRTHROUGH - Cache reads but not writes
 *
 * BUGS: Needs a quiet flag for the cases where drivers do not mind
 * failures and do not wish system log messages to be sent.
 */</doc>
<dec f='linux-4.14.y/arch/x86/include/asm/mtrr.h' l='38' type='int mtrr_add(unsigned long base, unsigned long size, unsigned int type, bool increment)'/>
<use f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/if.c' l='247' u='c' c='mtrr_ioctl'/>
<def f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/main.c' l='453' ll='462' type='int mtrr_add(unsigned long base, unsigned long size, unsigned int type, bool increment)'/>
<use f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/main.c' l='574' u='c' c='arch_phys_wc_add'/>
<doc f='linux-4.14.y/arch/x86/kernel/cpu/mtrr/main.c' l='418'>/**
 * mtrr_add - Add a memory type region
 * @base: Physical base address of region
 * @size: Physical size of region
 * @type: Type of MTRR desired
 * @increment: If this is true do usage counting on the region
 *
 * Memory type region registers control the caching on newer Intel and
 * non Intel processors. This function allows drivers to request an
 * MTRR is added. The details and hardware specifics of each processor&apos;s
 * implementation are hidden from the caller, but nevertheless the
 * caller should expect to need to provide a power of two size on an
 * equivalent power of two boundary.
 *
 * If the region cannot be added either because all regions are in use
 * or the CPU cannot support it a negative value is returned. On success
 * the register number for this entry is returned, but should be treated
 * as a cookie only.
 *
 * On a multiprocessor machine the changes are made to all processors.
 * This is required on x86 by the Intel processors.
 *
 * The available types are
 *
 * %MTRR_TYPE_UNCACHABLE - No caching
 *
 * %MTRR_TYPE_WRBACK - Write data back in bursts whenever
 *
 * %MTRR_TYPE_WRCOMB - Write data back soon but allow bursts
 *
 * %MTRR_TYPE_WRTHROUGH - Cache reads but not writes
 *
 * BUGS: Needs a quiet flag for the cases where drivers do not mind
 * failures and do not wish system log messages to be sent.
 */</doc>
