<dec f='linux-4.18.y/drivers/tty/serial/8250/8250.h' l='140' type='void serial8250_em485_destroy(struct uart_8250_port * p)'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_core.c' l='1082' u='c' c='serial8250_unregister_port'/>
<def f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='657' ll='667' type='void serial8250_em485_destroy(struct uart_8250_port * p)'/>
<dec f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='668' type='void serial8250_em485_destroy(struct uart_8250_port * )'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='668' c='serial8250_em485_destroy'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='668' u='a'/>
<use f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='668' u='a'/>
<doc f='linux-4.18.y/drivers/tty/serial/8250/8250_port.c' l='644'>/**
 *	serial8250_em485_destroy() - put uart_8250_port into normal state
 *	@p:	uart_8250_port port instance
 *
 *	The function is used to stop rs485 software emulating on the
 *	&amp;struct uart_8250_port* @p. The function is idempotent, so it is safe to
 *	call it multiple times.
 *
 *	The function is supposed to be called from .rs485_config callback
 *	or from any other callback protected with p-&gt;port.lock spinlock.
 *
 *	See also serial8250_em485_init()
 */</doc>
