<dec f='linux-4.14.y/include/linux/writeback.h' l='380' type='void balance_dirty_pages_ratelimited(struct address_space * mapping)'/>
<use f='linux-4.14.y/fs/buffer.c' l='2424' u='c' c='cont_expand_zero'/>
<use f='linux-4.14.y/mm/filemap.c' l='3060' u='c' c='generic_perform_write'/>
<use f='linux-4.14.y/mm/memory.c' l='2398' u='c' c='fault_dirty_shared_page'/>
<def f='linux-4.14.y/mm/page-writeback.c' l='1864' ll='1916' type='void balance_dirty_pages_ratelimited(struct address_space * mapping)'/>
<dec f='linux-4.14.y/mm/page-writeback.c' l='1917' type='void balance_dirty_pages_ratelimited(struct address_space * )'/>
<use f='linux-4.14.y/mm/page-writeback.c' l='1917' c='balance_dirty_pages_ratelimited'/>
<use f='linux-4.14.y/mm/page-writeback.c' l='1917' u='a'/>
<use f='linux-4.14.y/mm/page-writeback.c' l='1917' u='a'/>
<doc f='linux-4.14.y/mm/page-writeback.c' l='1851'>/**
 * balance_dirty_pages_ratelimited - balance dirty memory state
 * @mapping: address_space which was dirtied
 *
 * Processes which are dirtying memory should call in here once for each page
 * which was newly dirtied.  The function will periodically check the system&apos;s
 * dirty state and will initiate writeback if needed.
 *
 * On really big machines, get_writeback_state is expensive, so try to avoid
 * calling it too often (ratelimiting).  But once we&apos;re over the dirty memory
 * limit we decrease the ratelimiting by a lot, to prevent individual processes
 * from overshooting the limit by (ratelimit_pages) each.
 */</doc>
<dec f='linux-4.14.y/include/linux/writeback.h' l='380' type='void balance_dirty_pages_ratelimited(struct address_space * mapping)'/>
<use f='linux-4.14.y/fs/buffer.c' l='2424' u='c' c='cont_expand_zero'/>
<use f='linux-4.14.y/fs/ntfs/attrib.c' l='2548' u='c' c='ntfs_attr_set'/>
<use f='linux-4.14.y/fs/ntfs/attrib.c' l='2589' u='c' c='ntfs_attr_set'/>
<use f='linux-4.14.y/fs/ntfs/attrib.c' l='2606' u='c' c='ntfs_attr_set'/>
<use f='linux-4.14.y/fs/ntfs/file.c' l='279' u='c' c='ntfs_attr_extend_initialized'/>
<use f='linux-4.14.y/fs/ntfs/file.c' l='1916' u='c' c='ntfs_perform_write'/>
<use f='linux-4.14.y/mm/filemap.c' l='3060' u='c' c='generic_perform_write'/>
<use f='linux-4.14.y/mm/memory.c' l='2398' u='c' c='fault_dirty_shared_page'/>
<def f='linux-4.14.y/mm/page-writeback.c' l='1864' ll='1916' type='void balance_dirty_pages_ratelimited(struct address_space * mapping)'/>
<dec f='linux-4.14.y/mm/page-writeback.c' l='1917' type='void balance_dirty_pages_ratelimited(struct address_space * )'/>
<use f='linux-4.14.y/mm/page-writeback.c' l='1917' c='balance_dirty_pages_ratelimited'/>
<use f='linux-4.14.y/mm/page-writeback.c' l='1917' u='a'/>
<use f='linux-4.14.y/mm/page-writeback.c' l='1917' u='a'/>
<doc f='linux-4.14.y/mm/page-writeback.c' l='1851'>/**
 * balance_dirty_pages_ratelimited - balance dirty memory state
 * @mapping: address_space which was dirtied
 *
 * Processes which are dirtying memory should call in here once for each page
 * which was newly dirtied.  The function will periodically check the system&apos;s
 * dirty state and will initiate writeback if needed.
 *
 * On really big machines, get_writeback_state is expensive, so try to avoid
 * calling it too often (ratelimiting).  But once we&apos;re over the dirty memory
 * limit we decrease the ratelimiting by a lot, to prevent individual processes
 * from overshooting the limit by (ratelimit_pages) each.
 */</doc>
