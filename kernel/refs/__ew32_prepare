<dec f='linux-4.14.y/drivers/net/ethernet/intel/e1000e/e1000.h' l='599' type='s32 __ew32_prepare(struct e1000_hw * hw)'/>
<def f='linux-4.14.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='140' ll='148' type='s32 __ew32_prepare(struct e1000_hw * hw)'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='153' u='c' c='__ew32'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='628' u='c' c='e1000e_update_rdt_wa'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='645' u='c' c='e1000e_update_tdt_wa'/>
<doc f='linux-4.14.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='128'>/**
 * __ew32_prepare - prepare to write to MAC CSR register on certain parts
 * @hw: pointer to the HW structure
 *
 * When updating the MAC CSR registers, the Manageability Engine (ME) could
 * be accessing the registers at the same time.  Normally, this is handled in
 * h/w by an arbiter but on some parts there is a bug that acknowledges Host
 * accesses later than it should which could result in the register to have
 * an incorrect value.  Workaround this by checking the FWSM register which
 * has bit 24 set while ME is accessing MAC CSR registers, wait if it is set
 * and try again a number of times.
 **/</doc>
