<dec f='linux-4.18.y/drivers/net/ethernet/intel/e1000e/e1000.h' l='577' type='s32 __ew32_prepare(struct e1000_hw * hw)'/>
<def f='linux-4.18.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='122' ll='130' type='s32 __ew32_prepare(struct e1000_hw * hw)'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='135' u='c' c='__ew32'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='610' u='c' c='e1000e_update_rdt_wa'/>
<use f='linux-4.18.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='627' u='c' c='e1000e_update_tdt_wa'/>
<doc f='linux-4.18.y/drivers/net/ethernet/intel/e1000e/netdev.c' l='110'>/**
 * __ew32_prepare - prepare to write to MAC CSR register on certain parts
 * @hw: pointer to the HW structure
 *
 * When updating the MAC CSR registers, the Manageability Engine (ME) could
 * be accessing the registers at the same time.  Normally, this is handled in
 * h/w by an arbiter but on some parts there is a bug that acknowledges Host
 * accesses later than it should which could result in the register to have
 * an incorrect value.  Workaround this by checking the FWSM register which
 * has bit 24 set while ME is accessing MAC CSR registers, wait if it is set
 * and try again a number of times.
 **/</doc>
