<def f='linux-4.18.y/include/linux/usb/gadget.h' l='387' ll='422'/>
<size>608</size>
<doc f='linux-4.18.y/include/linux/usb/gadget.h' l='319'>/**
 * struct usb_gadget - represents a usb slave device
 * @work: (internal use) Workqueue to be used for sysfs_notify()
 * @udc: struct usb_udc pointer for this gadget
 * @ops: Function pointers used to access hardware-specific operations.
 * @ep0: Endpoint zero, used when reading or writing responses to
 *	driver setup() requests
 * @ep_list: List of other endpoints supported by the device.
 * @speed: Speed of current connection to USB host.
 * @max_speed: Maximal speed the UDC can handle.  UDC must support this
 *      and all slower speeds.
 * @state: the state we are now (attached, suspended, configured, etc)
 * @name: Identifies the controller hardware type.  Used in diagnostics
 *	and sometimes configuration.
 * @dev: Driver model state for this abstract device.
 * @isoch_delay: value from Set Isoch Delay request. Only valid on SS/SSP
 * @out_epnum: last used out ep number
 * @in_epnum: last used in ep number
 * @mA: last set mA value
 * @otg_caps: OTG capabilities of this gadget.
 * @sg_supported: true if we can handle scatter-gather
 * @is_otg: True if the USB device port uses a Mini-AB jack, so that the
 *	gadget driver must provide a USB OTG descriptor.
 * @is_a_peripheral: False unless is_otg, the &quot;A&quot; end of a USB cable
 *	is in the Mini-AB jack, and HNP has been used to switch roles
 *	so that the &quot;A&quot; device currently acts as A-Peripheral, not A-Host.
 * @a_hnp_support: OTG device feature flag, indicating that the A-Host
 *	supports HNP at this port.
 * @a_alt_hnp_support: OTG device feature flag, indicating that the A-Host
 *	only supports HNP on a different root port.
 * @b_hnp_enable: OTG device feature flag, indicating that the A-Host
 *	enabled HNP support.
 * @hnp_polling_support: OTG device feature flag, indicating if the OTG device
 *	in peripheral mode can support HNP polling.
 * @host_request_flag: OTG device feature flag, indicating if A-Peripheral
 *	or B-Peripheral wants to take host role.
 * @quirk_ep_out_aligned_size: epout requires buffer size to be aligned to
 *	MaxPacketSize.
 * @quirk_altset_not_supp: UDC controller doesn&apos;t support alt settings.
 * @quirk_stall_not_supp: UDC controller doesn&apos;t support stalling.
 * @quirk_zlp_not_supp: UDC controller doesn&apos;t support ZLP.
 * @quirk_avoids_skb_reserve: udc/platform wants to avoid skb_reserve() in
 *	u_ether.c to improve performance.
 * @is_selfpowered: if the gadget is self-powered.
 * @deactivated: True if gadget is deactivated - in deactivated state it cannot
 *	be connected.
 * @connected: True if gadget is connected.
 * @lpm_capable: If the gadget max_speed is FULL or HIGH, this flag
 *	indicates that it supports LPM as per the LPM ECN &amp; errata.
 *
 * Gadgets have a mostly-portable &quot;gadget driver&quot; implementing device
 * functions, handling all usb configurations and interfaces.  Gadget
 * drivers talk to hardware-specific code indirectly, through ops vectors.
 * That insulates the gadget driver from hardware details, and packages
 * the hardware endpoints through generic i/o queues.  The &quot;usb_gadget&quot;
 * and &quot;usb_ep&quot; interfaces provide that insulation from the hardware.
 *
 * Except for the driver data, all fields in this structure are
 * read-only to the gadget driver.  That driver data is part of the
 * &quot;driver model&quot; infrastructure in 2.6 (and later) kernels, and for
 * earlier systems is grouped in a similar structure that&apos;s not known
 * to the rest of the kernel.
 *
 * Values of the three OTG device feature flags are updated before the
 * setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before
 * driver suspend() calls.  They are valid only when is_otg, and when the
 * device is acting as a B-Peripheral (so is_a_peripheral is false).
 */</doc>
<mbr r='usb_gadget::work' o='0' t='struct work_struct'/>
<mbr r='usb_gadget::udc' o='256' t='struct usb_udc *'/>
<mbr r='usb_gadget::ops' o='320' t='const struct usb_gadget_ops *'/>
<mbr r='usb_gadget::ep0' o='384' t='struct usb_ep *'/>
<mbr r='usb_gadget::ep_list' o='448' t='struct list_head'/>
<mbr r='usb_gadget::speed' o='576' t='enum usb_device_speed'/>
<mbr r='usb_gadget::max_speed' o='608' t='enum usb_device_speed'/>
<mbr r='usb_gadget::state' o='640' t='enum usb_device_state'/>
<mbr r='usb_gadget::name' o='704' t='const char *'/>
<mbr r='usb_gadget::dev' o='768' t='struct device'/>
<mbr r='usb_gadget::isoch_delay' o='4608' t='unsigned int'/>
<mbr r='usb_gadget::out_epnum' o='4640' t='unsigned int'/>
<mbr r='usb_gadget::in_epnum' o='4672' t='unsigned int'/>
<mbr r='usb_gadget::mA' o='4704' t='unsigned int'/>
<mbr r='usb_gadget::otg_caps' o='4736' t='struct usb_otg_caps *'/>
<mbr r='usb_gadget::sg_supported' o='4800' t='unsigned int'/>
<mbr r='usb_gadget::is_otg' o='4801' t='unsigned int'/>
<mbr r='usb_gadget::is_a_peripheral' o='4802' t='unsigned int'/>
<mbr r='usb_gadget::b_hnp_enable' o='4803' t='unsigned int'/>
<mbr r='usb_gadget::a_hnp_support' o='4804' t='unsigned int'/>
<mbr r='usb_gadget::a_alt_hnp_support' o='4805' t='unsigned int'/>
<mbr r='usb_gadget::hnp_polling_support' o='4806' t='unsigned int'/>
<mbr r='usb_gadget::host_request_flag' o='4807' t='unsigned int'/>
<mbr r='usb_gadget::quirk_ep_out_aligned_size' o='4808' t='unsigned int'/>
<mbr r='usb_gadget::quirk_altset_not_supp' o='4809' t='unsigned int'/>
<mbr r='usb_gadget::quirk_stall_not_supp' o='4810' t='unsigned int'/>
<mbr r='usb_gadget::quirk_zlp_not_supp' o='4811' t='unsigned int'/>
<mbr r='usb_gadget::quirk_avoids_skb_reserve' o='4812' t='unsigned int'/>
<mbr r='usb_gadget::is_selfpowered' o='4813' t='unsigned int'/>
<mbr r='usb_gadget::deactivated' o='4814' t='unsigned int'/>
<mbr r='usb_gadget::connected' o='4815' t='unsigned int'/>
<mbr r='usb_gadget::lpm_capable' o='4816' t='unsigned int'/>
