<def f='linux-4.18.y/include/linux/fs.h' l='1581' ll='1584' type='void sb_start_pagefault(struct super_block * sb)'/>
<doc f='linux-4.18.y/include/linux/fs.h' l='1562'>/**
 * sb_start_pagefault - get write access to a superblock from a page fault
 * @sb: the super we write to
 *
 * When a process starts handling write page fault, it should embed the
 * operation into sb_start_pagefault() - sb_end_pagefault() pair to get
 * exclusion against file system freezing. This is needed since the page fault
 * is going to dirty a page. This function increments number of running page
 * faults preventing freezing. If the file system is already frozen, the
 * function waits until the file system is thawed.
 *
 * Since page fault freeze protection behaves as a lock, users have to preserve
 * ordering of freeze protection and other filesystem locks. It is advised to
 * put sb_start_pagefault() close to mmap_sem in lock ordering. Page fault
 * handling code implies lock dependency:
 *
 * mmap_sem
 *   -&gt; sb_start_pagefault
 */</doc>
<use f='linux-4.18.y/fs/ext4/inode.c' l='6129' u='c' c='ext4_page_mkwrite'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='61' u='c' c='f2fs_vm_page_mkwrite'/>
<use f='linux-4.18.y/mm/filemap.c' l='2702' u='c' c='filemap_page_mkwrite'/>
