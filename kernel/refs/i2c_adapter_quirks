<def f='linux-4.18.y/include/linux/i2c.h' l='634' ll='641'/>
<size>24</size>
<doc f='linux-4.18.y/include/linux/i2c.h' l='613'>/**
 * struct i2c_adapter_quirks - describe flaws of an i2c adapter
 * @flags: see I2C_AQ_* for possible flags and read below
 * @max_num_msgs: maximum number of messages per transfer
 * @max_write_len: maximum length of a write message
 * @max_read_len: maximum length of a read message
 * @max_comb_1st_msg_len: maximum length of the first msg in a combined message
 * @max_comb_2nd_msg_len: maximum length of the second msg in a combined message
 *
 * Note about combined messages: Some I2C controllers can only send one message
 * per transfer, plus something called combined message or write-then-read.
 * This is (usually) a small write message followed by a read message and
 * barely enough to access register based devices like EEPROMs. There is a flag
 * to support this mode. It implies max_num_msg = 2 and does the length checks
 * with max_comb_*_len because combined message mode usually has its own
 * limitations. Because of HW implementations, some controllers can actually do
 * write-then-anything or other variants. To support that, write-then-read has
 * been broken out into smaller bits like write-first and read-second which can
 * be combined as needed.
 */</doc>
<mbr r='i2c_adapter_quirks::flags' o='0' t='u64'/>
<mbr r='i2c_adapter_quirks::max_num_msgs' o='64' t='int'/>
<mbr r='i2c_adapter_quirks::max_write_len' o='96' t='u16'/>
<mbr r='i2c_adapter_quirks::max_read_len' o='112' t='u16'/>
<mbr r='i2c_adapter_quirks::max_comb_1st_msg_len' o='128' t='u16'/>
<mbr r='i2c_adapter_quirks::max_comb_2nd_msg_len' o='144' t='u16'/>
