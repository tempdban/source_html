<dec f='linux-4.14.y/include/linux/bitmap.h' l='95' type='int __bitmap_equal(const unsigned long * bitmap1, const unsigned long * bitmap2, unsigned int nbits)'/>
<use f='linux-4.14.y/include/linux/bitmap.h' l='280' u='c' c='bitmap_equal'/>
<def f='linux-4.14.y/lib/bitmap.c' l='47' ll='60' type='int __bitmap_equal(const unsigned long * bitmap1, const unsigned long * bitmap2, unsigned int bits)'/>
<dec f='linux-4.14.y/lib/bitmap.c' l='61' type='int __bitmap_equal(const unsigned long * , const unsigned long * , unsigned int )'/>
<use f='linux-4.14.y/lib/bitmap.c' l='61' c='__bitmap_equal'/>
<use f='linux-4.14.y/lib/bitmap.c' l='61' u='a'/>
<use f='linux-4.14.y/lib/bitmap.c' l='61' u='a'/>
<doc f='linux-4.14.y/lib/bitmap.c' l='21'>/*
 * bitmaps provide an array of bits, implemented using an an
 * array of unsigned longs.  The number of valid bits in a
 * given bitmap does _not_ need to be an exact multiple of
 * BITS_PER_LONG.
 *
 * The possible unused bits in the last, partially used word
 * of a bitmap are &apos;don&apos;t care&apos;.  The implementation makes
 * no particular effort to keep them zero.  It ensures that
 * their value will not affect the results of any operation.
 * The bitmap operations that return Boolean (bitmap_empty,
 * for example) or scalar (bitmap_weight, for example) results
 * carefully filter out these unused bits from impacting their
 * results.
 *
 * These operations actually hold to a slightly stronger rule:
 * if you don&apos;t input any bitmaps to these ops that have some
 * unused bits set, then they won&apos;t output any set unused bits
 * in output bitmaps.
 *
 * The byte ordering of bitmaps is more natural on little
 * endian architectures.  See the big-endian headers
 * include/asm-ppc64/bitops.h and include/asm-s390/bitops.h
 * for the best explanations of this ordering.
 */</doc>
<dec f='linux-4.14.y/include/linux/bitmap.h' l='95' type='int __bitmap_equal(const unsigned long * bitmap1, const unsigned long * bitmap2, unsigned int nbits)'/>
<use f='linux-4.14.y/include/linux/bitmap.h' l='280' u='c' c='bitmap_equal'/>
<def f='linux-4.14.y/lib/bitmap.c' l='47' ll='60' type='int __bitmap_equal(const unsigned long * bitmap1, const unsigned long * bitmap2, unsigned int bits)'/>
<dec f='linux-4.14.y/lib/bitmap.c' l='61' type='int __bitmap_equal(const unsigned long * , const unsigned long * , unsigned int )'/>
<use f='linux-4.14.y/lib/bitmap.c' l='61' c='__bitmap_equal'/>
<use f='linux-4.14.y/lib/bitmap.c' l='61' u='a'/>
<use f='linux-4.14.y/lib/bitmap.c' l='61' u='a'/>
<doc f='linux-4.14.y/lib/bitmap.c' l='21'>/*
 * bitmaps provide an array of bits, implemented using an an
 * array of unsigned longs.  The number of valid bits in a
 * given bitmap does _not_ need to be an exact multiple of
 * BITS_PER_LONG.
 *
 * The possible unused bits in the last, partially used word
 * of a bitmap are &apos;don&apos;t care&apos;.  The implementation makes
 * no particular effort to keep them zero.  It ensures that
 * their value will not affect the results of any operation.
 * The bitmap operations that return Boolean (bitmap_empty,
 * for example) or scalar (bitmap_weight, for example) results
 * carefully filter out these unused bits from impacting their
 * results.
 *
 * These operations actually hold to a slightly stronger rule:
 * if you don&apos;t input any bitmaps to these ops that have some
 * unused bits set, then they won&apos;t output any set unused bits
 * in output bitmaps.
 *
 * The byte ordering of bitmaps is more natural on little
 * endian architectures.  See the big-endian headers
 * include/asm-ppc64/bitops.h and include/asm-s390/bitops.h
 * for the best explanations of this ordering.
 */</doc>
