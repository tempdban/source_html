<def f='linux-4.14.y/arch/x86/include/asm/word-at-a-time.h' l='14' ll='16'/>
<size>16</size>
<doc f='linux-4.14.y/arch/x86/include/asm/word-at-a-time.h' l='7'>/*
 * This is largely generic for little-endian machines, but the
 * optimal byte mask counting is probably going to be something
 * that is architecture-specific. If you have a reliably fast
 * bit count instruction, that might be better than the multiply
 * and shift, for example.
 */</doc>
<mbr r='word_at_a_time::one_bits' o='0' t='const unsigned long'/>
<mbr r='word_at_a_time::high_bits' o='64' t='const unsigned long'/>
<def f='linux-4.14.y/arch/x86/include/asm/word-at-a-time.h' l='14' ll='16'/>
<size>16</size>
<doc f='linux-4.14.y/arch/x86/include/asm/word-at-a-time.h' l='7'>/*
 * This is largely generic for little-endian machines, but the
 * optimal byte mask counting is probably going to be something
 * that is architecture-specific. If you have a reliably fast
 * bit count instruction, that might be better than the multiply
 * and shift, for example.
 */</doc>
<mbr r='word_at_a_time::one_bits' o='0' t='const unsigned long'/>
<mbr r='word_at_a_time::high_bits' o='64' t='const unsigned long'/>
