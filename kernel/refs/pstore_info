<def f='linux-4.18.y/include/linux/pstore.h' l='169' ll='189'/>
<size>136</size>
<doc f='linux-4.18.y/include/linux/pstore.h' l='85'>/**
 * struct pstore_info - backend pstore driver structure
 *
 * @owner:	module which is repsonsible for this backend driver
 * @name:	name of the backend driver
 *
 * @buf_lock:	spinlock to serialize access to @buf
 * @buf:	preallocated crash dump buffer
 * @bufsize:	size of @buf available for crash dump writes
 *
 * @read_mutex:	serializes @open, @read, @close, and @erase callbacks
 * @flags:	bitfield of frontends the backend can accept writes for
 * @data:	backend-private pointer passed back during callbacks
 *
 * Callbacks:
 *
 * @open:
 *	Notify backend that pstore is starting a full read of backend
 *	records. Followed by one or more @read calls, and a final @close.
 *
 *	@psi:	in: pointer to the struct pstore_info for the backend
 *
 *	Returns 0 on success, and non-zero on error.
 *
 * @close:
 *	Notify backend that pstore has finished a full read of backend
 *	records. Always preceded by an @open call and one or more @read
 *	calls.
 *
 *	@psi:	in: pointer to the struct pstore_info for the backend
 *
 *	Returns 0 on success, and non-zero on error. (Though pstore will
 *	ignore the error.)
 *
 * @read:
 *	Read next available backend record. Called after a successful
 *	@open.
 *
 *	@record:
 *		pointer to record to populate. @buf should be allocated
 *		by the backend and filled. At least @type and @id should
 *		be populated, since these are used when creating pstorefs
 *		file names.
 *
 *	Returns record size on success, zero when no more records are
 *	available, or negative on error.
 *
 * @write:
 *	A newly generated record needs to be written to backend storage.
 *
 *	@record:
 *		pointer to record metadata. When @type is PSTORE_TYPE_DMESG,
 *		@buf will be pointing to the preallocated @psi.buf, since
 *		memory allocation may be broken during an Oops. Regardless,
 *		@buf must be proccesed or copied before returning. The
 *		backend is also expected to write @id with something that
 *		can help identify this record to a future @erase callback.
 *		The @time field will be prepopulated with the current time,
 *		when available. The @size field will have the size of data
 *		in @buf.
 *
 *	Returns 0 on success, and non-zero on error.
 *
 * @write_user:
 *	Perform a frontend write to a backend record, using a specified
 *	buffer that is coming directly from userspace, instead of the
 *	@record @buf.
 *
 *	@record:	pointer to record metadata.
 *	@buf:		pointer to userspace contents to write to backend
 *
 *	Returns 0 on success, and non-zero on error.
 *
 * @erase:
 *	Delete a record from backend storage.  Different backends
 *	identify records differently, so entire original record is
 *	passed back to assist in identification of what the backend
 *	should remove from storage.
 *
 *	@record:	pointer to record metadata.
 *
 *	Returns 0 on success, and non-zero on error.
 *
 */</doc>
<mbr r='pstore_info::owner' o='0' t='struct module *'/>
<mbr r='pstore_info::name' o='64' t='char *'/>
<mbr r='pstore_info::buf_lock' o='128' t='spinlock_t'/>
<mbr r='pstore_info::buf' o='192' t='char *'/>
<mbr r='pstore_info::bufsize' o='256' t='size_t'/>
<mbr r='pstore_info::read_mutex' o='320' t='struct mutex'/>
<mbr r='pstore_info::flags' o='576' t='int'/>
<mbr r='pstore_info::data' o='640' t='void *'/>
<mbr r='pstore_info::open' o='704' t='int (*)(struct pstore_info *)'/>
<mbr r='pstore_info::close' o='768' t='int (*)(struct pstore_info *)'/>
<mbr r='pstore_info::read' o='832' t='ssize_t (*)(struct pstore_record *)'/>
<mbr r='pstore_info::write' o='896' t='int (*)(struct pstore_record *)'/>
<mbr r='pstore_info::write_user' o='960' t='int (*)(struct pstore_record *, const char *)'/>
<mbr r='pstore_info::erase' o='1024' t='int (*)(struct pstore_record *)'/>
