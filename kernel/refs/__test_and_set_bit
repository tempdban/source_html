<def f='linux-4.18.y/arch/x86/include/asm/bitops.h' l='246' ll='255' type='bool __test_and_set_bit(long nr, volatile unsigned long * addr)'/>
<use f='linux-4.18.y/include/asm-generic/bitops/le.h' l='90' u='c' c='__test_and_set_bit_le'/>
<doc f='linux-4.18.y/arch/x86/include/asm/bitops.h' l='237'>/**
 * __test_and_set_bit - Set a bit and return its old value
 * @nr: Bit to set
 * @addr: Address to count from
 *
 * This operation is non-atomic and can be reordered.
 * If two examples of this operation race, one can appear to succeed
 * but actually fail.  You must protect multiple accesses with a lock.
 */</doc>
<use f='linux-4.18.y/arch/x86/events/core.c' l='780' u='c' c='__perf_sched_find_counter'/>
<use f='linux-4.18.y/arch/x86/events/core.c' l='788' u='c' c='__perf_sched_find_counter'/>
<use f='linux-4.18.y/arch/x86/kernel/cpu/cpuid-deps.c' l='104' u='c' c='do_clear_cpu_cap'/>
<use f='linux-4.18.y/arch/x86/kernel/process.c' l='360' u='c' c='amd_set_core_ssb_state'/>
<use f='linux-4.18.y/arch/x86/kvm/lapic.c' l='93' u='c' c='__apic_test_and_set_vector'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='2009' u='c' c='mark_unsync'/>
<use f='linux-4.18.y/drivers/uio/uio_pdrv_genirq.c' l='72' u='c' c='uio_pdrv_genirq_handler'/>
<use f='linux-4.18.y/drivers/uio/uio_pdrv_genirq.c' l='97' u='c' c='uio_pdrv_genirq_irqcontrol'/>
<use f='linux-4.18.y/fs/f2fs/segment.c' l='1797' u='c' c='__mark_sit_entry_dirty'/>
<use f='linux-4.18.y/kernel/sysctl_binary.c' l='1377' u='c' c='warn_on_bintable'/>
<use f='linux-4.18.y/mm/mmap.c' l='3429' u='c' c='vm_lock_anon_vma'/>
<use f='linux-4.18.y/net/core/dev.c' l='3977' u='c' c='enqueue_to_backlog'/>
