<dec f='linux-4.14.y/include/linux/dma-fence.h' l='276' type='int dma_fence_signal_locked(struct dma_fence * fence)'/>
<use f='linux-4.14.y/include/linux/dma-fence.h' l='305' u='c' c='dma_fence_is_signaled_locked'/>
<def f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='68' ll='96' type='int dma_fence_signal_locked(struct dma_fence * fence)'/>
<dec f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' type='int dma_fence_signal_locked(struct dma_fence * )'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' c='dma_fence_signal_locked'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' u='a'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' u='a'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='209' u='c' c='dma_fence_enable_sw_signaling'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='267' u='c' c='dma_fence_add_callback'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='395' u='c' c='dma_fence_default_wait'/>
<doc f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='56'>/**
 * dma_fence_signal_locked - signal completion of a fence
 * @fence: the fence to signal
 *
 * Signal completion for software callbacks on a fence, this will unblock
 * dma_fence_wait() calls and run all the callbacks added with
 * dma_fence_add_callback(). Can be called multiple times, but since a fence
 * can only go from unsignaled to signaled state, it will only be effective
 * the first time.
 *
 * Unlike dma_fence_signal, this function must be called with fence-&gt;lock held.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_fence.c' l='114' u='c' c='virtio_gpu_fence_event_process'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='459' u='c' c='__vmw_fences_update'/>
<dec f='linux-4.14.y/include/linux/dma-fence.h' l='276' type='int dma_fence_signal_locked(struct dma_fence * fence)'/>
<use f='linux-4.14.y/include/linux/dma-fence.h' l='305' u='c' c='dma_fence_is_signaled_locked'/>
<def f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='68' ll='96' type='int dma_fence_signal_locked(struct dma_fence * fence)'/>
<dec f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' type='int dma_fence_signal_locked(struct dma_fence * )'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' c='dma_fence_signal_locked'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' u='a'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='97' u='a'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='209' u='c' c='dma_fence_enable_sw_signaling'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='267' u='c' c='dma_fence_add_callback'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='395' u='c' c='dma_fence_default_wait'/>
<doc f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='56'>/**
 * dma_fence_signal_locked - signal completion of a fence
 * @fence: the fence to signal
 *
 * Signal completion for software callbacks on a fence, this will unblock
 * dma_fence_wait() calls and run all the callbacks added with
 * dma_fence_add_callback(). Can be called multiple times, but since a fence
 * can only go from unsignaled to signaled state, it will only be effective
 * the first time.
 *
 * Unlike dma_fence_signal, this function must be called with fence-&gt;lock held.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_fence.c' l='114' u='c' c='virtio_gpu_fence_event_process'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='459' u='c' c='__vmw_fences_update'/>
