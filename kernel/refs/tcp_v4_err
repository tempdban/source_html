<dec f='linux-4.14.y/include/net/tcp.h' l='344' type='void tcp_v4_err(struct sk_buff * skb, u32 )'/>
<use f='linux-4.14.y/net/ipv4/af_inet.c' l='1614'/>
<use f='linux-4.14.y/net/ipv4/af_inet.c' l='1614'/>
<def f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='366' ll='556' type='void tcp_v4_err(struct sk_buff * icmp_skb, u32 info)'/>
<doc f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='350'>/*
 * This routine is called by the ICMP module when it gets some
 * sort of error condition.  If err &lt; 0 then the socket should
 * be closed and the error returned to the user.  If err &gt; 0
 * it&apos;s just the icmp type &lt;&lt; 8 | icmp code.  After adjustment
 * header points to the first 8 bytes of the tcp header.  We need
 * to find the appropriate port.
 *
 * The locking strategy used here is very &quot;optimistic&quot;. When
 * someone else accesses the socket the ICMP is just dropped
 * and for some paths there is no check at all.
 * A more general error queue to queue errors for later handling
 * is probably better.
 *
 */</doc>
