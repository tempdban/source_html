<dec f='linux-4.18.y/include/linux/xz.h' l='194' type='struct xz_dec * xz_dec_init(enum xz_mode mode, uint32_t dict_max)'/>
<use f='linux-4.18.y/lib/decompress_unxz.c' l='270' u='c' c='unxz'/>
<use f='linux-4.18.y/lib/decompress_unxz.c' l='272' u='c' c='unxz'/>
<doc f='linux-4.18.y/include/linux/xz.h' l='151'>/**
 * xz_dec_init() - Allocate and initialize a XZ decoder state
 * @mode:       Operation mode
 * @dict_max:   Maximum size of the LZMA2 dictionary (history buffer) for
 *              multi-call decoding. This is ignored in single-call mode
 *              (mode == XZ_SINGLE). LZMA2 dictionary is always 2^n bytes
 *              or 2^n + 2^(n-1) bytes (the latter sizes are less common
 *              in practice), so other values for dict_max don&apos;t make sense.
 *              In the kernel, dictionary sizes of 64 KiB, 128 KiB, 256 KiB,
 *              512 KiB, and 1 MiB are probably the only reasonable values,
 *              except for kernel and initramfs images where a bigger
 *              dictionary can be fine and useful.
 *
 * Single-call mode (XZ_SINGLE): xz_dec_run() decodes the whole stream at
 * once. The caller must provide enough output space or the decoding will
 * fail. The output space is used as the dictionary buffer, which is why
 * there is no need to allocate the dictionary as part of the decoder&apos;s
 * internal state.
 *
 * Because the output buffer is used as the workspace, streams encoded using
 * a big dictionary are not a problem in single-call mode. It is enough that
 * the output buffer is big enough to hold the actual uncompressed data; it
 * can be smaller than the dictionary size stored in the stream headers.
 *
 * Multi-call mode with preallocated dictionary (XZ_PREALLOC): dict_max bytes
 * of memory is preallocated for the LZMA2 dictionary. This way there is no
 * risk that xz_dec_run() could run out of memory, since xz_dec_run() will
 * never allocate any memory. Instead, if the preallocated dictionary is too
 * small for decoding the given input stream, xz_dec_run() will return
 * XZ_MEMLIMIT_ERROR. Thus, it is important to know what kind of data will be
 * decoded to avoid allocating excessive amount of memory for the dictionary.
 *
 * Multi-call mode with dynamically allocated dictionary (XZ_DYNALLOC):
 * dict_max specifies the maximum allowed dictionary size that xz_dec_run()
 * may allocate once it has parsed the dictionary size from the stream
 * headers. This way excessive allocations can be avoided while still
 * limiting the maximum memory usage to a sane value to prevent running the
 * system out of memory when decompressing streams from untrusted sources.
 *
 * On success, xz_dec_init() returns a pointer to struct xz_dec, which is
 * ready to be used with xz_dec_run(). If memory allocation fails,
 * xz_dec_init() returns NULL.
 */</doc>
<def f='linux-4.18.y/lib/xz/xz_dec_stream.c' l='786' ll='814' macro='1' type='struct xz_dec * xz_dec_init(enum xz_mode mode, uint32_t dict_max)'/>
<dec f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='13' type='struct xz_dec * xz_dec_init(enum xz_mode , uint32_t )'/>
<use f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='13' c='xz_dec_init'/>
<use f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='13' u='a'/>
<use f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='13' u='a'/>
