<def f='linux-4.14.y/include/linux/pagemap.h' l='344' ll='350' type='struct page * grab_cache_page_nowait(struct address_space * mapping, unsigned long index)'/>
<doc f='linux-4.14.y/include/linux/pagemap.h' l='331'>/**
 * grab_cache_page_nowait - returns locked page at given index in given cache
 * @mapping: target address_space
 * @index: the page index
 *
 * Same as grab_cache_page(), but do not wait if the page is unavailable.
 * This is intended for speculative data generators, where the data can
 * be regenerated if the page couldn&apos;t be grabbed.  This routine should
 * be safe to call while holding the lock for another page.
 *
 * Clear __GFP_FS when allocating the page to avoid recursion into the fs
 * and deadlock against the caller&apos;s locked page.
 */</doc>
<def f='linux-4.14.y/include/linux/pagemap.h' l='344' ll='350' type='struct page * grab_cache_page_nowait(struct address_space * mapping, unsigned long index)'/>
<doc f='linux-4.14.y/include/linux/pagemap.h' l='331'>/**
 * grab_cache_page_nowait - returns locked page at given index in given cache
 * @mapping: target address_space
 * @index: the page index
 *
 * Same as grab_cache_page(), but do not wait if the page is unavailable.
 * This is intended for speculative data generators, where the data can
 * be regenerated if the page couldn&apos;t be grabbed.  This routine should
 * be safe to call while holding the lock for another page.
 *
 * Clear __GFP_FS when allocating the page to avoid recursion into the fs
 * and deadlock against the caller&apos;s locked page.
 */</doc>
<use f='linux-4.14.y/fs/isofs/compress.c' l='337' u='c' c='zisofs_readpage'/>
<use f='linux-4.14.y/fs/ntfs/compress.c' l='575' u='c' c='ntfs_read_compressed_block'/>
