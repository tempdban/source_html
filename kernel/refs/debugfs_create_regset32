<dec f='linux-4.14.y/include/linux/debugfs.h' l='152' type='struct dentry * debugfs_create_regset32(const char * name, umode_t mode, struct dentry * parent, struct debugfs_regset32 * regset)'/>
<def f='linux-4.14.y/fs/debugfs/file.c' l='1082' ll='1087' type='struct dentry * debugfs_create_regset32(const char * name, umode_t mode, struct dentry * parent, struct debugfs_regset32 * regset)'/>
<dec f='linux-4.14.y/fs/debugfs/file.c' l='1088' type='struct dentry * debugfs_create_regset32(const char * , umode_t , struct dentry * , struct debugfs_regset32 * )'/>
<use f='linux-4.14.y/fs/debugfs/file.c' l='1088' c='debugfs_create_regset32'/>
<use f='linux-4.14.y/fs/debugfs/file.c' l='1088' u='a'/>
<use f='linux-4.14.y/fs/debugfs/file.c' l='1088' u='a'/>
<doc f='linux-4.14.y/fs/debugfs/file.c' l='1057'>/**
 * debugfs_create_regset32 - create a debugfs file that returns register values
 * @name: a pointer to a string containing the name of the file to create.
 * @mode: the permission that the file should have
 * @parent: a pointer to the parent dentry for this file.  This should be a
 *          directory dentry if set.  If this parameter is %NULL, then the
 *          file will be created in the root of the debugfs filesystem.
 * @regset: a pointer to a struct debugfs_regset32, which contains a pointer
 *          to an array of register definitions, the array size and the base
 *          address where the register bank is to be found.
 *
 * This function creates a file in debugfs with the given name that reports
 * the names and values of a set of 32-bit registers. If the @mode variable
 * is so set it can be read from. Writing is not supported.
 *
 * This function will return a pointer to a dentry if it succeeds.  This
 * pointer must be passed to the debugfs_remove() function when the file is
 * to be removed (no automatic cleanup happens if your module is unloaded,
 * you are responsible here.)  If an error occurs, %NULL will be returned.
 *
 * If debugfs is not enabled in the kernel, the value -%ENODEV will be
 * returned.  It is not wise to check for this value, but rather, check for
 * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling
 * code.
 */</doc>
<dec f='linux-4.14.y/include/linux/debugfs.h' l='152' type='struct dentry * debugfs_create_regset32(const char * name, umode_t mode, struct dentry * parent, struct debugfs_regset32 * regset)'/>
<def f='linux-4.14.y/fs/debugfs/file.c' l='1082' ll='1087' type='struct dentry * debugfs_create_regset32(const char * name, umode_t mode, struct dentry * parent, struct debugfs_regset32 * regset)'/>
<dec f='linux-4.14.y/fs/debugfs/file.c' l='1088' type='struct dentry * debugfs_create_regset32(const char * , umode_t , struct dentry * , struct debugfs_regset32 * )'/>
<use f='linux-4.14.y/fs/debugfs/file.c' l='1088' c='debugfs_create_regset32'/>
<use f='linux-4.14.y/fs/debugfs/file.c' l='1088' u='a'/>
<use f='linux-4.14.y/fs/debugfs/file.c' l='1088' u='a'/>
<doc f='linux-4.14.y/fs/debugfs/file.c' l='1057'>/**
 * debugfs_create_regset32 - create a debugfs file that returns register values
 * @name: a pointer to a string containing the name of the file to create.
 * @mode: the permission that the file should have
 * @parent: a pointer to the parent dentry for this file.  This should be a
 *          directory dentry if set.  If this parameter is %NULL, then the
 *          file will be created in the root of the debugfs filesystem.
 * @regset: a pointer to a struct debugfs_regset32, which contains a pointer
 *          to an array of register definitions, the array size and the base
 *          address where the register bank is to be found.
 *
 * This function creates a file in debugfs with the given name that reports
 * the names and values of a set of 32-bit registers. If the @mode variable
 * is so set it can be read from. Writing is not supported.
 *
 * This function will return a pointer to a dentry if it succeeds.  This
 * pointer must be passed to the debugfs_remove() function when the file is
 * to be removed (no automatic cleanup happens if your module is unloaded,
 * you are responsible here.)  If an error occurs, %NULL will be returned.
 *
 * If debugfs is not enabled in the kernel, the value -%ENODEV will be
 * returned.  It is not wise to check for this value, but rather, check for
 * %NULL or !%NULL instead as to eliminate the need for #ifdef in the calling
 * code.
 */</doc>
