<dec f='linux-4.14.y/include/linux/blkdev.h' l='1201' type='int blk_queue_dma_drain(struct request_queue * q, dma_drain_needed_fn * dma_drain_needed, void * buf, unsigned int size)'/>
<def f='linux-4.14.y/block/blk-settings.c' l='777' ll='790' type='int blk_queue_dma_drain(struct request_queue * q, dma_drain_needed_fn * dma_drain_needed, void * buf, unsigned int size)'/>
<dec f='linux-4.14.y/block/blk-settings.c' l='791' type='int blk_queue_dma_drain(struct request_queue * , dma_drain_needed_fn * , void * , unsigned int )'/>
<use f='linux-4.14.y/block/blk-settings.c' l='791' c='blk_queue_dma_drain'/>
<use f='linux-4.14.y/block/blk-settings.c' l='791' u='a'/>
<use f='linux-4.14.y/block/blk-settings.c' l='791' u='a'/>
<doc f='linux-4.14.y/block/blk-settings.c' l='756'>/**
 * blk_queue_dma_drain - Set up a drain buffer for excess dma.
 * @q:  the request queue for the device
 * @dma_drain_needed: fn which returns non-zero if drain is necessary
 * @buf:	physically contiguous buffer
 * @size:	size of the buffer in bytes
 *
 * Some devices have excess DMA problems and can&apos;t simply discard (or
 * zero fill) the unwanted piece of the transfer.  They have to have a
 * real area of memory to transfer it into.  The use case for this is
 * ATAPI devices in DMA mode.  If the packet command causes a transfer
 * bigger than the transfer size some HBAs will lock up if there
 * aren&apos;t DMA elements to contain the excess transfer.  What this API
 * does is adjust the queue so that the buf is always appended
 * silently to the scatterlist.
 *
 * Note: This routine adjusts max_hw_segments to make room for appending
 * the drain buffer.  If you call blk_queue_max_segments() after calling
 * this routine, you must set the limit to one fewer than your device
 * can support otherwise there won&apos;t be room for the drain buffer.
 */</doc>
<use f='linux-4.14.y/drivers/ata/libata-scsi.c' l='1291' u='c' c='ata_scsi_dev_config'/>
