<dec f='linux-4.14.y/include/drm/drm_crtc.h' l='445' type='int (*)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, struct drm_modeset_acquire_ctx *)'/>
<offset>448</offset>
<doc f='linux-4.14.y/include/drm/drm_crtc.h' l='392'>/**
	 * @page_flip:
	 *
	 * Legacy entry point to schedule a flip to the given framebuffer.
	 *
	 * Page flipping is a synchronization mechanism that replaces the frame
	 * buffer being scanned out by the CRTC with a new frame buffer during
	 * vertical blanking, avoiding tearing (except when requested otherwise
	 * through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
	 * requests a page flip the DRM core verifies that the new frame buffer
	 * is large enough to be scanned out by the CRTC in the currently
	 * configured mode and then calls this hook with a pointer to the new
	 * frame buffer.
	 *
	 * The driver must wait for any pending rendering to the new framebuffer
	 * to complete before executing the flip. It should also wait for any
	 * pending rendering from other drivers if the underlying buffer is a
	 * shared dma-buf.
	 *
	 * An application can request to be notified when the page flip has
	 * completed. The drm core will supply a &amp;struct drm_event in the event
	 * parameter in this case. This can be handled by the
	 * drm_crtc_send_vblank_event() function, which the driver should call on
	 * the provided event upon completion of the flip. Note that if
	 * the driver supports vblank signalling and timestamping the vblank
	 * counters and timestamps must agree with the ones returned from page
	 * flip events. With the current vblank helper infrastructure this can
	 * be achieved by holding a vblank reference while the page flip is
	 * pending, acquired through drm_crtc_vblank_get() and released with
	 * drm_crtc_vblank_put(). Drivers are free to implement their own vblank
	 * counter and timestamp tracking though, e.g. if they have accurate
	 * timestamp registers in hardware.
	 *
	 * This callback is optional.
	 *
	 * NOTE:
	 *
	 * Very early versions of the KMS ABI mandated that the driver must
	 * block (but not reject) any rendering to the old framebuffer until the
	 * flip operation has completed and the old framebuffer is no longer
	 * visible. This requirement has been lifted, and userspace is instead
	 * expected to request delivery of an event and wait with recycling old
	 * buffers until such has been received.
	 *
	 * RETURNS:
	 *
	 * 0 on success or a negative error code on failure. Note that if a
	 * page flip operation is already pending the callback should return
	 * -EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
	 * or just runtime disabled through DPMS respectively the new atomic
	 * &quot;ACTIVE&quot; state) should result in an -EINVAL error code. Note that
	 * drm_atomic_helper_page_flip() checks this already for atomic drivers.
	 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_kms.c' l='121' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane.c' l='983' u='r' c='drm_mode_page_flip_ioctl'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane.c' l='1056' u='r' c='drm_mode_page_flip_ioctl'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='84' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='300' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='45' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='391' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='1028' u='w'/>
<dec f='linux-4.14.y/include/drm/drm_crtc.h' l='445' type='int (*)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, struct drm_modeset_acquire_ctx *)'/>
<offset>448</offset>
<doc f='linux-4.14.y/include/drm/drm_crtc.h' l='392'>/**
	 * @page_flip:
	 *
	 * Legacy entry point to schedule a flip to the given framebuffer.
	 *
	 * Page flipping is a synchronization mechanism that replaces the frame
	 * buffer being scanned out by the CRTC with a new frame buffer during
	 * vertical blanking, avoiding tearing (except when requested otherwise
	 * through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
	 * requests a page flip the DRM core verifies that the new frame buffer
	 * is large enough to be scanned out by the CRTC in the currently
	 * configured mode and then calls this hook with a pointer to the new
	 * frame buffer.
	 *
	 * The driver must wait for any pending rendering to the new framebuffer
	 * to complete before executing the flip. It should also wait for any
	 * pending rendering from other drivers if the underlying buffer is a
	 * shared dma-buf.
	 *
	 * An application can request to be notified when the page flip has
	 * completed. The drm core will supply a &amp;struct drm_event in the event
	 * parameter in this case. This can be handled by the
	 * drm_crtc_send_vblank_event() function, which the driver should call on
	 * the provided event upon completion of the flip. Note that if
	 * the driver supports vblank signalling and timestamping the vblank
	 * counters and timestamps must agree with the ones returned from page
	 * flip events. With the current vblank helper infrastructure this can
	 * be achieved by holding a vblank reference while the page flip is
	 * pending, acquired through drm_crtc_vblank_get() and released with
	 * drm_crtc_vblank_put(). Drivers are free to implement their own vblank
	 * counter and timestamp tracking though, e.g. if they have accurate
	 * timestamp registers in hardware.
	 *
	 * This callback is optional.
	 *
	 * NOTE:
	 *
	 * Very early versions of the KMS ABI mandated that the driver must
	 * block (but not reject) any rendering to the old framebuffer until the
	 * flip operation has completed and the old framebuffer is no longer
	 * visible. This requirement has been lifted, and userspace is instead
	 * expected to request delivery of an event and wait with recycling old
	 * buffers until such has been received.
	 *
	 * RETURNS:
	 *
	 * 0 on success or a negative error code on failure. Note that if a
	 * page flip operation is already pending the callback should return
	 * -EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
	 * or just runtime disabled through DPMS respectively the new atomic
	 * &quot;ACTIVE&quot; state) should result in an -EINVAL error code. Note that
	 * drm_atomic_helper_page_flip() checks this already for atomic drivers.
	 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_kms.c' l='121' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane.c' l='983' u='r' c='drm_mode_page_flip_ioctl'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane.c' l='1056' u='r' c='drm_mode_page_flip_ioctl'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='84' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='300' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='45' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='391' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='1028' u='w'/>
