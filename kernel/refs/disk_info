<def f='linux-4.14.y/drivers/md/raid5.h' l='453' ll='456'/>
<size>24</size>
<doc f='linux-4.14.y/drivers/md/raid5.h' l='429'>/*
 * Plugging:
 *
 * To improve write throughput, we need to delay the handling of some
 * stripes until there has been a chance that several write requests
 * for the one stripe have all been collected.
 * In particular, any write request that would require pre-reading
 * is put on a &quot;delayed&quot; queue until there are no stripes currently
 * in a pre-read phase.  Further, if the &quot;delayed&quot; queue is empty when
 * a stripe is put on it then we &quot;plug&quot; the queue and do not process it
 * until an unplug call is made. (the unplug_io_fn() is called).
 *
 * When preread is initiated on a stripe, we set PREREAD_ACTIVE and add
 * it to the count of prereading stripes.
 * When write is initiated, or the stripe refcnt == 0 (just in case) we
 * clear the PREREAD_ACTIVE flag and decrement the count
 * Whenever the &apos;handle&apos; queue is empty and the device is not plugged, we
 * move any strips from delayed to handle and clear the DELAYED flag and set
 * PREREAD_ACTIVE.
 * In stripe_handle, if we find pre-reading is necessary, we do it if
 * PREREAD_ACTIVE is set, else we set DELAYED which will send it to the delayed queue.
 * HANDLE gets cleared if stripe_handle leaves nothing locked.
 */</doc>
<mbr r='disk_info::rdev' o='0' t='struct md_rdev *'/>
<mbr r='disk_info::replacement' o='64' t='struct md_rdev *'/>
<mbr r='disk_info::extra_page' o='128' t='struct page *'/>
<def f='linux-4.14.y/drivers/md/raid5.h' l='453' ll='456'/>
<size>24</size>
<doc f='linux-4.14.y/drivers/md/raid5.h' l='429'>/*
 * Plugging:
 *
 * To improve write throughput, we need to delay the handling of some
 * stripes until there has been a chance that several write requests
 * for the one stripe have all been collected.
 * In particular, any write request that would require pre-reading
 * is put on a &quot;delayed&quot; queue until there are no stripes currently
 * in a pre-read phase.  Further, if the &quot;delayed&quot; queue is empty when
 * a stripe is put on it then we &quot;plug&quot; the queue and do not process it
 * until an unplug call is made. (the unplug_io_fn() is called).
 *
 * When preread is initiated on a stripe, we set PREREAD_ACTIVE and add
 * it to the count of prereading stripes.
 * When write is initiated, or the stripe refcnt == 0 (just in case) we
 * clear the PREREAD_ACTIVE flag and decrement the count
 * Whenever the &apos;handle&apos; queue is empty and the device is not plugged, we
 * move any strips from delayed to handle and clear the DELAYED flag and set
 * PREREAD_ACTIVE.
 * In stripe_handle, if we find pre-reading is necessary, we do it if
 * PREREAD_ACTIVE is set, else we set DELAYED which will send it to the delayed queue.
 * HANDLE gets cleared if stripe_handle leaves nothing locked.
 */</doc>
<mbr r='disk_info::rdev' o='0' t='struct md_rdev *'/>
<mbr r='disk_info::replacement' o='64' t='struct md_rdev *'/>
<mbr r='disk_info::extra_page' o='128' t='struct page *'/>
