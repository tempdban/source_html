<dec f='linux-4.18.y/include/linux/completion.h' l='119' type='void complete_all(struct completion * )'/>
<use f='linux-4.18.y/crypto/algapi.c' l='336' u='c' c='crypto_alg_tested'/>
<use f='linux-4.18.y/crypto/algboss.c' l='89' u='c' c='cryptomgr_probe'/>
<use f='linux-4.18.y/crypto/api.c' l='166' u='c' c='crypto_larval_kill'/>
<use f='linux-4.18.y/drivers/base/firmware_loader/firmware.h' l='110' u='c' c='__fw_state_set'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1885' u='c' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1891' u='c' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='2073' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='2077' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='2078' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='2106' u='c' c='drm_atomic_helper_commit_cleanup_done'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='2115' u='c' c='drm_atomic_helper_commit_cleanup_done'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_file.c' l='705' u='c' c='drm_send_event_locked'/>
<use f='linux-4.18.y/drivers/usb/host/xhci-ring.c' l='1393' u='c' c='handle_cmd_completion'/>
<use f='linux-4.18.y/fs/f2fs/segment.c' l='899' u='c' c='f2fs_submit_discard_endio'/>
<use f='linux-4.18.y/kernel/kthread.c' l='193' u='c' c='__kthread_parkme'/>
<def f='linux-4.18.y/kernel/sched/completion.c' l='57' ll='65' type='void complete_all(struct completion * x)'/>
<dec f='linux-4.18.y/kernel/sched/completion.c' l='66' type='void complete_all(struct completion * )'/>
<use f='linux-4.18.y/kernel/sched/completion.c' l='66' c='complete_all'/>
<use f='linux-4.18.y/kernel/sched/completion.c' l='66' u='a'/>
<use f='linux-4.18.y/kernel/sched/completion.c' l='66' u='a'/>
<doc f='linux-4.18.y/kernel/sched/completion.c' l='41'>/**
 * complete_all: - signals all threads waiting on this completion
 * @x:  holds the state of this particular completion
 *
 * This will wake up all threads waiting on this particular completion event.
 *
 * It may be assumed that this function implies a write memory barrier before
 * changing the task state if and only if any tasks are woken up.
 *
 * Since complete_all() sets the completion of @x permanently to done
 * to allow multiple waiters to finish, a call to reinit_completion()
 * must be used on @x if @x is to be used again. The code must make
 * sure that all waiters have woken and finished before reinitializing
 * @x. Also note that the function completion_done() can not be used
 * to know if there are still waiters after complete_all() has been called.
 */</doc>
