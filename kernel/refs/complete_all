<dec f='linux-4.14.y/include/linux/completion.h' l='151' type='void complete_all(struct completion * )'/>
<use f='linux-4.14.y/crypto/algapi.c' l='327' u='c' c='crypto_alg_tested'/>
<use f='linux-4.14.y/crypto/algboss.c' l='89' u='c' c='cryptomgr_probe'/>
<use f='linux-4.14.y/crypto/api.c' l='165' u='c' c='crypto_larval_kill'/>
<use f='linux-4.14.y/drivers/base/firmware_class.c' l='150' u='c' c='__fw_state_set'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1744' u='c' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1750' u='c' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1866' u='c' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1895' u='c' c='drm_atomic_helper_commit_cleanup_done'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='705' u='c' c='drm_send_event_locked'/>
<def f='linux-4.14.y/kernel/sched/completion.c' l='65' ll='73' type='void complete_all(struct completion * x)'/>
<dec f='linux-4.14.y/kernel/sched/completion.c' l='74' type='void complete_all(struct completion * )'/>
<use f='linux-4.14.y/kernel/sched/completion.c' l='74' c='complete_all'/>
<use f='linux-4.14.y/kernel/sched/completion.c' l='74' u='a'/>
<use f='linux-4.14.y/kernel/sched/completion.c' l='74' u='a'/>
<doc f='linux-4.14.y/kernel/sched/completion.c' l='49'>/**
 * complete_all: - signals all threads waiting on this completion
 * @x:  holds the state of this particular completion
 *
 * This will wake up all threads waiting on this particular completion event.
 *
 * It may be assumed that this function implies a write memory barrier before
 * changing the task state if and only if any tasks are woken up.
 *
 * Since complete_all() sets the completion of @x permanently to done
 * to allow multiple waiters to finish, a call to reinit_completion()
 * must be used on @x if @x is to be used again. The code must make
 * sure that all waiters have woken and finished before reinitializing
 * @x. Also note that the function completion_done() can not be used
 * to know if there are still waiters after complete_all() has been called.
 */</doc>
