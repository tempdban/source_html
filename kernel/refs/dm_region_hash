<def f='linux-4.14.y/drivers/md/dm-region-hash.c' l='57' ll='99'/>
<size>208</size>
<doc f='linux-4.14.y/drivers/md/dm-region-hash.c' l='21'>/*-----------------------------------------------------------------
 * Region hash
 *
 * The mirror splits itself up into discrete regions.  Each
 * region can be in one of three states: clean, dirty,
 * nosync.  There is no need to put clean regions in the hash.
 *
 * In addition to being present in the hash table a region _may_
 * be present on one of three lists.
 *
 *   clean_regions: Regions on this list have no io pending to
 *   them, they are in sync, we are no longer interested in them,
 *   they are dull.  dm_rh_update_states() will remove them from the
 *   hash table.
 *
 *   quiesced_regions: These regions have been spun down, ready
 *   for recovery.  rh_recovery_start() will remove regions from
 *   this list and hand them to kmirrord, which will schedule the
 *   recovery io with kcopyd.
 *
 *   recovered_regions: Regions that kcopyd has successfully
 *   recovered.  dm_rh_update_states() will now schedule any delayed
 *   io, up the recovery_count, and remove the region from the
 *   hash.
 *
 * There are 2 locks:
 *   A rw spin lock &apos;hash_lock&apos; protects just the hash table,
 *   this is never held in write mode from interrupt context,
 *   which I believe means that we only have to disable irqs when
 *   doing a write lock.
 *
 *   An ordinary spin lock &apos;region_lock&apos; that protects the three
 *   lists in the region_hash, with the &apos;state&apos;, &apos;list&apos; and
 *   &apos;delayed_bios&apos; fields of the regions.  This is used from irq
 *   context, so all other uses will have to suspend local irqs.
 *---------------------------------------------------------------*/</doc>
<mbr r='dm_region_hash::region_size' o='0' t='uint32_t'/>
<mbr r='dm_region_hash::region_shift' o='32' t='unsigned int'/>
<mbr r='dm_region_hash::log' o='64' t='struct dm_dirty_log *'/>
<mbr r='dm_region_hash::hash_lock' o='128' t='rwlock_t'/>
<mbr r='dm_region_hash::region_pool' o='192' t='mempool_t *'/>
<mbr r='dm_region_hash::mask' o='256' t='unsigned int'/>
<mbr r='dm_region_hash::nr_buckets' o='288' t='unsigned int'/>
<mbr r='dm_region_hash::prime' o='320' t='unsigned int'/>
<mbr r='dm_region_hash::shift' o='352' t='unsigned int'/>
<mbr r='dm_region_hash::buckets' o='384' t='struct list_head *'/>
<mbr r='dm_region_hash::max_recovery' o='448' t='unsigned int'/>
<mbr r='dm_region_hash::region_lock' o='480' t='spinlock_t'/>
<mbr r='dm_region_hash::recovery_in_flight' o='512' t='atomic_t'/>
<mbr r='dm_region_hash::recovery_count' o='576' t='struct semaphore'/>
<mbr r='dm_region_hash::clean_regions' o='768' t='struct list_head'/>
<mbr r='dm_region_hash::quiesced_regions' o='896' t='struct list_head'/>
<mbr r='dm_region_hash::recovered_regions' o='1024' t='struct list_head'/>
<mbr r='dm_region_hash::failed_recovered_regions' o='1152' t='struct list_head'/>
<mbr r='dm_region_hash::flush_failure' o='1280' t='int'/>
<mbr r='dm_region_hash::context' o='1344' t='void *'/>
<mbr r='dm_region_hash::target_begin' o='1408' t='sector_t'/>
<mbr r='dm_region_hash::dispatch_bios' o='1472' t='void (*)(void *, struct bio_list *)'/>
<mbr r='dm_region_hash::wakeup_workers' o='1536' t='void (*)(void *)'/>
<mbr r='dm_region_hash::wakeup_all_recovery_waiters' o='1600' t='void (*)(void *)'/>
<def f='linux-4.14.y/drivers/md/dm-region-hash.c' l='57' ll='99'/>
<size>208</size>
<doc f='linux-4.14.y/drivers/md/dm-region-hash.c' l='21'>/*-----------------------------------------------------------------
 * Region hash
 *
 * The mirror splits itself up into discrete regions.  Each
 * region can be in one of three states: clean, dirty,
 * nosync.  There is no need to put clean regions in the hash.
 *
 * In addition to being present in the hash table a region _may_
 * be present on one of three lists.
 *
 *   clean_regions: Regions on this list have no io pending to
 *   them, they are in sync, we are no longer interested in them,
 *   they are dull.  dm_rh_update_states() will remove them from the
 *   hash table.
 *
 *   quiesced_regions: These regions have been spun down, ready
 *   for recovery.  rh_recovery_start() will remove regions from
 *   this list and hand them to kmirrord, which will schedule the
 *   recovery io with kcopyd.
 *
 *   recovered_regions: Regions that kcopyd has successfully
 *   recovered.  dm_rh_update_states() will now schedule any delayed
 *   io, up the recovery_count, and remove the region from the
 *   hash.
 *
 * There are 2 locks:
 *   A rw spin lock &apos;hash_lock&apos; protects just the hash table,
 *   this is never held in write mode from interrupt context,
 *   which I believe means that we only have to disable irqs when
 *   doing a write lock.
 *
 *   An ordinary spin lock &apos;region_lock&apos; that protects the three
 *   lists in the region_hash, with the &apos;state&apos;, &apos;list&apos; and
 *   &apos;delayed_bios&apos; fields of the regions.  This is used from irq
 *   context, so all other uses will have to suspend local irqs.
 *---------------------------------------------------------------*/</doc>
<mbr r='dm_region_hash::region_size' o='0' t='uint32_t'/>
<mbr r='dm_region_hash::region_shift' o='32' t='unsigned int'/>
<mbr r='dm_region_hash::log' o='64' t='struct dm_dirty_log *'/>
<mbr r='dm_region_hash::hash_lock' o='128' t='rwlock_t'/>
<mbr r='dm_region_hash::region_pool' o='192' t='mempool_t *'/>
<mbr r='dm_region_hash::mask' o='256' t='unsigned int'/>
<mbr r='dm_region_hash::nr_buckets' o='288' t='unsigned int'/>
<mbr r='dm_region_hash::prime' o='320' t='unsigned int'/>
<mbr r='dm_region_hash::shift' o='352' t='unsigned int'/>
<mbr r='dm_region_hash::buckets' o='384' t='struct list_head *'/>
<mbr r='dm_region_hash::max_recovery' o='448' t='unsigned int'/>
<mbr r='dm_region_hash::region_lock' o='480' t='spinlock_t'/>
<mbr r='dm_region_hash::recovery_in_flight' o='512' t='atomic_t'/>
<mbr r='dm_region_hash::recovery_count' o='576' t='struct semaphore'/>
<mbr r='dm_region_hash::clean_regions' o='768' t='struct list_head'/>
<mbr r='dm_region_hash::quiesced_regions' o='896' t='struct list_head'/>
<mbr r='dm_region_hash::recovered_regions' o='1024' t='struct list_head'/>
<mbr r='dm_region_hash::failed_recovered_regions' o='1152' t='struct list_head'/>
<mbr r='dm_region_hash::flush_failure' o='1280' t='int'/>
<mbr r='dm_region_hash::context' o='1344' t='void *'/>
<mbr r='dm_region_hash::target_begin' o='1408' t='sector_t'/>
<mbr r='dm_region_hash::dispatch_bios' o='1472' t='void (*)(void *, struct bio_list *)'/>
<mbr r='dm_region_hash::wakeup_workers' o='1536' t='void (*)(void *)'/>
<mbr r='dm_region_hash::wakeup_all_recovery_waiters' o='1600' t='void (*)(void *)'/>
