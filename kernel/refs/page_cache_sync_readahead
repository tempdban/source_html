<dec f='linux-4.18.y/include/linux/mm.h' l='2383' type='void page_cache_sync_readahead(struct address_space * mapping, struct file_ra_state * ra, struct file * filp, unsigned long offset, unsigned long size)'/>
<use f='linux-4.18.y/fs/ext4/dir.c' l='164' u='c' c='ext4_readdir'/>
<use f='linux-4.18.y/fs/f2fs/dir.c' l='874' u='c' c='f2fs_readdir'/>
<use f='linux-4.18.y/mm/filemap.c' l='2092' u='c' c='generic_file_buffered_read'/>
<use f='linux-4.18.y/mm/filemap.c' l='2422' u='c' c='do_sync_mmap_readahead'/>
<def f='linux-4.18.y/mm/readahead.c' l='508' ll='524' type='void page_cache_sync_readahead(struct address_space * mapping, struct file_ra_state * ra, struct file * filp, unsigned long offset, unsigned long req_size)'/>
<dec f='linux-4.18.y/mm/readahead.c' l='525' type='void page_cache_sync_readahead(struct address_space * , struct file_ra_state * , struct file * , unsigned long , unsigned long )'/>
<use f='linux-4.18.y/mm/readahead.c' l='525' c='page_cache_sync_readahead'/>
<use f='linux-4.18.y/mm/readahead.c' l='525' u='a'/>
<use f='linux-4.18.y/mm/readahead.c' l='525' u='a'/>
<doc f='linux-4.18.y/mm/readahead.c' l='494'>/**
 * page_cache_sync_readahead - generic file readahead
 * @mapping: address_space which holds the pagecache and I/O vectors
 * @ra: file_ra_state which holds the readahead state
 * @filp: passed on to -&gt;readpage() and -&gt;readpages()
 * @offset: start offset into @mapping, in pagecache page-sized units
 * @req_size: hint: total size of the read which the caller is performing in
 *            pagecache pages
 *
 * page_cache_sync_readahead() should be called when a cache miss happened:
 * it will submit the read.  The readahead logic may decide to piggyback more
 * pages onto the read request if access patterns suggest it will improve
 * performance.
 */</doc>
