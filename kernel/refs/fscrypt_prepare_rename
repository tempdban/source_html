<def f='linux-4.18.y/include/linux/fscrypt.h' l='125' ll='135' type='int fscrypt_prepare_rename(struct inode * old_dir, struct dentry * old_dentry, struct inode * new_dir, struct dentry * new_dentry, unsigned int flags)'/>
<doc f='linux-4.18.y/include/linux/fscrypt.h' l='104'>/**
 * fscrypt_prepare_rename - prepare for a rename between possibly-encrypted directories
 * @old_dir: source directory
 * @old_dentry: dentry for source file
 * @new_dir: target directory
 * @new_dentry: dentry for target location (may be negative unless exchanging)
 * @flags: rename flags (we care at least about %RENAME_EXCHANGE)
 *
 * Prepare for -&gt;rename() where the source and/or target directories may be
 * encrypted.  A new link can only be added to an encrypted directory if the
 * directory&apos;s encryption key is available --- since otherwise we&apos;d have no way
 * to encrypt the filename.  A rename to an existing name, on the other hand,
 * *is* cryptographically possible without the key.  However, we take the more
 * conservative approach and just forbid all no-key renames.
 *
 * We also verify that the rename will not violate the constraint that all files
 * in an encrypted directory tree use the same encryption policy.
 *
 * Return: 0 on success, -ENOKEY if an encryption key is missing, -EPERM if the
 * rename would cause inconsistent encryption policies, or another -errno code.
 */</doc>
<use f='linux-4.18.y/fs/ext4/namei.c' l='3819' u='c' c='ext4_rename2'/>
<use f='linux-4.18.y/fs/f2fs/namei.c' l='1165' u='c' c='f2fs_rename2'/>
