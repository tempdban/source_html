<dec f='linux-4.18.y/fs/ntfs/runlist.h' l='90' type='int ntfs_mapping_pairs_build(const ntfs_volume * vol, s8 * dst, const int dst_len, const runlist_element * rl, const VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='1704' u='c' c='ntfs_attr_make_non_resident'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='2302' u='c' c='ntfs_attr_extend_allocation'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='2446' u='c' c='ntfs_attr_extend_allocation'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='1116' u='c' c='ntfs_prepare_pages_for_non_resident_write'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='1313' u='c' c='ntfs_prepare_pages_for_non_resident_write'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='2747' u='c' c='ntfs_truncate'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1453' u='c' c='ntfs_mft_bitmap_extend_allocation_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1539' u='c' c='ntfs_mft_bitmap_extend_allocation_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1890' u='c' c='ntfs_mft_data_extend_allocation_nolock'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1971' u='c' c='ntfs_mft_data_extend_allocation_nolock'/>
<def f='linux-4.18.y/fs/ntfs/runlist.c' l='1323' ll='1473' type='int ntfs_mapping_pairs_build(const ntfs_volume * vol, s8 * dst, const int dst_len, const runlist_element * rl, const VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)'/>
<doc f='linux-4.18.y/fs/ntfs/runlist.c' l='1285'>/**
 * ntfs_mapping_pairs_build - build the mapping pairs array from a runlist
 * @vol:	ntfs volume (needed for the ntfs version)
 * @dst:	destination buffer to which to write the mapping pairs array
 * @dst_len:	size of destination buffer @dst in bytes
 * @rl:		locked runlist for which to build the mapping pairs array
 * @first_vcn:	first vcn which to include in the mapping pairs array
 * @last_vcn:	last vcn which to include in the mapping pairs array
 * @stop_vcn:	first vcn outside destination buffer on success or -ENOSPC
 *
 * Create the mapping pairs array from the locked runlist @rl, starting at vcn
 * @first_vcn and finishing with vcn @last_vcn and save the array in @dst.
 * @dst_len is the size of @dst in bytes and it should be at least equal to the
 * value obtained by calling ntfs_get_size_for_mapping_pairs().
 *
 * A @last_vcn of -1 means end of runlist and in that case the mapping pairs
 * array corresponding to the runlist starting at vcn @first_vcn and finishing
 * at the end of the runlist is created.
 *
 * If @rl is NULL, just write a single terminator byte to @dst.
 *
 * On success or -ENOSPC error, if @stop_vcn is not NULL, *@stop_vcn is set to
 * the first vcn outside the destination buffer.  Note that on error, @dst has
 * been filled with all the mapping pairs that will fit, thus it can be treated
 * as partial success, in that a new attribute extent needs to be created or
 * the next extent has to be used and the mapping pairs build has to be
 * continued with @first_vcn set to *@stop_vcn.
 *
 * Return 0 on success and -errno on error.  The following error codes are
 * defined:
 *	-EINVAL	- Run list contains unmapped elements.  Make sure to only pass
 *		  fully mapped runlists to this function.
 *	-EIO	- The runlist is corrupt.
 *	-ENOSPC	- The destination buffer is too small.
 *
 * Locking: @rl must be locked on entry (either for reading or writing), it
 *	    remains locked throughout, and is left locked upon return.
 */</doc>
