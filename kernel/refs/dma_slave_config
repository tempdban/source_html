<def f='linux-4.14.y/include/linux/dmaengine.h' l='367' ll='379'/>
<size>56</size>
<doc f='linux-4.14.y/include/linux/dmaengine.h' l='316'>/**
 * struct dma_slave_config - dma slave channel runtime config
 * @direction: whether the data shall go in or out on this slave
 * channel, right now. DMA_MEM_TO_DEV and DMA_DEV_TO_MEM are
 * legal values. DEPRECATED, drivers should use the direction argument
 * to the device_prep_slave_sg and device_prep_dma_cyclic functions or
 * the dir field in the dma_interleaved_template structure.
 * @src_addr: this is the physical address where DMA slave data
 * should be read (RX), if the source is memory this argument is
 * ignored.
 * @dst_addr: this is the physical address where DMA slave data
 * should be written (TX), if the source is memory this argument
 * is ignored.
 * @src_addr_width: this is the width in bytes of the source (RX)
 * register where DMA data shall be read. If the source
 * is memory this may be ignored depending on architecture.
 * Legal values: 1, 2, 4, 8.
 * @dst_addr_width: same as src_addr_width but for destination
 * target (TX) mutatis mutandis.
 * @src_maxburst: the maximum number of words (note: words, as in
 * units of the src_addr_width member, not bytes) that can be sent
 * in one burst to the device. Typically something like half the
 * FIFO depth on I/O peripherals so you don&apos;t overflow it. This
 * may or may not be applicable on memory sources.
 * @dst_maxburst: same as src_maxburst but for destination target
 * mutatis mutandis.
 * @src_port_window_size: The length of the register area in words the data need
 * to be accessed on the device side. It is only used for devices which is using
 * an area instead of a single register to receive the data. Typically the DMA
 * loops in this area in order to transfer the data.
 * @dst_port_window_size: same as src_port_window_size but for the destination
 * port.
 * @device_fc: Flow Controller Settings. Only valid for slave channels. Fill
 * with &apos;true&apos; if peripheral should be flow controller. Direction will be
 * selected at Runtime.
 * @slave_id: Slave requester id. Only valid for slave channels. The dma
 * slave peripheral will have unique id as dma requester which need to be
 * pass as slave config.
 *
 * This struct is passed in as configuration data to a DMA engine
 * in order to set up a certain channel for DMA transport at runtime.
 * The DMA device/engine has to provide support for an additional
 * callback in the dma_device structure, device_config and this struct
 * will then be passed in as an argument to the function.
 *
 * The rationale for adding configuration information to this struct is as
 * follows: if it is likely that more than one DMA slave controllers in
 * the world will support the configuration option, then make it generic.
 * If not: if it is fixed so that it be sent in static from the platform
 * data, then prefer to do that.
 */</doc>
<mbr r='dma_slave_config::direction' o='0' t='enum dma_transfer_direction'/>
<mbr r='dma_slave_config::src_addr' o='64' t='phys_addr_t'/>
<mbr r='dma_slave_config::dst_addr' o='128' t='phys_addr_t'/>
<mbr r='dma_slave_config::src_addr_width' o='192' t='enum dma_slave_buswidth'/>
<mbr r='dma_slave_config::dst_addr_width' o='224' t='enum dma_slave_buswidth'/>
<mbr r='dma_slave_config::src_maxburst' o='256' t='u32'/>
<mbr r='dma_slave_config::dst_maxburst' o='288' t='u32'/>
<mbr r='dma_slave_config::src_port_window_size' o='320' t='u32'/>
<mbr r='dma_slave_config::dst_port_window_size' o='352' t='u32'/>
<mbr r='dma_slave_config::device_fc' o='384' t='bool'/>
<mbr r='dma_slave_config::slave_id' o='416' t='unsigned int'/>
