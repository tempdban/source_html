<def f='linux-4.18.y/include/drm/ttm/ttm_bo_driver.h' l='623' ll='645' type='int __ttm_bo_reserve(struct ttm_buffer_object * bo, bool interruptible, bool no_wait, struct ww_acquire_ctx * ticket)'/>
<use f='linux-4.18.y/include/drm/ttm/ttm_bo_driver.h' l='699' u='c' c='ttm_bo_reserve'/>
<doc f='linux-4.18.y/include/drm/ttm/ttm_bo_driver.h' l='602'>/**
 * __ttm_bo_reserve:
 *
 * @bo: A pointer to a struct ttm_buffer_object.
 * @interruptible: Sleep interruptible if waiting.
 * @no_wait: Don&apos;t sleep while trying to reserve, rather return -EBUSY.
 * @ticket: ticket used to acquire the ww_mutex.
 *
 * Will not remove reserved buffers from the lru lists.
 * Otherwise identical to ttm_bo_reserve.
 *
 * Returns:
 * -EDEADLK: The reservation may cause a deadlock.
 * Release all buffer reservations, wait for @bo to become unreserved and
 * try again. (only if use_sequence == 1).
 * -ERESTARTSYS: A wait for the buffer to become unreserved was interrupted by
 * a signal. Release all buffer reservations and return to user-space.
 * -EBUSY: The function needed to sleep, but @no_wait was true
 * -EALREADY: Bo already reserved using @ticket. This error code will only
 * be returned if @use_ticket is set to true.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/ttm/ttm_execbuf_util.c' l='114' u='c' c='ttm_eu_reserve_buffers'/>
