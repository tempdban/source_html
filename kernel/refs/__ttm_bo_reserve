<def f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='828' ll='850' type='int __ttm_bo_reserve(struct ttm_buffer_object * bo, bool interruptible, bool no_wait, struct ww_acquire_ctx * ticket)'/>
<use f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='904' u='c' c='ttm_bo_reserve'/>
<doc f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='807'>/**
 * __ttm_bo_reserve:
 *
 * @bo: A pointer to a struct ttm_buffer_object.
 * @interruptible: Sleep interruptible if waiting.
 * @no_wait: Don&apos;t sleep while trying to reserve, rather return -EBUSY.
 * @ticket: ticket used to acquire the ww_mutex.
 *
 * Will not remove reserved buffers from the lru lists.
 * Otherwise identical to ttm_bo_reserve.
 *
 * Returns:
 * -EDEADLK: The reservation may cause a deadlock.
 * Release all buffer reservations, wait for @bo to become unreserved and
 * try again. (only if use_sequence == 1).
 * -ERESTARTSYS: A wait for the buffer to become unreserved was interrupted by
 * a signal. Release all buffer reservations and return to user-space.
 * -EBUSY: The function needed to sleep, but @no_wait was true
 * -EALREADY: Bo already reserved using @ticket. This error code will only
 * be returned if @use_ticket is set to true.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='452' u='c' c='ttm_bo_cleanup_refs_or_queue'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='535' u='c' c='ttm_bo_cleanup_refs_and_unlock'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='595' u='c' c='ttm_bo_delayed_delete'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='598' u='c' c='ttm_bo_delayed_delete'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='747' u='c' c='ttm_mem_evict_first'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='1722' u='c' c='ttm_bo_swapout'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='1826' u='c' c='ttm_bo_wait_unreserved'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_execbuf_util.c' l='113' u='c' c='ttm_eu_reserve_buffers'/>
<def f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='828' ll='850' type='int __ttm_bo_reserve(struct ttm_buffer_object * bo, bool interruptible, bool no_wait, struct ww_acquire_ctx * ticket)'/>
<use f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='904' u='c' c='ttm_bo_reserve'/>
<doc f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='807'>/**
 * __ttm_bo_reserve:
 *
 * @bo: A pointer to a struct ttm_buffer_object.
 * @interruptible: Sleep interruptible if waiting.
 * @no_wait: Don&apos;t sleep while trying to reserve, rather return -EBUSY.
 * @ticket: ticket used to acquire the ww_mutex.
 *
 * Will not remove reserved buffers from the lru lists.
 * Otherwise identical to ttm_bo_reserve.
 *
 * Returns:
 * -EDEADLK: The reservation may cause a deadlock.
 * Release all buffer reservations, wait for @bo to become unreserved and
 * try again. (only if use_sequence == 1).
 * -ERESTARTSYS: A wait for the buffer to become unreserved was interrupted by
 * a signal. Release all buffer reservations and return to user-space.
 * -EBUSY: The function needed to sleep, but @no_wait was true
 * -EALREADY: Bo already reserved using @ticket. This error code will only
 * be returned if @use_ticket is set to true.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='452' u='c' c='ttm_bo_cleanup_refs_or_queue'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='535' u='c' c='ttm_bo_cleanup_refs_and_unlock'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='595' u='c' c='ttm_bo_delayed_delete'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='598' u='c' c='ttm_bo_delayed_delete'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='747' u='c' c='ttm_mem_evict_first'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='1722' u='c' c='ttm_bo_swapout'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='1826' u='c' c='ttm_bo_wait_unreserved'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_execbuf_util.c' l='113' u='c' c='ttm_eu_reserve_buffers'/>
