<dec f='linux-4.18.y/include/linux/kernfs.h' l='340' type='void kernfs_activate(struct kernfs_node * kn)'/>
<use f='linux-4.18.y/fs/kernfs/dir.c' l='796' u='c' c='kernfs_add_one'/>
<use f='linux-4.18.y/fs/kernfs/dir.c' l='965' u='c' c='kernfs_create_root'/>
<def f='linux-4.18.y/fs/kernfs/dir.c' l='1233' ll='1252' type='void kernfs_activate(struct kernfs_node * kn)'/>
<doc f='linux-4.18.y/fs/kernfs/dir.c' l='1220'>/**
 * kernfs_activate - activate a node which started deactivated
 * @kn: kernfs_node whose subtree is to be activated
 *
 * If the root has KERNFS_ROOT_CREATE_DEACTIVATED set, a newly created node
 * needs to be explicitly activated.  A node which hasn&apos;t been activated
 * isn&apos;t visible to userland and deactivation is skipped during its
 * removal.  This is useful to construct atomic init sequences where
 * creation of multiple nodes should either succeed or fail atomically.
 *
 * The caller is responsible for ensuring that this function is not called
 * after kernfs_remove*() is invoked on @kn.
 */</doc>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1706' u='c' c='rebind_subsystems'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1977' u='c' c='cgroup_setup_root'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='3177' u='c' c='cgroup_subtree_control_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='3653' u='c' c='cgroup_apply_cftypes'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='4983' u='c' c='cgroup_mkdir'/>
