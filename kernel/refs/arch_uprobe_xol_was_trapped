<dec f='linux-4.18.y/include/linux/uprobes.h' l='144' type='bool arch_uprobe_xol_was_trapped(struct task_struct * tsk)'/>
<def f='linux-4.18.y/arch/x86/kernel/uprobes.c' l='953' ll='959' type='bool arch_uprobe_xol_was_trapped(struct task_struct * t)'/>
<doc f='linux-4.18.y/arch/x86/kernel/uprobes.c' l='943'>/*
 * If xol insn itself traps and generates a signal(Say,
 * SIGILL/SIGSEGV/etc), then detect the case where a singlestepped
 * instruction jumps back to its own address. It is assumed that anything
 * like do_page_fault/do_trap/etc sets thread.trap_nr != -1.
 *
 * arch_uprobe_pre_xol/arch_uprobe_post_xol save/restore thread.trap_nr,
 * arch_uprobe_xol_was_trapped() simply checks that -&gt;trap_nr is not equal to
 * UPROBE_TRAP_NR == -1 set by arch_uprobe_pre_xol().
 */</doc>
<use f='linux-4.18.y/kernel/events/uprobes.c' l='1672' u='c' c='uprobe_deny_signal'/>
