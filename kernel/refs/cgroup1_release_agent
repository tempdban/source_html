<dec f='linux-4.18.y/kernel/cgroup/cgroup-internal.h' l='225' type='void cgroup1_release_agent(struct work_struct * work)'/>
<def f='linux-4.18.y/kernel/cgroup/cgroup-v1.c' l='802' ll='840' type='void cgroup1_release_agent(struct work_struct * work)'/>
<doc f='linux-4.18.y/kernel/cgroup/cgroup-v1.c' l='779'>/*
 * Notify userspace when a cgroup is released, by running the
 * configured release agent with the name of the cgroup (path
 * relative to the root of cgroup file system) as the argument.
 *
 * Most likely, this user command will try to rmdir this cgroup.
 *
 * This races with the possibility that some other task will be
 * attached to this cgroup before it is removed, or that some other
 * user task will &apos;mkdir&apos; a child cgroup of this cgroup.  That&apos;s ok.
 * The presumed &apos;rmdir&apos; will fail quietly if this cgroup is no longer
 * unused, and this cgroup will be reprieved from its death sentence,
 * to continue to serve a useful existence.  Next time it&apos;s released,
 * we will get notified again, if it still has &apos;notify_on_release&apos; set.
 *
 * The final arg to call_usermodehelper() is UMH_WAIT_EXEC, which
 * means only wait until the task is successfully execve()&apos;d.  The
 * separate release agent task is forked by call_usermodehelper(),
 * then control in this thread returns here, without waiting for the
 * release agent task.  We don&apos;t bother to wait because the caller of
 * this routine has no use for the exit status of the release agent
 * task, so no sense holding our caller up for that.
 */</doc>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1870' u='r' c='init_cgroup_housekeeping'/>
