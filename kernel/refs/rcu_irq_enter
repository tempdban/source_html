<dec f='linux-4.14.y/include/linux/rcutree.h' l='84' type='void rcu_irq_enter()'/>
<def f='linux-4.14.y/kernel/rcu/tree.c' l='1016' ll='1036' type='void rcu_irq_enter()'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='1046' u='c' c='rcu_irq_enter_irqson'/>
<doc f='linux-4.14.y/kernel/rcu/tree.c' l='997'>/**
 * rcu_irq_enter - inform RCU that current CPU is entering irq away from idle
 *
 * Enter an interrupt handler, which might possibly result in exiting
 * idle mode, in other words, entering the mode in which read-side critical
 * sections can occur.  The caller must have disabled interrupts.
 *
 * Note that the Linux kernel is fully capable of entering an interrupt
 * handler that it never exits, for example when doing upcalls to
 * user mode!  This code assumes that the idle loop never does upcalls to
 * user mode.  If your architecture does do upcalls from the idle loop (or
 * does anything else that results in unbalanced calls to the irq_enter()
 * and irq_exit() functions), RCU will give you what you deserve, good
 * and hard.  But very infrequently and irreproducibly.
 *
 * Use things like work queues to work around this limitation.
 *
 * You have been warned.
 */</doc>
<use f='linux-4.14.y/kernel/softirq.c' l='338' u='c' c='irq_enter'/>
<dec f='linux-4.14.y/include/linux/rcutree.h' l='84' type='void rcu_irq_enter()'/>
<def f='linux-4.14.y/kernel/rcu/tree.c' l='1016' ll='1036' type='void rcu_irq_enter()'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='1046' u='c' c='rcu_irq_enter_irqson'/>
<doc f='linux-4.14.y/kernel/rcu/tree.c' l='997'>/**
 * rcu_irq_enter - inform RCU that current CPU is entering irq away from idle
 *
 * Enter an interrupt handler, which might possibly result in exiting
 * idle mode, in other words, entering the mode in which read-side critical
 * sections can occur.  The caller must have disabled interrupts.
 *
 * Note that the Linux kernel is fully capable of entering an interrupt
 * handler that it never exits, for example when doing upcalls to
 * user mode!  This code assumes that the idle loop never does upcalls to
 * user mode.  If your architecture does do upcalls from the idle loop (or
 * does anything else that results in unbalanced calls to the irq_enter()
 * and irq_exit() functions), RCU will give you what you deserve, good
 * and hard.  But very infrequently and irreproducibly.
 *
 * Use things like work queues to work around this limitation.
 *
 * You have been warned.
 */</doc>
<use f='linux-4.14.y/kernel/softirq.c' l='338' u='c' c='irq_enter'/>
