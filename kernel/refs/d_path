<dec f='linux-4.18.y/include/linux/dcache.h' l='302' type='char * d_path(const struct path * , char * , int )'/>
<def f='linux-4.18.y/fs/d_path.c' l='256' ll='285' type='char * d_path(const struct path * path, char * buf, int buflen)'/>
<dec f='linux-4.18.y/fs/d_path.c' l='286' type='char * d_path(const struct path * , char * , int )'/>
<use f='linux-4.18.y/fs/d_path.c' l='286' c='d_path'/>
<use f='linux-4.18.y/fs/d_path.c' l='286' u='a'/>
<use f='linux-4.18.y/fs/d_path.c' l='286' u='a'/>
<doc f='linux-4.18.y/fs/d_path.c' l='240'>/**
 * d_path - return the path of a dentry
 * @path: path to report
 * @buf: buffer to return value in
 * @buflen: buffer length
 *
 * Convert a dentry into an ASCII path name. If the entry has been deleted
 * the string &quot; (deleted)&quot; is appended. Note that this is ambiguous.
 *
 * Returns a pointer into the buffer or an error code if the path was
 * too long. Note: Callers should use the returned pointer, not the passed
 * in buffer, to use the name! The implementation often starts at an offset
 * into the buffer, and may leave 0 bytes at the start.
 *
 * &quot;buflen&quot; should be positive.
 */</doc>
<use f='linux-4.18.y/fs/ext4/file.c' l='409' u='c' c='ext4_sample_last_mounted'/>
<use f='linux-4.18.y/fs/open.c' l='889' u='c' c='file_path'/>
<use f='linux-4.18.y/fs/proc/base.c' l='1617' u='c' c='do_proc_readlink'/>
<use f='linux-4.18.y/fs/seq_file.c' l='471' u='c' c='seq_path'/>
<use f='linux-4.18.y/kernel/audit.c' l='2034' u='c' c='audit_log_d_path'/>
<use f='linux-4.18.y/lib/seq_buf.c' l='270' u='c' c='seq_buf_path'/>
