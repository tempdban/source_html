<dec f='linux-4.18.y/include/linux/usb/gadget.h' l='245' type='int usb_ep_queue(struct usb_ep * ep, struct usb_request * req, gfp_t gfp_flags)'/>
<use f='linux-4.18.y/drivers/usb/gadget/composite.c' l='1388' u='c' c='composite_ep0_queue'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_acm.c' l='410' u='c' c='acm_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_acm.c' l='518' u='c' c='acm_cdc_notify'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ecm.c' l='424' u='c' c='ecm_do_notify'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ecm.c' l='518' u='c' c='ecm_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_eem.c' l='450' u='c' c='eem_unwrap'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_fs.c' l='292' u='c' c='__ffs_ep0_queue_wait'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_fs.c' l='998' u='c' c='ffs_epfile_io'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_fs.c' l='1037' u='c' c='ffs_epfile_io'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_hid.c' l='302' u='c' c='f_hidg_read'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_hid.c' l='394' u='c' c='f_hidg_write'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_hid.c' l='602' u='c' c='hidg_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_hid.c' l='697' u='c' c='hidg_set_alt'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_loopback.c' l='264' u='c' c='loopback_complete'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_loopback.c' l='342' u='c' c='alloc_requests'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_mass_storage.c' l='422' u='c' c='ep0_queue'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_mass_storage.c' l='551' u='c' c='start_transfer'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ncm.c' l='597' u='c' c='ncm_do_notify'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ncm.c' l='851' u='c' c='ncm_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_printer.c' l='397' u='c' c='setup_rx_reqs'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_printer.c' l='638' u='c' c='printer_write'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_printer.c' l='1004' u='c' c='printer_func_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_rndis.c' l='402' u='c' c='rndis_response_available'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_rndis.c' l='439' u='c' c='rndis_response_complete'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_rndis.c' l='527' u='c' c='rndis_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_sourcesink.c' l='567' u='c' c='source_sink_complete'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_sourcesink.c' l='617' u='c' c='source_sink_start_ep'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_sourcesink.c' l='823' u='c' c='sourcesink_setup'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='236' u='c' c='rx_submit'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='582' u='c' c='eth_start_xmit'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_serial.c' l='271' u='c' c='gs_start_tx'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_serial.c' l='327' u='c' c='gs_start_rx'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_serial.c' l='1019' u='c' c='gs_console_thread'/>
<def f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='254' ll='270' type='int usb_ep_queue(struct usb_ep * ep, struct usb_request * req, gfp_t gfp_flags)'/>
<dec f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='271' type='int usb_ep_queue(struct usb_ep * , struct usb_request * , gfp_t )'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='271' c='usb_ep_queue'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='271' u='a'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='271' u='a'/>
<doc f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='188'>/**
 * usb_ep_queue - queues (submits) an I/O request to an endpoint.
 * @ep:the endpoint associated with the request
 * @req:the request being submitted
 * @gfp_flags: GFP_* flags to use in case the lower level driver couldn&apos;t
 *	pre-allocate all necessary memory with the request.
 *
 * This tells the device controller to perform the specified request through
 * that endpoint (reading or writing a buffer).  When the request completes,
 * including being canceled by usb_ep_dequeue(), the request&apos;s completion
 * routine is called to return the request to the driver.  Any endpoint
 * (except control endpoints like ep0) may have more than one transfer
 * request queued; they complete in FIFO order.  Once a gadget driver
 * submits a request, that request may not be examined or modified until it
 * is given back to that driver through the completion callback.
 *
 * Each request is turned into one or more packets.  The controller driver
 * never merges adjacent requests into the same packet.  OUT transfers
 * will sometimes use data that&apos;s already buffered in the hardware.
 * Drivers can rely on the fact that the first byte of the request&apos;s buffer
 * always corresponds to the first byte of some USB packet, for both
 * IN and OUT transfers.
 *
 * Bulk endpoints can queue any amount of data; the transfer is packetized
 * automatically.  The last packet will be short if the request doesn&apos;t fill it
 * out completely.  Zero length packets (ZLPs) should be avoided in portable
 * protocols since not all usb hardware can successfully handle zero length
 * packets.  (ZLPs may be explicitly written, and may be implicitly written if
 * the request &apos;zero&apos; flag is set.)  Bulk endpoints may also be used
 * for interrupt transfers; but the reverse is not true, and some endpoints
 * won&apos;t support every interrupt transfer.  (Such as 768 byte packets.)
 *
 * Interrupt-only endpoints are less functional than bulk endpoints, for
 * example by not supporting queueing or not handling buffers that are
 * larger than the endpoint&apos;s maxpacket size.  They may also treat data
 * toggle differently.
 *
 * Control endpoints ... after getting a setup() callback, the driver queues
 * one response (even if it would be zero length).  That enables the
 * status ack, after transferring data as specified in the response.  Setup
 * functions may return negative error codes to generate protocol stalls.
 * (Note that some USB device controllers disallow protocol stall responses
 * in some cases.)  When control responses are deferred (the response is
 * written after the setup callback returns), then usb_ep_set_halt() may be
 * used on ep0 to trigger protocol stalls.  Depending on the controller,
 * it may not be possible to trigger a status-stage protocol stall when the
 * data stage is over, that is, from within the response&apos;s completion
 * routine.
 *
 * For periodic endpoints, like interrupt or isochronous ones, the usb host
 * arranges to poll once per interval, and the gadget driver usually will
 * have queued some data to transfer at that time.
 *
 * Note that @req&apos;s -&gt;complete() callback must never be called from
 * within usb_ep_queue() as that can create deadlock situations.
 *
 * Returns zero, or a negative error code.  Endpoints that are not enabled
 * report errors; errors will also be
 * reported when the usb peripheral is disconnected.
 *
 * If and only if @req is successfully queued (the return value is zero),
 * @req-&gt;complete() will be called exactly once, when the Gadget core and
 * UDC are finished with the request.  When the completion function is called,
 * control of the request is returned to the device driver which submitted it.
 * The completion handler may then immediately free or reuse @req.
 */</doc>
