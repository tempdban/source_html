<dec f='linux-4.14.y/drivers/usb/core/hub.h' l='123' type='int hub_port_debounce(struct usb_hub * hub, int port1, bool must_be_connected)'/>
<use f='linux-4.14.y/drivers/usb/core/hub.h' l='161' u='c' c='hub_port_debounce_be_connected'/>
<use f='linux-4.14.y/drivers/usb/core/hub.h' l='167' u='c' c='hub_port_debounce_be_stable'/>
<def f='linux-4.14.y/drivers/usb/core/hub.c' l='4214' ll='4255' type='int hub_port_debounce(struct usb_hub * hub, int port1, bool must_be_connected)'/>
<doc f='linux-4.14.y/drivers/usb/core/hub.c' l='4199'>/* USB 2.0 spec, 7.1.7.3 / fig 7-29:
 *
 * Between connect detection and reset signaling there must be a delay
 * of 100ms at least for debounce and power-settling.  The corresponding
 * timer shall restart whenever the downstream port detects a disconnect.
 *
 * Apparently there are some bluetooth and irda-dongles and a number of
 * low-speed devices for which this debounce period may last over a second.
 * Not covered by the spec - but easy to deal with.
 *
 * This implementation uses a 1500ms total debounce timeout; if the
 * connection isn&apos;t stable by then it returns -ETIMEDOUT.  It checks
 * every 25ms for transient disconnects.  When the port status has been
 * unchanged for 100ms it returns the port status.
 */</doc>
