<dec f='linux-4.18.y/include/linux/irqdomain.h' l='251' type='struct irq_domain * irq_domain_add_simple(struct device_node * of_node, unsigned int size, unsigned int first_irq, const struct irq_domain_ops * ops, void * host_data)'/>
<def f='linux-4.18.y/kernel/irq/irqdomain.c' l='316' ll='341' type='struct irq_domain * irq_domain_add_simple(struct device_node * of_node, unsigned int size, unsigned int first_irq, const struct irq_domain_ops * ops, void * host_data)'/>
<dec f='linux-4.18.y/kernel/irq/irqdomain.c' l='342' type='struct irq_domain * irq_domain_add_simple(struct device_node * , unsigned int , unsigned int , const struct irq_domain_ops * , void * )'/>
<use f='linux-4.18.y/kernel/irq/irqdomain.c' l='342' c='irq_domain_add_simple'/>
<use f='linux-4.18.y/kernel/irq/irqdomain.c' l='342' u='a'/>
<use f='linux-4.18.y/kernel/irq/irqdomain.c' l='342' u='a'/>
<doc f='linux-4.18.y/kernel/irq/irqdomain.c' l='298'>/**
 * irq_domain_add_simple() - Register an irq_domain and optionally map a range of irqs
 * @of_node: pointer to interrupt controller&apos;s device tree node.
 * @size: total number of irqs in mapping
 * @first_irq: first number of irq block assigned to the domain,
 *	pass zero to assign irqs on-the-fly. If first_irq is non-zero, then
 *	pre-map all of the irqs in the domain to virqs starting at first_irq.
 * @ops: domain callbacks
 * @host_data: Controller private data pointer
 *
 * Allocates an irq_domain, and optionally if first_irq is positive then also
 * allocate irq_descs and map all of the hwirqs to virqs starting at first_irq.
 *
 * This is intended to implement the expected behaviour for most
 * interrupt controllers. If device tree is used, then first_irq will be 0 and
 * irqs get mapped dynamically on the fly. However, if the controller requires
 * static virq assignments (non-DT boot) then it will set that up correctly.
 */</doc>
