<def f='linux-4.18.y/include/linux/rmap.h' l='29' ll='62'/>
<size>80</size>
<doc f='linux-4.18.y/include/linux/rmap.h' l='15'>/*
 * The anon_vma heads a list of private &quot;related&quot; vmas, to scan if
 * an anonymous page pointing to this anon_vma needs to be unmapped:
 * the vmas on the list will be related by forking, or by splitting.
 *
 * Since vmas come and go as they are split and merged (particularly
 * in mprotect), the mapping field of an anonymous page cannot point
 * directly to a vma: instead it points to an anon_vma, on whose list
 * the related vmas can be easily linked or unlinked.
 *
 * After unlinking the last vma on the list, we must garbage collect
 * the anon_vma object itself: we&apos;re guaranteed no page can be
 * pointing to this anon_vma once its vma list is empty.
 */</doc>
<mbr r='anon_vma::root' o='0' t='struct anon_vma *'/>
<mbr r='anon_vma::rwsem' o='64' t='struct rw_semaphore'/>
<mbr r='anon_vma::refcount' o='384' t='atomic_t'/>
<mbr r='anon_vma::degree' o='416' t='unsigned int'/>
<mbr r='anon_vma::parent' o='448' t='struct anon_vma *'/>
<mbr r='anon_vma::rb_root' o='512' t='struct rb_root_cached'/>
