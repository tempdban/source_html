<dec f='linux-4.18.y/include/linux/kthread.h' l='182' type='bool kthread_queue_work(struct kthread_worker * worker, struct kthread_work * work)'/>
<use f='linux-4.18.y/arch/x86/kvm/i8254.c' l='215' u='c' c='kvm_pit_ack_irq'/>
<use f='linux-4.18.y/arch/x86/kvm/i8254.c' l='275' u='c' c='pit_timer_fn'/>
<use f='linux-4.18.y/drivers/block/loop.c' l='1770' u='c' c='loop_queue_rq'/>
<use f='linux-4.18.y/drivers/md/dm-rq.c' l='690' u='c' c='dm_old_request_fn'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='1156' u='c' c='__spi_pump_messages'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='1170' u='c' c='__spi_pump_messages'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='1375' u='c' c='spi_finalize_current_message'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='1401' u='c' c='spi_start_queue'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='1481' u='c' c='__spi_queued_transfer'/>
<def f='linux-4.18.y/kernel/kthread.c' l='807' ll='820' type='bool kthread_queue_work(struct kthread_worker * worker, struct kthread_work * work)'/>
<dec f='linux-4.18.y/kernel/kthread.c' l='821' type='bool kthread_queue_work(struct kthread_worker * , struct kthread_work * )'/>
<use f='linux-4.18.y/kernel/kthread.c' l='821' c='kthread_queue_work'/>
<use f='linux-4.18.y/kernel/kthread.c' l='821' u='a'/>
<use f='linux-4.18.y/kernel/kthread.c' l='821' u='a'/>
<use f='linux-4.18.y/kernel/kthread.c' l='1153' u='c' c='kthread_flush_worker'/>
<doc f='linux-4.18.y/kernel/kthread.c' l='795'>/**
 * kthread_queue_work - queue a kthread_work
 * @worker: target kthread_worker
 * @work: kthread_work to queue
 *
 * Queue @work to work processor @task for async execution.  @task
 * must have been created with kthread_worker_create().  Returns %true
 * if @work was successfully queued, %false if it was already pending.
 *
 * Reinitialize the work if it needs to be used by another worker.
 * For example, when the worker was stopped and started again.
 */</doc>
