<def f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='896' ll='909' type='int ttm_bo_reserve(struct ttm_buffer_object * bo, bool interruptible, bool no_wait, struct ww_acquire_ctx * ticket)'/>
<doc f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='852'>/**
 * ttm_bo_reserve:
 *
 * @bo: A pointer to a struct ttm_buffer_object.
 * @interruptible: Sleep interruptible if waiting.
 * @no_wait: Don&apos;t sleep while trying to reserve, rather return -EBUSY.
 * @ticket: ticket used to acquire the ww_mutex.
 *
 * Locks a buffer object for validation. (Or prevents other processes from
 * locking it for validation) and removes it from lru lists, while taking
 * a number of measures to prevent deadlocks.
 *
 * Deadlocks may occur when two processes try to reserve multiple buffers in
 * different order, either by will or as a result of a buffer being evicted
 * to make room for a buffer already reserved. (Buffers are reserved before
 * they are evicted). The following algorithm prevents such deadlocks from
 * occurring:
 * Processes attempting to reserve multiple buffers other than for eviction,
 * (typically execbuf), should first obtain a unique 32-bit
 * validation sequence number,
 * and call this function with @use_ticket == 1 and @ticket-&gt;stamp == the unique
 * sequence number. If upon call of this function, the buffer object is already
 * reserved, the validation sequence is checked against the validation
 * sequence of the process currently reserving the buffer,
 * and if the current validation sequence is greater than that of the process
 * holding the reservation, the function returns -EDEADLK. Otherwise it sleeps
 * waiting for the buffer to become unreserved, after which it retries
 * reserving.
 * The caller should, when receiving an -EDEADLK error
 * release all its buffer reservations, wait for @bo to become unreserved, and
 * then rerun the validation with the same validation sequence. This procedure
 * will always guarantee that the process with the lowest validation sequence
 * will eventually succeed, preventing both deadlocks and starvation.
 *
 * Returns:
 * -EDEADLK: The reservation may cause a deadlock.
 * Release all buffer reservations, wait for @bo to become unreserved and
 * try again. (only if use_sequence == 1).
 * -ERESTARTSYS: A wait for the buffer to become unreserved was interrupted by
 * a signal. Release all buffer reservations and return to user-space.
 * -EBUSY: The function needed to sleep, but @no_wait was true
 * -EALREADY: Bo already reserved using @ticket. This error code will only
 * be returned if @use_ticket is set to true.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_fbdev.c' l='81' u='c' c='bochsfb_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_kms.c' l='46' u='c' c='bochs_crtc_mode_set_base'/>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_kms.c' l='60' u='c' c='bochs_crtc_mode_set_base'/>
<use f='linux-4.14.y/drivers/gpu/drm/cirrus/cirrus_drv.h' l='241' u='c' c='cirrus_bo_reserve'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_object.h' l='34' u='c' c='qxl_bo_reserve'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_object.h' l='70' u='c' c='qxl_bo_wait'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='1689' u='c' c='ttm_bo_synccpu_write_grab'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_vm.c' l='120' u='c' c='ttm_bo_vm_fault'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_vm.c' l='349' u='c' c='ttm_bo_vm_access'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_drv.h' l='402' u='c' c='virtio_gpu_object_reserve'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_object.c' l='160' u='c' c='virtio_gpu_object_wait'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_cotable.c' l='425' u='c' c='vmw_cotable_resize'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c' l='60' u='c' c='vmw_dmabuf_pin_in_placement'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c' l='108' u='c' c='vmw_dmabuf_pin_in_vram_or_gmr'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c' l='191' u='c' c='vmw_dmabuf_pin_in_start_of_vram'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c' l='247' u='c' c='vmw_dmabuf_unpin'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c' l='342' u='c' c='vmw_dummy_query_bo_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='103' u='c' c='vmw_cursor_update_dmabuf'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='198' u='c' c='vmw_kms_cursor_snoop'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='2457' u='c' c='vmw_kms_helper_buffer_prepare'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c' l='225' u='c' c='vmw_takedown_otable_base'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c' l='265' u='c' c='vmw_otable_batch_setup'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c' l='359' u='c' c='vmw_otable_batch_takedown'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c' l='442' u='c' c='vmw_mob_pt_populate'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c' l='547' u='c' c='vmw_mob_pt_setup'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_mob.c' l='597' u='c' c='vmw_mob_unbind'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c' l='107' u='c' c='vmw_resource_release'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c' l='1464' u='c' c='vmw_resource_pin'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c' l='1519' u='c' c='vmw_resource_unpin'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c' l='992' u='c' c='vmw_compat_shader_add'/>
