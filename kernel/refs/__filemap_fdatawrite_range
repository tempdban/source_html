<dec f='linux-4.14.y/include/linux/fs.h' l='2589' type='int __filemap_fdatawrite_range(struct address_space * mapping, loff_t start, loff_t end, int sync_mode)'/>
<use f='linux-4.14.y/fs/sync.c' l='347' u='c' c='SYSC_sync_file_range'/>
<use f='linux-4.14.y/mm/fadvise.c' l='120' u='c' c='SYSC_fadvise64_64'/>
<def f='linux-4.14.y/mm/filemap.c' l='330' ll='348' type='int __filemap_fdatawrite_range(struct address_space * mapping, loff_t start, loff_t end, int sync_mode)'/>
<use f='linux-4.14.y/mm/filemap.c' l='353' u='c' c='__filemap_fdatawrite'/>
<use f='linux-4.14.y/mm/filemap.c' l='365' u='c' c='filemap_fdatawrite_range'/>
<use f='linux-4.14.y/mm/filemap.c' l='558' u='c' c='filemap_write_and_wait_range'/>
<use f='linux-4.14.y/mm/filemap.c' l='655' u='c' c='file_write_and_wait_range'/>
<doc f='linux-4.14.y/mm/filemap.c' l='315'>/**
 * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
 * @mapping:	address space structure to write
 * @start:	offset in bytes where the range starts
 * @end:	offset in bytes where the range ends (inclusive)
 * @sync_mode:	enable synchronous operation
 *
 * Start writeback against all of a mapping&apos;s dirty pages that lie
 * within the byte offsets &lt;start, end&gt; inclusive.
 *
 * If sync_mode is WB_SYNC_ALL then this is a &quot;data integrity&quot; operation, as
 * opposed to a regular memory cleansing writeback.  The difference between
 * these two operations is that if a dirty page/buffer is encountered, it must
 * be waited upon, and not just skipped over.
 */</doc>
<dec f='linux-4.14.y/include/linux/fs.h' l='2589' type='int __filemap_fdatawrite_range(struct address_space * mapping, loff_t start, loff_t end, int sync_mode)'/>
<use f='linux-4.14.y/fs/sync.c' l='347' u='c' c='SYSC_sync_file_range'/>
<use f='linux-4.14.y/mm/fadvise.c' l='120' u='c' c='SYSC_fadvise64_64'/>
<def f='linux-4.14.y/mm/filemap.c' l='330' ll='348' type='int __filemap_fdatawrite_range(struct address_space * mapping, loff_t start, loff_t end, int sync_mode)'/>
<use f='linux-4.14.y/mm/filemap.c' l='353' u='c' c='__filemap_fdatawrite'/>
<use f='linux-4.14.y/mm/filemap.c' l='365' u='c' c='filemap_fdatawrite_range'/>
<use f='linux-4.14.y/mm/filemap.c' l='558' u='c' c='filemap_write_and_wait_range'/>
<use f='linux-4.14.y/mm/filemap.c' l='655' u='c' c='file_write_and_wait_range'/>
<doc f='linux-4.14.y/mm/filemap.c' l='315'>/**
 * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
 * @mapping:	address space structure to write
 * @start:	offset in bytes where the range starts
 * @end:	offset in bytes where the range ends (inclusive)
 * @sync_mode:	enable synchronous operation
 *
 * Start writeback against all of a mapping&apos;s dirty pages that lie
 * within the byte offsets &lt;start, end&gt; inclusive.
 *
 * If sync_mode is WB_SYNC_ALL then this is a &quot;data integrity&quot; operation, as
 * opposed to a regular memory cleansing writeback.  The difference between
 * these two operations is that if a dirty page/buffer is encountered, it must
 * be waited upon, and not just skipped over.
 */</doc>
