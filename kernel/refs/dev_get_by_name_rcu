<dec f='linux-4.18.y/include/linux/netdevice.h' l='2532' type='struct net_device * dev_get_by_name_rcu(struct net * net, const char * name)'/>
<def f='linux-4.18.y/net/core/dev.c' l='761' ll='771' type='struct net_device * dev_get_by_name_rcu(struct net * net, const char * name)'/>
<dec f='linux-4.18.y/net/core/dev.c' l='772' type='struct net_device * dev_get_by_name_rcu(struct net * , const char * )'/>
<use f='linux-4.18.y/net/core/dev.c' l='772' c='dev_get_by_name_rcu'/>
<use f='linux-4.18.y/net/core/dev.c' l='772' u='a'/>
<use f='linux-4.18.y/net/core/dev.c' l='772' u='a'/>
<use f='linux-4.18.y/net/core/dev.c' l='791' u='c' c='dev_get_by_name'/>
<doc f='linux-4.18.y/net/core/dev.c' l='749'>/**
 * dev_get_by_name_rcu	- find a device by its name
 * @net: the applicable net namespace
 * @name: name to find
 *
 * Find an interface by name.
 * If the name is found a pointer to the device is returned.
 * If the name is not found then %NULL is returned.
 * The reference counters are not incremented so the caller must be
 * careful with locks. The caller must hold RCU lock.
 */</doc>
<use f='linux-4.18.y/net/core/dev_ioctl.c' l='106' u='c' c='dev_ifsioc_locked'/>
<use f='linux-4.18.y/net/core/dev_ioctl.c' l='354' u='c' c='dev_load'/>
<use f='linux-4.18.y/net/core/sock.c' l='603' u='c' c='sock_setbindtodevice'/>
<use f='linux-4.18.y/net/netlabel/netlabel_unlabeled.c' l='399' u='c' c='netlbl_unlhsh_add'/>
<use f='linux-4.18.y/net/netlabel/netlabel_unlabeled.c' l='658' u='c' c='netlbl_unlhsh_remove'/>
<use f='linux-4.18.y/net/packet/af_packet.c' l='1889' u='c' c='packet_sendmsg_spkt'/>
<use f='linux-4.18.y/net/packet/af_packet.c' l='3050' u='c' c='packet_do_bind'/>
