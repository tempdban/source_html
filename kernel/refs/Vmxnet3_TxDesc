<def f='linux-4.18.y/drivers/net/vmxnet3/vmxnet3_defs.h' l='119' ll='155'/>
<size>16</size>
<doc f='linux-4.18.y/drivers/net/vmxnet3/vmxnet3_defs.h' l='101'>/*
 *	Little Endian layout of bitfields -
 *	Byte 0 :	7.....len.....0
 *	Byte 1 :	rsvd gen 13.len.8
 *	Byte 2 : 	5.msscof.0 ext1  dtype
 *	Byte 3 : 	13...msscof...6
 *
 *	Big Endian layout of bitfields -
 *	Byte 0:		13...msscof...6
 *	Byte 1 : 	5.msscof.0 ext1  dtype
 *	Byte 2 :	rsvd gen 13.len.8
 *	Byte 3 :	7.....len.....0
 *
 *	Thus, le32_to_cpu on the dword will allow the big endian driver to read
 *	the bit fields correctly. And cpu_to_le32 will convert bitfields
 *	bit fields written by big endian driver to format required by device.
 */</doc>
<mbr r='Vmxnet3_TxDesc::addr' o='0' t='__le64'/>
<mbr r='Vmxnet3_TxDesc::len' o='64' t='u32'/>
<mbr r='Vmxnet3_TxDesc::gen' o='78' t='u32'/>
<mbr r='Vmxnet3_TxDesc::rsvd' o='79' t='u32'/>
<mbr r='Vmxnet3_TxDesc::dtype' o='80' t='u32'/>
<mbr r='Vmxnet3_TxDesc::ext1' o='81' t='u32'/>
<mbr r='Vmxnet3_TxDesc::msscof' o='82' t='u32'/>
<mbr r='Vmxnet3_TxDesc::hlen' o='96' t='u32'/>
<mbr r='Vmxnet3_TxDesc::om' o='106' t='u32'/>
<mbr r='Vmxnet3_TxDesc::eop' o='108' t='u32'/>
<mbr r='Vmxnet3_TxDesc::cq' o='109' t='u32'/>
<mbr r='Vmxnet3_TxDesc::ext2' o='110' t='u32'/>
<mbr r='Vmxnet3_TxDesc::ti' o='111' t='u32'/>
<mbr r='Vmxnet3_TxDesc::tci' o='112' t='u32'/>
