<dec f='linux-4.14.y/include/linux/security.h' l='1693' type='struct dentry * securityfs_create_file(const char * name, umode_t mode, struct dentry * parent, void * data, const struct file_operations * fops)'/>
<use f='linux-4.14.y/security/apparmor/apparmorfs.c' l='2240' u='c' c='entry_create_file'/>
<use f='linux-4.14.y/security/apparmor/apparmorfs.c' l='2459' u='c' c='aa_create_aafs'/>
<use f='linux-4.14.y/security/apparmor/apparmorfs.c' l='2467' u='c' c='aa_create_aafs'/>
<use f='linux-4.14.y/security/apparmor/apparmorfs.c' l='2475' u='c' c='aa_create_aafs'/>
<use f='linux-4.14.y/security/apparmor/apparmorfs.c' l='2483' u='c' c='aa_create_aafs'/>
<def f='linux-4.14.y/security/inode.c' l='194' ll='199' type='struct dentry * securityfs_create_file(const char * name, umode_t mode, struct dentry * parent, void * data, const struct file_operations * fops)'/>
<dec f='linux-4.14.y/security/inode.c' l='200' type='struct dentry * securityfs_create_file(const char * , umode_t , struct dentry * , void * , const struct file_operations * )'/>
<use f='linux-4.14.y/security/inode.c' l='200' c='securityfs_create_file'/>
<use f='linux-4.14.y/security/inode.c' l='200' u='a'/>
<use f='linux-4.14.y/security/inode.c' l='200' u='a'/>
<use f='linux-4.14.y/security/inode.c' l='224' u='c' c='securityfs_create_dir'/>
<use f='linux-4.14.y/security/inode.c' l='339' u='c' c='securityfs_init'/>
<doc f='linux-4.14.y/security/inode.c' l='169'>/**
 * securityfs_create_file - create a file in the securityfs filesystem
 *
 * @name: a pointer to a string containing the name of the file to create.
 * @mode: the permission that the file should have
 * @parent: a pointer to the parent dentry for this file.  This should be a
 *          directory dentry if set.  If this parameter is %NULL, then the
 *          file will be created in the root of the securityfs filesystem.
 * @data: a pointer to something that the caller will want to get to later
 *        on.  The inode.i_private pointer will point to this value on
 *        the open() call.
 * @fops: a pointer to a struct file_operations that should be used for
 *        this file.
 *
 * This function creates a file in securityfs with the given @name.
 *
 * This function returns a pointer to a dentry if it succeeds.  This
 * pointer must be passed to the securityfs_remove() function when the file is
 * to be removed (no automatic cleanup happens if your module is unloaded,
 * you are responsible here).  If an error occurs, the function will return
 * the error value (via ERR_PTR).
 *
 * If securityfs is not enabled in the kernel, the value %-ENODEV is
 * returned.
 */</doc>
<use f='linux-4.14.y/security/tomoyo/securityfs_if.c' l='226' u='c' c='tomoyo_create_entry'/>
<use f='linux-4.14.y/security/tomoyo/securityfs_if.c' l='262' u='c' c='tomoyo_initerface_init'/>
