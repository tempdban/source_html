<def f='linux-4.18.y/kernel/events/internal.h' l='111' ll='114' type='int page_order(struct ring_buffer * rb)'/>
<use f='linux-4.18.y/kernel/events/internal.h' l='119' u='c' c='perf_data_size'/>
<use f='linux-4.18.y/kernel/events/internal.h' l='147' u='c' c='__output_custom'/>
<use f='linux-4.18.y/kernel/events/internal.h' l='147' u='c' c='__output_copy'/>
<use f='linux-4.18.y/kernel/events/internal.h' l='147' u='c' c='__output_skip'/>
<use f='linux-4.18.y/kernel/events/internal.h' l='147' u='c' c='__output_copy_user'/>
<use f='linux-4.18.y/kernel/events/ring_buffer.c' l='201' u='c' c='__perf_output_begin'/>
<def f='linux-4.18.y/mm/internal.h' l='228' ll='232' type='unsigned int page_order(struct page * page)'/>
<doc f='linux-4.18.y/mm/internal.h' l='220'>/*
 * This function returns the order of a free page in the buddy system. In
 * general, page_zone(page)-&gt;lock must be held by the caller to prevent the
 * page from being allocated in parallel and returning garbage as the order.
 * If a caller does not hold page_zone(page)-&gt;lock, it must guarantee that the
 * page cannot be allocated or merged in parallel. Alternatively, it must
 * handle invalid values gracefully, and use page_order_unsafe() below.
 */</doc>
<use f='linux-4.18.y/mm/page_alloc.c' l='722' u='c' c='page_is_buddy'/>
<use f='linux-4.18.y/mm/page_alloc.c' l='731' u='c' c='page_is_buddy'/>
<use f='linux-4.18.y/mm/page_alloc.c' l='2045' u='c' c='move_freepages'/>
<use f='linux-4.18.y/mm/page_alloc.c' l='2132' u='c' c='steal_suitable_fallback'/>
<use f='linux-4.18.y/mm/page_alloc.c' l='7668' u='c' c='has_unmovable_pages'/>
<use f='linux-4.18.y/mm/page_alloc.c' l='8036' u='c' c='is_free_buddy_page'/>
