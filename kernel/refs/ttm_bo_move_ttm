<dec f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='1011' type='int ttm_bo_move_ttm(struct ttm_buffer_object * bo, bool interruptible, bool no_wait_gpu, struct ttm_mem_reg * new_mem)'/>
<doc f='linux-4.14.y/include/drm/ttm/ttm_bo_driver.h' l='993'>/**
 * ttm_bo_move_ttm
 *
 * @bo: A pointer to a struct ttm_buffer_object.
 * @interruptible: Sleep interruptible if waiting.
 * @no_wait_gpu: Return immediately if the GPU is busy.
 * @new_mem: struct ttm_mem_reg indicating where to move.
 *
 * Optimized move function for a buffer object with both old and
 * new placement backed by a TTM. The function will, if successful,
 * free any old aperture space, and set (@new_mem)-&gt;mm_node to NULL,
 * and update the (@bo)-&gt;mem placement flags. If unsuccessful, the old
 * data remains untouched, and it&apos;s up to the caller to free the
 * memory space indicated by @new_mem.
 * Returns:
 * !0: Failure.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo.c' l='329' u='c' c='ttm_bo_handle_move_mem'/>
<def f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_util.c' l='47' ll='85' type='int ttm_bo_move_ttm(struct ttm_buffer_object * bo, bool interruptible, bool no_wait_gpu, struct ttm_mem_reg * new_mem)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_util.c' l='86' type='int ttm_bo_move_ttm(struct ttm_buffer_object * , bool , bool , struct ttm_mem_reg * )'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_util.c' l='86' c='ttm_bo_move_ttm'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_util.c' l='86' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/ttm/ttm_bo_util.c' l='86' u='a'/>
