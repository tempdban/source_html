<def f='linux-4.14.y/include/linux/swait.h' l='121' ll='124' type='int swait_active(struct swait_queue_head * wq)'/>
<use f='linux-4.14.y/include/linux/swait.h' l='144' u='c' c='swq_has_sleeper'/>
<doc f='linux-4.14.y/include/linux/swait.h' l='88'>/**
 * swait_active -- locklessly test for waiters on the queue
 * @wq: the waitqueue to test for waiters
 *
 * returns true if the wait list is not empty
 *
 * NOTE: this function is lockless and requires care, incorrect usage _will_
 * lead to sporadic and non-obvious failure.
 *
 * NOTE2: this function has the same above implications as regular waitqueues.
 *
 * Use either while holding swait_queue_head::lock or when used for wakeups
 * with an extra smp_mb() like:
 *
 *      CPU0 - waker                    CPU1 - waiter
 *
 *                                      for (;;) {
 *      @cond = true;                     prepare_to_swait(&amp;wq_head, &amp;wait, state);
 *      smp_mb();                         // smp_mb() from set_current_state()
 *      if (swait_active(wq_head))        if (@cond)
 *        wake_up(wq_head);                      break;
 *                                        schedule();
 *                                      }
 *                                      finish_swait(&amp;wq_head, &amp;wait);
 *
 * Because without the explicit smp_mb() it&apos;s possible for the
 * swait_active() load to get hoisted over the @cond store such that we&apos;ll
 * observe an empty wait list while the waiter might not observe @cond.
 * This, in turn, can trigger missing wakeups.
 *
 * Also note that this &apos;optimization&apos; trades a spin_lock() for an smp_mb(),
 * which (when the lock is uncontended) are of roughly equal cost.
 */</doc>
