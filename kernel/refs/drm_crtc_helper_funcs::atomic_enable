<dec f='linux-4.18.y/include/drm/drm_modeset_helper_vtables.h' l='422' type='void (*)(struct drm_crtc *, struct drm_crtc_state *)'/>
<offset>832</offset>
<doc f='linux-4.18.y/include/drm/drm_modeset_helper_vtables.h' l='401'>/**
	 * @atomic_enable:
	 *
	 * This callback should be used to enable the CRTC. With the atomic
	 * drivers it is called before all encoders connected to this CRTC are
	 * enabled through the encoder&apos;s own &amp;drm_encoder_helper_funcs.enable
	 * hook.  If that sequence is too simple drivers can just add their own
	 * hooks and call it from this CRTC callback here by looping over all
	 * encoders connected to it using for_each_encoder_on_crtc().
	 *
	 * This hook is used only by atomic helpers, for symmetry with
	 * @atomic_disable. Atomic drivers don&apos;t need to implement it if there&apos;s
	 * no need to enable anything at the CRTC level. To ensure that runtime
	 * PM handling (using either DPMS or the new &quot;ACTIVE&quot; property) works
	 * @atomic_enable must be the inverse of @atomic_disable for atomic
	 * drivers.
	 *
	 * Drivers can use the @old_crtc_state input parameter if the operations
	 * needed to enable the CRTC don&apos;t depend solely on the new state but
	 * also on the transition between the old state and the new state.
	 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1215' u='r' c='drm_atomic_helper_commit_modeset_enables'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1216' u='r' c='drm_atomic_helper_commit_modeset_enables'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='93' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_display.c' l='473' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='166' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c' l='350' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='611' u='w'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='1392' u='w'/>
