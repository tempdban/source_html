<dec f='linux-4.14.y/arch/x86/include/asm/processor.h' l='869'/>
<doc f='linux-4.14.y/arch/x86/include/asm/processor.h' l='851'>/*
 * User space process size.  This is the first address outside the user range.
 * There are a few constraints that determine this:
 *
 * On Intel CPUs, if a SYSCALL instruction is at the highest canonical
 * address, then that syscall will enter the kernel with a
 * non-canonical return address, and SYSRET will explode dangerously.
 * We avoid this particular problem by preventing anything executable
 * from being mapped at the maximum canonical address.
 *
 * On AMD CPUs in the Ryzen family, there&apos;s a nasty bug in which the
 * CPUs malfunction if they execute code from the highest canonical page.
 * They&apos;ll speculate right off the end of the canonical space, and
 * bad things happen.  This is worked around in the same way as the
 * Intel problem.
 *
 * With page table isolation enabled, we map the LDT in ... [stay tuned]
 */</doc>
<use f='linux-4.14.y/arch/x86/entry/vdso/vma.c' l='230' u='c'/>
<use f='linux-4.14.y/arch/x86/entry/vdso/vma.c' l='231' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/hw_breakpoint.c' l='188' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/hw_breakpoint.c' l='188' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/hw_breakpoint.c' l='257' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/process_64.c' l='612' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/process_64.c' l='626' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/ptrace.c' l='396' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/ptrace.c' l='410' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/sys_x86_64.c' l='219' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/traps.c' l='163' u='c'/>
<use f='linux-4.14.y/arch/x86/mm/fault.c' l='138' u='c'/>
<use f='linux-4.14.y/arch/x86/mm/fault.c' l='914' u='c'/>
<use f='linux-4.14.y/arch/x86/mm/fault.c' l='1216' u='c'/>
<use f='linux-4.14.y/arch/x86/mm/mmap.c' l='47' u='c'/>
