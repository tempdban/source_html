<dec f='linux-4.18.y/include/linux/wait.h' l='975'/>
<doc f='linux-4.18.y/include/linux/wait.h' l='955'>/**
 * wait_event_lock_irq - sleep until a condition gets true. The
 *			 condition is checked under the lock. This
 *			 is expected to be called with the lock
 *			 taken.
 * @wq_head: the waitqueue to wait on
 * @condition: a C expression for the event to wait for
 * @lock: a locked spinlock_t, which will be released before schedule()
 *	  and reacquired afterwards.
 *
 * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
 * @condition evaluates to true. The @condition is checked each time
 * the waitqueue @wq_head is woken up.
 *
 * wake_up() has to be called after changing any variable that could
 * change the result of the wait condition.
 *
 * This is supposed to be called while holding the lock. The lock is
 * dropped before going to sleep and is reacquired afterwards.
 */</doc>
<use f='linux-4.18.y/drivers/md/raid1.c' l='864' u='c'/>
<use f='linux-4.18.y/drivers/md/raid1.c' l='887' u='c'/>
<use f='linux-4.18.y/drivers/md/raid1.c' l='968' u='c'/>
<use f='linux-4.18.y/drivers/md/raid1.c' l='1002' u='c'/>
<use f='linux-4.18.y/drivers/md/raid10.c' l='971' u='c'/>
<use f='linux-4.18.y/drivers/md/raid10.c' l='978' u='c'/>
<use f='linux-4.18.y/drivers/md/raid10.c' l='1009' u='c'/>
<use f='linux-4.18.y/drivers/md/raid5-cache.c' l='1536' u='c'/>
<use f='linux-4.18.y/drivers/md/raid5-ppl.c' l='688' u='c'/>
<use f='linux-4.18.y/drivers/md/raid5.c' l='649' u='c'/>
<use f='linux-4.18.y/drivers/md/raid5.c' l='669' u='c'/>
<use f='linux-4.18.y/drivers/md/raid5.c' l='5264' u='c'/>
<use f='linux-4.18.y/drivers/md/raid5.c' l='6241' u='c'/>
<use f='linux-4.18.y/kernel/workqueue.c' l='3377' u='c'/>
<use f='linux-4.18.y/lib/percpu-refcount.c' l='222' u='c'/>
