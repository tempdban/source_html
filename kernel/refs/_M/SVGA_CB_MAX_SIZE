<dec f='linux-4.18.y/drivers/gpu/drm/vmwgfx/device_include/svga_reg.h' l='385'/>
<doc f='linux-4.18.y/drivers/gpu/drm/vmwgfx/device_include/svga_reg.h' l='322'>/*
 * Register based command buffers --
 *
 * Provide an SVGA device interface that allows the guest to submit
 * command buffers to the SVGA device through an SVGA device register.
 * The metadata for each command buffer is contained in the
 * SVGACBHeader structure along with the return status codes.
 *
 * The SVGA device supports command buffers if
 * SVGA_CAP_COMMAND_BUFFERS is set in the device caps register.  The
 * fifo must be enabled for command buffers to be submitted.
 *
 * Command buffers are submitted when the guest writing the 64 byte
 * aligned physical address into the SVGA_REG_COMMAND_LOW and
 * SVGA_REG_COMMAND_HIGH.  SVGA_REG_COMMAND_HIGH contains the upper 32
 * bits of the physical address.  SVGA_REG_COMMAND_LOW contains the
 * lower 32 bits of the physical address, since the command buffer
 * headers are required to be 64 byte aligned the lower 6 bits are
 * used for the SVGACBContext value.  Writing to SVGA_REG_COMMAND_LOW
 * submits the command buffer to the device and queues it for
 * execution.  The SVGA device supports at least
 * SVGA_CB_MAX_QUEUED_PER_CONTEXT command buffers that can be queued
 * per context and if that limit is reached the device will write the
 * status SVGA_CB_STATUS_QUEUE_FULL to the status value of the command
 * buffer header synchronously and not raise any IRQs.
 *
 * It is invalid to submit a command buffer without a valid physical
 * address and results are undefined.
 *
 * The device guarantees that command buffers of size SVGA_CB_MAX_SIZE
 * will be supported.  If a larger command buffer is submitted results
 * are unspecified and the device will either complete the command
 * buffer or return an error.
 *
 * The device guarantees that any individual command in a command
 * buffer can be up to SVGA_CB_MAX_COMMAND_SIZE in size which is
 * enough to fit a 64x64 color-cursor definition.  If the command is
 * too large the device is allowed to process the command or return an
 * error.
 *
 * The device context is a special SVGACBContext that allows for
 * synchronous register like accesses with the flexibility of
 * commands.  There is a different command set defined by
 * SVGADeviceContextCmdId.  The commands in each command buffer is not
 * allowed to straddle physical pages.
 *
 * The offset field which is available starting with the
 * SVGA_CAP_CMD_BUFFERS_2 cap bit can be set by the guest to bias the
 * start of command processing into the buffer.  If an error is
 * encountered the errorOffset will still be relative to the specific
 * PA, not biased by the offset.  When the command buffer is finished
 * the guest should not read the offset field as there is no guarantee
 * what it will set to.
 *
 * When the SVGA_CAP_HP_CMD_QUEUE cap bit is set a new command queue
 * SVGA_CB_CONTEXT_1 is available.  Commands submitted to this queue
 * will be executed as quickly as possible by the SVGA device
 * potentially before already queued commands on SVGA_CB_CONTEXT_0.
 * The SVGA device guarantees that any command buffers submitted to
 * SVGA_CB_CONTEXT_0 will be executed after any _already_ submitted
 * command buffers to SVGA_CB_CONTEXT_1.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c' l='500' u='c'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c' l='4002' u='c'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c' l='4012' u='c'/>
