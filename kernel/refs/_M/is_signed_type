<dec f='linux-4.18.y/include/linux/overflow.h' l='34'/>
<doc f='linux-4.18.y/include/linux/overflow.h' l='7'>/*
 * In the fallback code below, we need to compute the minimum and
 * maximum values representable in a given type. These macros may also
 * be useful elsewhere, so we provide them outside the
 * COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW block.
 *
 * It would seem more obvious to do something like
 *
 * #define type_min(T) (T)(is_signed_type(T) ? (T)1 &lt;&lt; (8*sizeof(T)-1) : 0)
 * #define type_max(T) (T)(is_signed_type(T) ? ((T)1 &lt;&lt; (8*sizeof(T)-1)) - 1 : ~(T)0)
 *
 * Unfortunately, the middle expressions, strictly speaking, have
 * undefined behaviour, and at least some versions of gcc warn about
 * the type_max expression (but not if -fsanitize=undefined is in
 * effect; in that case, the warning is deferred to runtime...).
 *
 * The slightly excessive casting in type_min is to make sure the
 * macros also produce sensible values for the exotic type _Bool. [The
 * overflow checkers only almost work for _Bool, but that&apos;s
 * a-feature-not-a-bug, since people shouldn&apos;t be doing arithmetic on
 * _Bools. Besides, the gcc builtins don&apos;t allow _Bool* as third
 * argument.]
 *
 * Idea stolen from
 * https://mail-index.netbsd.org/tech-misc/2007/02/05/0000.html -
 * credit to Christian Biere.
 */</doc>
<dec f='linux-4.18.y/include/linux/trace_events.h' l='536'/>
<use f='linux-4.18.y/kernel/trace/ring_buffer.c' l='401' u='c'/>
<use f='linux-4.18.y/kernel/trace/ring_buffer.c' l='407' u='c'/>
<use f='linux-4.18.y/kernel/trace/ring_buffer.c' l='413' u='c'/>
<use f='linux-4.18.y/kernel/trace/ring_buffer.c' l='419' u='c'/>
