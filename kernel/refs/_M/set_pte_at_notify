<dec f='linux-4.14.y/include/linux/mmu_notifier.h' l='388'/>
<doc f='linux-4.14.y/include/linux/mmu_notifier.h' l='378'>/*
 * set_pte_at_notify() sets the pte _after_ running the notifier.
 * This is safe to start by updating the secondary MMUs, because the primary MMU
 * pte invalidate must have already happened with a ptep_clear_flush() before
 * set_pte_at_notify() has been invoked.  Updating the secondary MMUs first is
 * required when we change both the protection of the mapping from read-only to
 * read-write and the pfn (like during copy on write page faults). Otherwise the
 * old page would remain mapped readonly in the secondary MMUs after the new
 * page is already writable by some CPU through the primary MMU.
 */</doc>
<use f='linux-4.14.y/kernel/events/uprobes.c' l='199' u='c'/>
<use f='linux-4.14.y/mm/memory.c' l='2518' u='c'/>
<dec f='linux-4.14.y/include/linux/mmu_notifier.h' l='388'/>
<doc f='linux-4.14.y/include/linux/mmu_notifier.h' l='378'>/*
 * set_pte_at_notify() sets the pte _after_ running the notifier.
 * This is safe to start by updating the secondary MMUs, because the primary MMU
 * pte invalidate must have already happened with a ptep_clear_flush() before
 * set_pte_at_notify() has been invoked.  Updating the secondary MMUs first is
 * required when we change both the protection of the mapping from read-only to
 * read-write and the pfn (like during copy on write page faults). Otherwise the
 * old page would remain mapped readonly in the secondary MMUs after the new
 * page is already writable by some CPU through the primary MMU.
 */</doc>
<use f='linux-4.14.y/kernel/events/uprobes.c' l='199' u='c'/>
<use f='linux-4.14.y/mm/memory.c' l='2518' u='c'/>
