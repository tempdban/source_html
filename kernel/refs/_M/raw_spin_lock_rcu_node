<dec f='linux-4.18.y/kernel/rcu/rcu.h' l='337'/>
<doc f='linux-4.18.y/kernel/rcu/rcu.h' l='323'>/*
 * Wrappers for the rcu_node::lock acquire and release.
 *
 * Because the rcu_nodes form a tree, the tree traversal locking will observe
 * different lock values, this in turn means that an UNLOCK of one level
 * followed by a LOCK of another level does not imply a full memory barrier;
 * and most importantly transitivity is lost.
 *
 * In order to restore full ordering between tree levels, augment the regular
 * lock acquire functions with smp_mb__after_unlock_lock().
 *
 * As -&gt;lock of struct rcu_node is a __private field, therefore one should use
 * these wrappers rather than directly call raw_spin_{lock,unlock}* on -&gt;lock.
 */</doc>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='1160' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='1664' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='2355' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='2488' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='2775' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='2866' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3495' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3550' u='c'/>
<use f='linux-4.18.y/kernel/rcu/tree_exp.h' l='222' u='c'/>
