<dec f='linux-4.14.y/kernel/rcu/rcu.h' l='320'/>
<use f='linux-4.14.y/kernel/rcu/srcutree.c' l='833' u='c'/>
<doc f='linux-4.14.y/kernel/rcu/rcu.h' l='306'>/*
 * Wrappers for the rcu_node::lock acquire and release.
 *
 * Because the rcu_nodes form a tree, the tree traversal locking will observe
 * different lock values, this in turn means that an UNLOCK of one level
 * followed by a LOCK of another level does not imply a full memory barrier;
 * and most importantly transitivity is lost.
 *
 * In order to restore full ordering between tree levels, augment the regular
 * lock acquire functions with smp_mb__after_unlock_lock().
 *
 * As -&gt;lock of struct rcu_node is a __private field, therefore one should use
 * these wrappers rather than directly call raw_spin_{lock,unlock}* on -&gt;lock.
 */</doc>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='1735' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='2488' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='2621' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='2901' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='2993' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3639' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3698' u='c'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='192' u='c'/>
