<dec f='linux-4.18.y/include/uapi/linux/uio.h' l='28'/>
<use f='linux-4.18.y/block/bio.c' l='447' u='c'/>
<use f='linux-4.18.y/block/bio.c' l='1126' u='c'/>
<use f='linux-4.18.y/drivers/vhost/vhost.h' l='126' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='278' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='350' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='360' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='363' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='462' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='462' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='560' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='581' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='717' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='756' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='817' u='c'/>
<use f='linux-4.18.y/drivers/vhost/net.c' l='836' u='c'/>
<use f='linux-4.18.y/drivers/vhost/vhost.c' l='388' u='c'/>
<use f='linux-4.18.y/drivers/vhost/vhost.c' l='391' u='c'/>
<use f='linux-4.18.y/drivers/vhost/vhost.c' l='393' u='c'/>
<use f='linux-4.18.y/drivers/vhost/vhost.c' l='1883' u='c'/>
<use f='linux-4.18.y/fs/read_write.c' l='776' u='c'/>
<use f='linux-4.18.y/fs/read_write.c' l='848' u='c'/>
<dec f='include/bits/uio.h' l='39'/>
<doc f='include/bits/uio.h' l='32'>/* Size of object which can be written atomically.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  */</doc>
<use f='linux-4.18.y/net/compat.c' l='77' u='c'/>
<use f='linux-4.18.y/net/core/sock.c' l='325' u='c'/>
<use f='linux-4.18.y/net/socket.c' l='2042' u='c'/>
<use f='linux-4.18.y/net/socket.c' l='2196' u='c'/>
<use f='linux-4.18.y/net/socket.c' l='2197' u='c'/>
