<dec f='linux-4.18.y/include/linux/xz.h' l='214' type='enum xz_ret xz_dec_run(struct xz_dec * s, struct xz_buf * b)'/>
<use f='linux-4.18.y/lib/decompress_unxz.c' l='300' u='c' c='unxz'/>
<use f='linux-4.18.y/lib/decompress_unxz.c' l='323' u='c' c='unxz'/>
<doc f='linux-4.18.y/include/linux/xz.h' l='196'>/**
 * xz_dec_run() - Run the XZ decoder
 * @s:          Decoder state allocated using xz_dec_init()
 * @b:          Input and output buffers
 *
 * The possible return values depend on build options and operation mode.
 * See enum xz_ret for details.
 *
 * Note that if an error occurs in single-call mode (return value is not
 * XZ_STREAM_END), b-&gt;in_pos and b-&gt;out_pos are not modified and the
 * contents of the output buffer from b-&gt;out[b-&gt;out_pos] onward are
 * undefined. This is true even after XZ_BUF_ERROR, because with some filter
 * chains, there may be a second pass over the output buffer, and this pass
 * cannot be properly done if the output buffer is truncated. Thus, you
 * cannot give the single-call decoder a too small buffer and then expect to
 * get that amount valid data from the beginning of the stream. You must use
 * the multi-call decoder if you don&apos;t want to uncompress the whole stream.
 */</doc>
<def f='linux-4.18.y/lib/xz/xz_dec_stream.c' l='750' ll='784' macro='1' type='enum xz_ret xz_dec_run(struct xz_dec * s, struct xz_buf * b)'/>
<dec f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='15' type='enum xz_ret xz_dec_run(struct xz_dec * , struct xz_buf * )'/>
<use f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='15' c='xz_dec_run'/>
<use f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='15' u='a'/>
<use f='linux-4.18.y/lib/xz/xz_dec_syms.c' l='15' u='a'/>
