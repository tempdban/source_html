<dec f='linux-4.18.y/include/linux/rcutree.h' l='86' type='void rcu_irq_exit()'/>
<use f='linux-4.18.y/arch/x86/kernel/kvm.c' l='141' u='c' c='kvm_async_pf_task_wait'/>
<use f='linux-4.18.y/arch/x86/kernel/kvm.c' l='161' u='c' c='kvm_async_pf_task_wait'/>
<use f='linux-4.18.y/arch/x86/kernel/kvm.c' l='180' u='c' c='kvm_async_pf_task_wait'/>
<use f='linux-4.18.y/arch/x86/kernel/kvm.c' l='284' u='c' c='do_async_page_fault'/>
<def f='linux-4.18.y/kernel/rcu/tree.c' l='842' ll='852' type='void rcu_irq_exit()'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='865' u='c' c='rcu_irq_exit_irqson'/>
<doc f='linux-4.18.y/kernel/rcu/tree.c' l='823'>/**
 * rcu_irq_exit - inform RCU that current CPU is exiting irq towards idle
 *
 * Exit from an interrupt handler, which might possibly result in entering
 * idle mode, in other words, leaving the mode in which read-side critical
 * sections can occur.  The caller must have disabled interrupts.
 *
 * This code assumes that the idle loop never does anything that might
 * result in unbalanced calls to irq_enter() and irq_exit().  If your
 * architecture&apos;s idle loop violates this assumption, RCU will give you what
 * you deserve, good and hard.  But very infrequently and irreproducibly.
 *
 * Use things like work queues to work around this limitation.
 *
 * You have been warned.
 *
 * If you add or remove a call to rcu_irq_exit(), be sure to test with
 * CONFIG_RCU_EQS_DEBUG=y.
 */</doc>
<use f='linux-4.18.y/kernel/softirq.c' l='415' u='c' c='irq_exit'/>
