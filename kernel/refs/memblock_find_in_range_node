<dec f='linux-4.18.y/include/linux/memblock.h' l='73' type='phys_addr_t memblock_find_in_range_node(phys_addr_t size, phys_addr_t align, phys_addr_t start, phys_addr_t end, int nid, ulong flags)'/>
<def f='linux-4.18.y/mm/memblock.c' l='190' ll='237' type='phys_addr_t memblock_find_in_range_node(phys_addr_t size, phys_addr_t align, phys_addr_t start, phys_addr_t end, int nid, ulong flags)'/>
<use f='linux-4.18.y/mm/memblock.c' l='259' u='c' c='memblock_find_in_range'/>
<use f='linux-4.18.y/mm/memblock.c' l='1152' u='c' c='memblock_alloc_range_nid'/>
<use f='linux-4.18.y/mm/memblock.c' l='1283' u='c' c='memblock_virt_alloc_internal'/>
<use f='linux-4.18.y/mm/memblock.c' l='1289' u='c' c='memblock_virt_alloc_internal'/>
<doc f='linux-4.18.y/mm/memblock.c' l='168'>/**
 * memblock_find_in_range_node - find free area in given range and node
 * @size: size of free area to find
 * @align: alignment of free area to find
 * @start: start of candidate range
 * @end: end of candidate range, can be %MEMBLOCK_ALLOC_{ANYWHERE|ACCESSIBLE}
 * @nid: nid of the free area to find, %NUMA_NO_NODE for any node
 * @flags: pick from blocks based on memory attributes
 *
 * Find @size free area aligned to @align in the specified range and node.
 *
 * When allocation direction is bottom-up, the @start should be greater
 * than the end of the kernel image. Otherwise, it will be trimmed. The
 * reason is that we want the bottom-up allocation just near the kernel
 * image so it is highly likely that the allocated memory and the kernel
 * will reside in the same node.
 *
 * If bottom-up allocation failed, will try to allocate memory top-down.
 *
 * RETURNS:
 * Found address on success, 0 on failure.
 */</doc>
<use f='linux-4.18.y/mm/nobootmem.c' l='51' u='c' c='__alloc_memory_core_early'/>
