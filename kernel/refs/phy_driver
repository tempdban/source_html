<def f='linux-4.14.y/include/linux/phy.h' l='506' ll='657'/>
<size>408</size>
<doc f='linux-4.14.y/include/linux/phy.h' l='485'>/* struct phy_driver: Driver structure for a particular PHY type
 *
 * driver_data: static driver data
 * phy_id: The result of reading the UID registers of this PHY
 *   type, and ANDing them with the phy_id_mask.  This driver
 *   only works for PHYs with IDs which match this field
 * name: The friendly name of this PHY type
 * phy_id_mask: Defines the important bits of the phy_id
 * features: A list of features (speed, duplex, etc) supported
 *   by this PHY
 * flags: A bitfield defining certain other features this PHY
 *   supports (like interrupts)
 *
 * The drivers must implement config_aneg and read_status.  All
 * other functions are optional. Note that none of these
 * functions should be called from interrupt time.  The goal is
 * for the bus read/write functions to be able to block when the
 * bus transaction is happening, and be freed up by an interrupt
 * (The MPC85xx has this ability, though it is not currently
 * supported in the driver).
 */</doc>
<mbr r='phy_driver::mdiodrv' o='0' t='struct mdio_driver_common'/>
<mbr r='phy_driver::phy_id' o='1024' t='u32'/>
<mbr r='phy_driver::name' o='1088' t='char *'/>
<mbr r='phy_driver::phy_id_mask' o='1152' t='unsigned int'/>
<mbr r='phy_driver::features' o='1184' t='u32'/>
<mbr r='phy_driver::flags' o='1216' t='u32'/>
<mbr r='phy_driver::driver_data' o='1280' t='const void *'/>
<mbr r='phy_driver::soft_reset' o='1344' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::config_init' o='1408' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::probe' o='1472' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::suspend' o='1536' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::resume' o='1600' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::config_aneg' o='1664' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::aneg_done' o='1728' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::read_status' o='1792' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::ack_interrupt' o='1856' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::config_intr' o='1920' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::did_interrupt' o='1984' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::remove' o='2048' t='void (*)(struct phy_device *)'/>
<mbr r='phy_driver::match_phy_device' o='2112' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::ts_info' o='2176' t='int (*)(struct phy_device *, struct ethtool_ts_info *)'/>
<mbr r='phy_driver::hwtstamp' o='2240' t='int (*)(struct phy_device *, struct ifreq *)'/>
<mbr r='phy_driver::rxtstamp' o='2304' t='bool (*)(struct phy_device *, struct sk_buff *, int)'/>
<mbr r='phy_driver::txtstamp' o='2368' t='void (*)(struct phy_device *, struct sk_buff *, int)'/>
<mbr r='phy_driver::set_wol' o='2432' t='int (*)(struct phy_device *, struct ethtool_wolinfo *)'/>
<mbr r='phy_driver::get_wol' o='2496' t='void (*)(struct phy_device *, struct ethtool_wolinfo *)'/>
<mbr r='phy_driver::link_change_notify' o='2560' t='void (*)(struct phy_device *)'/>
<mbr r='phy_driver::read_mmd' o='2624' t='int (*)(struct phy_device *, int, u16)'/>
<mbr r='phy_driver::write_mmd' o='2688' t='int (*)(struct phy_device *, int, u16, u16)'/>
<mbr r='phy_driver::module_info' o='2752' t='int (*)(struct phy_device *, struct ethtool_modinfo *)'/>
<mbr r='phy_driver::module_eeprom' o='2816' t='int (*)(struct phy_device *, struct ethtool_eeprom *, u8 *)'/>
<mbr r='phy_driver::get_sset_count' o='2880' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::get_strings' o='2944' t='void (*)(struct phy_device *, u8 *)'/>
<mbr r='phy_driver::get_stats' o='3008' t='void (*)(struct phy_device *, struct ethtool_stats *, u64 *)'/>
<mbr r='phy_driver::get_tunable' o='3072' t='int (*)(struct phy_device *, struct ethtool_tunable *, void *)'/>
<mbr r='phy_driver::set_tunable' o='3136' t='int (*)(struct phy_device *, struct ethtool_tunable *, const void *)'/>
<mbr r='phy_driver::set_loopback' o='3200' t='int (*)(struct phy_device *, bool)'/>
