<def f='linux-4.18.y/include/linux/phy.h' l='507' ll='661'/>
<size>432</size>
<doc f='linux-4.18.y/include/linux/phy.h' l='486'>/* struct phy_driver: Driver structure for a particular PHY type
 *
 * driver_data: static driver data
 * phy_id: The result of reading the UID registers of this PHY
 *   type, and ANDing them with the phy_id_mask.  This driver
 *   only works for PHYs with IDs which match this field
 * name: The friendly name of this PHY type
 * phy_id_mask: Defines the important bits of the phy_id
 * features: A list of features (speed, duplex, etc) supported
 *   by this PHY
 * flags: A bitfield defining certain other features this PHY
 *   supports (like interrupts)
 *
 * All functions are optional. If config_aneg or read_status
 * are not implemented, the phy core uses the genphy versions.
 * Note that none of these functions should be called from
 * interrupt time. The goal is for the bus read/write functions
 * to be able to block when the bus transaction is happening,
 * and be freed up by an interrupt (The MPC85xx has this ability,
 * though it is not currently supported in the driver).
 */</doc>
<mbr r='phy_driver::mdiodrv' o='0' t='struct mdio_driver_common'/>
<mbr r='phy_driver::phy_id' o='1088' t='u32'/>
<mbr r='phy_driver::name' o='1152' t='char *'/>
<mbr r='phy_driver::phy_id_mask' o='1216' t='u32'/>
<mbr r='phy_driver::features' o='1248' t='u32'/>
<mbr r='phy_driver::flags' o='1280' t='u32'/>
<mbr r='phy_driver::driver_data' o='1344' t='const void *'/>
<mbr r='phy_driver::soft_reset' o='1408' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::config_init' o='1472' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::probe' o='1536' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::suspend' o='1600' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::resume' o='1664' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::config_aneg' o='1728' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::aneg_done' o='1792' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::read_status' o='1856' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::ack_interrupt' o='1920' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::config_intr' o='1984' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::did_interrupt' o='2048' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::remove' o='2112' t='void (*)(struct phy_device *)'/>
<mbr r='phy_driver::match_phy_device' o='2176' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::ts_info' o='2240' t='int (*)(struct phy_device *, struct ethtool_ts_info *)'/>
<mbr r='phy_driver::hwtstamp' o='2304' t='int (*)(struct phy_device *, struct ifreq *)'/>
<mbr r='phy_driver::rxtstamp' o='2368' t='bool (*)(struct phy_device *, struct sk_buff *, int)'/>
<mbr r='phy_driver::txtstamp' o='2432' t='void (*)(struct phy_device *, struct sk_buff *, int)'/>
<mbr r='phy_driver::set_wol' o='2496' t='int (*)(struct phy_device *, struct ethtool_wolinfo *)'/>
<mbr r='phy_driver::get_wol' o='2560' t='void (*)(struct phy_device *, struct ethtool_wolinfo *)'/>
<mbr r='phy_driver::link_change_notify' o='2624' t='void (*)(struct phy_device *)'/>
<mbr r='phy_driver::read_mmd' o='2688' t='int (*)(struct phy_device *, int, u16)'/>
<mbr r='phy_driver::write_mmd' o='2752' t='int (*)(struct phy_device *, int, u16, u16)'/>
<mbr r='phy_driver::read_page' o='2816' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::write_page' o='2880' t='int (*)(struct phy_device *, int)'/>
<mbr r='phy_driver::module_info' o='2944' t='int (*)(struct phy_device *, struct ethtool_modinfo *)'/>
<mbr r='phy_driver::module_eeprom' o='3008' t='int (*)(struct phy_device *, struct ethtool_eeprom *, u8 *)'/>
<mbr r='phy_driver::get_sset_count' o='3072' t='int (*)(struct phy_device *)'/>
<mbr r='phy_driver::get_strings' o='3136' t='void (*)(struct phy_device *, u8 *)'/>
<mbr r='phy_driver::get_stats' o='3200' t='void (*)(struct phy_device *, struct ethtool_stats *, u64 *)'/>
<mbr r='phy_driver::get_tunable' o='3264' t='int (*)(struct phy_device *, struct ethtool_tunable *, void *)'/>
<mbr r='phy_driver::set_tunable' o='3328' t='int (*)(struct phy_device *, struct ethtool_tunable *, const void *)'/>
<mbr r='phy_driver::set_loopback' o='3392' t='int (*)(struct phy_device *, bool)'/>
