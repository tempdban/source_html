<dec f='linux-4.14.y/include/linux/sched.h' l='1504' type='void yield()'/>
<use f='linux-4.14.y/drivers/i2c/algos/i2c-algo-bit.c' l='350' u='c' c='try_address'/>
<use f='linux-4.14.y/fs/buffer.c' l='264' u='c' c='free_more_memory'/>
<def f='linux-4.14.y/kernel/sched/core.c' l='4916' ll='4920' type='void yield()'/>
<dec f='linux-4.14.y/kernel/sched/core.c' l='4921' type='void yield()'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4921' c='yield'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4921' u='a'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4921' u='a'/>
<doc f='linux-4.14.y/kernel/sched/core.c' l='4894'>/**
 * yield - yield the current processor to other threads.
 *
 * Do not ever use this function, there&apos;s a 99% chance you&apos;re doing it wrong.
 *
 * The scheduler is at all times free to pick the calling task as the most
 * eligible task to run, if removing the yield() call from your code breaks
 * it, its already broken.
 *
 * Typical broken usage is:
 *
 * while (!event)
 *	yield();
 *
 * where one assumes that yield() will let &apos;the other&apos; process run that will
 * make event true. If the current task is a SCHED_FIFO task that will never
 * happen. Never use yield() as a progress guarantee!!
 *
 * If you want to use yield() to wait for something, use wait_event().
 * If you want to use yield() to be &apos;nice&apos; for others, use cond_resched().
 * If you still want to use yield(), do not!
 */</doc>
<use f='linux-4.14.y/kernel/softirq.c' l='579' u='c' c='tasklet_kill'/>
<use f='linux-4.14.y/net/netlink/af_netlink.c' l='1493' u='c' c='netlink_broadcast_filtered'/>
<use f='linux-4.14.y/net/sched/sch_generic.c' l='936' u='c' c='dev_deactivate_many'/>
<dec f='linux-4.14.y/include/linux/sched.h' l='1504' type='void yield()'/>
<use f='linux-4.14.y/drivers/i2c/algos/i2c-algo-bit.c' l='350' u='c' c='try_address'/>
<use f='linux-4.14.y/fs/buffer.c' l='264' u='c' c='free_more_memory'/>
<def f='linux-4.14.y/kernel/sched/core.c' l='4916' ll='4920' type='void yield()'/>
<dec f='linux-4.14.y/kernel/sched/core.c' l='4921' type='void yield()'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4921' c='yield'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4921' u='a'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4921' u='a'/>
<doc f='linux-4.14.y/kernel/sched/core.c' l='4894'>/**
 * yield - yield the current processor to other threads.
 *
 * Do not ever use this function, there&apos;s a 99% chance you&apos;re doing it wrong.
 *
 * The scheduler is at all times free to pick the calling task as the most
 * eligible task to run, if removing the yield() call from your code breaks
 * it, its already broken.
 *
 * Typical broken usage is:
 *
 * while (!event)
 *	yield();
 *
 * where one assumes that yield() will let &apos;the other&apos; process run that will
 * make event true. If the current task is a SCHED_FIFO task that will never
 * happen. Never use yield() as a progress guarantee!!
 *
 * If you want to use yield() to wait for something, use wait_event().
 * If you want to use yield() to be &apos;nice&apos; for others, use cond_resched().
 * If you still want to use yield(), do not!
 */</doc>
<use f='linux-4.14.y/kernel/softirq.c' l='579' u='c' c='tasklet_kill'/>
<use f='linux-4.14.y/net/netlink/af_netlink.c' l='1493' u='c' c='netlink_broadcast_filtered'/>
<use f='linux-4.14.y/net/sched/sch_generic.c' l='936' u='c' c='dev_deactivate_many'/>
