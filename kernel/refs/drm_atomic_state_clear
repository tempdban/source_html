<dec f='linux-4.14.y/include/drm/drm_atomic.h' l='275' type='void drm_atomic_state_clear(struct drm_atomic_state * state)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='227' ll='236' type='void drm_atomic_state_clear(struct drm_atomic_state * state)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' type='void drm_atomic_state_clear(struct drm_atomic_state * )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' c='drm_atomic_state_clear'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='251' u='c' c='__drm_atomic_state_free'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2360' u='c' c='drm_mode_atomic_ioctl'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='213'>/**
 * drm_atomic_state_clear - clear state object
 * @state: atomic state
 *
 * When the w/w mutex algorithm detects a deadlock we need to back off and drop
 * all locks. So someone else could sneak in and change the current modeset
 * configuration. Which means that all the state assembled in @state is no
 * longer an atomic update to the current state, but to some arbitrary earlier
 * state. Which could break assumptions the driver&apos;s
 * &amp;drm_mode_config_funcs.atomic_check likely relies on.
 *
 * Hence we must clear all cached state and completely start over, using this
 * function.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_fb_helper.c' l='428' u='c' c='restore_fbdev_mode_atomic'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_fb_helper.c' l='1387' u='c' c='setcmap_atomic'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_framebuffer.c' l='846' u='c' c='atomic_remove_fb'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_mode_object.c' l='459' u='c' c='set_property_atomic'/>
<dec f='linux-4.14.y/include/drm/drm_atomic.h' l='275' type='void drm_atomic_state_clear(struct drm_atomic_state * state)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='227' ll='236' type='void drm_atomic_state_clear(struct drm_atomic_state * state)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' type='void drm_atomic_state_clear(struct drm_atomic_state * )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' c='drm_atomic_state_clear'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='237' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='251' u='c' c='__drm_atomic_state_free'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2360' u='c' c='drm_mode_atomic_ioctl'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='213'>/**
 * drm_atomic_state_clear - clear state object
 * @state: atomic state
 *
 * When the w/w mutex algorithm detects a deadlock we need to back off and drop
 * all locks. So someone else could sneak in and change the current modeset
 * configuration. Which means that all the state assembled in @state is no
 * longer an atomic update to the current state, but to some arbitrary earlier
 * state. Which could break assumptions the driver&apos;s
 * &amp;drm_mode_config_funcs.atomic_check likely relies on.
 *
 * Hence we must clear all cached state and completely start over, using this
 * function.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_fb_helper.c' l='428' u='c' c='restore_fbdev_mode_atomic'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_fb_helper.c' l='1387' u='c' c='setcmap_atomic'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_framebuffer.c' l='846' u='c' c='atomic_remove_fb'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_mode_object.c' l='459' u='c' c='set_property_atomic'/>
