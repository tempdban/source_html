<dec f='linux-4.14.y/include/linux/smp.h' l='101' type='void smp_call_function_many(const struct cpumask * mask, smp_call_func_t func, void * info, bool wait)'/>
<use f='linux-4.14.y/arch/x86/lib/msr-smp.c' l='115' u='c' c='__rwmsr_on_cpus'/>
<use f='linux-4.14.y/arch/x86/mm/tlb.c' l='585' u='c' c='native_flush_tlb_others'/>
<use f='linux-4.14.y/arch/x86/mm/tlb.c' l='589' u='c' c='native_flush_tlb_others'/>
<use f='linux-4.14.y/kernel/sched/membarrier.c' l='93' u='c' c='membarrier_private_expedited'/>
<def f='linux-4.14.y/kernel/smp.c' l='403' ll='471' type='void smp_call_function_many(const struct cpumask * mask, smp_call_func_t func, void * info, bool wait)'/>
<dec f='linux-4.14.y/kernel/smp.c' l='472' type='void smp_call_function_many(const struct cpumask * , smp_call_func_t , void * , bool )'/>
<use f='linux-4.14.y/kernel/smp.c' l='472' c='smp_call_function_many'/>
<use f='linux-4.14.y/kernel/smp.c' l='472' u='a'/>
<use f='linux-4.14.y/kernel/smp.c' l='472' u='a'/>
<use f='linux-4.14.y/kernel/smp.c' l='492' u='c' c='smp_call_function'/>
<use f='linux-4.14.y/kernel/smp.c' l='632' u='c' c='on_each_cpu_mask'/>
<doc f='linux-4.14.y/kernel/smp.c' l='389'>/**
 * smp_call_function_many(): Run a function on a set of other CPUs.
 * @mask: The set of cpus to run on (only runs on online subset).
 * @func: The function to run. This must be fast and non-blocking.
 * @info: An arbitrary pointer to pass to the function.
 * @wait: If true, wait (atomically) until function has completed
 *        on other CPUs.
 *
 * If @wait is true, then returns once @func has returned.
 *
 * You must not call this function with disabled interrupts or from a
 * hardware interrupt handler or from a bottom half handler. Preemption
 * must be disabled when calling this function.
 */</doc>
<use f='linux-4.14.y/kernel/trace/trace.c' l='2235' u='c' c='trace_buffered_event_disable'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='2254' u='c' c='trace_buffered_event_disable'/>
<dec f='linux-4.14.y/include/linux/smp.h' l='101' type='void smp_call_function_many(const struct cpumask * mask, smp_call_func_t func, void * info, bool wait)'/>
<use f='linux-4.14.y/arch/x86/lib/msr-smp.c' l='115' u='c' c='__rwmsr_on_cpus'/>
<use f='linux-4.14.y/arch/x86/mm/tlb.c' l='585' u='c' c='native_flush_tlb_others'/>
<use f='linux-4.14.y/arch/x86/mm/tlb.c' l='589' u='c' c='native_flush_tlb_others'/>
<use f='linux-4.14.y/kernel/sched/membarrier.c' l='93' u='c' c='membarrier_private_expedited'/>
<def f='linux-4.14.y/kernel/smp.c' l='403' ll='471' type='void smp_call_function_many(const struct cpumask * mask, smp_call_func_t func, void * info, bool wait)'/>
<dec f='linux-4.14.y/kernel/smp.c' l='472' type='void smp_call_function_many(const struct cpumask * , smp_call_func_t , void * , bool )'/>
<use f='linux-4.14.y/kernel/smp.c' l='472' c='smp_call_function_many'/>
<use f='linux-4.14.y/kernel/smp.c' l='472' u='a'/>
<use f='linux-4.14.y/kernel/smp.c' l='472' u='a'/>
<use f='linux-4.14.y/kernel/smp.c' l='492' u='c' c='smp_call_function'/>
<use f='linux-4.14.y/kernel/smp.c' l='632' u='c' c='on_each_cpu_mask'/>
<doc f='linux-4.14.y/kernel/smp.c' l='389'>/**
 * smp_call_function_many(): Run a function on a set of other CPUs.
 * @mask: The set of cpus to run on (only runs on online subset).
 * @func: The function to run. This must be fast and non-blocking.
 * @info: An arbitrary pointer to pass to the function.
 * @wait: If true, wait (atomically) until function has completed
 *        on other CPUs.
 *
 * If @wait is true, then returns once @func has returned.
 *
 * You must not call this function with disabled interrupts or from a
 * hardware interrupt handler or from a bottom half handler. Preemption
 * must be disabled when calling this function.
 */</doc>
<use f='linux-4.14.y/kernel/trace/trace.c' l='2235' u='c' c='trace_buffered_event_disable'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='2254' u='c' c='trace_buffered_event_disable'/>
