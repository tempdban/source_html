<def f='linux-4.14.y/include/asm-generic/pgtable.h' l='885' ll='928' type='int pmd_none_or_trans_huge_or_clear_bad(pmd_t * pmd)'/>
<doc f='linux-4.14.y/include/asm-generic/pgtable.h' l='864'>/*
 * This function is meant to be used by sites walking pagetables with
 * the mmap_sem hold in read mode to protect against MADV_DONTNEED and
 * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd
 * into a null pmd and the transhuge page fault can convert a null pmd
 * into an hugepmd or into a regular pmd (if the hugepage allocation
 * fails). While holding the mmap_sem in read mode the pmd becomes
 * stable and stops changing under us only if it&apos;s not null and not a
 * transhuge pmd. When those races occurs and this function makes a
 * difference vs the standard pmd_none_or_clear_bad, the result is
 * undefined so behaving like if the pmd was none is safe (because it
 * can return none anyway). The compiler level barrier() is critically
 * important to compute the two checks atomically on the same pmdval.
 *
 * For 32bit kernels with a 64bit large pmd_t this automatically takes
 * care of reading the pmd atomically to avoid SMP race conditions
 * against pmd_populate() when the mmap_sem is hold for reading by the
 * caller (a special atomic read not done by &quot;gcc&quot; as in the generic
 * version above, is also needed when THP is disabled because the page
 * fault can populate the pmd from under us).
 */</doc>
<use f='linux-4.14.y/mm/madvise.c' l='200' u='c' c='swapin_walk_pmd_entry'/>
<use f='linux-4.14.y/mm/memory.c' l='1435' u='c' c='zap_pmd_range'/>
<use f='linux-4.14.y/mm/swapfile.c' l='1870' u='c' c='unuse_pmd_range'/>
