<dec f='linux-4.18.y/include/linux/cpumask.h' l='218' type='int cpumask_any_but(const struct cpumask * mask, unsigned int cpu)'/>
<use f='linux-4.18.y/arch/x86/events/intel/cstate.c' l='383' u='c' c='cstate_cpu_exit'/>
<use f='linux-4.18.y/arch/x86/events/intel/cstate.c' l='394' u='c' c='cstate_cpu_exit'/>
<use f='linux-4.18.y/arch/x86/events/intel/rapl.c' l='580' u='c' c='rapl_cpu_offline'/>
<use f='linux-4.18.y/arch/x86/events/intel/uncore.c' l='1160' u='c' c='uncore_event_cpu_offline'/>
<use f='linux-4.18.y/arch/x86/kernel/tsc.c' l='1461' u='c' c='calibrate_delay_is_known'/>
<use f='linux-4.18.y/arch/x86/kernel/tsc_sync.c' l='168' u='c' c='tsc_store_and_check_tsc_adjust'/>
<use f='linux-4.18.y/arch/x86/mm/tlb.c' l='650' u='c' c='flush_tlb_mm_range'/>
<use f='linux-4.18.y/arch/x86/mm/tlb.c' l='711' u='c' c='arch_tlbbatch_flush'/>
<use f='linux-4.18.y/kernel/irq/cpuhotplug.c' l='38' u='c' c='irq_needs_fixup'/>
<def f='linux-4.18.y/lib/cpumask.c' l='52' ll='61' type='int cpumask_any_but(const struct cpumask * mask, unsigned int cpu)'/>
<dec f='linux-4.18.y/lib/cpumask.c' l='62' type='int cpumask_any_but(const struct cpumask * , unsigned int )'/>
<use f='linux-4.18.y/lib/cpumask.c' l='62' c='cpumask_any_but'/>
<use f='linux-4.18.y/lib/cpumask.c' l='62' u='a'/>
<use f='linux-4.18.y/lib/cpumask.c' l='62' u='a'/>
<doc f='linux-4.18.y/lib/cpumask.c' l='44'>/**
 * cpumask_any_but - return a &quot;random&quot; in a cpumask, but not this one.
 * @mask: the cpumask to search
 * @cpu: the cpu to ignore.
 *
 * Often used to find any cpu but smp_processor_id() in a mask.
 * Returns &gt;= nr_cpu_ids if no cpus set.
 */</doc>
<use f='linux-4.18.y/mm/rmap.c' l='637' u='c' c='should_defer_flush'/>
