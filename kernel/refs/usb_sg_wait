<dec f='linux-4.14.y/include/linux/usb.h' l='1846' type='void usb_sg_wait(struct usb_sg_request * io)'/>
<def f='linux-4.14.y/drivers/usb/core/message.c' l='513' ll='572' type='void usb_sg_wait(struct usb_sg_request * io)'/>
<dec f='linux-4.14.y/drivers/usb/core/message.c' l='573' type='void usb_sg_wait(struct usb_sg_request * )'/>
<use f='linux-4.14.y/drivers/usb/core/message.c' l='573' c='usb_sg_wait'/>
<use f='linux-4.14.y/drivers/usb/core/message.c' l='573' u='a'/>
<use f='linux-4.14.y/drivers/usb/core/message.c' l='573' u='a'/>
<doc f='linux-4.14.y/drivers/usb/core/message.c' l='469'>/**
 * usb_sg_wait - synchronously execute scatter/gather request
 * @io: request block handle, as initialized with usb_sg_init().
 * 	some fields become accessible when this call returns.
 * Context: !in_interrupt ()
 *
 * This function blocks until the specified I/O operation completes.  It
 * leverages the grouping of the related I/O requests to get good transfer
 * rates, by queueing the requests.  At higher speeds, such queuing can
 * significantly improve USB throughput.
 *
 * There are three kinds of completion for this function.
 *
 * (1) success, where io-&gt;status is zero.  The number of io-&gt;bytes
 *     transferred is as requested.
 * (2) error, where io-&gt;status is a negative errno value.  The number
 *     of io-&gt;bytes transferred before the error is usually less
 *     than requested, and can be nonzero.
 * (3) cancellation, a type of error with status -ECONNRESET that
 *     is initiated by usb_sg_cancel().
 *
 * When this function returns, all memory allocated through usb_sg_init() or
 * this call will have been freed.  The request block parameter may still be
 * passed to usb_sg_cancel(), or it may be freed.  It could also be
 * reinitialized and then reused.
 *
 * Data Transfer Rates:
 *
 * Bulk transfers are valid for full or high speed endpoints.
 * The best full speed data rate is 19 packets of 64 bytes each
 * per frame, or 1216 bytes per millisecond.
 * The best high speed data rate is 13 packets of 512 bytes each
 * per microframe, or 52 KBytes per millisecond.
 *
 * The reason to use interrupt transfers through this API would most likely
 * be to reserve high speed bandwidth, where up to 24 KBytes per millisecond
 * could be transferred.  That capability is less useful for low or full
 * speed interrupt endpoints, which allow at most one packet per millisecond,
 * of at most 8 or 64 bytes (respectively).
 *
 * It is not necessary to call this function to reserve bandwidth for devices
 * under an xHCI host controller, as the bandwidth is reserved when the
 * configuration or interface alt setting is selected.
 */</doc>
<use f='linux-4.14.y/drivers/usb/storage/transport.c' l='463' u='c' c='usb_stor_bulk_transfer_sglist'/>
