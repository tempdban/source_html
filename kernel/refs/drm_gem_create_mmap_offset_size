<dec f='linux-4.18.y/include/drm/drm_gem.h' l='283' type='int drm_gem_create_mmap_offset_size(struct drm_gem_object * obj, size_t size)'/>
<def f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='493' ll='500' type='int drm_gem_create_mmap_offset_size(struct drm_gem_object * obj, size_t size)'/>
<dec f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='501' type='int drm_gem_create_mmap_offset_size(struct drm_gem_object * , size_t )'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='501' c='drm_gem_create_mmap_offset_size'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='501' u='a'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='501' u='a'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='519' u='c' c='drm_gem_create_mmap_offset'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='476'>/**
 * drm_gem_create_mmap_offset_size - create a fake mmap offset for an object
 * @obj: obj in question
 * @size: the virtual size
 *
 * GEM memory mapping works by handing back to userspace a fake mmap offset
 * it can use in a subsequent mmap(2) call.  The DRM core code then looks
 * up the object based on the offset and sets up the various memory mapping
 * structures.
 *
 * This routine allocates and attaches a fake offset for @obj, in cases where
 * the virtual size differs from the physical size (ie. &amp;drm_gem_object.size).
 * Otherwise just use drm_gem_create_mmap_offset().
 *
 * This function is idempotent and handles an already allocated mmap offset
 * transparently. Drivers do not need to check for this case.
 */</doc>
