<dec f='linux-4.18.y/include/linux/netfilter/x_tables.h' l='280' type='int xt_check_entry_offsets(const void * base, const char * elems, unsigned int target_offset, unsigned int next_offset)'/>
<use f='linux-4.18.y/net/ipv4/netfilter/arp_tables.c' l='471' u='c' c='check_entry_size_and_hooks'/>
<use f='linux-4.18.y/net/ipv4/netfilter/ip_tables.c' l='614' u='c' c='check_entry_size_and_hooks'/>
<def f='linux-4.18.y/net/netfilter/x_tables.c' l='898' ll='939' type='int xt_check_entry_offsets(const void * base, const char * elems, unsigned int target_offset, unsigned int next_offset)'/>
<dec f='linux-4.18.y/net/netfilter/x_tables.c' l='940' type='int xt_check_entry_offsets(const void * , const char * , unsigned int , unsigned int )'/>
<use f='linux-4.18.y/net/netfilter/x_tables.c' l='940' c='xt_check_entry_offsets'/>
<use f='linux-4.18.y/net/netfilter/x_tables.c' l='940' u='a'/>
<use f='linux-4.18.y/net/netfilter/x_tables.c' l='940' u='a'/>
<doc f='linux-4.18.y/net/netfilter/x_tables.c' l='855'>/**
 * xt_check_entry_offsets - validate arp/ip/ip6t_entry
 *
 * @base: pointer to arp/ip/ip6t_entry
 * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry-&gt;elems
 * @target_offset: the arp/ip/ip6_t-&gt;target_offset
 * @next_offset: the arp/ip/ip6_t-&gt;next_offset
 *
 * validates that target_offset and next_offset are sane and that all
 * match sizes (if any) align with the target offset.
 *
 * This function does not validate the targets or matches themselves, it
 * only tests that all the offsets and sizes are correct, that all
 * match structures are aligned, and that the last structure ends where
 * the target structure begins.
 *
 * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.
 *
 * The arp/ip/ip6t_entry structure @base must have passed following tests:
 * - it must point to a valid memory location
 * - base to base + next_offset must be accessible, i.e. not exceed allocated
 *   length.
 *
 * A well-formed entry looks like this:
 *
 * ip(6)t_entry   match [mtdata]  match [mtdata] target [tgdata] ip(6)t_entry
 * e-&gt;elems[]-----&apos;                              |               |
 *                matchsize                      |               |
 *                                matchsize      |               |
 *                                               |               |
 * target_offset---------------------------------&apos;               |
 * next_offset---------------------------------------------------&apos;
 *
 * elems[]: flexible array member at end of ip(6)/arpt_entry struct.
 *          This is where matches (if any) and the target reside.
 * target_offset: beginning of target.
 * next_offset: start of the next rule; also: size of this rule.
 * Since targets have a minimum size, target_offset + minlen &lt;= next_offset.
 *
 * Every match stores its size, sum of sizes must not exceed target_offset.
 *
 * Return: 0 on success, negative errno on failure.
 */</doc>
