<dec f='linux-4.14.y/block/blk.h' l='113' type='bool blk_attempt_plug_merge(struct request_queue * q, struct bio * bio, unsigned int * request_count, struct request ** same_queue_rq)'/>
<def f='linux-4.14.y/block/blk-core.c' l='1705' ll='1759' type='bool blk_attempt_plug_merge(struct request_queue * q, struct bio * bio, unsigned int * request_count, struct request ** same_queue_rq)'/>
<use f='linux-4.14.y/block/blk-core.c' l='1835' u='c' c='blk_queue_bio'/>
<doc f='linux-4.14.y/block/blk-core.c' l='1683'>/**
 * blk_attempt_plug_merge - try to merge with %current&apos;s plugged list
 * @q: request_queue new bio is being queued at
 * @bio: new bio being queued
 * @request_count: out parameter for number of traversed plugged requests
 * @same_queue_rq: pointer to &amp;struct request that gets filled in when
 * another request associated with @q is found on the plug list
 * (optional, may be %NULL)
 *
 * Determine whether @bio being queued on @q can be merged with a request
 * on %current&apos;s plugged list.  Returns %true if merge was successful,
 * otherwise %false.
 *
 * Plugging coalesces IOs from the same issuer for the same purpose without
 * going through @q-&gt;queue_lock.  As such it&apos;s more of an issuing mechanism
 * than scheduling, and the request, while may have elvpriv data, is not
 * added on the elevator at this point.  In addition, we don&apos;t have
 * reliable access to the elevator outside queue lock.  Only check basic
 * merging parameters without querying the elevator.
 *
 * Caller must ensure !blk_queue_nomerges(q) beforehand.
 */</doc>
<use f='linux-4.14.y/block/blk-mq.c' l='1659' u='c' c='blk_mq_make_request'/>
<dec f='linux-4.14.y/block/blk.h' l='113' type='bool blk_attempt_plug_merge(struct request_queue * q, struct bio * bio, unsigned int * request_count, struct request ** same_queue_rq)'/>
<def f='linux-4.14.y/block/blk-core.c' l='1705' ll='1759' type='bool blk_attempt_plug_merge(struct request_queue * q, struct bio * bio, unsigned int * request_count, struct request ** same_queue_rq)'/>
<use f='linux-4.14.y/block/blk-core.c' l='1835' u='c' c='blk_queue_bio'/>
<doc f='linux-4.14.y/block/blk-core.c' l='1683'>/**
 * blk_attempt_plug_merge - try to merge with %current&apos;s plugged list
 * @q: request_queue new bio is being queued at
 * @bio: new bio being queued
 * @request_count: out parameter for number of traversed plugged requests
 * @same_queue_rq: pointer to &amp;struct request that gets filled in when
 * another request associated with @q is found on the plug list
 * (optional, may be %NULL)
 *
 * Determine whether @bio being queued on @q can be merged with a request
 * on %current&apos;s plugged list.  Returns %true if merge was successful,
 * otherwise %false.
 *
 * Plugging coalesces IOs from the same issuer for the same purpose without
 * going through @q-&gt;queue_lock.  As such it&apos;s more of an issuing mechanism
 * than scheduling, and the request, while may have elvpriv data, is not
 * added on the elevator at this point.  In addition, we don&apos;t have
 * reliable access to the elevator outside queue lock.  Only check basic
 * merging parameters without querying the elevator.
 *
 * Caller must ensure !blk_queue_nomerges(q) beforehand.
 */</doc>
<use f='linux-4.14.y/block/blk-mq.c' l='1659' u='c' c='blk_mq_make_request'/>
