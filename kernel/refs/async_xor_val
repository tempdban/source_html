<dec f='linux-4.18.y/include/linux/async_tx.h' l='179' type='struct dma_async_tx_descriptor * async_xor_val(struct page * dest, struct page ** src_list, unsigned int offset, int src_cnt, size_t len, enum sum_check_flags * result, struct async_submit_ctl * submit)'/>
<def f='linux-4.18.y/crypto/async_tx/async_xor.c' l='268' ll='340' type='struct dma_async_tx_descriptor * async_xor_val(struct page * dest, struct page ** src_list, unsigned int offset, int src_cnt, size_t len, enum sum_check_flags * result, struct async_submit_ctl * submit)'/>
<dec f='linux-4.18.y/crypto/async_tx/async_xor.c' l='341' type='struct dma_async_tx_descriptor * async_xor_val(struct page * , struct page ** , unsigned int , int , size_t , enum sum_check_flags * , struct async_submit_ctl * )'/>
<use f='linux-4.18.y/crypto/async_tx/async_xor.c' l='341' c='async_xor_val'/>
<use f='linux-4.18.y/crypto/async_tx/async_xor.c' l='341' u='a'/>
<use f='linux-4.18.y/crypto/async_tx/async_xor.c' l='341' u='a'/>
<doc f='linux-4.18.y/crypto/async_tx/async_xor.c' l='252'>/**
 * async_xor_val - attempt a xor parity check with a dma engine.
 * @dest: destination page used if the xor is performed synchronously
 * @src_list: array of source pages
 * @offset: offset in pages to start transaction
 * @src_cnt: number of source pages
 * @len: length in bytes
 * @result: 0 if sum == 0 else non-zero
 * @submit: submission / completion modifiers
 *
 * honored flags: ASYNC_TX_ACK
 *
 * src_list note: if the dest is also a source it must be at index zero.
 * The contents of this array will be overwritten if a scribble region
 * is not specified.
 */</doc>
<use f='linux-4.18.y/drivers/md/raid5.c' l='2036' u='c' c='ops_run_check_p'/>
