<dec f='linux-4.14.y/include/linux/vgaarb.h' l='77' type='int vga_get(struct pci_dev * pdev, unsigned int rsrc, int interruptible)'/>
<use f='linux-4.14.y/include/linux/vgaarb.h' l='94' u='c' c='vga_get_interruptible'/>
<use f='linux-4.14.y/include/linux/vgaarb.h' l='109' u='c' c='vga_get_uninterruptible'/>
<def f='linux-4.14.y/drivers/gpu/vga/vgaarb.c' l='416' ll='465' type='int vga_get(struct pci_dev * pdev, unsigned int rsrc, int interruptible)'/>
<dec f='linux-4.14.y/drivers/gpu/vga/vgaarb.c' l='466' type='int vga_get(struct pci_dev * , unsigned int , int )'/>
<use f='linux-4.14.y/drivers/gpu/vga/vgaarb.c' l='466' c='vga_get'/>
<use f='linux-4.14.y/drivers/gpu/vga/vgaarb.c' l='466' u='a'/>
<use f='linux-4.14.y/drivers/gpu/vga/vgaarb.c' l='466' u='a'/>
<doc f='linux-4.14.y/drivers/gpu/vga/vgaarb.c' l='382'>/**
 * vga_get - acquire &amp; locks VGA resources
 * @pdev: pci device of the VGA card or NULL for the system default
 * @rsrc: bit mask of resources to acquire and lock
 * @interruptible: blocking should be interruptible by signals ?
 *
 * This function acquires VGA resources for the given card and mark those
 * resources locked. If the resource requested are &quot;normal&quot; (and not legacy)
 * resources, the arbiter will first check whether the card is doing legacy
 * decoding for that type of resource. If yes, the lock is &quot;converted&quot; into a
 * legacy resource lock.
 *
 * The arbiter will first look for all VGA cards that might conflict and disable
 * their IOs and/or Memory access, including VGA forwarding on P2P bridges if
 * necessary, so that the requested resources can be used. Then, the card is
 * marked as locking these resources and the IO and/or Memory accesses are
 * enabled on the card (including VGA forwarding on parent P2P bridges if any).
 *
 * This function will block if some conflicting card is already locking one of
 * the required resources (or any resource on a different bus segment, since P2P
 * bridges don&apos;t differentiate VGA memory and IO afaik). You can indicate
 * whether this blocking should be interruptible by a signal (for userland
 * interface) or not.
 *
 * Must not be called at interrupt time or in atomic context.  If the card
 * already owns the resources, the function succeeds.  Nested calls are
 * supported (a per-resource counter is maintained)
 *
 * On success, release the VGA resource again with vga_put().
 *
 * Returns:
 *
 * 0 on success, negative error code on failure.
 */</doc>
