<dec f='linux-4.14.y/include/linux/fs.h' l='2598' type='int file_check_and_advance_wb_err(struct file * file)'/>
<use f='linux-4.14.y/fs/libfs.c' l='995' u='c' c='__generic_file_fsync'/>
<use f='linux-4.14.y/mm/filemap.c' l='485' u='c' c='file_fdatawait_range'/>
<def f='linux-4.14.y/mm/filemap.c' l='607' ll='632' type='int file_check_and_advance_wb_err(struct file * file)'/>
<dec f='linux-4.14.y/mm/filemap.c' l='633' type='int file_check_and_advance_wb_err(struct file * )'/>
<use f='linux-4.14.y/mm/filemap.c' l='633' c='file_check_and_advance_wb_err'/>
<use f='linux-4.14.y/mm/filemap.c' l='633' u='a'/>
<use f='linux-4.14.y/mm/filemap.c' l='633' u='a'/>
<use f='linux-4.14.y/mm/filemap.c' l='661' u='c' c='file_write_and_wait_range'/>
<doc f='linux-4.14.y/mm/filemap.c' l='585'>/**
 * file_check_and_advance_wb_err - report wb error (if any) that was previously
 * 				   and advance wb_err to current one
 * @file: struct file on which the error is being reported
 *
 * When userland calls fsync (or something like nfsd does the equivalent), we
 * want to report any writeback errors that occurred since the last fsync (or
 * since the file was opened if there haven&apos;t been any).
 *
 * Grab the wb_err from the mapping. If it matches what we have in the file,
 * then just quickly return 0. The file is all caught up.
 *
 * If it doesn&apos;t match, then take the mapping value, set the &quot;seen&quot; flag in
 * it and try to swap it into place. If it works, or another task beat us
 * to it with the new value, then update the f_wb_err and return the error
 * portion. The error at this point must be reported via proper channels
 * (a&apos;la fsync, or NFS COMMIT operation, etc.).
 *
 * While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
 * value is protected by the f_lock since we must ensure that it reflects
 * the latest value swapped in for this file descriptor.
 */</doc>
<dec f='linux-4.14.y/include/linux/fs.h' l='2598' type='int file_check_and_advance_wb_err(struct file * file)'/>
<use f='linux-4.14.y/fs/fuse/file.c' l='471' u='c' c='fuse_fsync_common'/>
<use f='linux-4.14.y/fs/libfs.c' l='995' u='c' c='__generic_file_fsync'/>
<use f='linux-4.14.y/mm/filemap.c' l='485' u='c' c='file_fdatawait_range'/>
<def f='linux-4.14.y/mm/filemap.c' l='607' ll='632' type='int file_check_and_advance_wb_err(struct file * file)'/>
<dec f='linux-4.14.y/mm/filemap.c' l='633' type='int file_check_and_advance_wb_err(struct file * )'/>
<use f='linux-4.14.y/mm/filemap.c' l='633' c='file_check_and_advance_wb_err'/>
<use f='linux-4.14.y/mm/filemap.c' l='633' u='a'/>
<use f='linux-4.14.y/mm/filemap.c' l='633' u='a'/>
<use f='linux-4.14.y/mm/filemap.c' l='661' u='c' c='file_write_and_wait_range'/>
<doc f='linux-4.14.y/mm/filemap.c' l='585'>/**
 * file_check_and_advance_wb_err - report wb error (if any) that was previously
 * 				   and advance wb_err to current one
 * @file: struct file on which the error is being reported
 *
 * When userland calls fsync (or something like nfsd does the equivalent), we
 * want to report any writeback errors that occurred since the last fsync (or
 * since the file was opened if there haven&apos;t been any).
 *
 * Grab the wb_err from the mapping. If it matches what we have in the file,
 * then just quickly return 0. The file is all caught up.
 *
 * If it doesn&apos;t match, then take the mapping value, set the &quot;seen&quot; flag in
 * it and try to swap it into place. If it works, or another task beat us
 * to it with the new value, then update the f_wb_err and return the error
 * portion. The error at this point must be reported via proper channels
 * (a&apos;la fsync, or NFS COMMIT operation, etc.).
 *
 * While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
 * value is protected by the f_lock since we must ensure that it reflects
 * the latest value swapped in for this file descriptor.
 */</doc>
