<dec f='linux-4.14.y/drivers/gpu/drm/drm_crtc_internal.h' l='157' type='int drm_framebuffer_check_src_coords(uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h, const struct drm_framebuffer * fb)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_crtc.c' l='528' u='c' c='drm_crtc_check_viewport'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_framebuffer.c' l='66' ll='90' type='int drm_framebuffer_check_src_coords(uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h, const struct drm_framebuffer * fb)'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_framebuffer.c' l='31'>/**
 * DOC: overview
 *
 * Frame buffers are abstract memory objects that provide a source of pixels to
 * scanout to a CRTC. Applications explicitly request the creation of frame
 * buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque
 * handle that can be passed to the KMS CRTC control, plane configuration and
 * page flip functions.
 *
 * Frame buffers rely on the underlying memory manager for allocating backing
 * storage. When creating a frame buffer applications pass a memory handle
 * (or a list of memory handles for multi-planar formats) through the
 * &amp;struct drm_mode_fb_cmd2 argument. For drivers using GEM as their userspace
 * buffer management interface this would be a GEM handle.  Drivers are however
 * free to use their own backing storage object handles, e.g. vmwgfx directly
 * exposes special TTM handles to userspace and so expects TTM handles in the
 * create ioctl and not GEM handles.
 *
 * Framebuffers are tracked with &amp;struct drm_framebuffer. They are published
 * using drm_framebuffer_init() - after calling that function userspace can use
 * and access the framebuffer object. The helper function
 * drm_helper_mode_fill_fb_struct() can be used to pre-fill the required
 * metadata fields.
 *
 * The lifetime of a drm framebuffer is controlled with a reference count,
 * drivers can grab additional references with drm_framebuffer_get() and drop
 * them again with drm_framebuffer_put(). For driver-private framebuffers for
 * which the last reference is never dropped (e.g. for the fbdev framebuffer
 * when the struct &amp;struct drm_framebuffer is embedded into the fbdev helper
 * struct) drivers can manually clean up a framebuffer at module unload time
 * with drm_framebuffer_unregister_private(). But doing this is not
 * recommended, and it&apos;s better to have a normal free-standing &amp;struct
 * drm_framebuffer.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane.c' l='632' u='c' c='__setplane_internal'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_plane.c' l='1015' u='c' c='drm_mode_page_flip_ioctl'/>
