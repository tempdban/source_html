<dec f='linux-4.14.y/include/linux/ring_buffer.h' l='126' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu)'/>
<def f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4011' ll='4032' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu)'/>
<dec f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * , int )'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' c='ring_buffer_read_prepare'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' u='a'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' u='a'/>
<doc f='linux-4.14.y/kernel/trace/ring_buffer.c' l='3991'>/**
 * ring_buffer_read_prepare - Prepare for a non consuming read of the buffer
 * @buffer: The ring buffer to read from
 * @cpu: The cpu buffer to iterate over
 *
 * This performs the initial preparations necessary to iterate
 * through the buffer.  Memory is allocated, buffer recording
 * is disabled, and the iterator pointer is returned to the caller.
 *
 * Disabling buffer recordng prevents the reading from being
 * corrupted. This is not a consuming read, so a producer is not
 * expected.
 *
 * After a sequence of ring_buffer_read_prepare calls, the user is
 * expected to make at least one call to ring_buffer_read_prepare_sync.
 * Afterwards, ring_buffer_read_start is invoked to get things going
 * for real.
 *
 * This overall must be paired with ring_buffer_read_finish.
 */</doc>
<use f='linux-4.14.y/kernel/trace/trace.c' l='3891' u='c' c='__tracing_open'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='3901' u='c' c='__tracing_open'/>
<use f='linux-4.14.y/kernel/trace/trace_kdb.c' l='54' u='c' c='ftrace_dump_buf'/>
<use f='linux-4.14.y/kernel/trace/trace_kdb.c' l='61' u='c' c='ftrace_dump_buf'/>
<dec f='linux-4.14.y/include/linux/ring_buffer.h' l='126' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu)'/>
<def f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4011' ll='4032' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * buffer, int cpu)'/>
<dec f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' type='struct ring_buffer_iter * ring_buffer_read_prepare(struct ring_buffer * , int )'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' c='ring_buffer_read_prepare'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' u='a'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4033' u='a'/>
<doc f='linux-4.14.y/kernel/trace/ring_buffer.c' l='3991'>/**
 * ring_buffer_read_prepare - Prepare for a non consuming read of the buffer
 * @buffer: The ring buffer to read from
 * @cpu: The cpu buffer to iterate over
 *
 * This performs the initial preparations necessary to iterate
 * through the buffer.  Memory is allocated, buffer recording
 * is disabled, and the iterator pointer is returned to the caller.
 *
 * Disabling buffer recordng prevents the reading from being
 * corrupted. This is not a consuming read, so a producer is not
 * expected.
 *
 * After a sequence of ring_buffer_read_prepare calls, the user is
 * expected to make at least one call to ring_buffer_read_prepare_sync.
 * Afterwards, ring_buffer_read_start is invoked to get things going
 * for real.
 *
 * This overall must be paired with ring_buffer_read_finish.
 */</doc>
<use f='linux-4.14.y/kernel/trace/trace.c' l='3891' u='c' c='__tracing_open'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='3901' u='c' c='__tracing_open'/>
<use f='linux-4.14.y/kernel/trace/trace_kdb.c' l='54' u='c' c='ftrace_dump_buf'/>
<use f='linux-4.14.y/kernel/trace/trace_kdb.c' l='61' u='c' c='ftrace_dump_buf'/>
