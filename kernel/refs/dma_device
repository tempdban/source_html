<def f='linux-4.14.y/include/linux/dmaengine.h' l='723' ll='804'/>
<size>296</size>
<doc f='linux-4.14.y/include/linux/dmaengine.h' l='664'>/**
 * struct dma_device - info on the entity supplying DMA services
 * @chancnt: how many DMA channels are supported
 * @privatecnt: how many DMA channels are requested by dma_request_channel
 * @channels: the list of struct dma_chan
 * @global_node: list_head for global dma_device_list
 * @filter: information for device/slave to filter function/param mapping
 * @cap_mask: one or more dma_capability flags
 * @max_xor: maximum number of xor sources, 0 if no capability
 * @max_pq: maximum number of PQ sources and PQ-continue capability
 * @copy_align: alignment shift for memcpy operations
 * @xor_align: alignment shift for xor operations
 * @pq_align: alignment shift for pq operations
 * @fill_align: alignment shift for memset operations
 * @dev_id: unique device ID
 * @dev: struct device reference for dma mapping api
 * @src_addr_widths: bit mask of src addr widths the device supports
 * @dst_addr_widths: bit mask of dst addr widths the device supports
 * @directions: bit mask of slave direction the device supports since
 * 	the enum dma_transfer_direction is not defined as bits for
 * 	each type of direction, the dma controller should fill (1 &lt;&lt;
 * 	&lt;TYPE&gt;) and same should be checked by controller as well
 * @max_burst: max burst capability per-transfer
 * @residue_granularity: granularity of the transfer residue reported
 *	by tx_status
 * @device_alloc_chan_resources: allocate resources and return the
 *	number of allocated descriptors
 * @device_free_chan_resources: release DMA channel&apos;s resources
 * @device_prep_dma_memcpy: prepares a memcpy operation
 * @device_prep_dma_xor: prepares a xor operation
 * @device_prep_dma_xor_val: prepares a xor validation operation
 * @device_prep_dma_pq: prepares a pq operation
 * @device_prep_dma_pq_val: prepares a pqzero_sum operation
 * @device_prep_dma_memset: prepares a memset operation
 * @device_prep_dma_memset_sg: prepares a memset operation over a scatter list
 * @device_prep_dma_interrupt: prepares an end of chain interrupt operation
 * @device_prep_slave_sg: prepares a slave dma operation
 * @device_prep_dma_cyclic: prepare a cyclic dma operation suitable for audio.
 *	The function takes a buffer of size buf_len. The callback function will
 *	be called after period_len bytes have been transferred.
 * @device_prep_interleaved_dma: Transfer expression in a generic way.
 * @device_prep_dma_imm_data: DMA&apos;s 8 byte immediate data to the dst address
 * @device_config: Pushes a new configuration to a channel, return 0 or an error
 *	code
 * @device_pause: Pauses any transfer happening on a channel. Returns
 *	0 or an error code
 * @device_resume: Resumes any transfer on a channel previously
 *	paused. Returns 0 or an error code
 * @device_terminate_all: Aborts all transfers on a channel. Returns 0
 *	or an error code
 * @device_synchronize: Synchronizes the termination of a transfers to the
 *  current context.
 * @device_tx_status: poll for transaction completion, the optional
 *	txstate parameter can be supplied with a pointer to get a
 *	struct with auxiliary transfer status information, otherwise the call
 *	will just return a simple status code
 * @device_issue_pending: push pending transactions to hardware
 * @descriptor_reuse: a submitted transfer can be resubmitted after completion
 */</doc>
<mbr r='dma_device::chancnt' o='0' t='unsigned int'/>
<mbr r='dma_device::privatecnt' o='32' t='unsigned int'/>
<mbr r='dma_device::channels' o='64' t='struct list_head'/>
<mbr r='dma_device::global_node' o='192' t='struct list_head'/>
<mbr r='dma_device::filter' o='320' t='struct dma_filter'/>
<mbr r='dma_device::cap_mask' o='512' t='dma_cap_mask_t'/>
<mbr r='dma_device::max_xor' o='576' t='unsigned short'/>
<mbr r='dma_device::max_pq' o='592' t='unsigned short'/>
<mbr r='dma_device::copy_align' o='608' t='enum dmaengine_alignment'/>
<mbr r='dma_device::xor_align' o='640' t='enum dmaengine_alignment'/>
<mbr r='dma_device::pq_align' o='672' t='enum dmaengine_alignment'/>
<mbr r='dma_device::fill_align' o='704' t='enum dmaengine_alignment'/>
<mbr r='dma_device::dev_id' o='736' t='int'/>
<mbr r='dma_device::dev' o='768' t='struct device *'/>
<mbr r='dma_device::src_addr_widths' o='832' t='u32'/>
<mbr r='dma_device::dst_addr_widths' o='864' t='u32'/>
<mbr r='dma_device::directions' o='896' t='u32'/>
<mbr r='dma_device::max_burst' o='928' t='u32'/>
<mbr r='dma_device::descriptor_reuse' o='960' t='bool'/>
<mbr r='dma_device::residue_granularity' o='992' t='enum dma_residue_granularity'/>
<mbr r='dma_device::device_alloc_chan_resources' o='1024' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_free_chan_resources' o='1088' t='void (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_prep_dma_memcpy' o='1152' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_xor' o='1216' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_xor_val' o='1280' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_pq' o='1344' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_pq_val' o='1408' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_memset' o='1472' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, int, size_t, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_memset_sg' o='1536' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, struct scatterlist *, unsigned int, int, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_interrupt' o='1600' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, unsigned long)'/>
<mbr r='dma_device::device_prep_slave_sg' o='1664' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, unsigned long, void *)'/>
<mbr r='dma_device::device_prep_dma_cyclic' o='1728' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, unsigned long)'/>
<mbr r='dma_device::device_prep_interleaved_dma' o='1792' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, struct dma_interleaved_template *, unsigned long)'/>
<mbr r='dma_device::device_prep_dma_imm_data' o='1856' t='struct dma_async_tx_descriptor *(*)(struct dma_chan *, dma_addr_t, u64, unsigned long)'/>
<mbr r='dma_device::device_config' o='1920' t='int (*)(struct dma_chan *, struct dma_slave_config *)'/>
<mbr r='dma_device::device_pause' o='1984' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_resume' o='2048' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_terminate_all' o='2112' t='int (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_synchronize' o='2176' t='void (*)(struct dma_chan *)'/>
<mbr r='dma_device::device_tx_status' o='2240' t='enum dma_status (*)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *)'/>
<mbr r='dma_device::device_issue_pending' o='2304' t='void (*)(struct dma_chan *)'/>
