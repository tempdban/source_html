<dec f='linux-4.18.y/include/linux/uio.h' l='248' type='int import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<use f='linux-4.18.y/block/scsi_ioctl.c' l='344' u='c' c='sg_io'/>
<use f='linux-4.18.y/drivers/scsi/sg.c' l='1814' u='c' c='sg_start_req'/>
<use f='linux-4.18.y/fs/aio.c' l='1463' u='c' c='aio_setup_rw'/>
<use f='linux-4.18.y/fs/read_write.c' l='984' u='c' c='vfs_readv'/>
<use f='linux-4.18.y/fs/read_write.c' l='1001' u='c' c='vfs_writev'/>
<use f='linux-4.18.y/fs/splice.c' l='1358' u='c' c='__do_sys_vmsplice'/>
<def f='linux-4.18.y/lib/iov_iter.c' l='1522' ll='1539' type='int import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<dec f='linux-4.18.y/lib/iov_iter.c' l='1540' type='int import_iovec(int , const struct iovec * , unsigned int , unsigned int , struct iovec ** , struct iov_iter * )'/>
<use f='linux-4.18.y/lib/iov_iter.c' l='1540' c='import_iovec'/>
<use f='linux-4.18.y/lib/iov_iter.c' l='1540' u='a'/>
<use f='linux-4.18.y/lib/iov_iter.c' l='1540' u='a'/>
<doc f='linux-4.18.y/lib/iov_iter.c' l='1500'>/**
 * import_iovec() - Copy an array of &amp;struct iovec from userspace
 *     into the kernel, check that it is valid, and initialize a new
 *     &amp;struct iov_iter iterator to access it.
 *
 * @type: One of %READ or %WRITE.
 * @uvector: Pointer to the userspace array.
 * @nr_segs: Number of elements in userspace array.
 * @fast_segs: Number of elements in @iov.
 * @iov: (input and output parameter) Pointer to pointer to (usually small
 *     on-stack) kernel array.
 * @i: Pointer to iterator that will be initialized on success.
 *
 * If the array pointed to by *@iov is large enough to hold all @nr_segs,
 * then this function places %NULL in *@iov on return. Otherwise, a new
 * array will be allocated and the result placed in *@iov. This means that
 * the caller may call kfree() on *@iov regardless of whether the small
 * on-stack array was used or not (and regardless of whether this function
 * returns an error or not).
 *
 * Return: 0 on success or negative error code on error.
 */</doc>
<use f='linux-4.18.y/mm/process_vm_access.c' l='277' u='c' c='process_vm_rw'/>
<use f='linux-4.18.y/net/socket.c' l='2047' u='c' c='copy_msghdr_from_user'/>
<use f='linux-4.18.y/security/keys/keyctl.c' l='1162' u='c' c='keyctl_instantiate_key_iov'/>
