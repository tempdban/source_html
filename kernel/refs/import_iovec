<dec f='linux-4.14.y/include/linux/uio.h' l='235' type='int import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<use f='linux-4.14.y/block/scsi_ioctl.c' l='345' u='c' c='sg_io'/>
<use f='linux-4.14.y/drivers/scsi/sg.c' l='1819' u='c' c='sg_start_req'/>
<use f='linux-4.14.y/fs/aio.c' l='1484' u='c' c='aio_setup_rw'/>
<use f='linux-4.14.y/fs/read_write.c' l='978' u='c' c='vfs_readv'/>
<use f='linux-4.14.y/fs/read_write.c' l='995' u='c' c='vfs_writev'/>
<use f='linux-4.14.y/fs/splice.c' l='1259' u='c' c='vmsplice_to_user'/>
<use f='linux-4.14.y/fs/splice.c' l='1302' u='c' c='vmsplice_to_pipe'/>
<def f='linux-4.14.y/lib/iov_iter.c' l='1392' ll='1409' type='int import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<dec f='linux-4.14.y/lib/iov_iter.c' l='1410' type='int import_iovec(int , const struct iovec * , unsigned int , unsigned int , struct iovec ** , struct iov_iter * )'/>
<use f='linux-4.14.y/lib/iov_iter.c' l='1410' c='import_iovec'/>
<use f='linux-4.14.y/lib/iov_iter.c' l='1410' u='a'/>
<use f='linux-4.14.y/lib/iov_iter.c' l='1410' u='a'/>
<doc f='linux-4.14.y/lib/iov_iter.c' l='1370'>/**
 * import_iovec() - Copy an array of &amp;struct iovec from userspace
 *     into the kernel, check that it is valid, and initialize a new
 *     &amp;struct iov_iter iterator to access it.
 *
 * @type: One of %READ or %WRITE.
 * @uvector: Pointer to the userspace array.
 * @nr_segs: Number of elements in userspace array.
 * @fast_segs: Number of elements in @iov.
 * @iov: (input and output parameter) Pointer to pointer to (usually small
 *     on-stack) kernel array.
 * @i: Pointer to iterator that will be initialized on success.
 *
 * If the array pointed to by *@iov is large enough to hold all @nr_segs,
 * then this function places %NULL in *@iov on return. Otherwise, a new
 * array will be allocated and the result placed in *@iov. This means that
 * the caller may call kfree() on *@iov regardless of whether the small
 * on-stack array was used or not (and regardless of whether this function
 * returns an error or not).
 *
 * Return: 0 on success or negative error code on error.
 */</doc>
<use f='linux-4.14.y/mm/process_vm_access.c' l='279' u='c' c='process_vm_rw'/>
<use f='linux-4.14.y/net/socket.c' l='1979' u='c' c='copy_msghdr_from_user'/>
<dec f='linux-4.14.y/include/linux/uio.h' l='235' type='int import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<use f='linux-4.14.y/block/scsi_ioctl.c' l='345' u='c' c='sg_io'/>
<use f='linux-4.14.y/drivers/scsi/sg.c' l='1819' u='c' c='sg_start_req'/>
<use f='linux-4.14.y/fs/aio.c' l='1484' u='c' c='aio_setup_rw'/>
<use f='linux-4.14.y/fs/read_write.c' l='978' u='c' c='vfs_readv'/>
<use f='linux-4.14.y/fs/read_write.c' l='995' u='c' c='vfs_writev'/>
<use f='linux-4.14.y/fs/splice.c' l='1259' u='c' c='vmsplice_to_user'/>
<use f='linux-4.14.y/fs/splice.c' l='1302' u='c' c='vmsplice_to_pipe'/>
<def f='linux-4.14.y/lib/iov_iter.c' l='1392' ll='1409' type='int import_iovec(int type, const struct iovec * uvector, unsigned int nr_segs, unsigned int fast_segs, struct iovec ** iov, struct iov_iter * i)'/>
<dec f='linux-4.14.y/lib/iov_iter.c' l='1410' type='int import_iovec(int , const struct iovec * , unsigned int , unsigned int , struct iovec ** , struct iov_iter * )'/>
<use f='linux-4.14.y/lib/iov_iter.c' l='1410' c='import_iovec'/>
<use f='linux-4.14.y/lib/iov_iter.c' l='1410' u='a'/>
<use f='linux-4.14.y/lib/iov_iter.c' l='1410' u='a'/>
<doc f='linux-4.14.y/lib/iov_iter.c' l='1370'>/**
 * import_iovec() - Copy an array of &amp;struct iovec from userspace
 *     into the kernel, check that it is valid, and initialize a new
 *     &amp;struct iov_iter iterator to access it.
 *
 * @type: One of %READ or %WRITE.
 * @uvector: Pointer to the userspace array.
 * @nr_segs: Number of elements in userspace array.
 * @fast_segs: Number of elements in @iov.
 * @iov: (input and output parameter) Pointer to pointer to (usually small
 *     on-stack) kernel array.
 * @i: Pointer to iterator that will be initialized on success.
 *
 * If the array pointed to by *@iov is large enough to hold all @nr_segs,
 * then this function places %NULL in *@iov on return. Otherwise, a new
 * array will be allocated and the result placed in *@iov. This means that
 * the caller may call kfree() on *@iov regardless of whether the small
 * on-stack array was used or not (and regardless of whether this function
 * returns an error or not).
 *
 * Return: 0 on success or negative error code on error.
 */</doc>
<use f='linux-4.14.y/mm/process_vm_access.c' l='279' u='c' c='process_vm_rw'/>
<use f='linux-4.14.y/net/socket.c' l='1979' u='c' c='copy_msghdr_from_user'/>
<use f='linux-4.14.y/security/keys/keyctl.c' l='1162' u='c' c='keyctl_instantiate_key_iov'/>
