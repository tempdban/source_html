<def f='linux-4.14.y/include/linux/mod_devicetable.h' l='102' ll='128'/>
<size>32</size>
<doc f='linux-4.14.y/include/linux/mod_devicetable.h' l='55'>/**
 * struct usb_device_id - identifies USB devices for probing and hotplugging
 * @match_flags: Bit mask controlling which of the other fields are used to
 *	match against new devices. Any field except for driver_info may be
 *	used, although some only make sense in conjunction with other fields.
 *	This is usually set by a USB_DEVICE_*() macro, which sets all
 *	other fields in this structure except for driver_info.
 * @idVendor: USB vendor ID for a device; numbers are assigned
 *	by the USB forum to its members.
 * @idProduct: Vendor-assigned product ID.
 * @bcdDevice_lo: Low end of range of vendor-assigned product version numbers.
 *	This is also used to identify individual product versions, for
 *	a range consisting of a single device.
 * @bcdDevice_hi: High end of version number range.  The range of product
 *	versions is inclusive.
 * @bDeviceClass: Class of device; numbers are assigned
 *	by the USB forum.  Products may choose to implement classes,
 *	or be vendor-specific.  Device classes specify behavior of all
 *	the interfaces on a device.
 * @bDeviceSubClass: Subclass of device; associated with bDeviceClass.
 * @bDeviceProtocol: Protocol of device; associated with bDeviceClass.
 * @bInterfaceClass: Class of interface; numbers are assigned
 *	by the USB forum.  Products may choose to implement classes,
 *	or be vendor-specific.  Interface classes specify behavior only
 *	of a given interface; other interfaces may support other classes.
 * @bInterfaceSubClass: Subclass of interface; associated with bInterfaceClass.
 * @bInterfaceProtocol: Protocol of interface; associated with bInterfaceClass.
 * @bInterfaceNumber: Number of interface; composite devices may use
 *	fixed interface numbers to differentiate between vendor-specific
 *	interfaces.
 * @driver_info: Holds information used by the driver.  Usually it holds
 *	a pointer to a descriptor understood by the driver, or perhaps
 *	device flags.
 *
 * In most cases, drivers will create a table of device IDs by using
 * USB_DEVICE(), or similar macros designed for that purpose.
 * They will then export it to userspace using MODULE_DEVICE_TABLE(),
 * and provide it to the USB core through their usb_driver structure.
 *
 * See the usb_match_id() function for information about how matches are
 * performed.  Briefly, you will normally use one of several macros to help
 * construct these entries.  Each entry you provide will either identify
 * one or more specific products, or will identify a class of products
 * which have agreed to behave the same.  You should put the more specific
 * matches towards the beginning of your table, so that driver_info can
 * record quirks of specific products.
 */</doc>
<mbr r='usb_device_id::match_flags' o='0' t='__u16'/>
<mbr r='usb_device_id::idVendor' o='16' t='__u16'/>
<mbr r='usb_device_id::idProduct' o='32' t='__u16'/>
<mbr r='usb_device_id::bcdDevice_lo' o='48' t='__u16'/>
<mbr r='usb_device_id::bcdDevice_hi' o='64' t='__u16'/>
<mbr r='usb_device_id::bDeviceClass' o='80' t='__u8'/>
<mbr r='usb_device_id::bDeviceSubClass' o='88' t='__u8'/>
<mbr r='usb_device_id::bDeviceProtocol' o='96' t='__u8'/>
<mbr r='usb_device_id::bInterfaceClass' o='104' t='__u8'/>
<mbr r='usb_device_id::bInterfaceSubClass' o='112' t='__u8'/>
<mbr r='usb_device_id::bInterfaceProtocol' o='120' t='__u8'/>
<mbr r='usb_device_id::bInterfaceNumber' o='128' t='__u8'/>
<mbr r='usb_device_id::driver_info' o='192' t='kernel_ulong_t'/>
