<dec f='linux-4.18.y/arch/x86/include/asm/stacktrace.h' l='114' type='void show_opcodes(struct pt_regs * regs, const char * loglvl)'/>
<def f='linux-4.18.y/arch/x86/kernel/dumpstack.c' l='95' ll='126' type='void show_opcodes(struct pt_regs * regs, const char * loglvl)'/>
<use f='linux-4.18.y/arch/x86/kernel/dumpstack.c' l='135' u='c' c='show_ip'/>
<doc f='linux-4.18.y/arch/x86/kernel/dumpstack.c' l='76'>/*
 * There are a couple of reasons for the 2/3rd prologue, courtesy of Linus:
 *
 * In case where we don&apos;t have the exact kernel image (which, if we did, we can
 * simply disassemble and navigate to the RIP), the purpose of the bigger
 * prologue is to have more context and to be able to correlate the code from
 * the different toolchains better.
 *
 * In addition, it helps in recreating the register allocation of the failing
 * kernel and thus make sense of the register dump.
 *
 * What is more, the additional complication of a variable length insn arch like
 * x86 warrants having longer byte sequence before rIP so that the disassembler
 * can &quot;sync&quot; up properly and find instruction boundaries when decoding the
 * opcode bytes.
 *
 * Thus, the 2/3rds prologue and 64 byte OPCODE_BUFSIZE is just a random
 * guesstimate in attempt to achieve all of the above.
 */</doc>
<use f='linux-4.18.y/arch/x86/mm/fault.c' l='839' u='c' c='show_signal_msg'/>
