<dec f='linux-4.18.y/include/linux/jbd2.h' l='1453' type='int jbd2_journal_cancel_revoke(handle_t * , struct journal_head * )'/>
<def f='linux-4.18.y/fs/jbd2/revoke.c' l='409' ll='463' type='int jbd2_journal_cancel_revoke(handle_t * handle, struct journal_head * jh)'/>
<doc f='linux-4.18.y/fs/jbd2/revoke.c' l='394'>/*
 * Cancel an outstanding revoke.  For use only internally by the
 * journaling code (called from jbd2_journal_get_write_access).
 *
 * We trust buffer_revoked() on the buffer if the buffer is already
 * being journaled: if there is no revoke pending on the buffer, then we
 * don&apos;t do anything here.
 *
 * This would break if it were possible for a buffer to be revoked and
 * discarded, and then reallocated within the same transaction.  In such
 * a case we would have lost the revoked bit, but when we arrived here
 * the second time we would still have a pending revoke to cancel.  So,
 * do not trust the Revoked bit on buffers unless RevokeValid is also
 * set.
 */</doc>
<use f='linux-4.18.y/fs/jbd2/transaction.c' l='1006' u='c' c='do_get_write_access'/>
<use f='linux-4.18.y/fs/jbd2/transaction.c' l='1184' u='c' c='jbd2_journal_get_create_access'/>
