<dec f='linux-4.14.y/include/linux/transport_class.h' l='67' type='void transport_setup_device(struct device * )'/>
<use f='linux-4.14.y/include/linux/transport_class.h' l='74' u='c' c='transport_register_device'/>
<use f='linux-4.14.y/drivers/ata/libata-transport.c' l='289' u='c' c='ata_tport_add'/>
<use f='linux-4.14.y/drivers/ata/libata-transport.c' l='418' u='c' c='ata_tlink_add'/>
<use f='linux-4.14.y/drivers/ata/libata-transport.c' l='669' u='c' c='ata_tdev_add'/>
<def f='linux-4.14.y/drivers/base/transport_class.c' l='145' ll='148' type='void transport_setup_device(struct device * dev)'/>
<dec f='linux-4.14.y/drivers/base/transport_class.c' l='149' type='void transport_setup_device(struct device * )'/>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='149' c='transport_setup_device'/>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='149' u='a'/>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='149' u='a'/>
<doc f='linux-4.14.y/drivers/base/transport_class.c' l='130'>/**
 * transport_setup_device - declare a new dev for transport class association but don&apos;t make it visible yet.
 * @dev: the generic device representing the entity being added
 *
 * Usually, dev represents some component in the HBA system (either
 * the HBA itself or a device remote across the HBA bus).  This
 * routine is simply a trigger point to see if any set of transport
 * classes wishes to associate with the added device.  This allocates
 * storage for the class device and initialises it, but does not yet
 * add it to the system or add attributes to it (you do this with
 * transport_add_device).  If you have no need for a separate setup
 * and add operations, use transport_register_device (see
 * transport_class.h).
 */</doc>
<use f='linux-4.14.y/drivers/scsi/scsi_scan.c' l='460' u='c' c='scsi_alloc_target'/>
<use f='linux-4.14.y/drivers/scsi/scsi_sysfs.c' l='1513' u='c' c='scsi_sysfs_device_initialize'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_fc.c' l='2650' u='c' c='fc_remote_port_create'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_fc.c' l='3402' u='c' c='fc_vport_setup'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='720' u='c' c='sas_phy_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='913' u='c' c='sas_port_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='1475' u='c' c='sas_end_device_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='1516' u='c' c='sas_expander_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_srp.c' l='740' u='c' c='srp_rport_add'/>
<dec f='linux-4.14.y/include/linux/transport_class.h' l='67' type='void transport_setup_device(struct device * )'/>
<use f='linux-4.14.y/include/linux/transport_class.h' l='74' u='c' c='transport_register_device'/>
<use f='linux-4.14.y/drivers/ata/libata-transport.c' l='289' u='c' c='ata_tport_add'/>
<use f='linux-4.14.y/drivers/ata/libata-transport.c' l='418' u='c' c='ata_tlink_add'/>
<use f='linux-4.14.y/drivers/ata/libata-transport.c' l='669' u='c' c='ata_tdev_add'/>
<def f='linux-4.14.y/drivers/base/transport_class.c' l='145' ll='148' type='void transport_setup_device(struct device * dev)'/>
<dec f='linux-4.14.y/drivers/base/transport_class.c' l='149' type='void transport_setup_device(struct device * )'/>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='149' c='transport_setup_device'/>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='149' u='a'/>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='149' u='a'/>
<doc f='linux-4.14.y/drivers/base/transport_class.c' l='130'>/**
 * transport_setup_device - declare a new dev for transport class association but don&apos;t make it visible yet.
 * @dev: the generic device representing the entity being added
 *
 * Usually, dev represents some component in the HBA system (either
 * the HBA itself or a device remote across the HBA bus).  This
 * routine is simply a trigger point to see if any set of transport
 * classes wishes to associate with the added device.  This allocates
 * storage for the class device and initialises it, but does not yet
 * add it to the system or add attributes to it (you do this with
 * transport_add_device).  If you have no need for a separate setup
 * and add operations, use transport_register_device (see
 * transport_class.h).
 */</doc>
<use f='linux-4.14.y/drivers/scsi/scsi_scan.c' l='460' u='c' c='scsi_alloc_target'/>
<use f='linux-4.14.y/drivers/scsi/scsi_sysfs.c' l='1513' u='c' c='scsi_sysfs_device_initialize'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_fc.c' l='2650' u='c' c='fc_remote_port_create'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_fc.c' l='3402' u='c' c='fc_vport_setup'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='720' u='c' c='sas_phy_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='913' u='c' c='sas_port_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='1475' u='c' c='sas_end_device_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_sas.c' l='1516' u='c' c='sas_expander_alloc'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_srp.c' l='740' u='c' c='srp_rport_add'/>
