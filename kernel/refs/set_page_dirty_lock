<dec f='linux-4.18.y/include/linux/mm.h' l='1546' type='int set_page_dirty_lock(struct page * page)'/>
<use f='linux-4.18.y/block/bio.c' l='1462' u='c' c='__bio_unmap_user'/>
<use f='linux-4.18.y/block/bio.c' l='1667' u='c' c='bio_set_pages_dirty'/>
<use f='linux-4.18.y/drivers/vhost/vhost.c' l='1668' u='c' c='set_bit_to_user'/>
<use f='linux-4.18.y/fs/block_dev.c' l='249' u='c' c='__blkdev_direct_IO_simple'/>
<use f='linux-4.18.y/fs/direct-io.c' l='559' u='c' c='dio_bio_complete'/>
<use f='linux-4.18.y/fs/fuse/dev.c' l='727' u='c' c='fuse_copy_finish'/>
<use f='linux-4.18.y/fs/fuse/file.c' l='536' u='c' c='fuse_release_user_pages'/>
<use f='linux-4.18.y/mm/memory.c' l='4486' u='c' c='__access_remote_vm'/>
<def f='linux-4.18.y/mm/page-writeback.c' l='2586' ll='2594' type='int set_page_dirty_lock(struct page * page)'/>
<dec f='linux-4.18.y/mm/page-writeback.c' l='2595' type='int set_page_dirty_lock(struct page * )'/>
<use f='linux-4.18.y/mm/page-writeback.c' l='2595' c='set_page_dirty_lock'/>
<use f='linux-4.18.y/mm/page-writeback.c' l='2595' u='a'/>
<use f='linux-4.18.y/mm/page-writeback.c' l='2595' u='a'/>
<doc f='linux-4.18.y/mm/page-writeback.c' l='2576'>/*
 * set_page_dirty() is racy if the caller has no reference against
 * page-&gt;mapping-&gt;host, and if the page is unlocked.  This is because another
 * CPU could truncate the page off the mapping and then free the mapping.
 *
 * Usually, the page _is_ locked, or the caller is a user-space process which
 * holds a reference on the inode by having an open file.
 *
 * In other cases, the page should be locked before running set_page_dirty().
 */</doc>
<use f='linux-4.18.y/mm/process_vm_access.c' l='51' u='c' c='process_vm_rw_pages'/>
