<def f='linux-4.18.y/arch/x86/mm/extable.c' l='98' ll='108' type='bool ex_handler_fprestore(const struct exception_table_entry * fixup, struct pt_regs * regs, int trapnr)'/>
<dec f='linux-4.18.y/arch/x86/mm/extable.c' l='109' type='bool ex_handler_fprestore(const struct exception_table_entry * , struct pt_regs * , int )'/>
<use f='linux-4.18.y/arch/x86/mm/extable.c' l='109' c='ex_handler_fprestore'/>
<use f='linux-4.18.y/arch/x86/mm/extable.c' l='109' u='a'/>
<use f='linux-4.18.y/arch/x86/mm/extable.c' l='109' u='a'/>
<doc f='linux-4.18.y/arch/x86/mm/extable.c' l='88'>/*
 * Handler for when we fail to restore a task&apos;s FPU state.  We should never get
 * here because the FPU state of a task using the FPU (task-&gt;thread.fpu.state)
 * should always be valid.  However, past bugs have allowed userspace to set
 * reserved bits in the XSAVE area using PTRACE_SETREGSET or sys_rt_sigreturn().
 * These caused XRSTOR to fail when switching to the task, leaking the FPU
 * registers of the task previously executing on the CPU.  Mitigate this class
 * of vulnerability by restoring from the initial state (essentially, zeroing
 * out all the FPU registers) if we can&apos;t restore from the task&apos;s FPU state.
 */</doc>
