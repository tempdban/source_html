<def f='linux-4.18.y/include/linux/usb/gadget.h' l='95' ll='117'/>
<size>88</size>
<doc f='linux-4.18.y/include/linux/usb/gadget.h' l='33'>/**
 * struct usb_request - describes one i/o request
 * @buf: Buffer used for data.  Always provide this; some controllers
 *	only use PIO, or don&apos;t use DMA for some endpoints.
 * @dma: DMA address corresponding to &apos;buf&apos;.  If you don&apos;t set this
 *	field, and the usb controller needs one, it is responsible
 *	for mapping and unmapping the buffer.
 * @sg: a scatterlist for SG-capable controllers.
 * @num_sgs: number of SG entries
 * @num_mapped_sgs: number of SG entries mapped to DMA (internal)
 * @length: Length of that data
 * @stream_id: The stream id, when USB3.0 bulk streams are being used
 * @no_interrupt: If true, hints that no completion irq is needed.
 *	Helpful sometimes with deep request queues that are handled
 *	directly by DMA controllers.
 * @zero: If true, when writing data, makes the last packet be &quot;short&quot;
 *     by adding a zero length packet as needed;
 * @short_not_ok: When reading data, makes short packets be
 *     treated as errors (queue stops advancing till cleanup).
 * @dma_mapped: Indicates if request has been mapped to DMA (internal)
 * @complete: Function called when request completes, so this request and
 *	its buffer may be re-used.  The function will always be called with
 *	interrupts disabled, and it must not sleep.
 *	Reads terminate with a short packet, or when the buffer fills,
 *	whichever comes first.  When writes terminate, some data bytes
 *	will usually still be in flight (often in a hardware fifo).
 *	Errors (for reads or writes) stop the queue from advancing
 *	until the completion function returns, so that any transfers
 *	invalidated by the error may first be dequeued.
 * @context: For use by the completion callback
 * @list: For use by the gadget driver.
 * @status: Reports completion code, zero or a negative errno.
 *	Normally, faults block the transfer queue from advancing until
 *	the completion callback returns.
 *	Code &quot;-ESHUTDOWN&quot; indicates completion caused by device disconnect,
 *	or when the driver disabled the endpoint.
 * @actual: Reports bytes transferred to/from the buffer.  For reads (OUT
 *	transfers) this may be less than the requested length.  If the
 *	short_not_ok flag is set, short reads are treated as errors
 *	even when status otherwise indicates successful completion.
 *	Note that for writes (IN transfers) some data bytes may still
 *	reside in a device-side FIFO when the request is reported as
 *	complete.
 *
 * These are allocated/freed through the endpoint they&apos;re used with.  The
 * hardware&apos;s driver can add extra per-request data to the memory it returns,
 * which often avoids separate memory allocations (potential failures),
 * later when the request is queued.
 *
 * Request flags affect request handling, such as whether a zero length
 * packet is written (the &quot;zero&quot; flag), whether a short read should be
 * treated as an error (blocking request queue advance, the &quot;short_not_ok&quot;
 * flag), or hinting that an interrupt is not required (the &quot;no_interrupt&quot;
 * flag, for use with deep request queues).
 *
 * Bulk endpoints can use any size buffers, and can also be used for interrupt
 * transfers. interrupt-only endpoints can be much less functional.
 *
 * NOTE:  this is analogous to &apos;struct urb&apos; on the host side, except that
 * it&apos;s thinner and promotes more pre-allocation.
 */</doc>
<mbr r='usb_request::buf' o='0' t='void *'/>
<mbr r='usb_request::length' o='64' t='unsigned int'/>
<mbr r='usb_request::dma' o='128' t='dma_addr_t'/>
<mbr r='usb_request::sg' o='192' t='struct scatterlist *'/>
<mbr r='usb_request::num_sgs' o='256' t='unsigned int'/>
<mbr r='usb_request::num_mapped_sgs' o='288' t='unsigned int'/>
<mbr r='usb_request::stream_id' o='320' t='unsigned int'/>
<mbr r='usb_request::no_interrupt' o='336' t='unsigned int'/>
<mbr r='usb_request::zero' o='337' t='unsigned int'/>
<mbr r='usb_request::short_not_ok' o='338' t='unsigned int'/>
<mbr r='usb_request::dma_mapped' o='339' t='unsigned int'/>
<mbr r='usb_request::complete' o='384' t='void (*)(struct usb_ep *, struct usb_request *)'/>
<mbr r='usb_request::context' o='448' t='void *'/>
<mbr r='usb_request::list' o='512' t='struct list_head'/>
<mbr r='usb_request::status' o='640' t='int'/>
<mbr r='usb_request::actual' o='672' t='unsigned int'/>
