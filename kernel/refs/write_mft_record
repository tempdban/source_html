<def f='linux-4.14.y/fs/ntfs/mft.h' l='102' ll='112' type='int write_mft_record(ntfs_inode * ni, MFT_RECORD * m, int sync)'/>
<doc f='linux-4.14.y/fs/ntfs/mft.h' l='84'>/**
 * write_mft_record - write out a mapped (extent) mft record
 * @ni:		ntfs inode describing the mapped (extent) mft record
 * @m:		mapped (extent) mft record to write
 * @sync:	if true, wait for i/o completion
 *
 * This is just a wrapper for write_mft_record_nolock() (see mft.c), which
 * locks the page for the duration of the write.  This ensures that there are
 * no race conditions between writing the mft record via the dirty inode code
 * paths and via the page cache write back code paths or between writing
 * neighbouring mft records residing in the same page.
 *
 * Locking the page also serializes us against -&gt;readpage() if the page is not
 * uptodate.
 *
 * On success, clean the mft record and return 0.  On error, leave the mft
 * record dirty and return -errno.
 */</doc>
<use f='linux-4.14.y/fs/ntfs/inode.c' l='3061' u='c' c='__ntfs_write_inode'/>
<use f='linux-4.14.y/fs/ntfs/inode.c' l='3081' u='c' c='__ntfs_write_inode'/>
<use f='linux-4.14.y/fs/ntfs/mft.c' l='2863' u='c' c='ntfs_extent_mft_record_free'/>
