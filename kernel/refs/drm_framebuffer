<def f='linux-4.14.y/include/drm/drm_framebuffer.h' l='109' ll='200'/>
<size>184</size>
<doc f='linux-4.14.y/include/drm/drm_framebuffer.h' l='95'>/**
 * struct drm_framebuffer - frame buffer object
 *
 * Note that the fb is refcounted for the benefit of driver internals,
 * for example some hw, disabling a CRTC/plane is asynchronous, and
 * scanout does not actually complete until the next vblank.  So some
 * cleanup (like releasing the reference(s) on the backing GEM bo(s))
 * should be deferred.  In cases like this, the driver would like to
 * hold a ref to the fb even though it has already been removed from
 * userspace perspective. See drm_framebuffer_get() and
 * drm_framebuffer_put().
 *
 * The refcount is stored inside the mode object @base.
 */</doc>
<mbr r='drm_framebuffer::dev' o='0' t='struct drm_device *'/>
<mbr r='drm_framebuffer::head' o='64' t='struct list_head'/>
<mbr r='drm_framebuffer::base' o='192' t='struct drm_mode_object'/>
<mbr r='drm_framebuffer::format' o='448' t='const struct drm_format_info *'/>
<mbr r='drm_framebuffer::funcs' o='512' t='const struct drm_framebuffer_funcs *'/>
<mbr r='drm_framebuffer::pitches' o='576' t='unsigned int [4]'/>
<mbr r='drm_framebuffer::offsets' o='704' t='unsigned int [4]'/>
<mbr r='drm_framebuffer::modifier' o='832' t='uint64_t'/>
<mbr r='drm_framebuffer::width' o='896' t='unsigned int'/>
<mbr r='drm_framebuffer::height' o='928' t='unsigned int'/>
<mbr r='drm_framebuffer::flags' o='960' t='int'/>
<mbr r='drm_framebuffer::hot_x' o='992' t='int'/>
<mbr r='drm_framebuffer::hot_y' o='1024' t='int'/>
<mbr r='drm_framebuffer::filp_head' o='1088' t='struct list_head'/>
<mbr r='drm_framebuffer::obj' o='1216' t='struct drm_gem_object *[4]'/>
<def f='linux-4.14.y/include/drm/drm_framebuffer.h' l='109' ll='200'/>
<size>184</size>
<doc f='linux-4.14.y/include/drm/drm_framebuffer.h' l='95'>/**
 * struct drm_framebuffer - frame buffer object
 *
 * Note that the fb is refcounted for the benefit of driver internals,
 * for example some hw, disabling a CRTC/plane is asynchronous, and
 * scanout does not actually complete until the next vblank.  So some
 * cleanup (like releasing the reference(s) on the backing GEM bo(s))
 * should be deferred.  In cases like this, the driver would like to
 * hold a ref to the fb even though it has already been removed from
 * userspace perspective. See drm_framebuffer_get() and
 * drm_framebuffer_put().
 *
 * The refcount is stored inside the mode object @base.
 */</doc>
<mbr r='drm_framebuffer::dev' o='0' t='struct drm_device *'/>
<mbr r='drm_framebuffer::head' o='64' t='struct list_head'/>
<mbr r='drm_framebuffer::base' o='192' t='struct drm_mode_object'/>
<mbr r='drm_framebuffer::format' o='448' t='const struct drm_format_info *'/>
<mbr r='drm_framebuffer::funcs' o='512' t='const struct drm_framebuffer_funcs *'/>
<mbr r='drm_framebuffer::pitches' o='576' t='unsigned int [4]'/>
<mbr r='drm_framebuffer::offsets' o='704' t='unsigned int [4]'/>
<mbr r='drm_framebuffer::modifier' o='832' t='uint64_t'/>
<mbr r='drm_framebuffer::width' o='896' t='unsigned int'/>
<mbr r='drm_framebuffer::height' o='928' t='unsigned int'/>
<mbr r='drm_framebuffer::flags' o='960' t='int'/>
<mbr r='drm_framebuffer::hot_x' o='992' t='int'/>
<mbr r='drm_framebuffer::hot_y' o='1024' t='int'/>
<mbr r='drm_framebuffer::filp_head' o='1088' t='struct list_head'/>
<mbr r='drm_framebuffer::obj' o='1216' t='struct drm_gem_object *[4]'/>
