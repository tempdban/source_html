<def f='linux-4.18.y/include/linux/input.h' l='121' ll='190'/>
<size>1072</size>
<doc f='linux-4.18.y/include/linux/input.h' l='39'>/**
 * struct input_dev - represents an input device
 * @name: name of the device
 * @phys: physical path to the device in the system hierarchy
 * @uniq: unique identification code for the device (if device has it)
 * @id: id of the device (struct input_id)
 * @propbit: bitmap of device properties and quirks
 * @evbit: bitmap of types of events supported by the device (EV_KEY,
 *	EV_REL, etc.)
 * @keybit: bitmap of keys/buttons this device has
 * @relbit: bitmap of relative axes for the device
 * @absbit: bitmap of absolute axes for the device
 * @mscbit: bitmap of miscellaneous events supported by the device
 * @ledbit: bitmap of leds present on the device
 * @sndbit: bitmap of sound effects supported by the device
 * @ffbit: bitmap of force feedback effects supported by the device
 * @swbit: bitmap of switches present on the device
 * @hint_events_per_packet: average number of events generated by the
 *	device in a packet (between EV_SYN/SYN_REPORT events). Used by
 *	event handlers to estimate size of the buffer needed to hold
 *	events.
 * @keycodemax: size of keycode table
 * @keycodesize: size of elements in keycode table
 * @keycode: map of scancodes to keycodes for this device
 * @getkeycode: optional legacy method to retrieve current keymap.
 * @setkeycode: optional method to alter current keymap, used to implement
 *	sparse keymaps. If not supplied default mechanism will be used.
 *	The method is being called while holding event_lock and thus must
 *	not sleep
 * @ff: force feedback structure associated with the device if device
 *	supports force feedback effects
 * @repeat_key: stores key code of the last key pressed; used to implement
 *	software autorepeat
 * @timer: timer for software autorepeat
 * @rep: current values for autorepeat parameters (delay, rate)
 * @mt: pointer to multitouch state
 * @absinfo: array of &amp;struct input_absinfo elements holding information
 *	about absolute axes (current value, min, max, flat, fuzz,
 *	resolution)
 * @key: reflects current state of device&apos;s keys/buttons
 * @led: reflects current state of device&apos;s LEDs
 * @snd: reflects current state of sound effects
 * @sw: reflects current state of device&apos;s switches
 * @open: this method is called when the very first user calls
 *	input_open_device(). The driver must prepare the device
 *	to start generating events (start polling thread,
 *	request an IRQ, submit URB, etc.)
 * @close: this method is called when the very last user calls
 *	input_close_device().
 * @flush: purges the device. Most commonly used to get rid of force
 *	feedback effects loaded into the device when disconnecting
 *	from it
 * @event: event handler for events sent _to_ the device, like EV_LED
 *	or EV_SND. The device is expected to carry out the requested
 *	action (turn on a LED, play sound, etc.) The call is protected
 *	by @event_lock and must not sleep
 * @grab: input handle that currently has the device grabbed (via
 *	EVIOCGRAB ioctl). When a handle grabs a device it becomes sole
 *	recipient for all input events coming from the device
 * @event_lock: this spinlock is taken when input core receives
 *	and processes a new event for the device (in input_event()).
 *	Code that accesses and/or modifies parameters of a device
 *	(such as keymap or absmin, absmax, absfuzz, etc.) after device
 *	has been registered with input core must take this lock.
 * @mutex: serializes calls to open(), close() and flush() methods
 * @users: stores number of users (input handlers) that opened this
 *	device. It is used by input_open_device() and input_close_device()
 *	to make sure that dev-&gt;open() is only called when the first
 *	user opens device and dev-&gt;close() is called when the very
 *	last user closes the device
 * @going_away: marks devices that are in a middle of unregistering and
 *	causes input_open_device*() fail with -ENODEV.
 * @dev: driver model&apos;s view of this device
 * @h_list: list of input handles associated with the device. When
 *	accessing the list dev-&gt;mutex must be held
 * @node: used to place the device onto input_dev_list
 * @num_vals: number of values queued in the current frame
 * @max_vals: maximum number of values queued in a frame
 * @vals: array of values queued in the current frame
 * @devres_managed: indicates that devices is managed with devres framework
 *	and needs not be explicitly unregistered or freed.
 */</doc>
<mbr r='input_dev::name' o='0' t='const char *'/>
<mbr r='input_dev::phys' o='64' t='const char *'/>
<mbr r='input_dev::uniq' o='128' t='const char *'/>
<mbr r='input_dev::id' o='192' t='struct input_id'/>
<mbr r='input_dev::propbit' o='256' t='unsigned long [1]'/>
<mbr r='input_dev::evbit' o='320' t='unsigned long [1]'/>
<mbr r='input_dev::keybit' o='384' t='unsigned long [12]'/>
<mbr r='input_dev::relbit' o='1152' t='unsigned long [1]'/>
<mbr r='input_dev::absbit' o='1216' t='unsigned long [1]'/>
<mbr r='input_dev::mscbit' o='1280' t='unsigned long [1]'/>
<mbr r='input_dev::ledbit' o='1344' t='unsigned long [1]'/>
<mbr r='input_dev::sndbit' o='1408' t='unsigned long [1]'/>
<mbr r='input_dev::ffbit' o='1472' t='unsigned long [2]'/>
<mbr r='input_dev::swbit' o='1600' t='unsigned long [1]'/>
<mbr r='input_dev::hint_events_per_packet' o='1664' t='unsigned int'/>
<mbr r='input_dev::keycodemax' o='1696' t='unsigned int'/>
<mbr r='input_dev::keycodesize' o='1728' t='unsigned int'/>
<mbr r='input_dev::keycode' o='1792' t='void *'/>
<mbr r='input_dev::setkeycode' o='1856' t='int (*)(struct input_dev *, const struct input_keymap_entry *, unsigned int *)'/>
<mbr r='input_dev::getkeycode' o='1920' t='int (*)(struct input_dev *, struct input_keymap_entry *)'/>
<mbr r='input_dev::ff' o='1984' t='struct ff_device *'/>
<mbr r='input_dev::repeat_key' o='2048' t='unsigned int'/>
<mbr r='input_dev::timer' o='2112' t='struct timer_list'/>
<mbr r='input_dev::rep' o='2432' t='int [2]'/>
<mbr r='input_dev::mt' o='2496' t='struct input_mt *'/>
<mbr r='input_dev::absinfo' o='2560' t='struct input_absinfo *'/>
<mbr r='input_dev::key' o='2624' t='unsigned long [12]'/>
<mbr r='input_dev::led' o='3392' t='unsigned long [1]'/>
<mbr r='input_dev::snd' o='3456' t='unsigned long [1]'/>
<mbr r='input_dev::sw' o='3520' t='unsigned long [1]'/>
<mbr r='input_dev::open' o='3584' t='int (*)(struct input_dev *)'/>
<mbr r='input_dev::close' o='3648' t='void (*)(struct input_dev *)'/>
<mbr r='input_dev::flush' o='3712' t='int (*)(struct input_dev *, struct file *)'/>
<mbr r='input_dev::event' o='3776' t='int (*)(struct input_dev *, unsigned int, unsigned int, int)'/>
<mbr r='input_dev::grab' o='3840' t='struct input_handle *'/>
<mbr r='input_dev::event_lock' o='3904' t='spinlock_t'/>
<mbr r='input_dev::mutex' o='3968' t='struct mutex'/>
<mbr r='input_dev::users' o='4224' t='unsigned int'/>
<mbr r='input_dev::going_away' o='4256' t='bool'/>
<mbr r='input_dev::dev' o='4288' t='struct device'/>
<mbr r='input_dev::h_list' o='8128' t='struct list_head'/>
<mbr r='input_dev::node' o='8256' t='struct list_head'/>
<mbr r='input_dev::num_vals' o='8384' t='unsigned int'/>
<mbr r='input_dev::max_vals' o='8416' t='unsigned int'/>
<mbr r='input_dev::vals' o='8448' t='struct input_value *'/>
<mbr r='input_dev::devres_managed' o='8512' t='bool'/>
