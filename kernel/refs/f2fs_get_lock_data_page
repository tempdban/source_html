<dec f='linux-4.18.y/fs/f2fs/f2fs.h' l='2964' type='struct page * f2fs_get_lock_data_page(struct inode * inode, unsigned long index, bool for_write)'/>
<def f='linux-4.18.y/fs/f2fs/data.c' l='785' ll='806' type='struct page * f2fs_get_lock_data_page(struct inode * inode, unsigned long index, bool for_write)'/>
<use f='linux-4.18.y/fs/f2fs/data.c' l='856' u='c' c='f2fs_get_new_data_page'/>
<doc f='linux-4.18.y/fs/f2fs/data.c' l='780'>/*
 * If it tries to access a hole, return an error.
 * Because, the callers, functions in dir.c and GC, should be able to know
 * whether this page exists or not.
 */</doc>
<use f='linux-4.18.y/fs/f2fs/dir.c' l='755' u='c' c='f2fs_empty_dir'/>
<use f='linux-4.18.y/fs/f2fs/dir.c' l='877' u='c' c='f2fs_readdir'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='564' u='c' c='truncate_partial_data_page'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='1096' u='c' c='__clone_blkaddrs'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='2259' u='c' c='f2fs_defragment_range'/>
<use f='linux-4.18.y/fs/f2fs/gc.c' l='740' u='c' c='move_data_page'/>
