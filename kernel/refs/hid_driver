<def f='linux-4.14.y/include/linux/hid.h' l='713' ll='752'/>
<size>256</size>
<doc f='linux-4.14.y/include/linux/hid.h' l='673'>/**
 * struct hid_driver
 * @name: driver name (e.g. &quot;Footech_bar-wheel&quot;)
 * @id_table: which devices is this driver for (must be non-NULL for probe
 * 	      to be called)
 * @dyn_list: list of dynamically added device ids
 * @dyn_lock: lock protecting @dyn_list
 * @probe: new device inserted
 * @remove: device removed (NULL if not a hot-plug capable driver)
 * @report_table: on which reports to call raw_event (NULL means all)
 * @raw_event: if report in report_table, this hook is called (NULL means nop)
 * @usage_table: on which events to call event (NULL means all)
 * @event: if usage in usage_table, this hook is called (NULL means nop)
 * @report: this hook is called after parsing a report (NULL means nop)
 * @report_fixup: called before report descriptor parsing (NULL means nop)
 * @input_mapping: invoked on input registering before mapping an usage
 * @input_mapped: invoked on input registering after mapping an usage
 * @input_configured: invoked just before the device is registered
 * @feature_mapping: invoked on feature registering
 * @suspend: invoked on suspend (NULL means nop)
 * @resume: invoked on resume if device was not reset (NULL means nop)
 * @reset_resume: invoked on resume if device was reset (NULL means nop)
 *
 * probe should return -errno on error, or 0 on success. During probe,
 * input will not be passed to raw_event unless hid_device_io_start is
 * called.
 *
 * raw_event and event should return 0 on no action performed, 1 when no
 * further processing should be done and negative on error
 *
 * input_mapping shall return a negative value to completely ignore this usage
 * (e.g. doubled or invalid usage), zero to continue with parsing of this
 * usage by generic code (no special handling needed) or positive to skip
 * generic parsing (needed special handling which was done in the hook already)
 * input_mapped shall return negative to inform the layer that this usage
 * should not be considered for further processing or zero to notify that
 * no processing was performed and should be done in a generic manner
 * Both these functions may be NULL which means the same behavior as returning
 * zero from them.
 */</doc>
<mbr r='hid_driver::name' o='0' t='char *'/>
<mbr r='hid_driver::id_table' o='64' t='const struct hid_device_id *'/>
<mbr r='hid_driver::dyn_list' o='128' t='struct list_head'/>
<mbr r='hid_driver::dyn_lock' o='256' t='spinlock_t'/>
<mbr r='hid_driver::probe' o='320' t='int (*)(struct hid_device *, const struct hid_device_id *)'/>
<mbr r='hid_driver::remove' o='384' t='void (*)(struct hid_device *)'/>
<mbr r='hid_driver::report_table' o='448' t='const struct hid_report_id *'/>
<mbr r='hid_driver::raw_event' o='512' t='int (*)(struct hid_device *, struct hid_report *, u8 *, int)'/>
<mbr r='hid_driver::usage_table' o='576' t='const struct hid_usage_id *'/>
<mbr r='hid_driver::event' o='640' t='int (*)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32)'/>
<mbr r='hid_driver::report' o='704' t='void (*)(struct hid_device *, struct hid_report *)'/>
<mbr r='hid_driver::report_fixup' o='768' t='__u8 *(*)(struct hid_device *, __u8 *, unsigned int *)'/>
<mbr r='hid_driver::input_mapping' o='832' t='int (*)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, unsigned long **, int *)'/>
<mbr r='hid_driver::input_mapped' o='896' t='int (*)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, unsigned long **, int *)'/>
<mbr r='hid_driver::input_configured' o='960' t='int (*)(struct hid_device *, struct hid_input *)'/>
<mbr r='hid_driver::feature_mapping' o='1024' t='void (*)(struct hid_device *, struct hid_field *, struct hid_usage *)'/>
<mbr r='hid_driver::driver' o='1088' t='struct device_driver'/>
<def f='linux-4.14.y/include/linux/hid.h' l='713' ll='752'/>
<size>256</size>
<doc f='linux-4.14.y/include/linux/hid.h' l='673'>/**
 * struct hid_driver
 * @name: driver name (e.g. &quot;Footech_bar-wheel&quot;)
 * @id_table: which devices is this driver for (must be non-NULL for probe
 * 	      to be called)
 * @dyn_list: list of dynamically added device ids
 * @dyn_lock: lock protecting @dyn_list
 * @probe: new device inserted
 * @remove: device removed (NULL if not a hot-plug capable driver)
 * @report_table: on which reports to call raw_event (NULL means all)
 * @raw_event: if report in report_table, this hook is called (NULL means nop)
 * @usage_table: on which events to call event (NULL means all)
 * @event: if usage in usage_table, this hook is called (NULL means nop)
 * @report: this hook is called after parsing a report (NULL means nop)
 * @report_fixup: called before report descriptor parsing (NULL means nop)
 * @input_mapping: invoked on input registering before mapping an usage
 * @input_mapped: invoked on input registering after mapping an usage
 * @input_configured: invoked just before the device is registered
 * @feature_mapping: invoked on feature registering
 * @suspend: invoked on suspend (NULL means nop)
 * @resume: invoked on resume if device was not reset (NULL means nop)
 * @reset_resume: invoked on resume if device was reset (NULL means nop)
 *
 * probe should return -errno on error, or 0 on success. During probe,
 * input will not be passed to raw_event unless hid_device_io_start is
 * called.
 *
 * raw_event and event should return 0 on no action performed, 1 when no
 * further processing should be done and negative on error
 *
 * input_mapping shall return a negative value to completely ignore this usage
 * (e.g. doubled or invalid usage), zero to continue with parsing of this
 * usage by generic code (no special handling needed) or positive to skip
 * generic parsing (needed special handling which was done in the hook already)
 * input_mapped shall return negative to inform the layer that this usage
 * should not be considered for further processing or zero to notify that
 * no processing was performed and should be done in a generic manner
 * Both these functions may be NULL which means the same behavior as returning
 * zero from them.
 */</doc>
<mbr r='hid_driver::name' o='0' t='char *'/>
<mbr r='hid_driver::id_table' o='64' t='const struct hid_device_id *'/>
<mbr r='hid_driver::dyn_list' o='128' t='struct list_head'/>
<mbr r='hid_driver::dyn_lock' o='256' t='spinlock_t'/>
<mbr r='hid_driver::probe' o='320' t='int (*)(struct hid_device *, const struct hid_device_id *)'/>
<mbr r='hid_driver::remove' o='384' t='void (*)(struct hid_device *)'/>
<mbr r='hid_driver::report_table' o='448' t='const struct hid_report_id *'/>
<mbr r='hid_driver::raw_event' o='512' t='int (*)(struct hid_device *, struct hid_report *, u8 *, int)'/>
<mbr r='hid_driver::usage_table' o='576' t='const struct hid_usage_id *'/>
<mbr r='hid_driver::event' o='640' t='int (*)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32)'/>
<mbr r='hid_driver::report' o='704' t='void (*)(struct hid_device *, struct hid_report *)'/>
<mbr r='hid_driver::report_fixup' o='768' t='__u8 *(*)(struct hid_device *, __u8 *, unsigned int *)'/>
<mbr r='hid_driver::input_mapping' o='832' t='int (*)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, unsigned long **, int *)'/>
<mbr r='hid_driver::input_mapped' o='896' t='int (*)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, unsigned long **, int *)'/>
<mbr r='hid_driver::input_configured' o='960' t='int (*)(struct hid_device *, struct hid_input *)'/>
<mbr r='hid_driver::feature_mapping' o='1024' t='void (*)(struct hid_device *, struct hid_field *, struct hid_usage *)'/>
<mbr r='hid_driver::driver' o='1088' t='struct device_driver'/>
