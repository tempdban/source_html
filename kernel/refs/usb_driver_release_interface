<dec f='linux-4.18.y/include/linux/usb.h' l='862' type='void usb_driver_release_interface(struct usb_driver * driver, struct usb_interface * iface)'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='1554' u='c' c='acm_disconnect'/>
<use f='linux-4.18.y/drivers/usb/core/devio.c' l='762' u='c' c='releaseintf'/>
<use f='linux-4.18.y/drivers/usb/core/devio.c' l='2149' u='c' c='proc_ioctl'/>
<use f='linux-4.18.y/drivers/usb/core/devio.c' l='2280' u='c' c='proc_disconnect_claim'/>
<def f='linux-4.18.y/drivers/usb/core/driver.c' l='586' ll='611' type='void usb_driver_release_interface(struct usb_driver * driver, struct usb_interface * iface)'/>
<dec f='linux-4.18.y/drivers/usb/core/driver.c' l='612' type='void usb_driver_release_interface(struct usb_driver * , struct usb_interface * )'/>
<use f='linux-4.18.y/drivers/usb/core/driver.c' l='612' c='usb_driver_release_interface'/>
<use f='linux-4.18.y/drivers/usb/core/driver.c' l='612' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/driver.c' l='612' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/driver.c' l='1025' u='c' c='usb_forced_unbind_intf'/>
<doc f='linux-4.18.y/drivers/usb/core/driver.c' l='572'>/**
 * usb_driver_release_interface - unbind a driver from an interface
 * @driver: the driver to be unbound
 * @iface: the interface from which it will be unbound
 *
 * This can be used by drivers to release an interface without waiting
 * for their disconnect() methods to be called.  In typical cases this
 * also causes the driver disconnect() method to be called.
 *
 * This call is synchronous, and may not be used in an interrupt context.
 * Callers must own the device lock, so driver disconnect() entries don&apos;t
 * need extra locking, but other call contexts may need to explicitly claim
 * that lock.
 */</doc>
