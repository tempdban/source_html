<def f='linux-4.14.y/include/net/xfrm.h' l='118' ll='125'/>
<dec f='linux-4.14.y/include/net/xfrm.h' l='1494' type='int xfrm_state_walk(struct net * net, struct xfrm_state_walk * walk, int (*)(struct xfrm_state *, int, void *) func, void * )'/>
<size>32</size>
<doc f='linux-4.14.y/include/net/xfrm.h' l='57'>/* Organization of SPD aka &quot;XFRM rules&quot;
   ------------------------------------

   Basic objects:
   - policy rule, struct xfrm_policy (=SPD entry)
   - bundle of transformations, struct dst_entry == struct xfrm_dst (=SA bundle)
   - instance of a transformer, struct xfrm_state (=SA)
   - template to clone xfrm_state, struct xfrm_tmpl

   SPD is plain linear list of xfrm_policy rules, ordered by priority.
   (To be compatible with existing pfkeyv2 implementations,
   many rules with priority of 0x7fffffff are allowed to exist and
   such rules are ordered in an unpredictable way, thanks to bsd folks.)

   Lookup is plain linear search until the first match with selector.

   If &quot;action&quot; is &quot;block&quot;, then we prohibit the flow, otherwise:
   if &quot;xfrms_nr&quot; is zero, the flow passes untransformed. Otherwise,
   policy entry has list of up to XFRM_MAX_DEPTH transformations,
   described by templates xfrm_tmpl. Each template is resolved
   to a complete xfrm_state (see below) and we pack bundle of transformations
   to a dst_entry returned to requestor.

   dst -. xfrm  .-&gt; xfrm_state #1
    |---. child .-&gt; dst -. xfrm .-&gt; xfrm_state #2
                     |---. child .-&gt; dst -. xfrm .-&gt; xfrm_state #3
                                      |---. child .-&gt; NULL

   Bundles are cached at xrfm_policy struct (field -&gt;bundles).


   Resolution of xrfm_tmpl
   -----------------------
   Template contains:
   1. -&gt;mode		Mode: transport or tunnel
   2. -&gt;id.proto	Protocol: AH/ESP/IPCOMP
   3. -&gt;id.daddr	Remote tunnel endpoint, ignored for transport mode.
      Q: allow to resolve security gateway?
   4. -&gt;id.spi          If not zero, static SPI.
   5. -&gt;saddr		Local tunnel endpoint, ignored for transport mode.
   6. -&gt;algos		List of allowed algos. Plain bitmask now.
      Q: ealgos, aalgos, calgos. What a mess...
   7. -&gt;share		Sharing mode.
      Q: how to implement private sharing mode? To add struct sock* to
      flow id?

   Having this template we search through SAD searching for entries
   with appropriate mode/proto/algo, permitted by selector.
   If no appropriate entry found, it is requested from key manager.

   PROBLEMS:
   Q: How to find all the bundles referring to a physical path for
      PMTU discovery? Seems, dst should contain list of all parents...
      and enter to infinite locking hierarchy disaster.
      No! It is easier, we will not search for them, let them find us.
      We add genid to each dst plus pointer to genid of raw IP route,
      pmtu disc will update pmtu on raw IP route and increase its genid.
      dst_check() will see this for top level and trigger resyncing
      metrics. Plus, it will be made via sk-&gt;sk_dst_cache. Solved.
 */</doc>
<mbr r='xfrm_state_walk::all' o='0' t='struct list_head'/>
<mbr r='xfrm_state_walk::state' o='128' t='u8'/>
<mbr r='xfrm_state_walk::dying' o='136' t='u8'/>
<mbr r='xfrm_state_walk::proto' o='144' t='u8'/>
<mbr r='xfrm_state_walk::seq' o='160' t='u32'/>
<mbr r='xfrm_state_walk::filter' o='192' t='struct xfrm_address_filter *'/>
<def f='linux-4.14.y/include/net/xfrm.h' l='118' ll='125'/>
<dec f='linux-4.14.y/include/net/xfrm.h' l='1494' type='int xfrm_state_walk(struct net * net, struct xfrm_state_walk * walk, int (*)(struct xfrm_state *, int, void *) func, void * )'/>
<size>32</size>
<doc f='linux-4.14.y/include/net/xfrm.h' l='57'>/* Organization of SPD aka &quot;XFRM rules&quot;
   ------------------------------------

   Basic objects:
   - policy rule, struct xfrm_policy (=SPD entry)
   - bundle of transformations, struct dst_entry == struct xfrm_dst (=SA bundle)
   - instance of a transformer, struct xfrm_state (=SA)
   - template to clone xfrm_state, struct xfrm_tmpl

   SPD is plain linear list of xfrm_policy rules, ordered by priority.
   (To be compatible with existing pfkeyv2 implementations,
   many rules with priority of 0x7fffffff are allowed to exist and
   such rules are ordered in an unpredictable way, thanks to bsd folks.)

   Lookup is plain linear search until the first match with selector.

   If &quot;action&quot; is &quot;block&quot;, then we prohibit the flow, otherwise:
   if &quot;xfrms_nr&quot; is zero, the flow passes untransformed. Otherwise,
   policy entry has list of up to XFRM_MAX_DEPTH transformations,
   described by templates xfrm_tmpl. Each template is resolved
   to a complete xfrm_state (see below) and we pack bundle of transformations
   to a dst_entry returned to requestor.

   dst -. xfrm  .-&gt; xfrm_state #1
    |---. child .-&gt; dst -. xfrm .-&gt; xfrm_state #2
                     |---. child .-&gt; dst -. xfrm .-&gt; xfrm_state #3
                                      |---. child .-&gt; NULL

   Bundles are cached at xrfm_policy struct (field -&gt;bundles).


   Resolution of xrfm_tmpl
   -----------------------
   Template contains:
   1. -&gt;mode		Mode: transport or tunnel
   2. -&gt;id.proto	Protocol: AH/ESP/IPCOMP
   3. -&gt;id.daddr	Remote tunnel endpoint, ignored for transport mode.
      Q: allow to resolve security gateway?
   4. -&gt;id.spi          If not zero, static SPI.
   5. -&gt;saddr		Local tunnel endpoint, ignored for transport mode.
   6. -&gt;algos		List of allowed algos. Plain bitmask now.
      Q: ealgos, aalgos, calgos. What a mess...
   7. -&gt;share		Sharing mode.
      Q: how to implement private sharing mode? To add struct sock* to
      flow id?

   Having this template we search through SAD searching for entries
   with appropriate mode/proto/algo, permitted by selector.
   If no appropriate entry found, it is requested from key manager.

   PROBLEMS:
   Q: How to find all the bundles referring to a physical path for
      PMTU discovery? Seems, dst should contain list of all parents...
      and enter to infinite locking hierarchy disaster.
      No! It is easier, we will not search for them, let them find us.
      We add genid to each dst plus pointer to genid of raw IP route,
      pmtu disc will update pmtu on raw IP route and increase its genid.
      dst_check() will see this for top level and trigger resyncing
      metrics. Plus, it will be made via sk-&gt;sk_dst_cache. Solved.
 */</doc>
<mbr r='xfrm_state_walk::all' o='0' t='struct list_head'/>
<mbr r='xfrm_state_walk::state' o='128' t='u8'/>
<mbr r='xfrm_state_walk::dying' o='136' t='u8'/>
<mbr r='xfrm_state_walk::proto' o='144' t='u8'/>
<mbr r='xfrm_state_walk::seq' o='160' t='u32'/>
<mbr r='xfrm_state_walk::filter' o='192' t='struct xfrm_address_filter *'/>
