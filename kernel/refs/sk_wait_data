<dec f='linux-4.18.y/include/net/sock.h' l='1007' type='int sk_wait_data(struct sock * sk, long * timeo, const struct sk_buff * skb)'/>
<def f='linux-4.18.y/net/core/sock.c' l='2377' ll='2388' type='int sk_wait_data(struct sock * sk, long * timeo, const struct sk_buff * skb)'/>
<dec f='linux-4.18.y/net/core/sock.c' l='2389' type='int sk_wait_data(struct sock * , long * , const struct sk_buff * )'/>
<use f='linux-4.18.y/net/core/sock.c' l='2389' c='sk_wait_data'/>
<use f='linux-4.18.y/net/core/sock.c' l='2389' u='a'/>
<use f='linux-4.18.y/net/core/sock.c' l='2389' u='a'/>
<doc f='linux-4.18.y/net/core/sock.c' l='2366'>/**
 * sk_wait_data - wait for data to arrive at sk_receive_queue
 * @sk:    sock to wait on
 * @timeo: for how long
 * @skb:   last skb seen on sk_receive_queue
 *
 * Now socket state including sk-&gt;sk_err is changed only under lock,
 * hence we may omit checks after joining wait queue.
 * We check receive queue before schedule() only as optimization;
 * it is very likely that release_sock() added new data.
 */</doc>
<use f='linux-4.18.y/net/ipv4/tcp.c' l='834' u='c' c='tcp_splice_read'/>
<use f='linux-4.18.y/net/ipv4/tcp.c' l='2073' u='c' c='tcp_recvmsg'/>
