<dec f='linux-4.18.y/include/linux/vmalloc.h' l='104' type='int remap_vmalloc_range_partial(struct vm_area_struct * vma, unsigned long uaddr, void * kaddr, unsigned long size)'/>
<use f='linux-4.18.y/fs/proc/vmcore.c' l='599' u='c' c='mmap_vmcore'/>
<def f='linux-4.18.y/mm/vmalloc.c' l='2234' ll='2270' type='int remap_vmalloc_range_partial(struct vm_area_struct * vma, unsigned long uaddr, void * kaddr, unsigned long size)'/>
<dec f='linux-4.18.y/mm/vmalloc.c' l='2271' type='int remap_vmalloc_range_partial(struct vm_area_struct * , unsigned long , void * , unsigned long )'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='2271' c='remap_vmalloc_range_partial'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='2271' u='a'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='2271' u='a'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='2290' u='c' c='remap_vmalloc_range'/>
<doc f='linux-4.18.y/mm/vmalloc.c' l='2218'>/**
 *	remap_vmalloc_range_partial  -  map vmalloc pages to userspace
 *	@vma:		vma to cover
 *	@uaddr:		target user address to start at
 *	@kaddr:		virtual address of vmalloc kernel memory
 *	@size:		size of map area
 *
 *	Returns:	0 for success, -Exxx on failure
 *
 *	This function checks that @kaddr is a valid vmalloc&apos;ed area,
 *	and that it is big enough to cover the range starting at
 *	@uaddr in @vma. Will return failure if that criteria isn&apos;t
 *	met.
 *
 *	Similar to remap_pfn_range() (see mm/memory.c)
 */</doc>
