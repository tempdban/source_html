<dec f='linux-4.18.y/include/net/inet_connection_sock.h' l='162' type='struct sock * inet_csk_clone_lock(const struct sock * sk, const struct request_sock * req, const gfp_t priority)'/>
<def f='linux-4.18.y/net/ipv4/inet_connection_sock.c' l='771' ll='806' type='struct sock * inet_csk_clone_lock(const struct sock * sk, const struct request_sock * req, const gfp_t priority)'/>
<dec f='linux-4.18.y/net/ipv4/inet_connection_sock.c' l='807' type='struct sock * inet_csk_clone_lock(const struct sock * , const struct request_sock * , const gfp_t )'/>
<use f='linux-4.18.y/net/ipv4/inet_connection_sock.c' l='807' c='inet_csk_clone_lock'/>
<use f='linux-4.18.y/net/ipv4/inet_connection_sock.c' l='807' u='a'/>
<use f='linux-4.18.y/net/ipv4/inet_connection_sock.c' l='807' u='a'/>
<doc f='linux-4.18.y/net/ipv4/inet_connection_sock.c' l='763'>/**
 *	inet_csk_clone_lock - clone an inet socket, and lock its clone
 *	@sk: the socket to clone
 *	@req: request_sock
 *	@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)
 *
 *	Caller must unlock socket even in error path (bh_unlock_sock(newsk))
 */</doc>
<use f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='452' u='c' c='tcp_create_openreq_child'/>
