<def f='linux-4.18.y/include/linux/regset.h' l='190' ll='201'/>
<size>64</size>
<doc f='linux-4.18.y/include/linux/regset.h' l='131'>/**
 * struct user_regset - accessible thread CPU state
 * @n:			Number of slots (registers).
 * @size:		Size in bytes of a slot (register).
 * @align:		Required alignment, in bytes.
 * @bias:		Bias from natural indexing.
 * @core_note_type:	ELF note @n_type value used in core dumps.
 * @get:		Function to fetch values.
 * @set:		Function to store values.
 * @active:		Function to report if regset is active, or %NULL.
 * @writeback:		Function to write data back to user memory, or %NULL.
 * @get_size:		Function to return the regset&apos;s size, or %NULL.
 *
 * This data structure describes a machine resource we call a register set.
 * This is part of the state of an individual thread, not necessarily
 * actual CPU registers per se.  A register set consists of a number of
 * similar slots, given by @n.  Each slot is @size bytes, and aligned to
 * @align bytes (which is at least @size).  For dynamically-sized
 * regsets, @n must contain the maximum possible number of slots for the
 * regset, and @get_size must point to a function that returns the
 * current regset size.
 *
 * Callers that need to know only the current size of the regset and do
 * not care about its internal structure should call regset_size()
 * instead of inspecting @n or calling @get_size.
 *
 * For backward compatibility, the @get and @set methods must pad to, or
 * accept, @n * @size bytes, even if the current regset size is smaller.
 * The precise semantics of these operations depend on the regset being
 * accessed.
 *
 * The functions to which &amp;struct user_regset members point must be
 * called only on the current thread or on a thread that is in
 * %TASK_STOPPED or %TASK_TRACED state, that we are guaranteed will not
 * be woken up and return to user mode, and that we have called
 * wait_task_inactive() on.  (The target thread always might wake up for
 * SIGKILL while these functions are working, in which case that
 * thread&apos;s user_regset state might be scrambled.)
 *
 * The @pos argument must be aligned according to @align; the @count
 * argument must be a multiple of @size.  These functions are not
 * responsible for checking for invalid arguments.
 *
 * When there is a natural value to use as an index, @bias gives the
 * difference between the natural index and the slot index for the
 * register set.  For example, x86 GDT segment descriptors form a regset;
 * the segment selector produces a natural index, but only a subset of
 * that index space is available as a regset (the TLS slots); subtracting
 * @bias from a segment selector index value computes the regset slot.
 *
 * If nonzero, @core_note_type gives the n_type field (NT_* value)
 * of the core file note in which this regset&apos;s data appears.
 * NT_PRSTATUS is a special case in that the regset data starts at
 * offsetof(struct elf_prstatus, pr_reg) into the note data; that is
 * part of the per-machine ELF formats userland knows about.  In
 * other cases, the core file note contains exactly the whole regset
 * (@n * @size) and nothing else.  The core file note is normally
 * omitted when there is an @active function and it returns zero.
 */</doc>
<mbr r='user_regset::get' o='0' t='user_regset_get_fn *'/>
<mbr r='user_regset::set' o='64' t='user_regset_set_fn *'/>
<mbr r='user_regset::active' o='128' t='user_regset_active_fn *'/>
<mbr r='user_regset::writeback' o='192' t='user_regset_writeback_fn *'/>
<mbr r='user_regset::get_size' o='256' t='user_regset_get_size_fn *'/>
<mbr r='user_regset::n' o='320' t='unsigned int'/>
<mbr r='user_regset::size' o='352' t='unsigned int'/>
<mbr r='user_regset::align' o='384' t='unsigned int'/>
<mbr r='user_regset::bias' o='416' t='unsigned int'/>
<mbr r='user_regset::core_note_type' o='448' t='unsigned int'/>
