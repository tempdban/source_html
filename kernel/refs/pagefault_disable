<def f='linux-4.14.y/include/linux/uaccess.h' l='186' ll='194' type='void pagefault_disable()'/>
<use f='linux-4.14.y/include/linux/highmem.h' l='70' u='c' c='kmap_atomic'/>
<doc f='linux-4.14.y/include/linux/uaccess.h' l='179'>/*
 * These routines enable/disable the pagefault handler. If disabled, it will
 * not take any locks and go straight to the fixup table.
 *
 * User access methods will not sleep when called from a pagefault_disabled()
 * environment.
 */</doc>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2414' u='c' c='perf_callchain_user32'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2471' u='c' c='perf_callchain_user'/>
<use f='linux-4.14.y/arch/x86/kernel/stacktrace.c' l='194' u='c' c='copy_stack_frame'/>
<use f='linux-4.14.y/arch/x86/kvm/x86.c' l='2918' u='c' c='kvm_arch_vcpu_put'/>
<use f='linux-4.14.y/arch/x86/lib/usercopy.c' l='27' u='c' c='copy_from_user_nmi'/>
<use f='linux-4.14.y/include/linux/io-mapping.h' l='163' u='c' c='io_mapping_map_atomic_wc'/>
<use f='linux-4.14.y/kernel/events/uprobes.c' l='1707' u='c' c='is_trap_at_addr'/>
<use f='linux-4.14.y/arch/x86/include/asm/futex.h' l='50' u='c' c='arch_futex_atomic_op_inuser'/>
<use f='linux-4.14.y/kernel/futex.c' l='761' u='c' c='cmpxchg_futex_value_locked'/>
<use f='linux-4.14.y/kernel/futex.c' l='772' u='c' c='get_futex_value_locked'/>
<use f='linux-4.14.y/mm/maccess.c' l='32' u='c' c='__probe_kernel_read'/>
<use f='linux-4.14.y/mm/maccess.c' l='60' u='c' c='__probe_kernel_write'/>
<use f='linux-4.14.y/mm/maccess.c' l='96' u='c' c='strncpy_from_unsafe'/>
<use f='linux-4.14.y/virt/kvm/kvm_main.c' l='1813' u='c' c='__kvm_read_guest_atomic'/>
