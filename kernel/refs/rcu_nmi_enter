<dec f='linux-4.18.y/include/linux/hardirq.h' l='26' type='void rcu_nmi_enter()'/>
<use f='linux-4.18.y/arch/x86/kernel/nmi.c' l='516' macro='1' u='c'/>
<use f='linux-4.18.y/arch/x86/kernel/traps.c' l='106' u='c' c='ist_enter'/>
<use f='linux-4.18.y/kernel/extable.c' l='144' u='c' c='kernel_text_address'/>
<def f='linux-4.18.y/kernel/rcu/tree.c' l='945' ll='971' type='void rcu_nmi_enter()'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='1002' u='c' c='rcu_irq_enter'/>
<doc f='linux-4.18.y/kernel/rcu/tree.c' l='933'>/**
 * rcu_nmi_enter - inform RCU of entry to NMI context
 *
 * If the CPU was idle from RCU&apos;s viewpoint, update rdtp-&gt;dynticks and
 * rdtp-&gt;dynticks_nmi_nesting to let the RCU grace-period handling know
 * that the CPU is active.  This implementation permits nested NMIs, as
 * long as the nesting level does not overflow an int.  (You will probably
 * run out of stack space first.)
 *
 * If you add or remove a call to rcu_nmi_enter(), be sure to test
 * with CONFIG_RCU_EQS_DEBUG=y.
 */</doc>
