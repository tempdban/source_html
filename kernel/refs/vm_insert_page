<dec f='linux-4.14.y/include/linux/mm.h' l='2347' type='int vm_insert_page(struct vm_area_struct * , unsigned long addr, struct page * )'/>
<use f='linux-4.14.y/drivers/android/binder_alloc.c' l='277' u='c' c='binder_update_page_range'/>
<def f='linux-4.14.y/mm/memory.c' l='1764' ll='1777' type='int vm_insert_page(struct vm_area_struct * vma, unsigned long addr, struct page * page)'/>
<dec f='linux-4.14.y/mm/memory.c' l='1778' type='int vm_insert_page(struct vm_area_struct * , unsigned long , struct page * )'/>
<use f='linux-4.14.y/mm/memory.c' l='1778' c='vm_insert_page'/>
<use f='linux-4.14.y/mm/memory.c' l='1778' u='a'/>
<use f='linux-4.14.y/mm/memory.c' l='1778' u='a'/>
<doc f='linux-4.14.y/mm/memory.c' l='1737'>/**
 * vm_insert_page - insert single page into user vma
 * @vma: user vma to map to
 * @addr: target user address of this page
 * @page: source kernel page
 *
 * This allows drivers to insert individual pages they&apos;ve allocated
 * into a user vma.
 *
 * The page has to be a nice clean _individual_ kernel allocation.
 * If you allocate a compound page, you need to have marked it as
 * such (__GFP_COMP), or manually just split the page up yourself
 * (see split_page()).
 *
 * NOTE! Traditionally this was done with &quot;remap_pfn_range()&quot; which
 * took an arbitrary page protection parameter. This doesn&apos;t allow
 * that. Your vma protection will have to be set up correctly, which
 * means that if you want a shared writable mapping, you&apos;d better
 * ask for a shared writable mapping!
 *
 * The page does not need to be reserved.
 *
 * Usually this function is called from f_op-&gt;mmap() handler
 * under mm-&gt;mmap_sem write-lock, so it can change vma-&gt;vm_flags.
 * Caller must set VM_MIXEDMAP on vma if it wants to call this
 * function from other places, for example from page-fault handler.
 */</doc>
<use f='linux-4.14.y/mm/vmalloc.c' l='2271' u='c' c='remap_vmalloc_range_partial'/>
<use f='linux-4.14.y/net/packet/af_packet.c' l='4442' u='c' c='packet_mmap'/>
