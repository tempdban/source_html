<def f='linux-4.18.y/include/linux/rhashtable.h' l='357' ll='361' type='spinlock_t * rht_bucket_lock(const struct bucket_table * tbl, unsigned int hash)'/>
<use f='linux-4.18.y/include/linux/rhashtable.h' l='745' u='c' c='__rhashtable_insert_fast'/>
<use f='linux-4.18.y/include/linux/rhashtable.h' l='1033' u='c' c='__rhashtable_remove_fast_one'/>
<use f='linux-4.18.y/include/linux/rhashtable.h' l='1185' u='c' c='__rhashtable_replace_fast'/>
<doc f='linux-4.18.y/include/linux/rhashtable.h' l='344'>/* The bucket lock is selected based on the hash and protects mutations
 * on a group of hash buckets.
 *
 * A maximum of tbl-&gt;size/2 bucket locks is allocated. This ensures that
 * a single lock always covers both buckets which may both contains
 * entries which link to the same bucket of the old table during resizing.
 * This allows to simplify the locking as locking the bucket in both
 * tables during resize always guarantee protection.
 *
 * IMPORTANT: When holding the bucket lock of both the old and new table
 * during expansions and shrinking, the old bucket lock must always be
 * acquired first.
 */</doc>
<use f='linux-4.18.y/lib/rhashtable.c' l='258' u='c' c='rhashtable_rehash_one'/>
<use f='linux-4.18.y/lib/rhashtable.c' l='282' u='c' c='rhashtable_rehash_chain'/>
<use f='linux-4.18.y/lib/rhashtable.c' l='603' u='c' c='rhashtable_try_insert'/>
<use f='linux-4.18.y/lib/rhashtable.c' l='621' u='c' c='rhashtable_try_insert'/>
<use f='linux-4.18.y/lib/rhashtable.c' l='629' u='c' c='rhashtable_try_insert'/>
