<dec f='linux-4.14.y/include/linux/vmalloc.h' l='166' type='long vread(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-4.14.y/include/linux/vmalloc.h' l='165'>/* for /dev/kmem */</doc>
<use f='linux-4.14.y/drivers/char/mem.c' l='480' u='c' c='read_kmem'/>
<def f='linux-4.14.y/mm/vmalloc.c' l='2100' ll='2153' type='long vread(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-4.14.y/mm/vmalloc.c' l='2074'>/**
 *	vread() -  read vmalloc area in a safe way.
 *	@buf:		buffer for reading data
 *	@addr:		vm address.
 *	@count:		number of bytes to be read.
 *
 *	Returns # of bytes which addr and buf should be increased.
 *	(same number to @count). Returns 0 if [addr...addr+count) doesn&apos;t
 *	includes any intersect with alive vmalloc area.
 *
 *	This function checks that addr is a valid vmalloc&apos;ed area, and
 *	copy data from that area to a given buffer. If the given memory range
 *	of [addr...addr+count) includes some valid address, data is copied to
 *	proper area of @buf. If there are memory holes, they&apos;ll be zero-filled.
 *	IOREMAP area is treated as memory hole and no copy is done.
 *
 *	If [addr...addr+count) doesn&apos;t includes any intersects with alive
 *	vm_struct area, returns 0. @buf should be kernel&apos;s buffer.
 *
 *	Note: In usual ops, vread() is never necessary because the caller
 *	should know vmalloc() area is valid and can use memcpy().
 *	This is for routines which have to access vmalloc area without
 *	any informaion, as /dev/kmem.
 *
 */</doc>
