<def f='linux-4.14.y/include/linux/input.h' l='288' ll='309'/>
<size>120</size>
<doc f='linux-4.14.y/include/linux/input.h' l='248'>/**
 * struct input_handler - implements one of interfaces for input devices
 * @private: driver-specific data
 * @event: event handler. This method is being called by input core with
 *	interrupts disabled and dev-&gt;event_lock spinlock held and so
 *	it may not sleep
 * @events: event sequence handler. This method is being called by
 *	input core with interrupts disabled and dev-&gt;event_lock
 *	spinlock held and so it may not sleep
 * @filter: similar to @event; separates normal event handlers from
 *	&quot;filters&quot;.
 * @match: called after comparing device&apos;s id with handler&apos;s id_table
 *	to perform fine-grained matching between device and handler
 * @connect: called when attaching a handler to an input device
 * @disconnect: disconnects a handler from input device
 * @start: starts handler for given handle. This function is called by
 *	input core right after connect() method and also when a process
 *	that &quot;grabbed&quot; a device releases it
 * @legacy_minors: set to %true by drivers using legacy minor ranges
 * @minor: beginning of range of 32 legacy minors for devices this driver
 *	can provide
 * @name: name of the handler, to be shown in /proc/bus/input/handlers
 * @id_table: pointer to a table of input_device_ids this driver can
 *	handle
 * @h_list: list of input handles associated with the handler
 * @node: for placing the driver onto input_handler_list
 *
 * Input handlers attach to input devices and create input handles. There
 * are likely several handlers attached to any given input device at the
 * same time. All of them will get their copy of input event generated by
 * the device.
 *
 * The very same structure is used to implement input filters. Input core
 * allows filters to run first and will not pass event to regular handlers
 * if any of the filters indicate that the event should be filtered (by
 * returning %true from their filter() method).
 *
 * Note that input core serializes calls to connect() and disconnect()
 * methods.
 */</doc>
<mbr r='input_handler::private' o='0' t='void *'/>
<mbr r='input_handler::event' o='64' t='void (*)(struct input_handle *, unsigned int, unsigned int, int)'/>
<mbr r='input_handler::events' o='128' t='void (*)(struct input_handle *, const struct input_value *, unsigned int)'/>
<mbr r='input_handler::filter' o='192' t='bool (*)(struct input_handle *, unsigned int, unsigned int, int)'/>
<mbr r='input_handler::match' o='256' t='bool (*)(struct input_handler *, struct input_dev *)'/>
<mbr r='input_handler::connect' o='320' t='int (*)(struct input_handler *, struct input_dev *, const struct input_device_id *)'/>
<mbr r='input_handler::disconnect' o='384' t='void (*)(struct input_handle *)'/>
<mbr r='input_handler::start' o='448' t='void (*)(struct input_handle *)'/>
<mbr r='input_handler::legacy_minors' o='512' t='bool'/>
<mbr r='input_handler::minor' o='544' t='int'/>
<mbr r='input_handler::name' o='576' t='const char *'/>
<mbr r='input_handler::id_table' o='640' t='const struct input_device_id *'/>
<mbr r='input_handler::h_list' o='704' t='struct list_head'/>
<mbr r='input_handler::node' o='832' t='struct list_head'/>
<def f='linux-4.14.y/include/linux/input.h' l='288' ll='309'/>
<size>120</size>
<doc f='linux-4.14.y/include/linux/input.h' l='248'>/**
 * struct input_handler - implements one of interfaces for input devices
 * @private: driver-specific data
 * @event: event handler. This method is being called by input core with
 *	interrupts disabled and dev-&gt;event_lock spinlock held and so
 *	it may not sleep
 * @events: event sequence handler. This method is being called by
 *	input core with interrupts disabled and dev-&gt;event_lock
 *	spinlock held and so it may not sleep
 * @filter: similar to @event; separates normal event handlers from
 *	&quot;filters&quot;.
 * @match: called after comparing device&apos;s id with handler&apos;s id_table
 *	to perform fine-grained matching between device and handler
 * @connect: called when attaching a handler to an input device
 * @disconnect: disconnects a handler from input device
 * @start: starts handler for given handle. This function is called by
 *	input core right after connect() method and also when a process
 *	that &quot;grabbed&quot; a device releases it
 * @legacy_minors: set to %true by drivers using legacy minor ranges
 * @minor: beginning of range of 32 legacy minors for devices this driver
 *	can provide
 * @name: name of the handler, to be shown in /proc/bus/input/handlers
 * @id_table: pointer to a table of input_device_ids this driver can
 *	handle
 * @h_list: list of input handles associated with the handler
 * @node: for placing the driver onto input_handler_list
 *
 * Input handlers attach to input devices and create input handles. There
 * are likely several handlers attached to any given input device at the
 * same time. All of them will get their copy of input event generated by
 * the device.
 *
 * The very same structure is used to implement input filters. Input core
 * allows filters to run first and will not pass event to regular handlers
 * if any of the filters indicate that the event should be filtered (by
 * returning %true from their filter() method).
 *
 * Note that input core serializes calls to connect() and disconnect()
 * methods.
 */</doc>
<mbr r='input_handler::private' o='0' t='void *'/>
<mbr r='input_handler::event' o='64' t='void (*)(struct input_handle *, unsigned int, unsigned int, int)'/>
<mbr r='input_handler::events' o='128' t='void (*)(struct input_handle *, const struct input_value *, unsigned int)'/>
<mbr r='input_handler::filter' o='192' t='bool (*)(struct input_handle *, unsigned int, unsigned int, int)'/>
<mbr r='input_handler::match' o='256' t='bool (*)(struct input_handler *, struct input_dev *)'/>
<mbr r='input_handler::connect' o='320' t='int (*)(struct input_handler *, struct input_dev *, const struct input_device_id *)'/>
<mbr r='input_handler::disconnect' o='384' t='void (*)(struct input_handle *)'/>
<mbr r='input_handler::start' o='448' t='void (*)(struct input_handle *)'/>
<mbr r='input_handler::legacy_minors' o='512' t='bool'/>
<mbr r='input_handler::minor' o='544' t='int'/>
<mbr r='input_handler::name' o='576' t='const char *'/>
<mbr r='input_handler::id_table' o='640' t='const struct input_device_id *'/>
<mbr r='input_handler::h_list' o='704' t='struct list_head'/>
<mbr r='input_handler::node' o='832' t='struct list_head'/>
