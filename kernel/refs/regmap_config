<def f='linux-4.18.y/include/linux/regmap.h' l='335' ll='385'/>
<size>232</size>
<doc f='linux-4.18.y/include/linux/regmap.h' l='237'>/**
 * struct regmap_config - Configuration for the register map of a device.
 *
 * @name: Optional name of the regmap. Useful when a device has multiple
 *        register regions.
 *
 * @reg_bits: Number of bits in a register address, mandatory.
 * @reg_stride: The register address stride. Valid register addresses are a
 *              multiple of this value. If set to 0, a value of 1 will be
 *              used.
 * @pad_bits: Number of bits of padding between register and value.
 * @val_bits: Number of bits in a register value, mandatory.
 *
 * @writeable_reg: Optional callback returning true if the register
 *		   can be written to. If this field is NULL but wr_table
 *		   (see below) is not, the check is performed on such table
 *                 (a register is writeable if it belongs to one of the ranges
 *                  specified by wr_table).
 * @readable_reg: Optional callback returning true if the register
 *		  can be read from. If this field is NULL but rd_table
 *		   (see below) is not, the check is performed on such table
 *                 (a register is readable if it belongs to one of the ranges
 *                  specified by rd_table).
 * @volatile_reg: Optional callback returning true if the register
 *		  value can&apos;t be cached. If this field is NULL but
 *		  volatile_table (see below) is not, the check is performed on
 *                such table (a register is volatile if it belongs to one of
 *                the ranges specified by volatile_table).
 * @precious_reg: Optional callback returning true if the register
 *		  should not be read outside of a call from the driver
 *		  (e.g., a clear on read interrupt status register). If this
 *                field is NULL but precious_table (see below) is not, the
 *                check is performed on such table (a register is precious if
 *                it belongs to one of the ranges specified by precious_table).
 * @disable_locking: This regmap is either protected by external means or
 *                   is guaranteed not be be accessed from multiple threads.
 *                   Don&apos;t use any locking mechanisms.
 * @lock:	  Optional lock callback (overrides regmap&apos;s default lock
 *		  function, based on spinlock or mutex).
 * @unlock:	  As above for unlocking.
 * @lock_arg:	  this field is passed as the only argument of lock/unlock
 *		  functions (ignored in case regular lock/unlock functions
 *		  are not overridden).
 * @reg_read:	  Optional callback that if filled will be used to perform
 *           	  all the reads from the registers. Should only be provided for
 *		  devices whose read operation cannot be represented as a simple
 *		  read operation on a bus such as SPI, I2C, etc. Most of the
 *		  devices do not need this.
 * @reg_write:	  Same as above for writing.
 * @fast_io:	  Register IO is fast. Use a spinlock instead of a mutex
 *	     	  to perform locking. This field is ignored if custom lock/unlock
 *	     	  functions are used (see fields lock/unlock of struct regmap_config).
 *		  This field is a duplicate of a similar file in
 *		  &apos;struct regmap_bus&apos; and serves exact same purpose.
 *		   Use it only for &quot;no-bus&quot; cases.
 * @max_register: Optional, specifies the maximum valid register address.
 * @wr_table:     Optional, points to a struct regmap_access_table specifying
 *                valid ranges for write access.
 * @rd_table:     As above, for read access.
 * @volatile_table: As above, for volatile registers.
 * @precious_table: As above, for precious registers.
 * @reg_defaults: Power on reset values for registers (for use with
 *                register cache support).
 * @num_reg_defaults: Number of elements in reg_defaults.
 *
 * @read_flag_mask: Mask to be set in the top bytes of the register when doing
 *                  a read.
 * @write_flag_mask: Mask to be set in the top bytes of the register when doing
 *                   a write. If both read_flag_mask and write_flag_mask are
 *                   empty and zero_flag_mask is not set the regmap_bus default
 *                   masks are used.
 * @zero_flag_mask: If set, read_flag_mask and write_flag_mask are used even
 *                   if they are both empty.
 * @use_single_rw: If set, converts the bulk read and write operations into
 *		    a series of single read and write operations. This is useful
 *		    for device that does not support bulk read and write.
 * @can_multi_write: If set, the device supports the multi write mode of bulk
 *                   write operations, if clear multi write requests will be
 *                   split into individual write operations
 *
 * @cache_type: The actual cache type.
 * @reg_defaults_raw: Power on reset values for registers (for use with
 *                    register cache support).
 * @num_reg_defaults_raw: Number of elements in reg_defaults_raw.
 * @reg_format_endian: Endianness for formatted register addresses. If this is
 *                     DEFAULT, the @reg_format_endian_default value from the
 *                     regmap bus is used.
 * @val_format_endian: Endianness for formatted register values. If this is
 *                     DEFAULT, the @reg_format_endian_default value from the
 *                     regmap bus is used.
 *
 * @ranges: Array of configuration entries for virtual address ranges.
 * @num_ranges: Number of range configuration entries.
 * @use_hwlock: Indicate if a hardware spinlock should be used.
 * @hwlock_id: Specify the hardware spinlock id.
 * @hwlock_mode: The hardware spinlock mode, should be HWLOCK_IRQSTATE,
 *		 HWLOCK_IRQ or 0.
 */</doc>
<mbr r='regmap_config::name' o='0' t='const char *'/>
<mbr r='regmap_config::reg_bits' o='64' t='int'/>
<mbr r='regmap_config::reg_stride' o='96' t='int'/>
<mbr r='regmap_config::pad_bits' o='128' t='int'/>
<mbr r='regmap_config::val_bits' o='160' t='int'/>
<mbr r='regmap_config::writeable_reg' o='192' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::readable_reg' o='256' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::volatile_reg' o='320' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::precious_reg' o='384' t='bool (*)(struct device *, unsigned int)'/>
<mbr r='regmap_config::disable_locking' o='448' t='bool'/>
<mbr r='regmap_config::lock' o='512' t='regmap_lock'/>
<mbr r='regmap_config::unlock' o='576' t='regmap_unlock'/>
<mbr r='regmap_config::lock_arg' o='640' t='void *'/>
<mbr r='regmap_config::reg_read' o='704' t='int (*)(void *, unsigned int, unsigned int *)'/>
<mbr r='regmap_config::reg_write' o='768' t='int (*)(void *, unsigned int, unsigned int)'/>
<mbr r='regmap_config::fast_io' o='832' t='bool'/>
<mbr r='regmap_config::max_register' o='864' t='unsigned int'/>
<mbr r='regmap_config::wr_table' o='896' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::rd_table' o='960' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::volatile_table' o='1024' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::precious_table' o='1088' t='const struct regmap_access_table *'/>
<mbr r='regmap_config::reg_defaults' o='1152' t='const struct reg_default *'/>
<mbr r='regmap_config::num_reg_defaults' o='1216' t='unsigned int'/>
<mbr r='regmap_config::cache_type' o='1248' t='enum regcache_type'/>
<mbr r='regmap_config::reg_defaults_raw' o='1280' t='const void *'/>
<mbr r='regmap_config::num_reg_defaults_raw' o='1344' t='unsigned int'/>
<mbr r='regmap_config::read_flag_mask' o='1408' t='unsigned long'/>
<mbr r='regmap_config::write_flag_mask' o='1472' t='unsigned long'/>
<mbr r='regmap_config::zero_flag_mask' o='1536' t='bool'/>
<mbr r='regmap_config::use_single_rw' o='1544' t='bool'/>
<mbr r='regmap_config::can_multi_write' o='1552' t='bool'/>
<mbr r='regmap_config::reg_format_endian' o='1568' t='enum regmap_endian'/>
<mbr r='regmap_config::val_format_endian' o='1600' t='enum regmap_endian'/>
<mbr r='regmap_config::ranges' o='1664' t='const struct regmap_range_cfg *'/>
<mbr r='regmap_config::num_ranges' o='1728' t='unsigned int'/>
<mbr r='regmap_config::use_hwlock' o='1760' t='bool'/>
<mbr r='regmap_config::hwlock_id' o='1792' t='unsigned int'/>
<mbr r='regmap_config::hwlock_mode' o='1824' t='unsigned int'/>
