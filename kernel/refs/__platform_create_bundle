<dec f='linux-4.18.y/include/linux/platform_device.h' l='274' type='struct platform_device * __platform_create_bundle(struct platform_driver * driver, int (*)(struct platform_device *) probe, struct resource * res, unsigned int n_res, const void * data, size_t size, struct module * module)'/>
<def f='linux-4.18.y/drivers/base/platform.c' l='733' ll='772' type='struct platform_device * __platform_create_bundle(struct platform_driver * driver, int (*)(struct platform_device *) probe, struct resource * res, unsigned int n_res, const void * data, size_t size, struct module * module)'/>
<dec f='linux-4.18.y/drivers/base/platform.c' l='773' type='struct platform_device * __platform_create_bundle(struct platform_driver * , int (*)(struct platform_device *) , struct resource * , unsigned int , const void * , size_t , struct module * )'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='773' c='__platform_create_bundle'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='773' u='a'/>
<use f='linux-4.18.y/drivers/base/platform.c' l='773' u='a'/>
<doc f='linux-4.18.y/drivers/base/platform.c' l='718'>/**
 * __platform_create_bundle - register driver and create corresponding device
 * @driver: platform driver structure
 * @probe: the driver probe routine, probably from an __init section
 * @res: set of resources that needs to be allocated for the device
 * @n_res: number of resources
 * @data: platform specific data for this platform device
 * @size: size of platform specific data
 * @module: module which will be the owner of the driver
 *
 * Use this in legacy-style modules that probe hardware directly and
 * register a single platform device and corresponding platform driver.
 *
 * Returns &amp;struct platform_device pointer on success, or ERR_PTR() on error.
 */</doc>
<use f='linux-4.18.y/drivers/input/serio/i8042.c' l='1608' macro='1' u='c'/>
<use f='linux-4.18.y/drivers/mailbox/pcc.c' l='601' macro='1' u='c'/>
