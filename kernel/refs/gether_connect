<dec f='linux-4.18.y/drivers/usb/gadget/function/u_ether.h' l='250' type='struct net_device * gether_connect(struct gether * )'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ecm.c' l='585' u='c' c='ecm_set_alt'/>
<doc f='linux-4.18.y/drivers/usb/gadget/function/u_ether.h' l='249'>/* connect/disconnect is handled by individual functions */</doc>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_eem.c' l='215' u='c' c='eem_set_alt'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ncm.c' l='924' u='c' c='ncm_set_alt'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_rndis.c' l='593' u='c' c='rndis_set_alt'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_subset.c' l='274' u='c' c='geth_set_alt'/>
<def f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='1046' ll='1109' type='struct net_device * gether_connect(struct gether * link)'/>
<dec f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='1110' type='struct net_device * gether_connect(struct gether * )'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='1110' c='gether_connect'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='1110' u='a'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='1110' u='a'/>
<doc f='linux-4.18.y/drivers/usb/gadget/function/u_ether.c' l='1030'>/**
 * gether_connect - notify network layer that USB link is active
 * @link: the USB link, set up with endpoints, descriptors matching
 *	current device speed, and any framing wrapper(s) set up.
 * Context: irqs blocked
 *
 * This is called to activate endpoints and let the network layer know
 * the connection is active (&quot;carrier detect&quot;).  It may cause the I/O
 * queues to open and start letting network packets flow, but will in
 * any case activate the endpoints so that they respond properly to the
 * USB host.
 *
 * Verify net_device pointer returned using IS_ERR().  If it doesn&apos;t
 * indicate some error code (negative errno), ep-&gt;driver_data values
 * have been overwritten.
 */</doc>
