<def f='linux-4.14.y/include/net/tcp.h' l='2035' ll='2039' type='void tcp_listendrop(const struct sock * sk)'/>
<doc f='linux-4.14.y/include/net/tcp.h' l='2028'>/*
 * TCP listen path runs lockless.
 * We forced &quot;struct sock&quot; to be const qualified to make sure
 * we don&apos;t modify one of its field by mistake.
 * Here, we increment sk_drops which is an atomic_t, so we can safely
 * make sock writable again.
 */</doc>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='6439' u='c' c='tcp_conn_request'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='344' u='c' c='tcp_req_err'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1318' u='c' c='tcp_v4_conn_request'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1419' u='c' c='tcp_v4_syn_recv_sock'/>
<def f='linux-4.14.y/include/net/tcp.h' l='2035' ll='2039' type='void tcp_listendrop(const struct sock * sk)'/>
<doc f='linux-4.14.y/include/net/tcp.h' l='2028'>/*
 * TCP listen path runs lockless.
 * We forced &quot;struct sock&quot; to be const qualified to make sure
 * we don&apos;t modify one of its field by mistake.
 * Here, we increment sk_drops which is an atomic_t, so we can safely
 * make sock writable again.
 */</doc>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='6439' u='c' c='tcp_conn_request'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='344' u='c' c='tcp_req_err'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1318' u='c' c='tcp_v4_conn_request'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1419' u='c' c='tcp_v4_syn_recv_sock'/>
