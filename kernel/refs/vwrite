<dec f='linux-4.14.y/include/linux/vmalloc.h' l='167' type='long vwrite(char * buf, char * addr, unsigned long count)'/>
<use f='linux-4.14.y/drivers/char/mem.c' l='589' u='c' c='write_kmem'/>
<def f='linux-4.14.y/mm/vmalloc.c' l='2181' ll='2229' type='long vwrite(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-4.14.y/mm/vmalloc.c' l='2155'>/**
 *	vwrite() -  write vmalloc area in a safe way.
 *	@buf:		buffer for source data
 *	@addr:		vm address.
 *	@count:		number of bytes to be read.
 *
 *	Returns # of bytes which addr and buf should be incresed.
 *	(same number to @count).
 *	If [addr...addr+count) doesn&apos;t includes any intersect with valid
 *	vmalloc area, returns 0.
 *
 *	This function checks that addr is a valid vmalloc&apos;ed area, and
 *	copy data from a buffer to the given addr. If specified range of
 *	[addr...addr+count) includes some valid address, data is copied from
 *	proper area of @buf. If there are memory holes, no copy to hole.
 *	IOREMAP area is treated as memory hole and no copy is done.
 *
 *	If [addr...addr+count) doesn&apos;t includes any intersects with alive
 *	vm_struct area, returns 0. @buf should be kernel&apos;s buffer.
 *
 *	Note: In usual ops, vwrite() is never necessary because the caller
 *	should know vmalloc() area is valid and can use memcpy().
 *	This is for routines which have to access vmalloc area without
 *	any informaion, as /dev/kmem.
 */</doc>
<dec f='linux-4.14.y/include/linux/vmalloc.h' l='167' type='long vwrite(char * buf, char * addr, unsigned long count)'/>
<use f='linux-4.14.y/drivers/char/mem.c' l='589' u='c' c='write_kmem'/>
<def f='linux-4.14.y/mm/vmalloc.c' l='2181' ll='2229' type='long vwrite(char * buf, char * addr, unsigned long count)'/>
<doc f='linux-4.14.y/mm/vmalloc.c' l='2155'>/**
 *	vwrite() -  write vmalloc area in a safe way.
 *	@buf:		buffer for source data
 *	@addr:		vm address.
 *	@count:		number of bytes to be read.
 *
 *	Returns # of bytes which addr and buf should be incresed.
 *	(same number to @count).
 *	If [addr...addr+count) doesn&apos;t includes any intersect with valid
 *	vmalloc area, returns 0.
 *
 *	This function checks that addr is a valid vmalloc&apos;ed area, and
 *	copy data from a buffer to the given addr. If specified range of
 *	[addr...addr+count) includes some valid address, data is copied from
 *	proper area of @buf. If there are memory holes, no copy to hole.
 *	IOREMAP area is treated as memory hole and no copy is done.
 *
 *	If [addr...addr+count) doesn&apos;t includes any intersects with alive
 *	vm_struct area, returns 0. @buf should be kernel&apos;s buffer.
 *
 *	Note: In usual ops, vwrite() is never necessary because the caller
 *	should know vmalloc() area is valid and can use memcpy().
 *	This is for routines which have to access vmalloc area without
 *	any informaion, as /dev/kmem.
 */</doc>
