<dec f='linux-4.18.y/include/linux/cpuset.h' l='65' type='bool __cpuset_node_allowed(int node, gfp_t gfp_mask)'/>
<use f='linux-4.18.y/include/linux/cpuset.h' l='70' u='c' c='cpuset_node_allowed'/>
<use f='linux-4.18.y/include/linux/cpuset.h' l='76' u='c' c='__cpuset_zone_allowed'/>
<def f='linux-4.18.y/kernel/cgroup/cpuset.c' l='2553' ll='2585' type='bool __cpuset_node_allowed(int node, gfp_t gfp_mask)'/>
<doc f='linux-4.18.y/kernel/cgroup/cpuset.c' l='2513'>/**
 * cpuset_node_allowed - Can we allocate on a memory node?
 * @node: is this an allowed node?
 * @gfp_mask: memory allocation flags
 *
 * If we&apos;re in interrupt, yes, we can always allocate.  If @node is set in
 * current&apos;s mems_allowed, yes.  If it&apos;s not a __GFP_HARDWALL request and this
 * node is set in the nearest hardwalled cpuset ancestor to current&apos;s cpuset,
 * yes.  If current has access to memory reserves as an oom victim, yes.
 * Otherwise, no.
 *
 * GFP_USER allocations are marked with the __GFP_HARDWALL bit,
 * and do not allow allocations outside the current tasks cpuset
 * unless the task has been OOM killed.
 * GFP_KERNEL allocations are not so marked, so can escape to the
 * nearest enclosing hardwalled ancestor cpuset.
 *
 * Scanning up parent cpusets requires callback_lock.  The
 * __alloc_pages() routine only calls here with __GFP_HARDWALL bit
 * _not_ set if it&apos;s a GFP_KERNEL allocation, and all nodes in the
 * current tasks mems_allowed came up empty on the first pass over
 * the zonelist.  So only GFP_KERNEL allocations, if all nodes in the
 * cpuset are short of memory, might require taking the callback_lock.
 *
 * The first call here from mm/page_alloc:get_page_from_freelist()
 * has __GFP_HARDWALL set in gfp_mask, enforcing hardwall cpusets,
 * so no allocation on a node outside the cpuset is allowed (unless
 * in interrupt, of course).
 *
 * The second pass through get_page_from_freelist() doesn&apos;t even call
 * here for GFP_ATOMIC calls.  For those calls, the __alloc_pages()
 * variable &apos;wait&apos; is not set, and the bit ALLOC_CPUSET is not set
 * in alloc_flags.  That logic and the checks below have the combined
 * affect that:
 *	in_interrupt - any node ok (current task context irrelevant)
 *	GFP_ATOMIC   - any node ok
 *	tsk_is_oom_victim   - any node ok
 *	GFP_KERNEL   - any node in enclosing hardwalled cpuset ok
 *	GFP_USER     - only nodes in current tasks mems allowed ok.
 */</doc>
