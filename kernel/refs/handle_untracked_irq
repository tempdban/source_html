<dec f='linux-4.18.y/include/linux/irq.h' l='590' type='void handle_untracked_irq(struct irq_desc * desc)'/>
<def f='linux-4.18.y/kernel/irq/chip.c' l='567' ll='594' type='void handle_untracked_irq(struct irq_desc * desc)'/>
<dec f='linux-4.18.y/kernel/irq/chip.c' l='595' type='void handle_untracked_irq(struct irq_desc * )'/>
<use f='linux-4.18.y/kernel/irq/chip.c' l='595' c='handle_untracked_irq'/>
<use f='linux-4.18.y/kernel/irq/chip.c' l='595' u='a'/>
<use f='linux-4.18.y/kernel/irq/chip.c' l='595' u='a'/>
<doc f='linux-4.18.y/kernel/irq/chip.c' l='554'>/**
 *	handle_untracked_irq - Simple and software-decoded IRQs.
 *	@desc:	the interrupt description structure for this irq
 *
 *	Untracked interrupts are sent from a demultiplexing interrupt
 *	handler when the demultiplexer does not know which device it its
 *	multiplexed irq domain generated the interrupt. IRQ&apos;s handled
 *	through here are not subjected to stats tracking, randomness, or
 *	spurious interrupt detection.
 *
 *	Note: Like handle_simple_irq, the caller is expected to handle
 *	the ack, clear, mask and unmask issues if necessary.
 */</doc>
