<def f='linux-4.14.y/include/linux/spi/spi.h' l='409' ll='582'/>
<size>1208</size>
<doc f='linux-4.14.y/include/linux/spi/spi.h' l='296'>/**
 * struct spi_controller - interface to SPI master or slave controller
 * @dev: device interface to this driver
 * @list: link with the global spi_controller list
 * @bus_num: board-specific (and often SOC-specific) identifier for a
 *	given SPI controller.
 * @num_chipselect: chipselects are used to distinguish individual
 *	SPI slaves, and are numbered from zero to num_chipselects.
 *	each slave has a chipselect signal, but it&apos;s common that not
 *	every chipselect is connected to a slave.
 * @dma_alignment: SPI controller constraint on DMA buffers alignment.
 * @mode_bits: flags understood by this controller driver
 * @bits_per_word_mask: A mask indicating which values of bits_per_word are
 *	supported by the driver. Bit n indicates that a bits_per_word n+1 is
 *	supported. If set, the SPI core will reject any transfer with an
 *	unsupported bits_per_word. If not set, this value is simply ignored,
 *	and it&apos;s up to the individual driver to perform any validation.
 * @min_speed_hz: Lowest supported transfer speed
 * @max_speed_hz: Highest supported transfer speed
 * @flags: other constraints relevant to this driver
 * @slave: indicates that this is an SPI slave controller
 * @max_transfer_size: function that returns the max transfer size for
 *	a &amp;spi_device; may be %NULL, so the default %SIZE_MAX will be used.
 * @max_message_size: function that returns the max message size for
 *	a &amp;spi_device; may be %NULL, so the default %SIZE_MAX will be used.
 * @io_mutex: mutex for physical bus access
 * @bus_lock_spinlock: spinlock for SPI bus locking
 * @bus_lock_mutex: mutex for exclusion of multiple callers
 * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use
 * @setup: updates the device mode and clocking records used by a
 *	device&apos;s SPI controller; protocol code may call this.  This
 *	must fail if an unrecognized or unsupported mode is requested.
 *	It&apos;s always safe to call this unless transfers are pending on
 *	the device whose settings are being modified.
 * @transfer: adds a message to the controller&apos;s transfer queue.
 * @cleanup: frees controller-specific state
 * @can_dma: determine whether this controller supports DMA
 * @queued: whether this controller is providing an internal message queue
 * @kworker: thread struct for message pump
 * @kworker_task: pointer to task for message pump kworker thread
 * @pump_messages: work struct for scheduling work to the message pump
 * @queue_lock: spinlock to syncronise access to message queue
 * @queue: message queue
 * @idling: the device is entering idle state
 * @cur_msg: the currently in-flight message
 * @cur_msg_prepared: spi_prepare_message was called for the currently
 *                    in-flight message
 * @cur_msg_mapped: message has been mapped for DMA
 * @xfer_completion: used by core transfer_one_message()
 * @busy: message pump is busy
 * @running: message pump is running
 * @rt: whether this queue is set to run as a realtime task
 * @auto_runtime_pm: the core should ensure a runtime PM reference is held
 *                   while the hardware is prepared, using the parent
 *                   device for the spidev
 * @max_dma_len: Maximum length of a DMA transfer for the device.
 * @prepare_transfer_hardware: a message will soon arrive from the queue
 *	so the subsystem requests the driver to prepare the transfer hardware
 *	by issuing this call
 * @transfer_one_message: the subsystem calls the driver to transfer a single
 *	message while queuing transfers that arrive in the meantime. When the
 *	driver is finished with this message, it must call
 *	spi_finalize_current_message() so the subsystem can issue the next
 *	message
 * @unprepare_transfer_hardware: there are currently no more messages on the
 *	queue so the subsystem notifies the driver that it may relax the
 *	hardware by issuing this call
 * @set_cs: set the logic level of the chip select line.  May be called
 *          from interrupt context.
 * @prepare_message: set up the controller to transfer a single message,
 *                   for example doing DMA mapping.  Called from threaded
 *                   context.
 * @transfer_one: transfer a single spi_transfer.
 *                  - return 0 if the transfer is finished,
 *                  - return 1 if the transfer is still in progress. When
 *                    the driver is finished with this transfer it must
 *                    call spi_finalize_current_transfer() so the subsystem
 *                    can issue the next transfer. Note: transfer_one and
 *                    transfer_one_message are mutually exclusive; when both
 *                    are set, the generic subsystem does not call your
 *                    transfer_one callback.
 * @handle_err: the subsystem calls the driver to handle an error that occurs
 *		in the generic implementation of transfer_one_message().
 * @unprepare_message: undo any work done by prepare_message().
 * @slave_abort: abort the ongoing transfer request on an SPI slave controller
 * @spi_flash_read: to support spi-controller hardwares that provide
 *                  accelerated interface to read from flash devices.
 * @spi_flash_can_dma: analogous to can_dma() interface, but for
 *		       controllers implementing spi_flash_read.
 * @flash_read_supported: spi device supports flash read
 * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
 *	number. Any individual value may be -ENOENT for CS lines that
 *	are not GPIOs (driven by the SPI controller itself).
 * @statistics: statistics for the spi_controller
 * @dma_tx: DMA transmit channel
 * @dma_rx: DMA receive channel
 * @dummy_rx: dummy receive buffer for full-duplex devices
 * @dummy_tx: dummy transmit buffer for full-duplex devices
 * @fw_translate_cs: If the boot firmware uses different numbering scheme
 *	what Linux expects, this optional hook can be used to translate
 *	between the two.
 *
 * Each SPI controller can communicate with one or more @spi_device
 * children.  These make a small bus, sharing MOSI, MISO and SCK signals
 * but not chip select signals.  Each device may be configured to use a
 * different clock rate, since those shared signals are ignored unless
 * the chip is selected.
 *
 * The driver for an SPI controller manages access to those devices through
 * a queue of spi_message transactions, copying data between CPU memory and
 * an SPI slave device.  For each such message it queues, it calls the
 * message&apos;s completion function when the transaction completes.
 */</doc>
<mbr r='spi_controller::dev' o='0' t='struct device'/>
<mbr r='spi_controller::list' o='3776' t='struct list_head'/>
<mbr r='spi_controller::bus_num' o='3904' t='s16'/>
<mbr r='spi_controller::num_chipselect' o='3920' t='u16'/>
<mbr r='spi_controller::dma_alignment' o='3936' t='u16'/>
<mbr r='spi_controller::mode_bits' o='3952' t='u16'/>
<mbr r='spi_controller::bits_per_word_mask' o='3968' t='u32'/>
<mbr r='spi_controller::min_speed_hz' o='4000' t='u32'/>
<mbr r='spi_controller::max_speed_hz' o='4032' t='u32'/>
<mbr r='spi_controller::flags' o='4064' t='u16'/>
<mbr r='spi_controller::slave' o='4080' t='bool'/>
<mbr r='spi_controller::max_transfer_size' o='4096' t='size_t (*)(struct spi_device *)'/>
<mbr r='spi_controller::max_message_size' o='4160' t='size_t (*)(struct spi_device *)'/>
<mbr r='spi_controller::io_mutex' o='4224' t='struct mutex'/>
<mbr r='spi_controller::bus_lock_spinlock' o='4480' t='spinlock_t'/>
<mbr r='spi_controller::bus_lock_mutex' o='4544' t='struct mutex'/>
<mbr r='spi_controller::bus_lock_flag' o='4800' t='bool'/>
<mbr r='spi_controller::setup' o='4864' t='int (*)(struct spi_device *)'/>
<mbr r='spi_controller::transfer' o='4928' t='int (*)(struct spi_device *, struct spi_message *)'/>
<mbr r='spi_controller::cleanup' o='4992' t='void (*)(struct spi_device *)'/>
<mbr r='spi_controller::can_dma' o='5056' t='bool (*)(struct spi_controller *, struct spi_device *, struct spi_transfer *)'/>
<mbr r='spi_controller::queued' o='5120' t='bool'/>
<mbr r='spi_controller::kworker' o='5184' t='struct kthread_worker'/>
<mbr r='spi_controller::kworker_task' o='5632' t='struct task_struct *'/>
<mbr r='spi_controller::pump_messages' o='5696' t='struct kthread_work'/>
<mbr r='spi_controller::queue_lock' o='6016' t='spinlock_t'/>
<mbr r='spi_controller::queue' o='6080' t='struct list_head'/>
<mbr r='spi_controller::cur_msg' o='6208' t='struct spi_message *'/>
<mbr r='spi_controller::idling' o='6272' t='bool'/>
<mbr r='spi_controller::busy' o='6280' t='bool'/>
<mbr r='spi_controller::running' o='6288' t='bool'/>
<mbr r='spi_controller::rt' o='6296' t='bool'/>
<mbr r='spi_controller::auto_runtime_pm' o='6304' t='bool'/>
<mbr r='spi_controller::cur_msg_prepared' o='6312' t='bool'/>
<mbr r='spi_controller::cur_msg_mapped' o='6320' t='bool'/>
<mbr r='spi_controller::xfer_completion' o='6336' t='struct completion'/>
<mbr r='spi_controller::max_dma_len' o='6592' t='size_t'/>
<mbr r='spi_controller::prepare_transfer_hardware' o='6656' t='int (*)(struct spi_controller *)'/>
<mbr r='spi_controller::transfer_one_message' o='6720' t='int (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::unprepare_transfer_hardware' o='6784' t='int (*)(struct spi_controller *)'/>
<mbr r='spi_controller::prepare_message' o='6848' t='int (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::unprepare_message' o='6912' t='int (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::slave_abort' o='6976' t='int (*)(struct spi_controller *)'/>
<mbr r='spi_controller::spi_flash_read' o='7040' t='int (*)(struct spi_device *, struct spi_flash_read_message *)'/>
<mbr r='spi_controller::spi_flash_can_dma' o='7104' t='bool (*)(struct spi_device *, struct spi_flash_read_message *)'/>
<mbr r='spi_controller::flash_read_supported' o='7168' t='bool (*)(struct spi_device *)'/>
<mbr r='spi_controller::set_cs' o='7232' t='void (*)(struct spi_device *, bool)'/>
<mbr r='spi_controller::transfer_one' o='7296' t='int (*)(struct spi_controller *, struct spi_device *, struct spi_transfer *)'/>
<mbr r='spi_controller::handle_err' o='7360' t='void (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::cs_gpios' o='7424' t='int *'/>
<mbr r='spi_controller::statistics' o='7488' t='struct spi_statistics'/>
<mbr r='spi_controller::dma_tx' o='9344' t='struct dma_chan *'/>
<mbr r='spi_controller::dma_rx' o='9408' t='struct dma_chan *'/>
<mbr r='spi_controller::dummy_rx' o='9472' t='void *'/>
<mbr r='spi_controller::dummy_tx' o='9536' t='void *'/>
<mbr r='spi_controller::fw_translate_cs' o='9600' t='int (*)(struct spi_controller *, unsigned int)'/>
<def f='linux-4.14.y/include/linux/spi/spi.h' l='409' ll='582'/>
<size>1208</size>
<doc f='linux-4.14.y/include/linux/spi/spi.h' l='296'>/**
 * struct spi_controller - interface to SPI master or slave controller
 * @dev: device interface to this driver
 * @list: link with the global spi_controller list
 * @bus_num: board-specific (and often SOC-specific) identifier for a
 *	given SPI controller.
 * @num_chipselect: chipselects are used to distinguish individual
 *	SPI slaves, and are numbered from zero to num_chipselects.
 *	each slave has a chipselect signal, but it&apos;s common that not
 *	every chipselect is connected to a slave.
 * @dma_alignment: SPI controller constraint on DMA buffers alignment.
 * @mode_bits: flags understood by this controller driver
 * @bits_per_word_mask: A mask indicating which values of bits_per_word are
 *	supported by the driver. Bit n indicates that a bits_per_word n+1 is
 *	supported. If set, the SPI core will reject any transfer with an
 *	unsupported bits_per_word. If not set, this value is simply ignored,
 *	and it&apos;s up to the individual driver to perform any validation.
 * @min_speed_hz: Lowest supported transfer speed
 * @max_speed_hz: Highest supported transfer speed
 * @flags: other constraints relevant to this driver
 * @slave: indicates that this is an SPI slave controller
 * @max_transfer_size: function that returns the max transfer size for
 *	a &amp;spi_device; may be %NULL, so the default %SIZE_MAX will be used.
 * @max_message_size: function that returns the max message size for
 *	a &amp;spi_device; may be %NULL, so the default %SIZE_MAX will be used.
 * @io_mutex: mutex for physical bus access
 * @bus_lock_spinlock: spinlock for SPI bus locking
 * @bus_lock_mutex: mutex for exclusion of multiple callers
 * @bus_lock_flag: indicates that the SPI bus is locked for exclusive use
 * @setup: updates the device mode and clocking records used by a
 *	device&apos;s SPI controller; protocol code may call this.  This
 *	must fail if an unrecognized or unsupported mode is requested.
 *	It&apos;s always safe to call this unless transfers are pending on
 *	the device whose settings are being modified.
 * @transfer: adds a message to the controller&apos;s transfer queue.
 * @cleanup: frees controller-specific state
 * @can_dma: determine whether this controller supports DMA
 * @queued: whether this controller is providing an internal message queue
 * @kworker: thread struct for message pump
 * @kworker_task: pointer to task for message pump kworker thread
 * @pump_messages: work struct for scheduling work to the message pump
 * @queue_lock: spinlock to syncronise access to message queue
 * @queue: message queue
 * @idling: the device is entering idle state
 * @cur_msg: the currently in-flight message
 * @cur_msg_prepared: spi_prepare_message was called for the currently
 *                    in-flight message
 * @cur_msg_mapped: message has been mapped for DMA
 * @xfer_completion: used by core transfer_one_message()
 * @busy: message pump is busy
 * @running: message pump is running
 * @rt: whether this queue is set to run as a realtime task
 * @auto_runtime_pm: the core should ensure a runtime PM reference is held
 *                   while the hardware is prepared, using the parent
 *                   device for the spidev
 * @max_dma_len: Maximum length of a DMA transfer for the device.
 * @prepare_transfer_hardware: a message will soon arrive from the queue
 *	so the subsystem requests the driver to prepare the transfer hardware
 *	by issuing this call
 * @transfer_one_message: the subsystem calls the driver to transfer a single
 *	message while queuing transfers that arrive in the meantime. When the
 *	driver is finished with this message, it must call
 *	spi_finalize_current_message() so the subsystem can issue the next
 *	message
 * @unprepare_transfer_hardware: there are currently no more messages on the
 *	queue so the subsystem notifies the driver that it may relax the
 *	hardware by issuing this call
 * @set_cs: set the logic level of the chip select line.  May be called
 *          from interrupt context.
 * @prepare_message: set up the controller to transfer a single message,
 *                   for example doing DMA mapping.  Called from threaded
 *                   context.
 * @transfer_one: transfer a single spi_transfer.
 *                  - return 0 if the transfer is finished,
 *                  - return 1 if the transfer is still in progress. When
 *                    the driver is finished with this transfer it must
 *                    call spi_finalize_current_transfer() so the subsystem
 *                    can issue the next transfer. Note: transfer_one and
 *                    transfer_one_message are mutually exclusive; when both
 *                    are set, the generic subsystem does not call your
 *                    transfer_one callback.
 * @handle_err: the subsystem calls the driver to handle an error that occurs
 *		in the generic implementation of transfer_one_message().
 * @unprepare_message: undo any work done by prepare_message().
 * @slave_abort: abort the ongoing transfer request on an SPI slave controller
 * @spi_flash_read: to support spi-controller hardwares that provide
 *                  accelerated interface to read from flash devices.
 * @spi_flash_can_dma: analogous to can_dma() interface, but for
 *		       controllers implementing spi_flash_read.
 * @flash_read_supported: spi device supports flash read
 * @cs_gpios: Array of GPIOs to use as chip select lines; one per CS
 *	number. Any individual value may be -ENOENT for CS lines that
 *	are not GPIOs (driven by the SPI controller itself).
 * @statistics: statistics for the spi_controller
 * @dma_tx: DMA transmit channel
 * @dma_rx: DMA receive channel
 * @dummy_rx: dummy receive buffer for full-duplex devices
 * @dummy_tx: dummy transmit buffer for full-duplex devices
 * @fw_translate_cs: If the boot firmware uses different numbering scheme
 *	what Linux expects, this optional hook can be used to translate
 *	between the two.
 *
 * Each SPI controller can communicate with one or more @spi_device
 * children.  These make a small bus, sharing MOSI, MISO and SCK signals
 * but not chip select signals.  Each device may be configured to use a
 * different clock rate, since those shared signals are ignored unless
 * the chip is selected.
 *
 * The driver for an SPI controller manages access to those devices through
 * a queue of spi_message transactions, copying data between CPU memory and
 * an SPI slave device.  For each such message it queues, it calls the
 * message&apos;s completion function when the transaction completes.
 */</doc>
<mbr r='spi_controller::dev' o='0' t='struct device'/>
<mbr r='spi_controller::list' o='3776' t='struct list_head'/>
<mbr r='spi_controller::bus_num' o='3904' t='s16'/>
<mbr r='spi_controller::num_chipselect' o='3920' t='u16'/>
<mbr r='spi_controller::dma_alignment' o='3936' t='u16'/>
<mbr r='spi_controller::mode_bits' o='3952' t='u16'/>
<mbr r='spi_controller::bits_per_word_mask' o='3968' t='u32'/>
<mbr r='spi_controller::min_speed_hz' o='4000' t='u32'/>
<mbr r='spi_controller::max_speed_hz' o='4032' t='u32'/>
<mbr r='spi_controller::flags' o='4064' t='u16'/>
<mbr r='spi_controller::slave' o='4080' t='bool'/>
<mbr r='spi_controller::max_transfer_size' o='4096' t='size_t (*)(struct spi_device *)'/>
<mbr r='spi_controller::max_message_size' o='4160' t='size_t (*)(struct spi_device *)'/>
<mbr r='spi_controller::io_mutex' o='4224' t='struct mutex'/>
<mbr r='spi_controller::bus_lock_spinlock' o='4480' t='spinlock_t'/>
<mbr r='spi_controller::bus_lock_mutex' o='4544' t='struct mutex'/>
<mbr r='spi_controller::bus_lock_flag' o='4800' t='bool'/>
<mbr r='spi_controller::setup' o='4864' t='int (*)(struct spi_device *)'/>
<mbr r='spi_controller::transfer' o='4928' t='int (*)(struct spi_device *, struct spi_message *)'/>
<mbr r='spi_controller::cleanup' o='4992' t='void (*)(struct spi_device *)'/>
<mbr r='spi_controller::can_dma' o='5056' t='bool (*)(struct spi_controller *, struct spi_device *, struct spi_transfer *)'/>
<mbr r='spi_controller::queued' o='5120' t='bool'/>
<mbr r='spi_controller::kworker' o='5184' t='struct kthread_worker'/>
<mbr r='spi_controller::kworker_task' o='5632' t='struct task_struct *'/>
<mbr r='spi_controller::pump_messages' o='5696' t='struct kthread_work'/>
<mbr r='spi_controller::queue_lock' o='6016' t='spinlock_t'/>
<mbr r='spi_controller::queue' o='6080' t='struct list_head'/>
<mbr r='spi_controller::cur_msg' o='6208' t='struct spi_message *'/>
<mbr r='spi_controller::idling' o='6272' t='bool'/>
<mbr r='spi_controller::busy' o='6280' t='bool'/>
<mbr r='spi_controller::running' o='6288' t='bool'/>
<mbr r='spi_controller::rt' o='6296' t='bool'/>
<mbr r='spi_controller::auto_runtime_pm' o='6304' t='bool'/>
<mbr r='spi_controller::cur_msg_prepared' o='6312' t='bool'/>
<mbr r='spi_controller::cur_msg_mapped' o='6320' t='bool'/>
<mbr r='spi_controller::xfer_completion' o='6336' t='struct completion'/>
<mbr r='spi_controller::max_dma_len' o='6592' t='size_t'/>
<mbr r='spi_controller::prepare_transfer_hardware' o='6656' t='int (*)(struct spi_controller *)'/>
<mbr r='spi_controller::transfer_one_message' o='6720' t='int (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::unprepare_transfer_hardware' o='6784' t='int (*)(struct spi_controller *)'/>
<mbr r='spi_controller::prepare_message' o='6848' t='int (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::unprepare_message' o='6912' t='int (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::slave_abort' o='6976' t='int (*)(struct spi_controller *)'/>
<mbr r='spi_controller::spi_flash_read' o='7040' t='int (*)(struct spi_device *, struct spi_flash_read_message *)'/>
<mbr r='spi_controller::spi_flash_can_dma' o='7104' t='bool (*)(struct spi_device *, struct spi_flash_read_message *)'/>
<mbr r='spi_controller::flash_read_supported' o='7168' t='bool (*)(struct spi_device *)'/>
<mbr r='spi_controller::set_cs' o='7232' t='void (*)(struct spi_device *, bool)'/>
<mbr r='spi_controller::transfer_one' o='7296' t='int (*)(struct spi_controller *, struct spi_device *, struct spi_transfer *)'/>
<mbr r='spi_controller::handle_err' o='7360' t='void (*)(struct spi_controller *, struct spi_message *)'/>
<mbr r='spi_controller::cs_gpios' o='7424' t='int *'/>
<mbr r='spi_controller::statistics' o='7488' t='struct spi_statistics'/>
<mbr r='spi_controller::dma_tx' o='9344' t='struct dma_chan *'/>
<mbr r='spi_controller::dma_rx' o='9408' t='struct dma_chan *'/>
<mbr r='spi_controller::dummy_rx' o='9472' t='void *'/>
<mbr r='spi_controller::dummy_tx' o='9536' t='void *'/>
<mbr r='spi_controller::fw_translate_cs' o='9600' t='int (*)(struct spi_controller *, unsigned int)'/>
