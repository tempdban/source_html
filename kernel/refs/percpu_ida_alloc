<dec f='linux-4.18.y/include/linux/percpu_ida.h' l='66' type='int percpu_ida_alloc(struct percpu_ida * pool, int state)'/>
<def f='linux-4.18.y/lib/percpu_ida.c' l='133' ll='193' type='int percpu_ida_alloc(struct percpu_ida * pool, int state)'/>
<dec f='linux-4.18.y/lib/percpu_ida.c' l='194' type='int percpu_ida_alloc(struct percpu_ida * , int )'/>
<use f='linux-4.18.y/lib/percpu_ida.c' l='194' c='percpu_ida_alloc'/>
<use f='linux-4.18.y/lib/percpu_ida.c' l='194' u='a'/>
<use f='linux-4.18.y/lib/percpu_ida.c' l='194' u='a'/>
<doc f='linux-4.18.y/lib/percpu_ida.c' l='115'>/**
 * percpu_ida_alloc - allocate a tag
 * @pool: pool to allocate from
 * @state: task state for prepare_to_wait
 *
 * Returns a tag - an integer in the range [0..nr_tags) (passed to
 * tag_pool_init()), or otherwise -ENOSPC on allocation failure.
 *
 * Safe to be called from interrupt context (assuming it isn&apos;t passed
 * TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, of course).
 *
 * @gfp indicates whether or not to wait until a free id is available (it&apos;s not
 * used for internal memory allocations); thus if passed __GFP_RECLAIM we may sleep
 * however long it takes until another thread frees an id (same semantics as a
 * mempool).
 *
 * Will not fail if passed TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE.
 */</doc>
