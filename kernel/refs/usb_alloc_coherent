<dec f='linux-4.18.y/include/linux/usb.h' l='1753' type='void * usb_alloc_coherent(struct usb_device * dev, size_t size, gfp_t mem_flags, dma_addr_t * dma)'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='848' u='c' c='hid_alloc_buffers'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='850' u='c' c='hid_alloc_buffers'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='853' u='c' c='hid_alloc_buffers'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='1111' u='c' c='acm_write_buffers_alloc'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='1350' u='c' c='acm_probe'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='1366' u='c' c='acm_probe'/>
<use f='linux-4.18.y/drivers/usb/core/devio.c' l='226' u='c' c='usbdev_mmap'/>
<def f='linux-4.18.y/drivers/usb/core/usb.c' l='884' ll='890' type='void * usb_alloc_coherent(struct usb_device * dev, size_t size, gfp_t mem_flags, dma_addr_t * dma)'/>
<dec f='linux-4.18.y/drivers/usb/core/usb.c' l='891' type='void * usb_alloc_coherent(struct usb_device * , size_t , gfp_t , dma_addr_t * )'/>
<use f='linux-4.18.y/drivers/usb/core/usb.c' l='891' c='usb_alloc_coherent'/>
<use f='linux-4.18.y/drivers/usb/core/usb.c' l='891' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/usb.c' l='891' u='a'/>
<doc f='linux-4.18.y/drivers/usb/core/usb.c' l='861'>/**
 * usb_alloc_coherent - allocate dma-consistent buffer for URB_NO_xxx_DMA_MAP
 * @dev: device the buffer will be used with
 * @size: requested buffer size
 * @mem_flags: affect whether allocation may block
 * @dma: used to return DMA address of buffer
 *
 * Return: Either null (indicating no buffer could be allocated), or the
 * cpu-space pointer to a buffer that may be used to perform DMA to the
 * specified device.  Such cpu-space buffers are returned along with the DMA
 * address (through the pointer provided).
 *
 * Note:
 * These buffers are used with URB_NO_xxx_DMA_MAP set in urb-&gt;transfer_flags
 * to avoid behaviors like using &quot;DMA bounce buffers&quot;, or thrashing IOMMU
 * hardware during URB completion/resubmit.  The implementation varies between
 * platforms, depending on details of how DMA will work to this device.
 * Using these buffers also eliminates cacheline sharing problems on
 * architectures where CPU caches are not DMA-coherent.  On systems without
 * bus-snooping caches, these buffers are uncached.
 *
 * When the buffer is no longer used, free it with usb_free_coherent().
 */</doc>
<use f='linux-4.18.y/drivers/usb/storage/usb.c' l='462' u='c' c='associate_dev'/>
