<def f='linux-4.18.y/include/linux/regmap.h' l='1091' ll='1121'/>
<size>96</size>
<doc f='linux-4.18.y/include/linux/regmap.h' l='1050'>/**
 * struct regmap_irq_chip - Description of a generic regmap irq_chip.
 *
 * @name:        Descriptive name for IRQ controller.
 *
 * @status_base: Base status register address.
 * @mask_base:   Base mask register address.
 * @mask_writeonly: Base mask register is write only.
 * @unmask_base:  Base unmask register address. for chips who have
 *                separate mask and unmask registers
 * @ack_base:    Base ack address. If zero then the chip is clear on read.
 *               Using zero value is possible with @use_ack bit.
 * @wake_base:   Base address for wake enables.  If zero unsupported.
 * @type_base:   Base address for irq type.  If zero unsupported.
 * @irq_reg_stride:  Stride to use for chips where registers are not contiguous.
 * @init_ack_masked: Ack all masked interrupts once during initalization.
 * @mask_invert: Inverted mask register: cleared bits are masked out.
 * @use_ack:     Use @ack register even if it is zero.
 * @ack_invert:  Inverted ack register: cleared bits for ack.
 * @wake_invert: Inverted wake register: cleared bits are wake enabled.
 * @type_invert: Invert the type flags.
 * @runtime_pm:  Hold a runtime PM lock on the device when accessing it.
 *
 * @num_regs:    Number of registers in each control bank.
 * @irqs:        Descriptors for individual IRQs.  Interrupt numbers are
 *               assigned based on the index in the array of the interrupt.
 * @num_irqs:    Number of descriptors.
 * @num_type_reg:    Number of type registers.
 * @type_reg_stride: Stride to use for chips where type registers are not
 *			contiguous.
 * @handle_pre_irq:  Driver specific callback to handle interrupt from device
 *		     before regmap_irq_handler process the interrupts.
 * @handle_post_irq: Driver specific callback to handle interrupt from device
 *		     after handling the interrupts in regmap_irq_handler().
 * @irq_drv_data:    Driver specific IRQ data which is passed as parameter when
 *		     driver specific pre/post interrupt handler is called.
 *
 * This is not intended to handle every possible interrupt controller, but
 * it should handle a substantial proportion of those that are found in the
 * wild.
 */</doc>
<mbr r='regmap_irq_chip::name' o='0' t='const char *'/>
<mbr r='regmap_irq_chip::status_base' o='64' t='unsigned int'/>
<mbr r='regmap_irq_chip::mask_base' o='96' t='unsigned int'/>
<mbr r='regmap_irq_chip::unmask_base' o='128' t='unsigned int'/>
<mbr r='regmap_irq_chip::ack_base' o='160' t='unsigned int'/>
<mbr r='regmap_irq_chip::wake_base' o='192' t='unsigned int'/>
<mbr r='regmap_irq_chip::type_base' o='224' t='unsigned int'/>
<mbr r='regmap_irq_chip::irq_reg_stride' o='256' t='unsigned int'/>
<mbr r='regmap_irq_chip::mask_writeonly' o='288' t='bool'/>
<mbr r='regmap_irq_chip::init_ack_masked' o='289' t='bool'/>
<mbr r='regmap_irq_chip::mask_invert' o='290' t='bool'/>
<mbr r='regmap_irq_chip::use_ack' o='291' t='bool'/>
<mbr r='regmap_irq_chip::ack_invert' o='292' t='bool'/>
<mbr r='regmap_irq_chip::wake_invert' o='293' t='bool'/>
<mbr r='regmap_irq_chip::runtime_pm' o='294' t='bool'/>
<mbr r='regmap_irq_chip::type_invert' o='295' t='bool'/>
<mbr r='regmap_irq_chip::num_regs' o='320' t='int'/>
<mbr r='regmap_irq_chip::irqs' o='384' t='const struct regmap_irq *'/>
<mbr r='regmap_irq_chip::num_irqs' o='448' t='int'/>
<mbr r='regmap_irq_chip::num_type_reg' o='480' t='int'/>
<mbr r='regmap_irq_chip::type_reg_stride' o='512' t='unsigned int'/>
<mbr r='regmap_irq_chip::handle_pre_irq' o='576' t='int (*)(void *)'/>
<mbr r='regmap_irq_chip::handle_post_irq' o='640' t='int (*)(void *)'/>
<mbr r='regmap_irq_chip::irq_drv_data' o='704' t='void *'/>
