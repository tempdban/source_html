<dec f='linux-4.18.y/include/linux/fb.h' l='818' type='int fb_find_mode(struct fb_var_screeninfo * var, struct fb_info * info, const char * mode_option, const struct fb_videomode * db, unsigned int dbsize, const struct fb_videomode * default_mode, unsigned int default_bpp)'/>
<def f='linux-4.18.y/drivers/video/fbdev/core/modedb.c' l='672' ll='894' type='int fb_find_mode(struct fb_var_screeninfo * var, struct fb_info * info, const char * mode_option, const struct fb_videomode * db, unsigned int dbsize, const struct fb_videomode * default_mode, unsigned int default_bpp)'/>
<dec f='linux-4.18.y/drivers/video/fbdev/core/modedb.c' l='1263' type='int fb_find_mode(struct fb_var_screeninfo * , struct fb_info * , const char * , const struct fb_videomode * , unsigned int , const struct fb_videomode * , unsigned int )'/>
<use f='linux-4.18.y/drivers/video/fbdev/core/modedb.c' l='1263' c='fb_find_mode'/>
<use f='linux-4.18.y/drivers/video/fbdev/core/modedb.c' l='1263' u='a'/>
<use f='linux-4.18.y/drivers/video/fbdev/core/modedb.c' l='1263' u='a'/>
<doc f='linux-4.18.y/drivers/video/fbdev/core/modedb.c' l='630'>/**
 *     fb_find_mode - finds a valid video mode
 *     @var: frame buffer user defined part of display
 *     @info: frame buffer info structure
 *     @mode_option: string video mode to find
 *     @db: video mode database
 *     @dbsize: size of @db
 *     @default_mode: default video mode to fall back to
 *     @default_bpp: default color depth in bits per pixel
 *
 *     Finds a suitable video mode, starting with the specified mode
 *     in @mode_option with fallback to @default_mode.  If
 *     @default_mode fails, all modes in the video mode database will
 *     be tried.
 *
 *     Valid mode specifiers for @mode_option:
 *
 *     &lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][p][m] or
 *     &lt;name&gt;[-&lt;bpp&gt;][@&lt;refresh&gt;]
 *
 *     with &lt;xres&gt;, &lt;yres&gt;, &lt;bpp&gt; and &lt;refresh&gt; decimal numbers and
 *     &lt;name&gt; a string.
 *
 *      If &apos;M&apos; is present after yres (and before refresh/bpp if present),
 *      the function will compute the timings using VESA(tm) Coordinated
 *      Video Timings (CVT).  If &apos;R&apos; is present after &apos;M&apos;, will compute with
 *      reduced blanking (for flatpanels).  If &apos;i&apos; or &apos;p&apos; are present, compute
 *      interlaced or progressive mode.  If &apos;m&apos; is present, add margins equal
 *      to 1.8% of xres rounded down to 8 pixels, and 1.8% of yres. The chars
 *      &apos;i&apos;, &apos;p&apos; and &apos;m&apos; must be after &apos;M&apos; and &apos;R&apos;. Example:
 *
 *      1024x768MR-8@60m - Reduced blank with margins at 60Hz.
 *
 *     NOTE: The passed struct @var is _not_ cleared!  This allows you
 *     to supply values for e.g. the grayscale and accel_flags fields.
 *
 *     Returns zero for failure, 1 if using specified @mode_option,
 *     2 if using specified @mode_option with an ignored refresh rate,
 *     3 if default mode is used, 4 if fall back to any valid mode.
 *
 */</doc>
