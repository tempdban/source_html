<dec f='linux-4.18.y/fs/ntfs/inode.h' l='277' type='struct inode * ntfs_index_iget(struct inode * base_vi, ntfschar * name, u32 name_len)'/>
<def f='linux-4.18.y/fs/ntfs/inode.c' l='285' ll='319' type='struct inode * ntfs_index_iget(struct inode * base_vi, ntfschar * name, u32 name_len)'/>
<doc f='linux-4.18.y/fs/ntfs/inode.c' l='266'>/**
 * ntfs_index_iget - obtain a struct inode corresponding to an index
 * @base_vi:	vfs base inode containing the index related attributes
 * @name:	Unicode name of the index
 * @name_len:	length of @name in Unicode characters
 *
 * Obtain the (fake) struct inode corresponding to the index specified by @name
 * and @name_len, which is present in the base mft record specified by the vfs
 * inode @base_vi.
 *
 * If the index inode is in the cache, it is just returned with an increased
 * reference count.  Otherwise, a new struct inode is allocated and
 * initialized, and finally ntfs_read_locked_index_inode() is called to read
 * the index related attributes and fill in the inode structure.
 *
 * Return the struct inode of the index inode on success. Check the return
 * value with IS_ERR() and if true, the function failed and the error code is
 * obtained from PTR_ERR().
 */</doc>
<use f='linux-4.18.y/fs/ntfs/super.c' l='1415' u='c' c='load_and_init_quota'/>
