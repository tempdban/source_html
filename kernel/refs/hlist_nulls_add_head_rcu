<def f='linux-4.14.y/include/linux/rculist_nulls.h' l='91' ll='101' type='void hlist_nulls_add_head_rcu(struct hlist_nulls_node * n, struct hlist_nulls_head * h)'/>
<use f='linux-4.14.y/include/net/sock.h' l='683' u='c' c='__sk_nulls_add_node_rcu'/>
<doc f='linux-4.14.y/include/linux/rculist_nulls.h' l='72'>/**
 * hlist_nulls_add_head_rcu
 * @n: the element to add to the hash list.
 * @h: the list to add to.
 *
 * Description:
 * Adds the specified element to the specified hlist_nulls,
 * while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_nulls_add_head_rcu()
 * or hlist_nulls_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_nulls_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.  Regardless of the type of CPU, the
 * list-traversal primitive must be guarded by rcu_read_lock().
 */</doc>
<use f='linux-4.14.y/net/ipv4/inet_timewait_sock.c' l='86' u='c' c='inet_twsk_add_node_rcu'/>
<use f='linux-4.14.y/net/netfilter/nf_conntrack_core.c' l='610' u='c' c='__nf_conntrack_hash_insert'/>
<use f='linux-4.14.y/net/netfilter/nf_conntrack_core.c' l='612' u='c' c='__nf_conntrack_hash_insert'/>
<use f='linux-4.14.y/net/netfilter/nf_conntrack_core.c' l='1925' u='c' c='nf_conntrack_hash_resize'/>
<def f='linux-4.14.y/include/linux/rculist_nulls.h' l='91' ll='101' type='void hlist_nulls_add_head_rcu(struct hlist_nulls_node * n, struct hlist_nulls_head * h)'/>
<use f='linux-4.14.y/include/net/sock.h' l='683' u='c' c='__sk_nulls_add_node_rcu'/>
<doc f='linux-4.14.y/include/linux/rculist_nulls.h' l='72'>/**
 * hlist_nulls_add_head_rcu
 * @n: the element to add to the hash list.
 * @h: the list to add to.
 *
 * Description:
 * Adds the specified element to the specified hlist_nulls,
 * while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_nulls_add_head_rcu()
 * or hlist_nulls_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_nulls_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.  Regardless of the type of CPU, the
 * list-traversal primitive must be guarded by rcu_read_lock().
 */</doc>
<use f='linux-4.14.y/net/ipv4/inet_timewait_sock.c' l='86' u='c' c='inet_twsk_add_node_rcu'/>
<use f='linux-4.14.y/net/netfilter/nf_conntrack_core.c' l='610' u='c' c='__nf_conntrack_hash_insert'/>
<use f='linux-4.14.y/net/netfilter/nf_conntrack_core.c' l='612' u='c' c='__nf_conntrack_hash_insert'/>
<use f='linux-4.14.y/net/netfilter/nf_conntrack_core.c' l='1925' u='c' c='nf_conntrack_hash_resize'/>
