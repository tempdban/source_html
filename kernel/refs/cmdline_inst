<def f='linux-4.18.y/lib/librte_cmdline/cmdline_parse.h' l='131' ll='137'/>
<size>24</size>
<doc f='linux-4.18.y/lib/librte_cmdline/cmdline_parse.h' l='75'>/**
 * Store a instruction, which is a pointer to a callback function and
 * its parameter that is called when the instruction is parsed, a help
 * string, and a list of token composing this instruction.
 *
 * When no tokens are defined (tokens[0] == NULL), they are retrieved
 * dynamically by calling f() as follows:
 *
 * @code
 *
 * f((struct cmdline_token_hdr **)&amp;token_p,
 *   NULL,
 *   (struct cmdline_token_hdr **)&amp;inst-&gt;tokens[num]);
 *
 * @endcode
 *
 * The address of the resulting token is expected at the location pointed by
 * the first argument. Can be set to NULL to end the list.
 *
 * The cmdline argument (struct cmdline *) is always NULL.
 *
 * The last argument points to the inst-&gt;tokens[] entry to retrieve, which
 * is not necessarily inside allocated memory and should neither be read nor
 * written. Its sole purpose is to deduce the token entry index of interest
 * as described in the example below.
 *
 * Note about constraints:
 *
 * - Only the address of these tokens is dynamic, their storage should be
 *   static like normal tokens.
 * - Dynamic token lists that need to maintain an internal context (e.g. in
 *   order to determine the next token) must store it statically also. This
 *   context must be reinitialized when the first token is requested, that
 *   is, when &amp;inst-&gt;tokens[0] is provided as the third argument.
 * - Dynamic token lists must be NULL-terminated to generate usable
 *   commands.
 *
 * @code
 *
 * // Assuming first and third arguments are respectively named &quot;token_p&quot;
 * // and &quot;token&quot;:
 *
 * int index = token - inst-&gt;tokens;
 *
 * if (!index) {
 *     [...] // Clean up internal context if any.
 * }
 * [...] // Then set up dyn_token according to index.
 *
 * if (no_more_tokens)
 *     *token_p = NULL;
 * else
 *     *token_p = &amp;dyn_token;
 *
 * @endcode
 */</doc>
<mbr r='cmdline_inst::f' o='0' t='void (*)(void *, struct cmdline *, void *)'/>
<mbr r='cmdline_inst::data' o='64' t='void *'/>
<mbr r='cmdline_inst::help_str' o='128' t='const char *'/>
<mbr r='cmdline_inst::tokens' o='192' t='cmdline_parse_token_hdr_t *[]'/>
