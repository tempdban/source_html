<def f='linux-4.14.y/include/linux/skbuff.h' l='1619' ll='1627' type='struct sk_buff * skb_peek_tail(const struct sk_buff_head * list_)'/>
<use f='linux-4.14.y/include/linux/skbuff.h' l='1879' u='c' c='__skb_dequeue_tail'/>
<doc f='linux-4.14.y/include/linux/skbuff.h' l='1606'>/**
 *	skb_peek_tail - peek at the tail of an &amp;sk_buff_head
 *	@list_: list to peek at
 *
 *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */</doc>
<use f='linux-4.14.y/include/net/tcp.h' l='1636' u='c' c='tcp_write_queue_tail'/>
<use f='linux-4.14.y/net/core/neighbour.c' l='901' u='c' c='neigh_probe'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1066' u='c' c='sock_zerocopy_callback'/>
<use f='linux-4.14.y/net/core/sock.c' l='2303' u='c' c='sk_wait_data'/>
<use f='linux-4.14.y/net/core/sock.c' l='2303' u='c' c='sk_wait_data'/>
<use f='linux-4.14.y/net/ipv4/ip_output.c' l='883' u='c' c='__ip_append_data'/>
<use f='linux-4.14.y/net/ipv4/ip_output.c' l='1222' u='c' c='ip_append_page'/>
<use f='linux-4.14.y/net/ipv4/tcp.c' l='1833' u='c' c='tcp_recvmsg'/>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='4396' u='c' c='tcp_ofo_queue'/>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='4582' u='c' c='tcp_queue_rcv'/>
<use f='linux-4.14.y/net/unix/af_unix.c' l='1988' u='c' c='unix_stream_sendpage'/>
<use f='linux-4.14.y/net/unix/af_unix.c' l='2204' u='c' c='unix_stream_data_wait'/>
