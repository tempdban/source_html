<def f='linux-4.18.y/include/linux/skbuff.h' l='1618' ll='1626' type='struct sk_buff * skb_peek_tail(const struct sk_buff_head * list_)'/>
<use f='linux-4.18.y/include/linux/skbuff.h' l='1878' u='c' c='__skb_dequeue_tail'/>
<doc f='linux-4.18.y/include/linux/skbuff.h' l='1605'>/**
 *	skb_peek_tail - peek at the tail of an &amp;sk_buff_head
 *	@list_: list to peek at
 *
 *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the tail element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */</doc>
<use f='linux-4.18.y/include/net/tcp.h' l='1612' u='c' c='tcp_write_queue_tail'/>
<use f='linux-4.18.y/net/core/neighbour.c' l='904' u='c' c='neigh_probe'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='1065' u='c' c='sock_zerocopy_callback'/>
<use f='linux-4.18.y/net/core/sock.c' l='2384' u='c' c='sk_wait_data'/>
<use f='linux-4.18.y/net/core/sock.c' l='2384' u='c' c='sk_wait_data'/>
<use f='linux-4.18.y/net/ipv4/ip_output.c' l='885' u='c' c='__ip_append_data'/>
<use f='linux-4.18.y/net/ipv4/ip_output.c' l='1243' u='c' c='ip_append_page'/>
<use f='linux-4.18.y/net/ipv4/tcp.c' l='1994' u='c' c='tcp_recvmsg'/>
<use f='linux-4.18.y/net/ipv4/tcp_input.c' l='4426' u='c' c='tcp_ofo_queue'/>
<use f='linux-4.18.y/net/ipv4/tcp_input.c' l='4605' u='c' c='tcp_queue_rcv'/>
<use f='linux-4.18.y/net/unix/af_unix.c' l='1979' u='c' c='unix_stream_sendpage'/>
<use f='linux-4.18.y/net/unix/af_unix.c' l='2195' u='c' c='unix_stream_data_wait'/>
