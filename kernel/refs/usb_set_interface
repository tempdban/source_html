<dec f='linux-4.14.y/include/linux/usb.h' l='1779' type='int usb_set_interface(struct usb_device * dev, int ifnum, int alternate)'/>
<use f='linux-4.14.y/drivers/usb/core/devio.c' l='1368' u='c' c='proc_setintf'/>
<use f='linux-4.14.y/drivers/usb/core/driver.c' l='354' u='c' c='usb_probe_interface'/>
<use f='linux-4.14.y/drivers/usb/core/driver.c' l='455' u='c' c='usb_unbind_interface'/>
<use f='linux-4.14.y/drivers/usb/core/hub.c' l='1434' u='c' c='hub_configure'/>
<use f='linux-4.14.y/drivers/usb/core/hub.c' l='5570' u='c' c='usb_reset_and_verify_device'/>
<def f='linux-4.14.y/drivers/usb/core/message.c' l='1291' ll='1420' type='int usb_set_interface(struct usb_device * dev, int interface, int alternate)'/>
<dec f='linux-4.14.y/drivers/usb/core/message.c' l='1421' type='int usb_set_interface(struct usb_device * , int , int )'/>
<use f='linux-4.14.y/drivers/usb/core/message.c' l='1421' c='usb_set_interface'/>
<use f='linux-4.14.y/drivers/usb/core/message.c' l='1421' u='a'/>
<use f='linux-4.14.y/drivers/usb/core/message.c' l='1421' u='a'/>
<doc f='linux-4.14.y/drivers/usb/core/message.c' l='1258'>/**
 * usb_set_interface - Makes a particular alternate setting be current
 * @dev: the device whose interface is being updated
 * @interface: the interface being updated
 * @alternate: the setting being chosen.
 * Context: !in_interrupt ()
 *
 * This is used to enable data transfers on interfaces that may not
 * be enabled by default.  Not all devices support such configurability.
 * Only the driver bound to an interface may change its setting.
 *
 * Within any given configuration, each interface may have several
 * alternative settings.  These are often used to control levels of
 * bandwidth consumption.  For example, the default setting for a high
 * speed interrupt endpoint may not send more than 64 bytes per microframe,
 * while interrupt transfers of up to 3KBytes per microframe are legal.
 * Also, isochronous endpoints may never be part of an
 * interface&apos;s default setting.  To access such bandwidth, alternate
 * interface settings must be made current.
 *
 * Note that in the Linux USB subsystem, bandwidth associated with
 * an endpoint in a given alternate setting is not reserved until an URB
 * is submitted that needs that bandwidth.  Some other operating systems
 * allocate bandwidth early, when a configuration is chosen.
 *
 * This call is synchronous, and may not be used in an interrupt context.
 * Also, drivers must not change altsettings while urbs are scheduled for
 * endpoints in that interface; all such urbs must first be completed
 * (perhaps forced by unlinking).
 *
 * Return: Zero on success, or else the status code returned by the
 * underlying usb_control_msg() call.
 */</doc>
