<dec f='linux-4.18.y/include/linux/fs.h' l='3125' type='int __generic_block_fiemap(struct inode * inode, struct fiemap_extent_info * fieinfo, loff_t start, loff_t len, get_block_t * get_block)'/>
<def f='linux-4.18.y/fs/ioctl.c' l='280' ll='424' type='int __generic_block_fiemap(struct inode * inode, struct fiemap_extent_info * fieinfo, loff_t start, loff_t len, get_block_t * get_block)'/>
<dec f='linux-4.18.y/fs/ioctl.c' l='425' type='int __generic_block_fiemap(struct inode * , struct fiemap_extent_info * , loff_t , loff_t , get_block_t * )'/>
<use f='linux-4.18.y/fs/ioctl.c' l='425' c='__generic_block_fiemap'/>
<use f='linux-4.18.y/fs/ioctl.c' l='425' u='a'/>
<use f='linux-4.18.y/fs/ioctl.c' l='425' u='a'/>
<use f='linux-4.18.y/fs/ioctl.c' l='445' u='c' c='generic_block_fiemap'/>
<doc f='linux-4.18.y/fs/ioctl.c' l='260'>/**
 * __generic_block_fiemap - FIEMAP for block based inodes (no locking)
 * @inode: the inode to map
 * @fieinfo: the fiemap info struct that will be passed back to userspace
 * @start: where to start mapping in the inode
 * @len: how much space to map
 * @get_block: the fs&apos;s get_block function
 *
 * This does FIEMAP for block based inodes.  Basically it will just loop
 * through get_block until we hit the number of extents we want to map, or we
 * go past the end of the file and hit a hole.
 *
 * If it is possible to have data blocks beyond a hole past @inode-&gt;i_size, then
 * please do not use this function, it will stop at the first unmapped block
 * beyond i_size.
 *
 * If you use this function directly, you need to do your own locking. Use
 * generic_block_fiemap if you want the locking done for you.
 */</doc>
