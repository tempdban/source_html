<dec f='linux-4.14.y/fs/ext4/ext4.h' l='2519' type='int ext4_ind_map_blocks(handle_t * handle, struct inode * inode, struct ext4_map_blocks * map, int flags)'/>
<doc f='linux-4.14.y/fs/ext4/ext4.h' l='2518'>/* indirect.c */</doc>
<def f='linux-4.14.y/fs/ext4/indirect.c' l='515' ll='656' type='int ext4_ind_map_blocks(handle_t * handle, struct inode * inode, struct ext4_map_blocks * map, int flags)'/>
<doc f='linux-4.14.y/fs/ext4/indirect.c' l='487'>/*
 * The ext4_ind_map_blocks() function handles non-extents inodes
 * (i.e., using the traditional indirect/double-indirect i_blocks
 * scheme) for ext4_map_blocks().
 *
 * Allocation strategy is simple: if we have to allocate something, we will
 * have to go the whole way to leaf. So let&apos;s do it before attaching anything
 * to tree, set linkage between the newborn blocks, write them if sync is
 * required, recheck the path, free and repeat if check fails, otherwise
 * set the last missing link (that will protect us from any truncate-generated
 * removals - all blocks on the path are immune now) and possibly force the
 * write on the parent block.
 * That has a nice additional property: no special recovery from the failed
 * allocations is needed - we simply release blocks and do not touch anything
 * reachable from inode.
 *
 * `handle&apos; can be NULL if create == 0.
 *
 * return &gt; 0, # of blocks mapped or allocated.
 * return = 0, if plain lookup failed.
 * return &lt; 0, error case.
 *
 * The ext4_ind_get_blocks() function should be called with
 * down_write(&amp;EXT4_I(inode)-&gt;i_data_sem) if allocating filesystem
 * blocks (i.e., flags has EXT4_GET_BLOCKS_CREATE set) or
 * down_read(&amp;EXT4_I(inode)-&gt;i_data_sem) if not allocating file system
 * blocks.
 */</doc>
<use f='linux-4.14.y/fs/ext4/inode.c' l='561' u='c' c='ext4_map_blocks'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='637' u='c' c='ext4_map_blocks'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='1854' u='c' c='ext4_da_map_blocks'/>
