<dec f='linux-4.14.y/include/linux/skbuff.h' l='968' type='struct sk_buff * __alloc_skb(unsigned int size, gfp_t priority, int flags, int node)'/>
<use f='linux-4.14.y/include/linux/skbuff.h' l='975' u='c' c='alloc_skb'/>
<use f='linux-4.14.y/include/linux/skbuff.h' l='1017' u='c' c='alloc_skb_fclone'/>
<def f='linux-4.14.y/net/core/skbuff.c' l='177' ll='253' type='struct sk_buff * __alloc_skb(unsigned int size, gfp_t gfp_mask, int flags, int node)'/>
<dec f='linux-4.14.y/net/core/skbuff.c' l='254' type='struct sk_buff * __alloc_skb(unsigned int , gfp_t , int , int )'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='254' c='__alloc_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='254' u='a'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='254' u='a'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='399' u='c' c='__netdev_alloc_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='466' u='c' c='__napi_alloc_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1344' u='c' c='skb_copy'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1385' u='c' c='__pskb_copy_fclone'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1576' u='c' c='skb_copy_expand'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='3610' u='c' c='skb_segment'/>
<doc f='linux-4.14.y/net/core/skbuff.c' l='160'>/**
 *	__alloc_skb	-	allocate a network buffer
 *	@size: size to allocate
 *	@gfp_mask: allocation mask
 *	@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache
 *		instead of head cache and allocate a cloned (child) skb.
 *		If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for
 *		allocations in case the data is required for writeback
 *	@node: numa node to allocate memory on
 *
 *	Allocate a new &amp;sk_buff. The returned buffer has no headroom and a
 *	tail room of at least size bytes. The object has a reference count
 *	of one. The return is the buffer. On a failure the return is %NULL.
 *
 *	Buffers may only be allocated from interrupts using a @gfp_mask of
 *	%GFP_ATOMIC.
 */</doc>
<dec f='linux-4.14.y/include/linux/skbuff.h' l='968' type='struct sk_buff * __alloc_skb(unsigned int size, gfp_t priority, int flags, int node)'/>
<use f='linux-4.14.y/include/linux/skbuff.h' l='975' u='c' c='alloc_skb'/>
<use f='linux-4.14.y/include/linux/skbuff.h' l='1017' u='c' c='alloc_skb_fclone'/>
<def f='linux-4.14.y/net/core/skbuff.c' l='177' ll='253' type='struct sk_buff * __alloc_skb(unsigned int size, gfp_t gfp_mask, int flags, int node)'/>
<dec f='linux-4.14.y/net/core/skbuff.c' l='254' type='struct sk_buff * __alloc_skb(unsigned int , gfp_t , int , int )'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='254' c='__alloc_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='254' u='a'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='254' u='a'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='399' u='c' c='__netdev_alloc_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='466' u='c' c='__napi_alloc_skb'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1344' u='c' c='skb_copy'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1385' u='c' c='__pskb_copy_fclone'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='1576' u='c' c='skb_copy_expand'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='3610' u='c' c='skb_segment'/>
<doc f='linux-4.14.y/net/core/skbuff.c' l='160'>/**
 *	__alloc_skb	-	allocate a network buffer
 *	@size: size to allocate
 *	@gfp_mask: allocation mask
 *	@flags: If SKB_ALLOC_FCLONE is set, allocate from fclone cache
 *		instead of head cache and allocate a cloned (child) skb.
 *		If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for
 *		allocations in case the data is required for writeback
 *	@node: numa node to allocate memory on
 *
 *	Allocate a new &amp;sk_buff. The returned buffer has no headroom and a
 *	tail room of at least size bytes. The object has a reference count
 *	of one. The return is the buffer. On a failure the return is %NULL.
 *
 *	Buffers may only be allocated from interrupts using a @gfp_mask of
 *	%GFP_ATOMIC.
 */</doc>
