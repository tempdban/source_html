<dec f='linux-4.18.y/include/linux/usb.h' l='1707' type='void usb_kill_urb(struct urb * urb)'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='752' u='c' c='usbhid_close'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='780' u='c' c='usbhid_init_reports'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='782' u='c' c='usbhid_init_reports'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='1211' u='c' c='usbhid_stop'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='1212' u='c' c='usbhid_stop'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='1213' u='c' c='usbhid_stop'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='1428' u='c' c='hid_cease_io'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='1429' u='c' c='hid_cease_io'/>
<use f='linux-4.18.y/drivers/hid/usbhid/hid-core.c' l='1430' u='c' c='hid_cease_io'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='154' u='c' c='acm_kill_urbs'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='156' u='c' c='acm_kill_urbs'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='158' u='c' c='acm_kill_urbs'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='553' u='c' c='acm_softint'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='670' u='c' c='acm_port_activate'/>
<use f='linux-4.18.y/drivers/usb/class/cdc-acm.c' l='671' u='c' c='acm_port_activate'/>
<use f='linux-4.18.y/drivers/usb/core/devio.c' l='638' u='c' c='destroy_async'/>
<use f='linux-4.18.y/drivers/usb/core/devio.c' l='1814' u='c' c='proc_unlinkurb'/>
<use f='linux-4.18.y/drivers/usb/core/hcd.c' l='1933' u='c' c='usb_hcd_flush_endpoint'/>
<use f='linux-4.18.y/drivers/usb/core/hub.c' l='1270' u='c' c='hub_quiesce'/>
<use f='linux-4.18.y/drivers/usb/core/message.c' l='63' u='c' c='usb_start_wait_urb'/>
<def f='linux-4.18.y/drivers/usb/core/urb.c' l='688' ll='699' type='void usb_kill_urb(struct urb * urb)'/>
<dec f='linux-4.18.y/drivers/usb/core/urb.c' l='700' type='void usb_kill_urb(struct urb * )'/>
<use f='linux-4.18.y/drivers/usb/core/urb.c' l='700' c='usb_kill_urb'/>
<use f='linux-4.18.y/drivers/usb/core/urb.c' l='700' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/urb.c' l='700' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/urb.c' l='796' u='c' c='usb_kill_anchored_urbs'/>
<doc f='linux-4.18.y/drivers/usb/core/urb.c' l='661'>/**
 * usb_kill_urb - cancel a transfer request and wait for it to finish
 * @urb: pointer to URB describing a previously submitted request,
 *	may be NULL
 *
 * This routine cancels an in-progress request.  It is guaranteed that
 * upon return all completion handlers will have finished and the URB
 * will be totally idle and available for reuse.  These features make
 * this an ideal way to stop I/O in a disconnect() callback or close()
 * function.  If the request has not already finished or been unlinked
 * the completion handler will see urb-&gt;status == -ENOENT.
 *
 * While the routine is running, attempts to resubmit the URB will fail
 * with error -EPERM.  Thus even if the URB&apos;s completion handler always
 * tries to resubmit, it will not succeed and the URB will become idle.
 *
 * The URB must not be deallocated while this routine is running.  In
 * particular, when a driver calls this routine, it must insure that the
 * completion handler cannot deallocate the URB.
 *
 * This routine may not be used in an interrupt context (such as a bottom
 * half or a completion handler), or when holding a spinlock, or in other
 * situations where the caller can&apos;t schedule().
 *
 * This routine should not be called by a driver after its disconnect
 * method has returned.
 */</doc>
<use f='linux-4.18.y/drivers/usb/storage/transport.c' l='174' u='c' c='usb_stor_msg_common'/>
