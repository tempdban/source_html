<dec f='linux-4.14.y/arch/x86/include/asm/io.h' l='184' type='void * ioremap_uc(resource_size_t offset, unsigned long size)'/>
<def f='linux-4.14.y/arch/x86/mm/ioremap.c' l='267' macro='1' type='void * ioremap_uc(resource_size_t phys_addr, unsigned long size)'/>
<dec f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' type='void * ioremap_uc(resource_size_t , unsigned long )'/>
<use f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' c='ioremap_uc'/>
<use f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' u='a'/>
<use f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' u='a'/>
<doc f='linux-4.14.y/arch/x86/mm/ioremap.c' l='243'>/**
 * ioremap_uc     -   map bus memory into CPU space as strongly uncachable
 * @phys_addr:    bus address of the memory
 * @size:      size of the resource to map
 *
 * ioremap_uc performs a platform specific sequence of operations to
 * make bus memory CPU accessible via the readb/readw/readl/writeb/
 * writew/writel functions and the other mmio helpers. The returned
 * address is not guaranteed to be usable directly as a virtual
 * address.
 *
 * This version of ioremap ensures that the memory is marked with a strong
 * preference as completely uncachable on the CPU when possible. For non-PAT
 * systems this ends up setting page-attribute flags PCD=1, PWT=1. For PAT
 * systems this will set the PAT entry for the pages as strong UC.  This call
 * will honor existing caching rules from things like the PCI bus. Note that
 * there are other caches and buffers on many busses. In particular driver
 * authors should read up on PCI writes.
 *
 * It&apos;s useful if some control registers are in such an area and
 * write combining or read caching is not desirable:
 *
 * Must be freed with iounmap.
 */</doc>
<dec f='linux-4.14.y/arch/x86/include/asm/io.h' l='184' type='void * ioremap_uc(resource_size_t offset, unsigned long size)'/>
<def f='linux-4.14.y/arch/x86/mm/ioremap.c' l='267' macro='1' type='void * ioremap_uc(resource_size_t phys_addr, unsigned long size)'/>
<dec f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' type='void * ioremap_uc(resource_size_t , unsigned long )'/>
<use f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' c='ioremap_uc'/>
<use f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' u='a'/>
<use f='linux-4.14.y/arch/x86/mm/ioremap.c' l='274' macro='1' u='a'/>
<doc f='linux-4.14.y/arch/x86/mm/ioremap.c' l='243'>/**
 * ioremap_uc     -   map bus memory into CPU space as strongly uncachable
 * @phys_addr:    bus address of the memory
 * @size:      size of the resource to map
 *
 * ioremap_uc performs a platform specific sequence of operations to
 * make bus memory CPU accessible via the readb/readw/readl/writeb/
 * writew/writel functions and the other mmio helpers. The returned
 * address is not guaranteed to be usable directly as a virtual
 * address.
 *
 * This version of ioremap ensures that the memory is marked with a strong
 * preference as completely uncachable on the CPU when possible. For non-PAT
 * systems this ends up setting page-attribute flags PCD=1, PWT=1. For PAT
 * systems this will set the PAT entry for the pages as strong UC.  This call
 * will honor existing caching rules from things like the PCI bus. Note that
 * there are other caches and buffers on many busses. In particular driver
 * authors should read up on PCI writes.
 *
 * It&apos;s useful if some control registers are in such an area and
 * write combining or read caching is not desirable:
 *
 * Must be freed with iounmap.
 */</doc>
