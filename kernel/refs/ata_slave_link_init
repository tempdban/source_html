<dec f='linux-4.14.y/include/linux/libata.h' l='1111' type='int ata_slave_link_init(struct ata_port * ap)'/>
<use f='linux-4.14.y/drivers/ata/ata_piix.c' l='1509' u='c' c='piix_init_sidpr'/>
<def f='linux-4.14.y/drivers/ata/libata-core.c' l='6212' ll='6226' type='int ata_slave_link_init(struct ata_port * ap)'/>
<dec f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' type='int ata_slave_link_init(struct ata_port * )'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' c='ata_slave_link_init'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' u='a'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' u='a'/>
<doc f='linux-4.14.y/drivers/ata/libata-core.c' l='6166'>/**
 *	ata_slave_link_init - initialize slave link
 *	@ap: port to initialize slave link for
 *
 *	Create and initialize slave link for @ap.  This enables slave
 *	link handling on the port.
 *
 *	In libata, a port contains links and a link contains devices.
 *	There is single host link but if a PMP is attached to it,
 *	there can be multiple fan-out links.  On SATA, there&apos;s usually
 *	a single device connected to a link but PATA and SATA
 *	controllers emulating TF based interface can have two - master
 *	and slave.
 *
 *	However, there are a few controllers which don&apos;t fit into this
 *	abstraction too well - SATA controllers which emulate TF
 *	interface with both master and slave devices but also have
 *	separate SCR register sets for each device.  These controllers
 *	need separate links for physical link handling
 *	(e.g. onlineness, link speed) but should be treated like a
 *	traditional M/S controller for everything else (e.g. command
 *	issue, softreset).
 *
 *	slave_link is libata&apos;s way of handling this class of
 *	controllers without impacting core layer too much.  For
 *	anything other than physical link handling, the default host
 *	link is used for both master and slave.  For physical link
 *	handling, separate @ap-&gt;slave_link is used.  All dirty details
 *	are implemented inside libata core layer.  From LLD&apos;s POV, the
 *	only difference is that prereset, hardreset and postreset are
 *	called once more for the slave link, so the reset sequence
 *	looks like the following.
 *
 *	prereset(M) -&gt; prereset(S) -&gt; hardreset(M) -&gt; hardreset(S) -&gt;
 *	softreset(M) -&gt; postreset(M) -&gt; postreset(S)
 *
 *	Note that softreset is called only for the master.  Softreset
 *	resets both M/S by definition, so SRST on master should handle
 *	both (the standard method will work just fine).
 *
 *	LOCKING:
 *	Should be called before host is registered.
 *
 *	RETURNS:
 *	0 on success, -errno on failure.
 */</doc>
<dec f='linux-4.14.y/include/linux/libata.h' l='1111' type='int ata_slave_link_init(struct ata_port * ap)'/>
<use f='linux-4.14.y/drivers/ata/ata_piix.c' l='1509' u='c' c='piix_init_sidpr'/>
<def f='linux-4.14.y/drivers/ata/libata-core.c' l='6212' ll='6226' type='int ata_slave_link_init(struct ata_port * ap)'/>
<dec f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' type='int ata_slave_link_init(struct ata_port * )'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' c='ata_slave_link_init'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' u='a'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='7258' u='a'/>
<doc f='linux-4.14.y/drivers/ata/libata-core.c' l='6166'>/**
 *	ata_slave_link_init - initialize slave link
 *	@ap: port to initialize slave link for
 *
 *	Create and initialize slave link for @ap.  This enables slave
 *	link handling on the port.
 *
 *	In libata, a port contains links and a link contains devices.
 *	There is single host link but if a PMP is attached to it,
 *	there can be multiple fan-out links.  On SATA, there&apos;s usually
 *	a single device connected to a link but PATA and SATA
 *	controllers emulating TF based interface can have two - master
 *	and slave.
 *
 *	However, there are a few controllers which don&apos;t fit into this
 *	abstraction too well - SATA controllers which emulate TF
 *	interface with both master and slave devices but also have
 *	separate SCR register sets for each device.  These controllers
 *	need separate links for physical link handling
 *	(e.g. onlineness, link speed) but should be treated like a
 *	traditional M/S controller for everything else (e.g. command
 *	issue, softreset).
 *
 *	slave_link is libata&apos;s way of handling this class of
 *	controllers without impacting core layer too much.  For
 *	anything other than physical link handling, the default host
 *	link is used for both master and slave.  For physical link
 *	handling, separate @ap-&gt;slave_link is used.  All dirty details
 *	are implemented inside libata core layer.  From LLD&apos;s POV, the
 *	only difference is that prereset, hardreset and postreset are
 *	called once more for the slave link, so the reset sequence
 *	looks like the following.
 *
 *	prereset(M) -&gt; prereset(S) -&gt; hardreset(M) -&gt; hardreset(S) -&gt;
 *	softreset(M) -&gt; postreset(M) -&gt; postreset(S)
 *
 *	Note that softreset is called only for the master.  Softreset
 *	resets both M/S by definition, so SRST on master should handle
 *	both (the standard method will work just fine).
 *
 *	LOCKING:
 *	Should be called before host is registered.
 *
 *	RETURNS:
 *	0 on success, -errno on failure.
 */</doc>
