<dec f='linux-4.18.y/include/linux/i2c.h' l='449' type='struct i2c_client * i2c_new_device(struct i2c_adapter * adap, const struct i2c_board_info * info)'/>
<doc f='linux-4.18.y/include/linux/i2c.h' l='444'>/* Add-on boards should register/unregister their devices; e.g. a board
 * with integrated I2C, a config eeprom, sensors, and a codec that&apos;s
 * used in conjunction with the primary hardware.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_encoder_slave.c' l='64' u='c' c='drm_i2c_encoder_init'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-acpi.c' l='182' u='c' c='i2c_acpi_register_device'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-acpi.c' l='420' u='c' c='i2c_acpi_new_device'/>
<def f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='716' ll='790' type='struct i2c_client * i2c_new_device(struct i2c_adapter * adap, const struct i2c_board_info * info)'/>
<dec f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='791' type='struct i2c_client * i2c_new_device(struct i2c_adapter * , const struct i2c_board_info * )'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='791' c='i2c_new_device'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='791' u='a'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='791' u='a'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='863' u='c' c='i2c_new_dummy'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='986' u='c' c='i2c_sysfs_new_device'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='1099' u='c' c='i2c_scan_static_board_info'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='2121' u='c' c='i2c_detect_address'/>
<use f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='2220' u='c' c='i2c_new_probed_device'/>
<doc f='linux-4.18.y/drivers/i2c/i2c-core-base.c' l='700'>/**
 * i2c_new_device - instantiate an i2c device
 * @adap: the adapter managing the device
 * @info: describes one I2C device; bus_num is ignored
 * Context: can sleep
 *
 * Create an i2c device. Binding is handled through driver model
 * probe()/remove() methods.  A driver may be bound to this device when we
 * return from this function, or any later moment (e.g. maybe hotplugging will
 * load the driver module).  This call is not appropriate for use by mainboard
 * initialization logic, which usually runs during an arch_initcall() long
 * before any i2c_adapter could exist.
 *
 * This returns the new i2c client, which may be saved for later use with
 * i2c_unregister_device(); or NULL to indicate an error.
 */</doc>
<use f='linux-4.18.y/drivers/i2c/i2c-core-smbus.c' l='669' u='c' c='i2c_setup_smbus_alert'/>
