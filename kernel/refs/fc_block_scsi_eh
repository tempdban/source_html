<dec f='linux-4.18.y/include/scsi/scsi_transport_fc.h' l='810' type='int fc_block_scsi_eh(struct scsi_cmnd * cmnd)'/>
<def f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3321' ll='3329' type='int fc_block_scsi_eh(struct scsi_cmnd * cmnd)'/>
<dec f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3330' type='int fc_block_scsi_eh(struct scsi_cmnd * )'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3330' c='fc_block_scsi_eh'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3330' u='a'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3330' u='a'/>
<doc f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3307'>/**
 * fc_block_scsi_eh - Block SCSI eh thread for blocked fc_rport
 * @cmnd: SCSI command that scsi_eh is trying to recover
 *
 * This routine can be called from a FC LLD scsi_eh callback. It
 * blocks the scsi_eh thread until the fc_rport leaves the
 * FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is
 * necessary to avoid the scsi_eh failing recovery actions for blocked
 * rports which would lead to offlined SCSI devices.
 *
 * Returns: 0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.
 *	    FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
 *	    passed back to scsi_eh.
 */</doc>
