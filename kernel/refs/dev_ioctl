<dec f='linux-4.18.y/include/linux/netdevice.h' l='3407' type='int dev_ioctl(struct net * net, unsigned int cmd, struct ifreq * ifr, bool * need_copyout)'/>
<def f='linux-4.18.y/net/core/dev_ioctl.c' l='382' ll='524' type='int dev_ioctl(struct net * net, unsigned int cmd, struct ifreq * ifr, bool * need_copyout)'/>
<doc f='linux-4.18.y/net/core/dev_ioctl.c' l='370'>/**
 *	dev_ioctl	-	network device ioctl
 *	@net: the applicable net namespace
 *	@cmd: command to issue
 *	@arg: pointer to a struct ifreq in user space
 *
 *	Issue ioctl functions to devices. This is normally called by the
 *	user space syscall interfaces but can sometimes be useful for
 *	other purposes. The return value is the return from the syscall if
 *	positive or a negative errno code on error.
 */</doc>
<use f='linux-4.18.y/net/socket.c' l='994' u='c' c='sock_do_ioctl'/>
<use f='linux-4.18.y/net/socket.c' l='1029' u='c' c='sock_ioctl'/>
<use f='linux-4.18.y/net/socket.c' l='2896' u='c' c='ethtool_ioctl'/>
<use f='linux-4.18.y/net/socket.c' l='2951' u='c' c='compat_siocwandev'/>
<use f='linux-4.18.y/net/socket.c' l='2973' u='c' c='compat_ifr_data_ioctl'/>
<use f='linux-4.18.y/net/socket.c' l='2994' u='c' c='compat_sioc_ifmap'/>
