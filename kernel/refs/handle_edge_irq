<dec f='linux-4.14.y/include/linux/irq.h' l='568' type='void handle_edge_irq(struct irq_desc * desc)'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/htirq.c' l='100' u='r' c='htirq_domain_alloc'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/io_apic.c' l='931' u='r' c='mp_register_handler'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/io_apic.c' l='1930' u='r' c='lapic_register_intr'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='135'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='135'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='173'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='173'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='221' u='r' c='dmar_msi_init'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='319' u='r' c='hpet_msi_init'/>
<def f='linux-4.14.y/kernel/irq/chip.c' l='726' ll='777' type='void handle_edge_irq(struct irq_desc * desc)'/>
<dec f='linux-4.14.y/kernel/irq/chip.c' l='778' type='void handle_edge_irq(struct irq_desc * )'/>
<use f='linux-4.14.y/kernel/irq/chip.c' l='778' c='handle_edge_irq'/>
<use f='linux-4.14.y/kernel/irq/chip.c' l='778' u='a'/>
<use f='linux-4.14.y/kernel/irq/chip.c' l='778' u='a'/>
<doc f='linux-4.14.y/kernel/irq/chip.c' l='711'>/**
 *	handle_edge_irq - edge type IRQ handler
 *	@desc:	the interrupt description structure for this irq
 *
 *	Interrupt occures on the falling and/or rising edge of a hardware
 *	signal. The occurrence is latched into the irq controller hardware
 *	and must be acked in order to be reenabled. After the ack another
 *	interrupt can happen on the same source even before the first one
 *	is handled by the associated event handler. If this happens it
 *	might be necessary to disable (mask) the interrupt depending on the
 *	controller hardware. This requires to reenable the interrupt inside
 *	of the loop which handles the interrupts which have arrived while
 *	the handler was running. If all pending interrupts are handled, the
 *	loop is left.
 */</doc>
<dec f='linux-4.14.y/include/linux/irq.h' l='568' type='void handle_edge_irq(struct irq_desc * desc)'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/htirq.c' l='100' u='r' c='htirq_domain_alloc'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/io_apic.c' l='931' u='r' c='mp_register_handler'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/io_apic.c' l='1930' u='r' c='lapic_register_intr'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='135'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='135'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='173'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='173'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='221' u='r' c='dmar_msi_init'/>
<use f='linux-4.14.y/arch/x86/kernel/apic/msi.c' l='319' u='r' c='hpet_msi_init'/>
<def f='linux-4.14.y/kernel/irq/chip.c' l='726' ll='777' type='void handle_edge_irq(struct irq_desc * desc)'/>
<dec f='linux-4.14.y/kernel/irq/chip.c' l='778' type='void handle_edge_irq(struct irq_desc * )'/>
<use f='linux-4.14.y/kernel/irq/chip.c' l='778' c='handle_edge_irq'/>
<use f='linux-4.14.y/kernel/irq/chip.c' l='778' u='a'/>
<use f='linux-4.14.y/kernel/irq/chip.c' l='778' u='a'/>
<doc f='linux-4.14.y/kernel/irq/chip.c' l='711'>/**
 *	handle_edge_irq - edge type IRQ handler
 *	@desc:	the interrupt description structure for this irq
 *
 *	Interrupt occures on the falling and/or rising edge of a hardware
 *	signal. The occurrence is latched into the irq controller hardware
 *	and must be acked in order to be reenabled. After the ack another
 *	interrupt can happen on the same source even before the first one
 *	is handled by the associated event handler. If this happens it
 *	might be necessary to disable (mask) the interrupt depending on the
 *	controller hardware. This requires to reenable the interrupt inside
 *	of the loop which handles the interrupts which have arrived while
 *	the handler was running. If all pending interrupts are handled, the
 *	loop is left.
 */</doc>
