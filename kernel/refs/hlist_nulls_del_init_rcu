<def f='linux-4.14.y/include/linux/rculist_nulls.h' l='33' ll='39' type='void hlist_nulls_del_init_rcu(struct hlist_nulls_node * n)'/>
<use f='linux-4.14.y/include/net/sock.h' l='642' u='c' c='__sk_nulls_del_node_init_rcu'/>
<doc f='linux-4.14.y/include/linux/rculist_nulls.h' l='13'>/**
 * hlist_nulls_del_init_rcu - deletes entry from hash list with re-initialization
 * @n: the element to delete from the hash list.
 *
 * Note: hlist_nulls_unhashed() on the node return true after this. It is
 * useful for RCU based read lockfree traversal if the writer side
 * must know if the list entry is still hashed or already unhashed.
 *
 * In particular, it means that we can not poison the forward pointers
 * that may still be used for walking the hash list and we can only
 * zero the pprev pointer so list_unhashed() will return true after
 * this.
 *
 * The caller must take whatever precautions are necessary (such as
 * holding appropriate locks) to avoid racing with another
 * list-mutation primitive, such as hlist_nulls_add_head_rcu() or
 * hlist_nulls_del_rcu(), running on this same list.  However, it is
 * perfectly legal to run concurrently with the _rcu list-traversal
 * primitives, such as hlist_nulls_for_each_entry_rcu().
 */</doc>
<def f='linux-4.14.y/include/linux/rculist_nulls.h' l='33' ll='39' type='void hlist_nulls_del_init_rcu(struct hlist_nulls_node * n)'/>
<use f='linux-4.14.y/include/net/sock.h' l='642' u='c' c='__sk_nulls_del_node_init_rcu'/>
<doc f='linux-4.14.y/include/linux/rculist_nulls.h' l='13'>/**
 * hlist_nulls_del_init_rcu - deletes entry from hash list with re-initialization
 * @n: the element to delete from the hash list.
 *
 * Note: hlist_nulls_unhashed() on the node return true after this. It is
 * useful for RCU based read lockfree traversal if the writer side
 * must know if the list entry is still hashed or already unhashed.
 *
 * In particular, it means that we can not poison the forward pointers
 * that may still be used for walking the hash list and we can only
 * zero the pprev pointer so list_unhashed() will return true after
 * this.
 *
 * The caller must take whatever precautions are necessary (such as
 * holding appropriate locks) to avoid racing with another
 * list-mutation primitive, such as hlist_nulls_add_head_rcu() or
 * hlist_nulls_del_rcu(), running on this same list.  However, it is
 * perfectly legal to run concurrently with the _rcu list-traversal
 * primitives, such as hlist_nulls_for_each_entry_rcu().
 */</doc>
