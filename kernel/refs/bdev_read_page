<dec f='linux-4.18.y/include/linux/blkdev.h' l='1976' type='int bdev_read_page(struct block_device * , sector_t , struct page * )'/>
<def f='linux-4.18.y/fs/block_dev.c' l='657' ll='672' type='int bdev_read_page(struct block_device * bdev, sector_t sector, struct page * page)'/>
<dec f='linux-4.18.y/fs/block_dev.c' l='673' type='int bdev_read_page(struct block_device * , sector_t , struct page * )'/>
<use f='linux-4.18.y/fs/block_dev.c' l='673' c='bdev_read_page'/>
<use f='linux-4.18.y/fs/block_dev.c' l='673' u='a'/>
<use f='linux-4.18.y/fs/block_dev.c' l='673' u='a'/>
<doc f='linux-4.18.y/fs/block_dev.c' l='641'>/**
 * bdev_read_page() - Start reading a page from a block device
 * @bdev: The device to read the page from
 * @sector: The offset on the device to read the page to (need not be aligned)
 * @page: The page to read
 *
 * On entry, the page should be locked.  It will be unlocked when the page
 * has been read.  If the block driver implements rw_page synchronously,
 * that will be true on exit from this function, but it need not be.
 *
 * Errors returned by this function are usually &quot;soft&quot;, eg out of memory, or
 * queue full; callers should try a different route to read this page rather
 * than propagate an error back up the stack.
 *
 * Return: negative errno if an error occurs, 0 if submission was successful.
 */</doc>
<use f='linux-4.18.y/fs/mpage.c' l='282' u='c' c='do_mpage_readpage'/>
<use f='linux-4.18.y/mm/page_io.c' l='377' u='c' c='swap_readpage'/>
