<dec f='linux-4.14.y/include/linux/mmu_notifier.h' l='168' type='void (*)(struct mmu_notifier *, struct mm_struct *, unsigned long, unsigned long)'/>
<use f='linux-4.14.y/drivers/iommu/amd_iommu_v2.c' l='432' u='w'/>
<offset>448</offset>
<doc f='linux-4.14.y/include/linux/mmu_notifier.h' l='148'>/*
	 * invalidate_range() is either called between
	 * invalidate_range_start() and invalidate_range_end() when the
	 * VM has to free pages that where unmapped, but before the
	 * pages are actually freed, or outside of _start()/_end() when
	 * a (remote) TLB is necessary.
	 *
	 * If invalidate_range() is used to manage a non-CPU TLB with
	 * shared page-tables, it not necessary to implement the
	 * invalidate_range_start()/end() notifiers, as
	 * invalidate_range() alread catches the points in time when an
	 * external TLB range needs to be flushed.
	 *
	 * The invalidate_range() function is called under the ptl
	 * spin-lock and not allowed to sleep.
	 *
	 * Note that this function might be called with just a sub-range
	 * of what was passed to invalidate_range_start()/end(), if
	 * called between those functions.
	 */</doc>
<use f='linux-4.14.y/drivers/iommu/intel-svm.c' l='284' u='w'/>
<use f='linux-4.14.y/mm/mmu_notifier.c' l='208' u='r' c='__mmu_notifier_invalidate_range_end'/>
<use f='linux-4.14.y/mm/mmu_notifier.c' l='209' u='r' c='__mmu_notifier_invalidate_range_end'/>
<use f='linux-4.14.y/mm/mmu_notifier.c' l='225' u='r' c='__mmu_notifier_invalidate_range'/>
<use f='linux-4.14.y/mm/mmu_notifier.c' l='226' u='r' c='__mmu_notifier_invalidate_range'/>
