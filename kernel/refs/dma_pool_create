<dec f='linux-4.14.y/include/linux/dmapool.h' l='19' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t allocation)'/>
<use f='linux-4.14.y/drivers/dma/idma64.c' l='504' u='c' c='idma64_alloc_chan_resources'/>
<use f='linux-4.14.y/drivers/dma/ioat/init.c' l='509' u='c' c='ioat_probe'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf.c' l='1310' u='c' c='vmw_cmdbuf_man_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf.c' l='1319' u='c' c='vmw_cmdbuf_man_create'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/e100.c' l='2964' macro='1' u='c'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mbox.c' l='1154' u='c' c='megaraid_mbox_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mbox.c' l='1182' u='c' c='megaraid_mbox_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mbox.c' l='1203' u='c' c='megaraid_mbox_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mm.c' l='943' u='c' c='mraid_mm_register_adp'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mm.c' l='1089' u='c' c='mraid_mm_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_base.c' l='3935' u='c' c='megasas_create_frame_pool'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_base.c' l='3944' u='c' c='megasas_create_frame_pool'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='373' u='c' c='megasas_create_sg_sense_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='378' u='c' c='megasas_create_sg_sense_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='476' u='c' c='megasas_alloc_request_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='506' u='c' c='megasas_alloc_reply_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='559' u='c' c='megasas_alloc_rdpq_fusion'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3447' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3578' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3631' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3655' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3681' u='c' c='_base_allocate_memory_pools'/>
<def f='linux-4.14.y/mm/dmapool.c' l='131' ll='203' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t boundary)'/>
<dec f='linux-4.14.y/mm/dmapool.c' l='204' type='struct dma_pool * dma_pool_create(const char * , struct device * , size_t , size_t , size_t )'/>
<use f='linux-4.14.y/mm/dmapool.c' l='204' c='dma_pool_create'/>
<use f='linux-4.14.y/mm/dmapool.c' l='204' u='a'/>
<use f='linux-4.14.y/mm/dmapool.c' l='204' u='a'/>
<use f='linux-4.14.y/mm/dmapool.c' l='511' u='c' c='dmam_pool_create'/>
<doc f='linux-4.14.y/mm/dmapool.c' l='110'>/**
 * dma_pool_create - Creates a pool of consistent memory blocks, for dma.
 * @name: name of pool, for diagnostics
 * @dev: device that will be doing the DMA
 * @size: size of the blocks in this pool.
 * @align: alignment requirement for blocks; must be a power of two
 * @boundary: returned blocks won&apos;t cross this power of two boundary
 * Context: !in_interrupt()
 *
 * Returns a dma allocation pool with the requested characteristics, or
 * null if one can&apos;t be created.  Given one of these pools, dma_pool_alloc()
 * may be used to allocate memory.  Such memory will all have &quot;consistent&quot;
 * DMA mappings, accessible by the device and its driver without using
 * cache flushing primitives.  The actual size of blocks allocated may be
 * larger than requested because of alignment.
 *
 * If @boundary is nonzero, objects returned from dma_pool_alloc() won&apos;t
 * cross that size boundary.  This is useful for devices which have
 * addressing restrictions on individual DMA transfers, such as not crossing
 * boundaries of 4KBytes.
 */</doc>
<dec f='linux-4.14.y/include/linux/dmapool.h' l='19' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t allocation)'/>
<use f='linux-4.14.y/drivers/dma/idma64.c' l='504' u='c' c='idma64_alloc_chan_resources'/>
<use f='linux-4.14.y/drivers/dma/ioat/init.c' l='509' u='c' c='ioat_probe'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf.c' l='1310' u='c' c='vmw_cmdbuf_man_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf.c' l='1319' u='c' c='vmw_cmdbuf_man_create'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/e100.c' l='2964' macro='1' u='c'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mbox.c' l='1154' u='c' c='megaraid_mbox_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mbox.c' l='1182' u='c' c='megaraid_mbox_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mbox.c' l='1203' u='c' c='megaraid_mbox_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mm.c' l='943' u='c' c='mraid_mm_register_adp'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_mm.c' l='1089' u='c' c='mraid_mm_setup_dma_pools'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_base.c' l='3935' u='c' c='megasas_create_frame_pool'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_base.c' l='3944' u='c' c='megasas_create_frame_pool'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='373' u='c' c='megasas_create_sg_sense_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='378' u='c' c='megasas_create_sg_sense_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='476' u='c' c='megasas_alloc_request_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='506' u='c' c='megasas_alloc_reply_fusion'/>
<use f='linux-4.14.y/drivers/scsi/megaraid/megaraid_sas_fusion.c' l='559' u='c' c='megasas_alloc_rdpq_fusion'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3447' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3578' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3631' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3655' u='c' c='_base_allocate_memory_pools'/>
<use f='linux-4.14.y/drivers/scsi/mpt3sas/mpt3sas_base.c' l='3681' u='c' c='_base_allocate_memory_pools'/>
<def f='linux-4.14.y/mm/dmapool.c' l='131' ll='203' type='struct dma_pool * dma_pool_create(const char * name, struct device * dev, size_t size, size_t align, size_t boundary)'/>
<dec f='linux-4.14.y/mm/dmapool.c' l='204' type='struct dma_pool * dma_pool_create(const char * , struct device * , size_t , size_t , size_t )'/>
<use f='linux-4.14.y/mm/dmapool.c' l='204' c='dma_pool_create'/>
<use f='linux-4.14.y/mm/dmapool.c' l='204' u='a'/>
<use f='linux-4.14.y/mm/dmapool.c' l='204' u='a'/>
<use f='linux-4.14.y/mm/dmapool.c' l='511' u='c' c='dmam_pool_create'/>
<doc f='linux-4.14.y/mm/dmapool.c' l='110'>/**
 * dma_pool_create - Creates a pool of consistent memory blocks, for dma.
 * @name: name of pool, for diagnostics
 * @dev: device that will be doing the DMA
 * @size: size of the blocks in this pool.
 * @align: alignment requirement for blocks; must be a power of two
 * @boundary: returned blocks won&apos;t cross this power of two boundary
 * Context: !in_interrupt()
 *
 * Returns a dma allocation pool with the requested characteristics, or
 * null if one can&apos;t be created.  Given one of these pools, dma_pool_alloc()
 * may be used to allocate memory.  Such memory will all have &quot;consistent&quot;
 * DMA mappings, accessible by the device and its driver without using
 * cache flushing primitives.  The actual size of blocks allocated may be
 * larger than requested because of alignment.
 *
 * If @boundary is nonzero, objects returned from dma_pool_alloc() won&apos;t
 * cross that size boundary.  This is useful for devices which have
 * addressing restrictions on individual DMA transfers, such as not crossing
 * boundaries of 4KBytes.
 */</doc>
