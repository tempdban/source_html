<dec f='linux-4.14.y/include/net/route.h' l='211' type='void ip_rt_send_redirect(struct sk_buff * skb)'/>
<use f='linux-4.14.y/net/ipv4/ip_forward.c' l='144' u='c' c='ip_forward'/>
<def f='linux-4.14.y/net/ipv4/route.c' l='877' ll='940' type='void ip_rt_send_redirect(struct sk_buff * skb)'/>
<doc f='linux-4.14.y/net/ipv4/route.c' l='861'>/*
 * Algorithm:
 *	1. The first ip_rt_redirect_number redirects are sent
 *	   with exponential backoff, then we stop sending them at all,
 *	   assuming that the host ignores our redirects.
 *	2. If we did not see packets requiring redirects
 *	   during ip_rt_redirect_silence, we assume that the host
 *	   forgot redirected route and start to send redirects again.
 *
 * This algorithm is much cheaper and more intelligent than dumb load limiting
 * in icmp.c.
 *
 * NOTE. Do not forget to inhibit load limiting for redirects (redundant)
 * and &quot;frag. need&quot; (breaks PMTU discovery) in icmp.c.
 */</doc>
<dec f='linux-4.14.y/include/net/route.h' l='211' type='void ip_rt_send_redirect(struct sk_buff * skb)'/>
<use f='linux-4.14.y/net/ipv4/ip_forward.c' l='144' u='c' c='ip_forward'/>
<def f='linux-4.14.y/net/ipv4/route.c' l='877' ll='940' type='void ip_rt_send_redirect(struct sk_buff * skb)'/>
<doc f='linux-4.14.y/net/ipv4/route.c' l='861'>/*
 * Algorithm:
 *	1. The first ip_rt_redirect_number redirects are sent
 *	   with exponential backoff, then we stop sending them at all,
 *	   assuming that the host ignores our redirects.
 *	2. If we did not see packets requiring redirects
 *	   during ip_rt_redirect_silence, we assume that the host
 *	   forgot redirected route and start to send redirects again.
 *
 * This algorithm is much cheaper and more intelligent than dumb load limiting
 * in icmp.c.
 *
 * NOTE. Do not forget to inhibit load limiting for redirects (redundant)
 * and &quot;frag. need&quot; (breaks PMTU discovery) in icmp.c.
 */</doc>
