<dec f='linux-4.14.y/include/linux/umh.h' l='33' type='int call_usermodehelper(const char * path, char ** argv, char ** envp, int wait)'/>
<use f='linux-4.14.y/kernel/cgroup/cgroup-v1.c' l='845' u='c' c='cgroup1_release_agent'/>
<use f='linux-4.14.y/kernel/reboot.c' l='403' u='c' c='run_cmd'/>
<def f='linux-4.14.y/kernel/umh.c' l='478' ll='489' type='int call_usermodehelper(const char * path, char ** argv, char ** envp, int wait)'/>
<dec f='linux-4.14.y/kernel/umh.c' l='490' type='int call_usermodehelper(const char * , char ** , char ** , int )'/>
<use f='linux-4.14.y/kernel/umh.c' l='490' c='call_usermodehelper'/>
<use f='linux-4.14.y/kernel/umh.c' l='490' u='a'/>
<use f='linux-4.14.y/kernel/umh.c' l='490' u='a'/>
<doc f='linux-4.14.y/kernel/umh.c' l='465'>/**
 * call_usermodehelper() - prepare and start a usermode application
 * @path: path to usermode executable
 * @argv: arg vector for process
 * @envp: environment for process
 * @wait: wait for the application to finish and return status.
 *        when UMH_NO_WAIT don&apos;t wait at all, but you get no useful error back
 *        when the program couldn&apos;t be exec&apos;ed. This makes it safe to call
 *        from interrupt context.
 *
 * This function is the equivalent to use call_usermodehelper_setup() and
 * call_usermodehelper_exec().
 */</doc>
<use f='linux-4.14.y/net/bridge/br_stp_if.c' l='138' u='c' c='br_stp_call_user'/>
<use f='linux-4.14.y/security/tomoyo/load_policy.c' l='106' u='c' c='tomoyo_load_policy'/>
