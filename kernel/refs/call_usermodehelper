<dec f='linux-4.18.y/include/linux/umh.h' l='35' type='int call_usermodehelper(const char * path, char ** argv, char ** envp, int wait)'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup-v1.c' l='833' u='c' c='cgroup1_release_agent'/>
<use f='linux-4.18.y/kernel/reboot.c' l='430' u='c' c='run_cmd'/>
<def f='linux-4.18.y/kernel/umh.c' l='596' ll='607' type='int call_usermodehelper(const char * path, char ** argv, char ** envp, int wait)'/>
<dec f='linux-4.18.y/kernel/umh.c' l='608' type='int call_usermodehelper(const char * , char ** , char ** , int )'/>
<use f='linux-4.18.y/kernel/umh.c' l='608' c='call_usermodehelper'/>
<use f='linux-4.18.y/kernel/umh.c' l='608' u='a'/>
<use f='linux-4.18.y/kernel/umh.c' l='608' u='a'/>
<doc f='linux-4.18.y/kernel/umh.c' l='583'>/**
 * call_usermodehelper() - prepare and start a usermode application
 * @path: path to usermode executable
 * @argv: arg vector for process
 * @envp: environment for process
 * @wait: wait for the application to finish and return status.
 *        when UMH_NO_WAIT don&apos;t wait at all, but you get no useful error back
 *        when the program couldn&apos;t be exec&apos;ed. This makes it safe to call
 *        from interrupt context.
 *
 * This function is the equivalent to use call_usermodehelper_setup() and
 * call_usermodehelper_exec().
 */</doc>
<use f='linux-4.18.y/net/bridge/br_stp_if.c' l='138' u='c' c='br_stp_call_user'/>
<use f='linux-4.18.y/security/tomoyo/load_policy.c' l='106' u='c' c='tomoyo_load_policy'/>
