<dec f='linux-4.14.y/include/linux/anon_inodes.h' l='17' type='int anon_inode_getfd(const char * name, const struct file_operations * fops, void * priv, int flags)'/>
<def f='linux-4.14.y/fs/anon_inodes.c' l='139' ll='162' type='int anon_inode_getfd(const char * name, const struct file_operations * fops, void * priv, int flags)'/>
<dec f='linux-4.14.y/fs/anon_inodes.c' l='163' type='int anon_inode_getfd(const char * , const struct file_operations * , void * , int )'/>
<use f='linux-4.14.y/fs/anon_inodes.c' l='163' c='anon_inode_getfd'/>
<use f='linux-4.14.y/fs/anon_inodes.c' l='163' u='a'/>
<use f='linux-4.14.y/fs/anon_inodes.c' l='163' u='a'/>
<doc f='linux-4.14.y/fs/anon_inodes.c' l='123'>/**
 * anon_inode_getfd - creates a new file instance by hooking it up to an
 *                    anonymous inode, and a dentry that describe the &quot;class&quot;
 *                    of the file
 *
 * @name:    [in]    name of the &quot;class&quot; of the new file
 * @fops:    [in]    file operations for the new file
 * @priv:    [in]    private data for the new file (will be file&apos;s private_data)
 * @flags:   [in]    flags
 *
 * Creates a new file by hooking it on a single inode. This is useful for files
 * that do not need to have a full-fledged inode in order to operate correctly.
 * All the files created with anon_inode_getfd() will share a single inode,
 * hence saving memory and avoiding code duplication for the file/inode/dentry
 * setup.  Returns new descriptor or an error code.
 */</doc>
<use f='linux-4.14.y/fs/notify/fanotify/fanotify_user.c' l='809' u='c' c='SYSC_fanotify_init'/>
<use f='linux-4.14.y/fs/notify/inotify/inotify_user.c' l='655' u='c' c='SYSC_inotify_init1'/>
<use f='linux-4.14.y/fs/signalfd.c' l='280' u='c' c='SYSC_signalfd4'/>
<use f='linux-4.14.y/fs/timerfd.c' l='427' u='c' c='SYSC_timerfd_create'/>
<dec f='linux-4.14.y/include/linux/anon_inodes.h' l='17' type='int anon_inode_getfd(const char * name, const struct file_operations * fops, void * priv, int flags)'/>
<def f='linux-4.14.y/fs/anon_inodes.c' l='139' ll='162' type='int anon_inode_getfd(const char * name, const struct file_operations * fops, void * priv, int flags)'/>
<dec f='linux-4.14.y/fs/anon_inodes.c' l='163' type='int anon_inode_getfd(const char * , const struct file_operations * , void * , int )'/>
<use f='linux-4.14.y/fs/anon_inodes.c' l='163' c='anon_inode_getfd'/>
<use f='linux-4.14.y/fs/anon_inodes.c' l='163' u='a'/>
<use f='linux-4.14.y/fs/anon_inodes.c' l='163' u='a'/>
<doc f='linux-4.14.y/fs/anon_inodes.c' l='123'>/**
 * anon_inode_getfd - creates a new file instance by hooking it up to an
 *                    anonymous inode, and a dentry that describe the &quot;class&quot;
 *                    of the file
 *
 * @name:    [in]    name of the &quot;class&quot; of the new file
 * @fops:    [in]    file operations for the new file
 * @priv:    [in]    private data for the new file (will be file&apos;s private_data)
 * @flags:   [in]    flags
 *
 * Creates a new file by hooking it on a single inode. This is useful for files
 * that do not need to have a full-fledged inode in order to operate correctly.
 * All the files created with anon_inode_getfd() will share a single inode,
 * hence saving memory and avoiding code duplication for the file/inode/dentry
 * setup.  Returns new descriptor or an error code.
 */</doc>
<use f='linux-4.14.y/fs/notify/fanotify/fanotify_user.c' l='809' u='c' c='SYSC_fanotify_init'/>
<use f='linux-4.14.y/fs/notify/inotify/inotify_user.c' l='655' u='c' c='SYSC_inotify_init1'/>
<use f='linux-4.14.y/fs/signalfd.c' l='280' u='c' c='SYSC_signalfd4'/>
<use f='linux-4.14.y/fs/timerfd.c' l='427' u='c' c='SYSC_timerfd_create'/>
