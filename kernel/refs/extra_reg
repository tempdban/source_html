<def f='linux-4.14.y/arch/x86/events/perf_event.h' l='422' ll='429'/>
<size>32</size>
<doc f='linux-4.14.y/arch/x86/events/perf_event.h' l='412'>/*
 * Extra registers for specific events.
 *
 * Some events need large masks and require external MSRs.
 * Those extra MSRs end up being shared for all events on
 * a PMU and sometimes between PMU of sibling HT threads.
 * In either case, the kernel needs to handle conflicting
 * accesses to those extra, shared, regs. The data structure
 * to manage those registers is stored in cpu_hw_event.
 */</doc>
<mbr r='extra_reg::event' o='0' t='unsigned int'/>
<mbr r='extra_reg::msr' o='32' t='unsigned int'/>
<mbr r='extra_reg::config_mask' o='64' t='u64'/>
<mbr r='extra_reg::valid_mask' o='128' t='u64'/>
<mbr r='extra_reg::idx' o='192' t='int'/>
<mbr r='extra_reg::extra_msr_access' o='224' t='bool'/>
<def f='linux-4.14.y/arch/x86/events/perf_event.h' l='422' ll='429'/>
<size>32</size>
<doc f='linux-4.14.y/arch/x86/events/perf_event.h' l='412'>/*
 * Extra registers for specific events.
 *
 * Some events need large masks and require external MSRs.
 * Those extra MSRs end up being shared for all events on
 * a PMU and sometimes between PMU of sibling HT threads.
 * In either case, the kernel needs to handle conflicting
 * accesses to those extra, shared, regs. The data structure
 * to manage those registers is stored in cpu_hw_event.
 */</doc>
<mbr r='extra_reg::event' o='0' t='unsigned int'/>
<mbr r='extra_reg::msr' o='32' t='unsigned int'/>
<mbr r='extra_reg::config_mask' o='64' t='u64'/>
<mbr r='extra_reg::valid_mask' o='128' t='u64'/>
<mbr r='extra_reg::idx' o='192' t='int'/>
<mbr r='extra_reg::extra_msr_access' o='224' t='bool'/>
