<dec f='linux-4.18.y/include/linux/spi/spi.h' l='1104' type='int spi_write_then_read(struct spi_device * spi, const void * txbuf, unsigned int n_tx, void * rxbuf, unsigned int n_rx)'/>
<use f='linux-4.18.y/include/linux/spi/spi.h' l='1124' u='c' c='spi_w8r8'/>
<use f='linux-4.18.y/include/linux/spi/spi.h' l='1149' u='c' c='spi_w8r16'/>
<use f='linux-4.18.y/include/linux/spi/spi.h' l='1175' u='c' c='spi_w8r16be'/>
<use f='linux-4.18.y/drivers/base/regmap/regmap-spi.c' l='102' u='c' c='regmap_spi_read'/>
<doc f='linux-4.18.y/include/linux/spi/spi.h' l='1103'>/* this copies txbuf and rxbuf data; for small transfers only! */</doc>
<def f='linux-4.18.y/drivers/spi/spi.c' l='3270' ll='3321' type='int spi_write_then_read(struct spi_device * spi, const void * txbuf, unsigned int n_tx, void * rxbuf, unsigned int n_rx)'/>
<dec f='linux-4.18.y/drivers/spi/spi.c' l='3322' type='int spi_write_then_read(struct spi_device * , const void * , unsigned int , void * , unsigned int )'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='3322' c='spi_write_then_read'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='3322' u='a'/>
<use f='linux-4.18.y/drivers/spi/spi.c' l='3322' u='a'/>
<doc f='linux-4.18.y/drivers/spi/spi.c' l='3249'>/**
 * spi_write_then_read - SPI synchronous write followed by read
 * @spi: device with which data will be exchanged
 * @txbuf: data to be written (need not be dma-safe)
 * @n_tx: size of txbuf, in bytes
 * @rxbuf: buffer into which data will be read (need not be dma-safe)
 * @n_rx: size of rxbuf, in bytes
 * Context: can sleep
 *
 * This performs a half duplex MicroWire style transaction with the
 * device, sending txbuf and then reading rxbuf.  The return value
 * is zero for success, else a negative errno status code.
 * This call may only be used from a context that may sleep.
 *
 * Parameters to this routine are always copied using a small buffer;
 * portable code should never use this for more than 32 bytes.
 * Performance-sensitive or bulk transfer code should instead use
 * spi_{async,sync}() calls with dma-safe buffers.
 *
 * Return: zero on success, else a negative error code.
 */</doc>
