<dec f='linux-4.18.y/include/linux/fs.h' l='2466' type='struct super_block * freeze_bdev(struct block_device * )'/>
<use f='linux-4.18.y/drivers/md/dm.c' l='2484' u='c' c='lock_fs'/>
<def f='linux-4.18.y/fs/block_dev.c' l='491' ll='528' type='struct super_block * freeze_bdev(struct block_device * bdev)'/>
<dec f='linux-4.18.y/fs/block_dev.c' l='529' type='struct super_block * freeze_bdev(struct block_device * )'/>
<use f='linux-4.18.y/fs/block_dev.c' l='529' c='freeze_bdev'/>
<use f='linux-4.18.y/fs/block_dev.c' l='529' u='a'/>
<use f='linux-4.18.y/fs/block_dev.c' l='529' u='a'/>
<doc f='linux-4.18.y/fs/block_dev.c' l='479'>/**
 * freeze_bdev  --  lock a filesystem and force it into a consistent state
 * @bdev:	blockdevice to lock
 *
 * If a superblock is found on this device, we take the s_umount semaphore
 * on it to make sure nobody unmounts until the snapshot creation is done.
 * The reference counter (bd_fsfreeze_count) guarantees that only the last
 * unfreeze process can unfreeze the frozen filesystem actually when multiple
 * freeze requests arrive simultaneously. It counts up in freeze_bdev() and
 * count down in thaw_bdev(). When it becomes 0, thaw_bdev() will unfreeze
 * actually.
 */</doc>
<use f='linux-4.18.y/fs/ext4/ioctl.c' l='484' u='c' c='ext4_shutdown'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='1901' u='c' c='f2fs_ioc_shutdown'/>
