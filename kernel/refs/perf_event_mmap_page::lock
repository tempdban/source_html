<dec f='linux-4.18.y/include/uapi/linux/perf_event.h' l='512' type='__u32'/>
<offset>64</offset>
<doc f='linux-4.18.y/include/uapi/linux/perf_event.h' l='477'>/*
	 * Bits needed to read the hw events in user-space.
	 *
	 *   u32 seq, time_mult, time_shift, index, width;
	 *   u64 count, enabled, running;
	 *   u64 cyc, time_offset;
	 *   s64 pmc = 0;
	 *
	 *   do {
	 *     seq = pc-&gt;lock;
	 *     barrier()
	 *
	 *     enabled = pc-&gt;time_enabled;
	 *     running = pc-&gt;time_running;
	 *
	 *     if (pc-&gt;cap_usr_time &amp;&amp; enabled != running) {
	 *       cyc = rdtsc();
	 *       time_offset = pc-&gt;time_offset;
	 *       time_mult   = pc-&gt;time_mult;
	 *       time_shift  = pc-&gt;time_shift;
	 *     }
	 *
	 *     index = pc-&gt;index;
	 *     count = pc-&gt;offset;
	 *     if (pc-&gt;cap_user_rdpmc &amp;&amp; index) {
	 *       width = pc-&gt;pmc_width;
	 *       pmc = rdpmc(index - 1);
	 *     }
	 *
	 *     barrier();
	 *   } while (pc-&gt;lock != seq);
	 *
	 * NOTE: for obvious reason this only works on self-monitoring
	 *       processes.
	 */</doc>
<doc f='linux-4.18.y/include/uapi/linux/perf_event.h' l='512'>/* seqlock for synchronization */</doc>
<use f='linux-4.18.y/kernel/events/core.c' l='5253' u='w' c='perf_event_update_userpage'/>
<use f='linux-4.18.y/kernel/events/core.c' l='5269' u='w' c='perf_event_update_userpage'/>
