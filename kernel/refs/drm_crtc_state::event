<dec f='linux-4.18.y/include/drm/drm_crtc.h' l='254' type='struct drm_pending_vblank_event *'/>
<offset>4352</offset>
<doc f='linux-4.18.y/include/drm/drm_crtc.h' l='206'>/**
	 * @event:
	 *
	 * Optional pointer to a DRM event to signal upon completion of the
	 * state update. The driver must send out the event when the atomic
	 * commit operation completes. There are two cases:
	 *
	 *  - The event is for a CRTC which is being disabled through this
	 *    atomic commit. In that case the event can be send out any time
	 *    after the hardware has stopped scanning out the current
	 *    framebuffers. It should contain the timestamp and counter for the
	 *    last vblank before the display pipeline was shut off. The simplest
	 *    way to achieve that is calling drm_crtc_send_vblank_event()
	 *    somewhen after drm_crtc_vblank_off() has been called.
	 *
	 *  - For a CRTC which is enabled at the end of the commit (even when it
	 *    undergoes an full modeset) the vblank timestamp and counter must
	 *    be for the vblank right before the first frame that scans out the
	 *    new set of buffers. Again the event can only be sent out after the
	 *    hardware has stopped scanning out the old buffers.
	 *
	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
	 *    that case.
	 *
	 * This can be handled by the drm_crtc_send_vblank_event() function,
	 * which the driver should call on the provided event upon completion of
	 * the atomic commit. Note that if the driver supports vblank signalling
	 * and timestamping the vblank counters and timestamps must agree with
	 * the ones returned from page flip events. With the current vblank
	 * helper infrastructure this can be achieved by holding a vblank
	 * reference while the page flip is pending, acquired through
	 * drm_crtc_vblank_get() and released with drm_crtc_vblank_put().
	 * Drivers are free to implement their own vblank counter and timestamp
	 * tracking though, e.g. if they have accurate timestamp registers in
	 * hardware.
	 *
	 * For hardware which supports some means to synchronize vblank
	 * interrupt delivery with committing display state there&apos;s also
	 * drm_crtc_arm_vblank_event(). See the documentation of that function
	 * for a detailed discussion of the constraints it needs to be used
	 * safely.
	 *
	 * If the device can&apos;t notify of flip completion in a race-free way
	 * at all, then the event should be armed just after the page flip is
	 * committed. In the worst case the driver will send the event to
	 * userspace one frame too late. This doesn&apos;t allow for a real atomic
	 * update, but it should avoid tearing.
	 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='648' u='r' c='drm_atomic_crtc_check'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='2190' u='w' c='prepare_crtc_signaling'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='2194' u='r' c='prepare_crtc_signaling'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='2203' u='w' c='prepare_crtc_signaling'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='2232' u='r' c='prepare_crtc_signaling'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='2268' u='r' c='complete_crtc_signaling'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic.c' l='2276' u='w' c='complete_crtc_signaling'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1895' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1901' u='w' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1904' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='1905' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='2072' u='r' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='3213' u='w' c='page_flip_common'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='3418' u='w' c='__drm_atomic_helper_crtc_duplicate_state'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='3466' u='r' c='__drm_atomic_helper_crtc_destroy_state'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_display.c' l='351' u='r' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_display.c' l='352' u='r' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_display.c' l='353' u='w' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='156' u='r' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='157' u='r' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='158' u='w' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='573' u='r' c='vmw_du_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='576' u='w' c='vmw_du_crtc_atomic_flush'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='542' u='r' c='vmw_sou_primary_plane_atomic_update'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='560' u='w' c='vmw_sou_primary_plane_atomic_update'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='1315' u='r' c='vmw_stdu_primary_plane_atomic_update'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='1338' u='w' c='vmw_stdu_primary_plane_atomic_update'/>
