<dec f='linux-4.14.y/include/drm/drm_crtc.h' l='254' type='struct drm_pending_vblank_event *'/>
<offset>4096</offset>
<doc f='linux-4.14.y/include/drm/drm_crtc.h' l='206'>/**
	 * @event:
	 *
	 * Optional pointer to a DRM event to signal upon completion of the
	 * state update. The driver must send out the event when the atomic
	 * commit operation completes. There are two cases:
	 *
	 *  - The event is for a CRTC which is being disabled through this
	 *    atomic commit. In that case the event can be send out any time
	 *    after the hardware has stopped scanning out the current
	 *    framebuffers. It should contain the timestamp and counter for the
	 *    last vblank before the display pipeline was shut off. The simplest
	 *    way to achieve that is calling drm_crtc_send_vblank_event()
	 *    somewhen after drm_crtc_vblank_off() has been called.
	 *
	 *  - For a CRTC which is enabled at the end of the commit (even when it
	 *    undergoes an full modeset) the vblank timestamp and counter must
	 *    be for the vblank right before the first frame that scans out the
	 *    new set of buffers. Again the event can only be sent out after the
	 *    hardware has stopped scanning out the old buffers.
	 *
	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
	 *    that case.
	 *
	 * This can be handled by the drm_crtc_send_vblank_event() function,
	 * which the driver should call on the provided event upon completion of
	 * the atomic commit. Note that if the driver supports vblank signalling
	 * and timestamping the vblank counters and timestamps must agree with
	 * the ones returned from page flip events. With the current vblank
	 * helper infrastructure this can be achieved by holding a vblank
	 * reference while the page flip is pending, acquired through
	 * drm_crtc_vblank_get() and released with drm_crtc_vblank_put().
	 * Drivers are free to implement their own vblank counter and timestamp
	 * tracking though, e.g. if they have accurate timestamp registers in
	 * hardware.
	 *
	 * For hardware which supports some means to synchronize vblank
	 * interrupt delivery with committing display state there&apos;s also
	 * drm_crtc_arm_vblank_event(). See the documentation of that function
	 * for a detailed discussion of the constraints it needs to be used
	 * safely.
	 *
	 * If the device can&apos;t notify of flip completion in a race-free way
	 * at all, then the event should be armed just after the page flip is
	 * committed. In the worst case the driver will send the event to
	 * userspace one frame too late. This doesn&apos;t allow for a real atomic
	 * update, but it should avoid tearing.
	 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='620' u='r' c='drm_atomic_crtc_check'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2097' u='w' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2101' u='r' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2110' u='w' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2139' u='r' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2175' u='r' c='complete_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2183' u='w' c='complete_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1754' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1760' u='w' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1763' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1764' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1865' u='r' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2986' u='w' c='page_flip_common'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='3190' u='w' c='__drm_atomic_helper_crtc_duplicate_state'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='278' u='r' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='279' u='r' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='280' u='w' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='143' u='r' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='144' u='r' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='145' u='w' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='582' u='r' c='vmw_du_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='585' u='w' c='vmw_du_crtc_atomic_flush'/>
<dec f='linux-4.14.y/include/drm/drm_crtc.h' l='254' type='struct drm_pending_vblank_event *'/>
<offset>4096</offset>
<doc f='linux-4.14.y/include/drm/drm_crtc.h' l='206'>/**
	 * @event:
	 *
	 * Optional pointer to a DRM event to signal upon completion of the
	 * state update. The driver must send out the event when the atomic
	 * commit operation completes. There are two cases:
	 *
	 *  - The event is for a CRTC which is being disabled through this
	 *    atomic commit. In that case the event can be send out any time
	 *    after the hardware has stopped scanning out the current
	 *    framebuffers. It should contain the timestamp and counter for the
	 *    last vblank before the display pipeline was shut off. The simplest
	 *    way to achieve that is calling drm_crtc_send_vblank_event()
	 *    somewhen after drm_crtc_vblank_off() has been called.
	 *
	 *  - For a CRTC which is enabled at the end of the commit (even when it
	 *    undergoes an full modeset) the vblank timestamp and counter must
	 *    be for the vblank right before the first frame that scans out the
	 *    new set of buffers. Again the event can only be sent out after the
	 *    hardware has stopped scanning out the old buffers.
	 *
	 *  - Events for disabled CRTCs are not allowed, and drivers can ignore
	 *    that case.
	 *
	 * This can be handled by the drm_crtc_send_vblank_event() function,
	 * which the driver should call on the provided event upon completion of
	 * the atomic commit. Note that if the driver supports vblank signalling
	 * and timestamping the vblank counters and timestamps must agree with
	 * the ones returned from page flip events. With the current vblank
	 * helper infrastructure this can be achieved by holding a vblank
	 * reference while the page flip is pending, acquired through
	 * drm_crtc_vblank_get() and released with drm_crtc_vblank_put().
	 * Drivers are free to implement their own vblank counter and timestamp
	 * tracking though, e.g. if they have accurate timestamp registers in
	 * hardware.
	 *
	 * For hardware which supports some means to synchronize vblank
	 * interrupt delivery with committing display state there&apos;s also
	 * drm_crtc_arm_vblank_event(). See the documentation of that function
	 * for a detailed discussion of the constraints it needs to be used
	 * safely.
	 *
	 * If the device can&apos;t notify of flip completion in a race-free way
	 * at all, then the event should be armed just after the page flip is
	 * committed. In the worst case the driver will send the event to
	 * userspace one frame too late. This doesn&apos;t allow for a real atomic
	 * update, but it should avoid tearing.
	 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='620' u='r' c='drm_atomic_crtc_check'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2097' u='w' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2101' u='r' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2110' u='w' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2139' u='r' c='prepare_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2175' u='r' c='complete_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic.c' l='2183' u='w' c='complete_crtc_signaling'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1754' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1760' u='w' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1763' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1764' u='r' c='drm_atomic_helper_setup_commit'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1865' u='r' c='drm_atomic_helper_commit_hw_done'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='2986' u='w' c='page_flip_common'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='3190' u='w' c='__drm_atomic_helper_crtc_duplicate_state'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='278' u='r' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='279' u='r' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='280' u='w' c='qxl_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='143' u='r' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='144' u='r' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='145' u='w' c='virtio_gpu_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='582' u='r' c='vmw_du_crtc_atomic_flush'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='585' u='w' c='vmw_du_crtc_atomic_flush'/>
