<dec f='linux-4.18.y/include/linux/netfilter/x_tables.h' l='304' type='void * xt_copy_counters_from_user(const void * user, unsigned int len, struct xt_counters_info * info, bool compat)'/>
<use f='linux-4.18.y/net/ipv4/netfilter/arp_tables.c' l='1006' u='c' c='do_add_counters'/>
<use f='linux-4.18.y/net/ipv4/netfilter/ip_tables.c' l='1170' u='c' c='do_add_counters'/>
<def f='linux-4.18.y/net/netfilter/x_tables.c' l='1056' ll='1106' type='void * xt_copy_counters_from_user(const void * user, unsigned int len, struct xt_counters_info * info, bool compat)'/>
<dec f='linux-4.18.y/net/netfilter/x_tables.c' l='1107' type='void * xt_copy_counters_from_user(const void * , unsigned int , struct xt_counters_info * , bool )'/>
<use f='linux-4.18.y/net/netfilter/x_tables.c' l='1107' c='xt_copy_counters_from_user'/>
<use f='linux-4.18.y/net/netfilter/x_tables.c' l='1107' u='a'/>
<use f='linux-4.18.y/net/netfilter/x_tables.c' l='1107' u='a'/>
<doc f='linux-4.18.y/net/netfilter/x_tables.c' l='1035'>/**
 * xt_copy_counters_from_user - copy counters and metadata from userspace
 *
 * @user: src pointer to userspace memory
 * @len: alleged size of userspace memory
 * @info: where to store the xt_counters_info metadata
 * @compat: true if we setsockopt call is done by 32bit task on 64bit kernel
 *
 * Copies counter meta data from @user and stores it in @info.
 *
 * vmallocs memory to hold the counters, then copies the counter data
 * from @user to the new memory and returns a pointer to it.
 *
 * If @compat is true, @info gets converted automatically to the 64bit
 * representation.
 *
 * The metadata associated with the counters is stored in @info.
 *
 * Return: returns pointer that caller has to test via IS_ERR().
 * If IS_ERR is false, caller has to vfree the pointer.
 */</doc>
