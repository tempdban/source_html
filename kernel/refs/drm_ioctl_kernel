<dec f='linux-4.14.y/include/drm/drm_ioctl.h' l='175' type='long drm_ioctl_kernel(struct file * , drm_ioctl_t * , void * , u32 )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='107' u='c' c='compat_drm_version'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='142' u='c' c='compat_drm_getunique'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='180' u='c' c='compat_drm_getmap'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='212' u='c' c='compat_drm_addmap'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='240' u='c' c='compat_drm_rmmap'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='265' u='c' c='compat_drm_getclient'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='295' u='c' c='compat_drm_getstats'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='329' u='c' c='compat_drm_addbufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='358' u='c' c='compat_drm_markbufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='398' u='c' c='compat_drm_infobufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='461' u='c' c='compat_drm_mapbufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='489' u='c' c='compat_drm_freebufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='509' u='c' c='compat_drm_setsareactx'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='525' u='c' c='compat_drm_getsareactx'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='554' u='c' c='compat_drm_resctx'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='597' u='c' c='compat_drm_dma'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='766' u='c' c='compat_drm_sg_alloc'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='788' u='c' c='compat_drm_sg_free'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='808' u='c' c='compat_drm_update_draw'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='845' u='c' c='compat_drm_wait_vblank'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='887' u='c' c='compat_drm_mode_addfb2'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='718' ll='742' type='long drm_ioctl_kernel(struct file * file, drm_ioctl_t * func, void * kdata, u32 flags)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' type='long drm_ioctl_kernel(struct file * , drm_ioctl_t * , void * , u32 )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' c='drm_ioctl_kernel'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='831' u='c' c='drm_ioctl'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='670'>/**
 * DOC: driver specific ioctls
 *
 * First things first, driver private IOCTLs should only be needed for drivers
 * supporting rendering. Kernel modesetting is all standardized, and extended
 * through properties. There are a few exceptions in some existing drivers,
 * which define IOCTL for use by the display DRM master, but they all predate
 * properties.
 *
 * Now if you do have a render driver you always have to support it through
 * driver private properties. There&apos;s a few steps needed to wire all the things
 * up.
 *
 * First you need to define the structure for your IOCTL in your driver private
 * UAPI header in ``include/uapi/drm/my_driver_drm.h``::
 *
 *     struct my_driver_operation {
 *             u32 some_thing;
 *             u32 another_thing;
 *     };
 *
 * Please make sure that you follow all the best practices from
 * ``Documentation/ioctl/botching-up-ioctls.txt``. Note that drm_ioctl()
 * automatically zero-extends structures, hence make sure you can add more stuff
 * at the end, i.e. don&apos;t put a variable sized array there.
 *
 * Then you need to define your IOCTL number, using one of DRM_IO(), DRM_IOR(),
 * DRM_IOW() or DRM_IOWR(). It must start with the DRM_IOCTL\_ prefix::
 *
 *     ##define DRM_IOCTL_MY_DRIVER_OPERATION \
 *         DRM_IOW(DRM_COMMAND_BASE, struct my_driver_operation)
 * 
 * DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to
 * DRM_COMMAND_END. Finally you need an array of &amp;struct drm_ioctl_desc to wire
 * up the handlers and set the access rights::
 *
 *     static const struct drm_ioctl_desc my_driver_ioctls[] = {
 *         DRM_IOCTL_DEF_DRV(MY_DRIVER_OPERATION, my_driver_operation,
 *                 DRM_AUTH|DRM_RENDER_ALLOW),
 *     };
 *
 * And then assign this to the &amp;drm_driver.ioctls field in your driver
 * structure.
 *
 * See the separate chapter on :ref:`file operations&lt;drm_driver_fops&gt;` for how
 * the driver-specific IOCTLs are wired up.
 */</doc>
<dec f='linux-4.14.y/include/drm/drm_ioctl.h' l='175' type='long drm_ioctl_kernel(struct file * , drm_ioctl_t * , void * , u32 )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='107' u='c' c='compat_drm_version'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='142' u='c' c='compat_drm_getunique'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='180' u='c' c='compat_drm_getmap'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='212' u='c' c='compat_drm_addmap'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='240' u='c' c='compat_drm_rmmap'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='265' u='c' c='compat_drm_getclient'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='295' u='c' c='compat_drm_getstats'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='329' u='c' c='compat_drm_addbufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='358' u='c' c='compat_drm_markbufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='398' u='c' c='compat_drm_infobufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='461' u='c' c='compat_drm_mapbufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='489' u='c' c='compat_drm_freebufs'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='509' u='c' c='compat_drm_setsareactx'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='525' u='c' c='compat_drm_getsareactx'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='554' u='c' c='compat_drm_resctx'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='597' u='c' c='compat_drm_dma'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='766' u='c' c='compat_drm_sg_alloc'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='788' u='c' c='compat_drm_sg_free'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='808' u='c' c='compat_drm_update_draw'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='845' u='c' c='compat_drm_wait_vblank'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioc32.c' l='887' u='c' c='compat_drm_mode_addfb2'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='718' ll='742' type='long drm_ioctl_kernel(struct file * file, drm_ioctl_t * func, void * kdata, u32 flags)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' type='long drm_ioctl_kernel(struct file * , drm_ioctl_t * , void * , u32 )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' c='drm_ioctl_kernel'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='743' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='831' u='c' c='drm_ioctl'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_ioctl.c' l='670'>/**
 * DOC: driver specific ioctls
 *
 * First things first, driver private IOCTLs should only be needed for drivers
 * supporting rendering. Kernel modesetting is all standardized, and extended
 * through properties. There are a few exceptions in some existing drivers,
 * which define IOCTL for use by the display DRM master, but they all predate
 * properties.
 *
 * Now if you do have a render driver you always have to support it through
 * driver private properties. There&apos;s a few steps needed to wire all the things
 * up.
 *
 * First you need to define the structure for your IOCTL in your driver private
 * UAPI header in ``include/uapi/drm/my_driver_drm.h``::
 *
 *     struct my_driver_operation {
 *             u32 some_thing;
 *             u32 another_thing;
 *     };
 *
 * Please make sure that you follow all the best practices from
 * ``Documentation/ioctl/botching-up-ioctls.txt``. Note that drm_ioctl()
 * automatically zero-extends structures, hence make sure you can add more stuff
 * at the end, i.e. don&apos;t put a variable sized array there.
 *
 * Then you need to define your IOCTL number, using one of DRM_IO(), DRM_IOR(),
 * DRM_IOW() or DRM_IOWR(). It must start with the DRM_IOCTL\_ prefix::
 *
 *     ##define DRM_IOCTL_MY_DRIVER_OPERATION \
 *         DRM_IOW(DRM_COMMAND_BASE, struct my_driver_operation)
 * 
 * DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to
 * DRM_COMMAND_END. Finally you need an array of &amp;struct drm_ioctl_desc to wire
 * up the handlers and set the access rights::
 *
 *     static const struct drm_ioctl_desc my_driver_ioctls[] = {
 *         DRM_IOCTL_DEF_DRV(MY_DRIVER_OPERATION, my_driver_operation,
 *                 DRM_AUTH|DRM_RENDER_ALLOW),
 *     };
 *
 * And then assign this to the &amp;drm_driver.ioctls field in your driver
 * structure.
 *
 * See the separate chapter on :ref:`file operations&lt;drm_driver_fops&gt;` for how
 * the driver-specific IOCTLs are wired up.
 */</doc>
