<dec f='linux-4.18.y/arch/x86/include/asm/traps.h' l='65' type='void do_debug(struct pt_regs * , long )'/>
<def f='linux-4.18.y/arch/x86/kernel/traps.c' l='721' ll='822' type='void do_debug(struct pt_regs * regs, long error_code)'/>
<doc f='linux-4.18.y/arch/x86/kernel/traps.c' l='697'>/*
 * Our handling of the processor debug registers is non-trivial.
 * We do not clear them on entry and exit from the kernel. Therefore
 * it is possible to get a watchpoint trap here from inside the kernel.
 * However, the code in ./ptrace.c has ensured that the user can
 * only set watchpoints on userspace addresses. Therefore the in-kernel
 * watchpoint trap can only occur in code which is reading/writing
 * from user space. Such code must not hold kernel locks (since it
 * can equally take a page fault), therefore it is safe to call
 * force_sig_info even though that claims and releases locks.
 *
 * Code in ./signal.c ensures that the debug control register
 * is restored before we deliver any signal, and therefore that
 * user code runs with the correct debug control register even though
 * we clear it here.
 *
 * Being careful here means that we don&apos;t have to be as careful in a
 * lot of more complicated places (task switching can be a bit lazy
 * about restoring all the debug state, and ptrace doesn&apos;t have to
 * find every occurrence of the TF bit that could be saved away even
 * by user code)
 *
 * May run on IST stack.
 */</doc>
