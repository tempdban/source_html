<dec f='linux-4.14.y/include/linux/percpu.h' l='114' type='int pcpu_setup_first_chunk(const struct pcpu_alloc_info * ai, void * base_addr)'/>
<def f='linux-4.14.y/mm/percpu.c' l='2013' ll='2176' type='int pcpu_setup_first_chunk(const struct pcpu_alloc_info * ai, void * base_addr)'/>
<use f='linux-4.14.y/mm/percpu.c' l='2513' u='c' c='pcpu_embed_first_chunk'/>
<use f='linux-4.14.y/mm/percpu.c' l='2635' u='c' c='pcpu_page_first_chunk'/>
<doc f='linux-4.14.y/mm/percpu.c' l='1956'>/**
 * pcpu_setup_first_chunk - initialize the first percpu chunk
 * @ai: pcpu_alloc_info describing how to percpu area is shaped
 * @base_addr: mapped address
 *
 * Initialize the first percpu chunk which contains the kernel static
 * perpcu area.  This function is to be called from arch percpu area
 * setup path.
 *
 * @ai contains all information necessary to initialize the first
 * chunk and prime the dynamic percpu allocator.
 *
 * @ai-&gt;static_size is the size of static percpu area.
 *
 * @ai-&gt;reserved_size, if non-zero, specifies the amount of bytes to
 * reserve after the static area in the first chunk.  This reserves
 * the first chunk such that it&apos;s available only through reserved
 * percpu allocation.  This is primarily used to serve module percpu
 * static areas on architectures where the addressing model has
 * limited offset range for symbol relocations to guarantee module
 * percpu symbols fall inside the relocatable range.
 *
 * @ai-&gt;dyn_size determines the number of bytes available for dynamic
 * allocation in the first chunk.  The area between @ai-&gt;static_size +
 * @ai-&gt;reserved_size + @ai-&gt;dyn_size and @ai-&gt;unit_size is unused.
 *
 * @ai-&gt;unit_size specifies unit size and must be aligned to PAGE_SIZE
 * and equal to or larger than @ai-&gt;static_size + @ai-&gt;reserved_size +
 * @ai-&gt;dyn_size.
 *
 * @ai-&gt;atom_size is the allocation atom size and used as alignment
 * for vm areas.
 *
 * @ai-&gt;alloc_size is the allocation size and always multiple of
 * @ai-&gt;atom_size.  This is larger than @ai-&gt;atom_size if
 * @ai-&gt;unit_size is larger than @ai-&gt;atom_size.
 *
 * @ai-&gt;nr_groups and @ai-&gt;groups describe virtual memory layout of
 * percpu areas.  Units which should be colocated are put into the
 * same group.  Dynamic VM areas will be allocated according to these
 * groupings.  If @ai-&gt;nr_groups is zero, a single group containing
 * all units is assumed.
 *
 * The caller should have mapped the first chunk at @base_addr and
 * copied static data to each unit.
 *
 * The first chunk will always contain a static and a dynamic region.
 * However, the static region is not managed by any chunk.  If the first
 * chunk also contains a reserved region, it is served by two chunks -
 * one for the reserved region and one for the dynamic region.  They
 * share the same vm, but use offset regions in the area allocation map.
 * The chunk serving the dynamic region is circulated in the chunk slots
 * and available for dynamic allocation like any other chunk.
 *
 * RETURNS:
 * 0 on success, -errno on failure.
 */</doc>
