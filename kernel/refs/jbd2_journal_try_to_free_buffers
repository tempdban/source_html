<dec f='linux-4.14.y/include/linux/jbd2.h' l='1365' type='int jbd2_journal_try_to_free_buffers(journal_t * , struct page * , gfp_t )'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='3401' u='c' c='ext4_releasepage'/>
<use f='linux-4.14.y/fs/ext4/super.c' l='1136' u='c' c='bdev_try_to_free_page'/>
<dec f='linux-4.14.y/fs/jbd2/journal.c' l='96' type='int jbd2_journal_try_to_free_buffers(journal_t * , struct page * , gfp_t )'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='96' c='jbd2_journal_try_to_free_buffers'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='96' u='a'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='96' u='a'/>
<def f='linux-4.14.y/fs/jbd2/transaction.c' l='1996' ll='2031' type='int jbd2_journal_try_to_free_buffers(journal_t * journal, struct page * page, gfp_t gfp_mask)'/>
<doc f='linux-4.14.y/fs/jbd2/transaction.c' l='1958'>/**
 * int jbd2_journal_try_to_free_buffers() - try to free page buffers.
 * @journal: journal for operation
 * @page: to try and free
 * @gfp_mask: we use the mask to detect how hard should we try to release
 * buffers. If __GFP_DIRECT_RECLAIM and __GFP_FS is set, we wait for commit
 * code to release the buffers.
 *
 *
 * For all the buffers on this page,
 * if they are fully written out ordered data, move them onto BUF_CLEAN
 * so try_to_free_buffers() can reap them.
 *
 * This function returns non-zero if we wish try_to_free_buffers()
 * to be called. We do this if the page is releasable by try_to_free_buffers().
 * We also do it if the page has locked or dirty buffers and the caller wants
 * us to perform sync or async writeout.
 *
 * This complicates JBD locking somewhat.  We aren&apos;t protected by the
 * BKL here.  We wish to remove the buffer from its committing or
 * running transaction&apos;s -&gt;t_datalist via __jbd2_journal_unfile_buffer.
 *
 * This may *change* the value of transaction_t-&gt;t_datalist, so anyone
 * who looks at t_datalist needs to lock against this function.
 *
 * Even worse, someone may be doing a jbd2_journal_dirty_data on this
 * buffer.  So we need to lock against that.  jbd2_journal_dirty_data()
 * will come out of the lock with the buffer dirty, which makes it
 * ineligible for release here.
 *
 * Who else is affected by this?  hmm...  Really the only contender
 * is do_get_write_access() - it could be looking at the buffer while
 * journal_try_to_free_buffer() is changing its state.  But that
 * cannot happen because we never reallocate freed data as metadata
 * while the data is part of a transaction.  Yes?
 *
 * Return 0 on failure, 1 on success
 */</doc>
<dec f='linux-4.14.y/include/linux/jbd2.h' l='1365' type='int jbd2_journal_try_to_free_buffers(journal_t * , struct page * , gfp_t )'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='3401' u='c' c='ext4_releasepage'/>
<use f='linux-4.14.y/fs/ext4/super.c' l='1136' u='c' c='bdev_try_to_free_page'/>
<dec f='linux-4.14.y/fs/jbd2/journal.c' l='96' type='int jbd2_journal_try_to_free_buffers(journal_t * , struct page * , gfp_t )'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='96' c='jbd2_journal_try_to_free_buffers'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='96' u='a'/>
<use f='linux-4.14.y/fs/jbd2/journal.c' l='96' u='a'/>
<def f='linux-4.14.y/fs/jbd2/transaction.c' l='1996' ll='2031' type='int jbd2_journal_try_to_free_buffers(journal_t * journal, struct page * page, gfp_t gfp_mask)'/>
<doc f='linux-4.14.y/fs/jbd2/transaction.c' l='1958'>/**
 * int jbd2_journal_try_to_free_buffers() - try to free page buffers.
 * @journal: journal for operation
 * @page: to try and free
 * @gfp_mask: we use the mask to detect how hard should we try to release
 * buffers. If __GFP_DIRECT_RECLAIM and __GFP_FS is set, we wait for commit
 * code to release the buffers.
 *
 *
 * For all the buffers on this page,
 * if they are fully written out ordered data, move them onto BUF_CLEAN
 * so try_to_free_buffers() can reap them.
 *
 * This function returns non-zero if we wish try_to_free_buffers()
 * to be called. We do this if the page is releasable by try_to_free_buffers().
 * We also do it if the page has locked or dirty buffers and the caller wants
 * us to perform sync or async writeout.
 *
 * This complicates JBD locking somewhat.  We aren&apos;t protected by the
 * BKL here.  We wish to remove the buffer from its committing or
 * running transaction&apos;s -&gt;t_datalist via __jbd2_journal_unfile_buffer.
 *
 * This may *change* the value of transaction_t-&gt;t_datalist, so anyone
 * who looks at t_datalist needs to lock against this function.
 *
 * Even worse, someone may be doing a jbd2_journal_dirty_data on this
 * buffer.  So we need to lock against that.  jbd2_journal_dirty_data()
 * will come out of the lock with the buffer dirty, which makes it
 * ineligible for release here.
 *
 * Who else is affected by this?  hmm...  Really the only contender
 * is do_get_write_access() - it could be looking at the buffer while
 * journal_try_to_free_buffer() is changing its state.  But that
 * cannot happen because we never reallocate freed data as metadata
 * while the data is part of a transaction.  Yes?
 *
 * Return 0 on failure, 1 on success
 */</doc>
