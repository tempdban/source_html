<dec f='linux-4.18.y/include/linux/hrtimer.h' l='486' type='int schedule_hrtimeout_range(ktime_t * expires, u64 delta, const enum hrtimer_mode mode)'/>
<use f='linux-4.18.y/fs/eventpoll.c' l='1811' u='c' c='ep_poll'/>
<use f='linux-4.18.y/fs/select.c' l='243' u='c' c='poll_schedule_timeout'/>
<use f='linux-4.18.y/kernel/signal.c' l='3077' macro='1' u='c'/>
<def f='linux-4.18.y/kernel/time/hrtimer.c' l='1990' ll='1995' type='int schedule_hrtimeout_range(ktime_t * expires, u64 delta, const enum hrtimer_mode mode)'/>
<dec f='linux-4.18.y/kernel/time/hrtimer.c' l='1996' type='int schedule_hrtimeout_range(ktime_t * , u64 , const enum hrtimer_mode )'/>
<use f='linux-4.18.y/kernel/time/hrtimer.c' l='1996' c='schedule_hrtimeout_range'/>
<use f='linux-4.18.y/kernel/time/hrtimer.c' l='1996' u='a'/>
<use f='linux-4.18.y/kernel/time/hrtimer.c' l='1996' u='a'/>
<use f='linux-4.18.y/kernel/time/hrtimer.c' l='2027' u='c' c='schedule_hrtimeout'/>
<doc f='linux-4.18.y/kernel/time/hrtimer.c' l='1958'>/**
 * schedule_hrtimeout_range - sleep until timeout
 * @expires:	timeout value (ktime_t)
 * @delta:	slack in expires timeout (ktime_t)
 * @mode:	timer mode
 *
 * Make the current task sleep until the given expiry time has
 * elapsed. The routine will return immediately unless
 * the current task state has been set (see set_current_state()).
 *
 * The @delta argument gives the kernel the freedom to schedule the
 * actual wakeup to a time that is both power and performance friendly.
 * The kernel give the normal best effort behavior for &quot;@expires+@delta&quot;,
 * but may decide to fire the timer earlier, but no earlier than @expires.
 *
 * You can set the task state as follows -
 *
 * %TASK_UNINTERRUPTIBLE - at least @timeout time is guaranteed to
 * pass before the routine returns unless the current task is explicitly
 * woken up, (e.g. by wake_up_process()).
 *
 * %TASK_INTERRUPTIBLE - the routine may return early if a signal is
 * delivered to the current task or the current task is explicitly woken
 * up.
 *
 * The current task state is guaranteed to be TASK_RUNNING when this
 * routine returns.
 *
 * Returns 0 when the timer has expired. If the task was woken before the
 * timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
 * by an explicit wakeup, it returns -EINTR.
 */</doc>
<use f='linux-4.18.y/kernel/time/timer.c' l='1995' u='c' c='usleep_range'/>
