<def f='linux-4.18.y/kernel/locking/qspinlock_stat.h' l='44' ll='60'/>
<doc f='linux-4.18.y/kernel/locking/qspinlock_stat.h' l='15'>/*
 * When queued spinlock statistical counters are enabled, the following
 * debugfs files will be created for reporting the counter values:
 *
 * &lt;debugfs&gt;/qlockstat/
 *   pv_hash_hops	- average # of hops per hashing operation
 *   pv_kick_unlock	- # of vCPU kicks issued at unlock time
 *   pv_kick_wake	- # of vCPU kicks used for computing pv_latency_wake
 *   pv_latency_kick	- average latency (ns) of vCPU kick operation
 *   pv_latency_wake	- average latency (ns) from vCPU kick to wakeup
 *   pv_lock_stealing	- # of lock stealing operations
 *   pv_spurious_wakeup	- # of spurious wakeups in non-head vCPUs
 *   pv_wait_again	- # of wait&apos;s after a queue head vCPU kick
 *   pv_wait_early	- # of early vCPU wait&apos;s
 *   pv_wait_head	- # of vCPU wait&apos;s at the queue head
 *   pv_wait_node	- # of vCPU wait&apos;s at a non-head queue node
 *   lock_pending	- # of locking operations via pending code
 *   lock_slowpath	- # of locking operations via MCS lock queue
 *
 * Writing to the &quot;reset_counters&quot; file will reset all the above counter
 * values.
 *
 * These statistical counters are implemented as per-cpu variables which are
 * summed and computed whenever the corresponding debugfs files are read. This
 * minimizes added overhead making the counters usable even in a production
 * environment.
 *
 * There may be slight difference between pv_kick_wake and pv_kick_unlock.
 */</doc>
