<dec f='linux-4.18.y/drivers/md/raid5-log.h' l='9' type='void r5l_flush_stripe_to_raid(struct r5l_log * log)'/>
<use f='linux-4.18.y/drivers/md/raid5-log.h' l='96' u='c' c='log_flush_stripe_to_raid'/>
<def f='linux-4.18.y/drivers/md/raid5-cache.c' l='1299' ll='1323' type='void r5l_flush_stripe_to_raid(struct r5l_log * log)'/>
<doc f='linux-4.18.y/drivers/md/raid5-cache.c' l='1285'>/*
 * Starting dispatch IO to raid.
 * io_unit(meta) consists of a log. There is one situation we want to avoid. A
 * broken meta in the middle of a log causes recovery can&apos;t find meta at the
 * head of log. If operations require meta at the head persistent in log, we
 * must make sure meta before it persistent in log too. A case is:
 *
 * stripe data/parity is in log, we start write stripe to raid disks. stripe
 * data/parity must be persistent in log before we do the write to raid disks.
 *
 * The solution is we restrictly maintain io_unit list order. In this case, we
 * only write stripes of an io_unit to raid disks till the io_unit is the first
 * one whose data/parity is in log.
 */</doc>
<use f='linux-4.18.y/drivers/md/raid5.c' l='6195' u='c' c='handle_active_stripes'/>
<use f='linux-4.18.y/drivers/md/raid5.c' l='6251' u='c' c='raid5_do_work'/>
<use f='linux-4.18.y/drivers/md/raid5.c' l='6338' u='c' c='raid5d'/>
