<dec f='linux-4.18.y/drivers/gpu/drm/drm_internal.h' l='80' type='int drm_getmagic(struct drm_device * dev, void * data, struct drm_file * file_priv)'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_internal.h' l='79'>/* drm_auth.c */</doc>
<def f='linux-4.18.y/drivers/gpu/drm/drm_auth.c' l='58' ll='76' type='int drm_getmagic(struct drm_device * dev, void * data, struct drm_file * file_priv)'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_auth.c' l='36'>/**
 * DOC: master and authentication
 *
 * &amp;struct drm_master is used to track groups of clients with open
 * primary/legacy device nodes. For every &amp;struct drm_file which has had at
 * least once successfully became the device master (either through the
 * SET_MASTER IOCTL, or implicitly through opening the primary device node when
 * no one else is the current master that time) there exists one &amp;drm_master.
 * This is noted in &amp;drm_file.is_master. All other clients have just a pointer
 * to the &amp;drm_master they are associated with.
 *
 * In addition only one &amp;drm_master can be the current master for a &amp;drm_device.
 * It can be switched through the DROP_MASTER and SET_MASTER IOCTL, or
 * implicitly through closing/openeing the primary device node. See also
 * drm_is_current_master().
 *
 * Clients can authenticate against the current master (if it matches their own)
 * using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
 * this allows controlled access to the device for an entire group of mutually
 * trusted clients.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='547'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='547'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='547'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_ioctl.c' l='547'/>
