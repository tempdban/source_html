<dec f='linux-4.18.y/include/linux/idr.h' l='106' type='int idr_alloc_cyclic(struct idr * , void * ptr, int start, int end, gfp_t )'/>
<use f='linux-4.18.y/fs/kernfs/dir.c' l='640' u='c' c='__kernfs_new_node'/>
<use f='linux-4.18.y/fs/notify/inotify/inotify_user.c' l='366' u='c' c='inotify_add_to_idr'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1219' u='c' c='cgroup_init_root_id'/>
<use f='linux-4.18.y/kernel/pid.c' l='192' u='c' c='alloc_pid'/>
<def f='linux-4.18.y/lib/idr.c' l='120' ll='138' type='int idr_alloc_cyclic(struct idr * idr, void * ptr, int start, int end, gfp_t gfp)'/>
<dec f='linux-4.18.y/lib/idr.c' l='139' type='int idr_alloc_cyclic(struct idr * , void * , int , int , gfp_t )'/>
<use f='linux-4.18.y/lib/idr.c' l='139' c='idr_alloc_cyclic'/>
<use f='linux-4.18.y/lib/idr.c' l='139' u='a'/>
<use f='linux-4.18.y/lib/idr.c' l='139' u='a'/>
<doc f='linux-4.18.y/lib/idr.c' l='98'>/**
 * idr_alloc_cyclic() - Allocate an ID cyclically.
 * @idr: IDR handle.
 * @ptr: Pointer to be associated with the new ID.
 * @start: The minimum ID (inclusive).
 * @end: The maximum ID (exclusive).
 * @gfp: Memory allocation flags.
 *
 * Allocates an unused ID in the range specified by @nextid and @end.  If
 * @end is &lt;= 0, it is treated as one larger than %INT_MAX.  This allows
 * callers to use @start + N as @end as long as N is within integer range.
 * The search for an unused ID will start at the last ID allocated and will
 * wrap around to @start if no free IDs are found before reaching @end.
 *
 * The caller should provide their own locking to ensure that two
 * concurrent modifications to the IDR are not possible.  Read-only
 * accesses to the IDR may be done under the RCU read lock or may
 * exclude simultaneous writers.
 *
 * Return: The newly allocated ID, -ENOMEM if memory allocation failed,
 * or -ENOSPC if no free IDs could be found.
 */</doc>
