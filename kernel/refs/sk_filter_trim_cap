<dec f='linux-4.18.y/include/linux/filter.h' l='707' type='int sk_filter_trim_cap(struct sock * sk, struct sk_buff * skb, unsigned int cap)'/>
<use f='linux-4.18.y/include/linux/filter.h' l='710' u='c' c='sk_filter'/>
<def f='linux-4.18.y/net/core/filter.c' l='85' ll='121' type='int sk_filter_trim_cap(struct sock * sk, struct sk_buff * skb, unsigned int cap)'/>
<dec f='linux-4.18.y/net/core/filter.c' l='122' type='int sk_filter_trim_cap(struct sock * , struct sk_buff * , unsigned int )'/>
<use f='linux-4.18.y/net/core/filter.c' l='122' c='sk_filter_trim_cap'/>
<use f='linux-4.18.y/net/core/filter.c' l='122' u='a'/>
<use f='linux-4.18.y/net/core/filter.c' l='122' u='a'/>
<doc f='linux-4.18.y/net/core/filter.c' l='72'>/**
 *	sk_filter_trim_cap - run a packet through a socket filter
 *	@sk: sock associated with &amp;sk_buff
 *	@skb: buffer to filter
 *	@cap: limit on how short the eBPF program may trim the packet
 *
 * Run the eBPF program and then cut skb-&gt;data to correct size returned by
 * the program. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
 * than pkt_len we keep whole skb-&gt;data. This is the socket level
 * wrapper to BPF_PROG_RUN. It returns 0 if the packet should
 * be accepted or -EPERM if the packet should be tossed.
 *
 */</doc>
<use f='linux-4.18.y/net/core/sock.c' l='498' u='c' c='__sk_receive_skb'/>
<use f='linux-4.18.y/net/ipv4/tcp_ipv4.c' l='1648' u='c' c='tcp_filter'/>
<use f='linux-4.18.y/net/ipv4/udp.c' l='1997' u='c' c='udp_queue_rcv_skb'/>
