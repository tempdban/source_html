<dec f='linux-4.18.y/include/linux/stop_machine.h' l='35' type='int stop_cpus(const struct cpumask * cpumask, cpu_stop_fn_t fn, void * arg)'/>
<def f='linux-4.18.y/kernel/stop_machine.c' l='432' ll='441' type='int stop_cpus(const struct cpumask * cpumask, cpu_stop_fn_t fn, void * arg)'/>
<use f='linux-4.18.y/kernel/stop_machine.c' l='616' u='c' c='stop_machine_cpuslocked'/>
<doc f='linux-4.18.y/kernel/stop_machine.c' l='404'>/**
 * stop_cpus - stop multiple cpus
 * @cpumask: cpus to stop
 * @fn: function to execute
 * @arg: argument to @fn
 *
 * Execute @fn(@arg) on online cpus in @cpumask.  On each target cpu,
 * @fn is run in a process context with the highest priority
 * preempting any task on the cpu and monopolizing it.  This function
 * returns after all executions are complete.
 *
 * This function doesn&apos;t guarantee the cpus in @cpumask stay online
 * till @fn completes.  If some cpus go down in the middle, execution
 * on the cpu may happen partially or fully on different cpus.  @fn
 * should either be ready for that or the caller should ensure that
 * the cpus stay online until this function completes.
 *
 * All stop_cpus() calls are serialized making it safe for @fn to wait
 * for all cpus to start executing it.
 *
 * CONTEXT:
 * Might sleep.
 *
 * RETURNS:
 * -ENOENT if @fn(@arg) was not executed at all because all cpus in
 * @cpumask were offline; otherwise, 0 if all executions of @fn
 * returned 0, any non zero return value if any returned non zero.
 */</doc>
