<dec f='linux-4.14.y/include/linux/glob.h' l='8' type='bool glob_match(const char * pat, const char * str)'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='4629' u='c' c='ata_dev_blacklisted'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='4632' u='c' c='ata_dev_blacklisted'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='3757' u='c' c='ftrace_match'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='368' u='c' c='regex_match_glob'/>
<def f='linux-4.14.y/lib/glob.c' l='40' ll='122' type='bool glob_match(const char * pat, const char * str)'/>
<dec f='linux-4.14.y/lib/glob.c' l='123' type='bool glob_match(const char * , const char * )'/>
<use f='linux-4.14.y/lib/glob.c' l='123' c='glob_match'/>
<use f='linux-4.14.y/lib/glob.c' l='123' u='a'/>
<use f='linux-4.14.y/lib/glob.c' l='123' u='a'/>
<doc f='linux-4.14.y/lib/glob.c' l='12'>/**
 * glob_match - Shell-style pattern matching, like !fnmatch(pat, str, 0)
 * @pat: Shell-style pattern to match, e.g. &quot;*.[ch]&quot;.
 * @str: String to match.  The pattern must match the entire string.
 *
 * Perform shell-style glob matching, returning true (1) if the match
 * succeeds, or false (0) if it fails.  Equivalent to !fnmatch(@pat, @str, 0).
 *
 * Pattern metacharacters are ?, *, [ and \.
 * (And, inside character classes, !, - and ].)
 *
 * This is small and simple implementation intended for device blacklists
 * where a string is matched against a number of patterns.  Thus, it
 * does not preprocess the patterns.  It is non-recursive, and run-time
 * is at most quadratic: strlen(@str)*strlen(@pat).
 *
 * An example of the worst case is glob_match(&quot;*aaaaa&quot;, &quot;aaaaaaaaaa&quot;);
 * it takes 6 passes over the pattern before matching the string.
 *
 * Like !fnmatch(@pat, @str, 0) and unlike the shell, this does NOT
 * treat / or leading . specially; it isn&apos;t actually used for pathnames.
 *
 * Note that according to glob(7) (and unlike bash), character classes
 * are complemented by a leading !; this does not support the regex-style
 * [^a-z] syntax.
 *
 * An opening bracket without a matching close is matched literally.
 */</doc>
<dec f='linux-4.14.y/include/linux/glob.h' l='8' type='bool glob_match(const char * pat, const char * str)'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='4629' u='c' c='ata_dev_blacklisted'/>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='4632' u='c' c='ata_dev_blacklisted'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='3757' u='c' c='ftrace_match'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='368' u='c' c='regex_match_glob'/>
<def f='linux-4.14.y/lib/glob.c' l='40' ll='122' type='bool glob_match(const char * pat, const char * str)'/>
<dec f='linux-4.14.y/lib/glob.c' l='123' type='bool glob_match(const char * , const char * )'/>
<use f='linux-4.14.y/lib/glob.c' l='123' c='glob_match'/>
<use f='linux-4.14.y/lib/glob.c' l='123' u='a'/>
<use f='linux-4.14.y/lib/glob.c' l='123' u='a'/>
<doc f='linux-4.14.y/lib/glob.c' l='12'>/**
 * glob_match - Shell-style pattern matching, like !fnmatch(pat, str, 0)
 * @pat: Shell-style pattern to match, e.g. &quot;*.[ch]&quot;.
 * @str: String to match.  The pattern must match the entire string.
 *
 * Perform shell-style glob matching, returning true (1) if the match
 * succeeds, or false (0) if it fails.  Equivalent to !fnmatch(@pat, @str, 0).
 *
 * Pattern metacharacters are ?, *, [ and \.
 * (And, inside character classes, !, - and ].)
 *
 * This is small and simple implementation intended for device blacklists
 * where a string is matched against a number of patterns.  Thus, it
 * does not preprocess the patterns.  It is non-recursive, and run-time
 * is at most quadratic: strlen(@str)*strlen(@pat).
 *
 * An example of the worst case is glob_match(&quot;*aaaaa&quot;, &quot;aaaaaaaaaa&quot;);
 * it takes 6 passes over the pattern before matching the string.
 *
 * Like !fnmatch(@pat, @str, 0) and unlike the shell, this does NOT
 * treat / or leading . specially; it isn&apos;t actually used for pathnames.
 *
 * Note that according to glob(7) (and unlike bash), character classes
 * are complemented by a leading !; this does not support the regex-style
 * [^a-z] syntax.
 *
 * An opening bracket without a matching close is matched literally.
 */</doc>
