<def f='linux-4.14.y/kernel/rcu/srcutree.c' l='814' ll='852' type='void __call_srcu(struct srcu_struct * sp, struct callback_head * rhp, rcu_callback_t func, bool do_norm)'/>
<use f='linux-4.14.y/kernel/rcu/srcutree.c' l='874' u='c' c='call_srcu'/>
<use f='linux-4.14.y/kernel/rcu/srcutree.c' l='897' u='c' c='__synchronize_srcu'/>
<doc f='linux-4.14.y/kernel/rcu/srcutree.c' l='786'>/*
 * Enqueue an SRCU callback on the srcu_data structure associated with
 * the current CPU and the specified srcu_struct structure, initiating
 * grace-period processing if it is not already running.
 *
 * Note that all CPUs must agree that the grace period extended beyond
 * all pre-existing SRCU read-side critical section.  On systems with
 * more than one CPU, this means that when &quot;func()&quot; is invoked, each CPU
 * is guaranteed to have executed a full memory barrier since the end of
 * its last corresponding SRCU read-side critical section whose beginning
 * preceded the call to call_rcu().  It also means that each CPU executing
 * an SRCU read-side critical section that continues beyond the start of
 * &quot;func()&quot; must have executed a memory barrier after the call_rcu()
 * but before the beginning of that SRCU read-side critical section.
 * Note that these guarantees include CPUs that are offline, idle, or
 * executing in user mode, as well as CPUs that are executing in the kernel.
 *
 * Furthermore, if CPU A invoked call_rcu() and CPU B invoked the
 * resulting SRCU callback function &quot;func()&quot;, then both CPU A and CPU
 * B are guaranteed to execute a full memory barrier during the time
 * interval between the call to call_rcu() and the invocation of &quot;func()&quot;.
 * This guarantee applies even if CPU A and CPU B are the same CPU (but
 * again only if the system has more than one CPU).
 *
 * Of course, these guarantees apply only for invocations of call_srcu(),
 * srcu_read_lock(), and srcu_read_unlock() that are all passed the same
 * srcu_struct structure.
 */</doc>
<def f='linux-4.14.y/kernel/rcu/srcutree.c' l='814' ll='852' type='void __call_srcu(struct srcu_struct * sp, struct callback_head * rhp, rcu_callback_t func, bool do_norm)'/>
<use f='linux-4.14.y/kernel/rcu/srcutree.c' l='874' u='c' c='call_srcu'/>
<use f='linux-4.14.y/kernel/rcu/srcutree.c' l='897' u='c' c='__synchronize_srcu'/>
<doc f='linux-4.14.y/kernel/rcu/srcutree.c' l='786'>/*
 * Enqueue an SRCU callback on the srcu_data structure associated with
 * the current CPU and the specified srcu_struct structure, initiating
 * grace-period processing if it is not already running.
 *
 * Note that all CPUs must agree that the grace period extended beyond
 * all pre-existing SRCU read-side critical section.  On systems with
 * more than one CPU, this means that when &quot;func()&quot; is invoked, each CPU
 * is guaranteed to have executed a full memory barrier since the end of
 * its last corresponding SRCU read-side critical section whose beginning
 * preceded the call to call_rcu().  It also means that each CPU executing
 * an SRCU read-side critical section that continues beyond the start of
 * &quot;func()&quot; must have executed a memory barrier after the call_rcu()
 * but before the beginning of that SRCU read-side critical section.
 * Note that these guarantees include CPUs that are offline, idle, or
 * executing in user mode, as well as CPUs that are executing in the kernel.
 *
 * Furthermore, if CPU A invoked call_rcu() and CPU B invoked the
 * resulting SRCU callback function &quot;func()&quot;, then both CPU A and CPU
 * B are guaranteed to execute a full memory barrier during the time
 * interval between the call to call_rcu() and the invocation of &quot;func()&quot;.
 * This guarantee applies even if CPU A and CPU B are the same CPU (but
 * again only if the system has more than one CPU).
 *
 * Of course, these guarantees apply only for invocations of call_srcu(),
 * srcu_read_lock(), and srcu_read_unlock() that are all passed the same
 * srcu_struct structure.
 */</doc>
