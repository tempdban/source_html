<def f='linux-4.14.y/include/net/netlink.h' l='222' ll='226'/>
<size>16</size>
<doc f='linux-4.14.y/include/net/netlink.h' l='188'>/**
 * struct nla_policy - attribute validation policy
 * @type: Type of attribute or NLA_UNSPEC
 * @len: Type specific length of payload
 *
 * Policies are defined as arrays of this struct, the array must be
 * accessible by attribute type up to the highest identifier to be expected.
 *
 * Meaning of `len&apos; field:
 *    NLA_STRING           Maximum length of string
 *    NLA_NUL_STRING       Maximum length of string (excluding NUL)
 *    NLA_FLAG             Unused
 *    NLA_BINARY           Maximum length of attribute payload
 *    NLA_NESTED           Don&apos;t use `len&apos; field -- length verification is
 *                         done by checking len of nested header (or empty)
 *    NLA_NESTED_COMPAT    Minimum length of structure payload
 *    NLA_U8, NLA_U16,
 *    NLA_U32, NLA_U64,
 *    NLA_S8, NLA_S16,
 *    NLA_S32, NLA_S64,
 *    NLA_MSECS            Leaving the length field zero will verify the
 *                         given type fits, using it verifies minimum length
 *                         just like &quot;All other&quot;
 *    NLA_BITFIELD32      A 32-bit bitmap/bitselector attribute
 *    All other            Minimum length of attribute payload
 *
 * Example:
 * static const struct nla_policy my_policy[ATTR_MAX+1] = {
 * 	[ATTR_FOO] = { .type = NLA_U16 },
 *	[ATTR_BAR] = { .type = NLA_STRING, .len = BARSIZ },
 *	[ATTR_BAZ] = { .len = sizeof(struct mystruct) },
 *	[ATTR_GOO] = { .type = NLA_BITFIELD32, .validation_data = &amp;myvalidflags },
 * };
 */</doc>
<mbr r='nla_policy::type' o='0' t='u16'/>
<mbr r='nla_policy::len' o='16' t='u16'/>
<mbr r='nla_policy::validation_data' o='64' t='void *'/>
