<def f='linux-4.18.y/arch/x86/include/asm/fpu/internal.h' l='410' ll='429' type='int copy_fpregs_to_fpstate(struct fpu * fpu)'/>
<use f='linux-4.18.y/arch/x86/include/asm/fpu/internal.h' l='532' u='c' c='switch_fpu_prepare'/>
<doc f='linux-4.18.y/arch/x86/include/asm/fpu/internal.h' l='400'>/*
 * These must be called with preempt disabled. Returns
 * &apos;true&apos; if the FPU state is still intact and we can
 * keep registers active.
 *
 * The legacy FNSAVE instruction cleared all FPU state
 * unconditionally, so registers are essentially destroyed.
 * Modern FPU state can be kept in registers, if there are
 * no pending FP exceptions.
 */</doc>
<use f='linux-4.18.y/arch/x86/kernel/fpu/core.c' l='109' u='c' c='__kernel_fpu_begin'/>
<use f='linux-4.18.y/arch/x86/kernel/fpu/core.c' l='153' u='c' c='fpu__save'/>
<use f='linux-4.18.y/arch/x86/kernel/fpu/core.c' l='213' u='c' c='fpu__copy'/>
<use f='linux-4.18.y/arch/x86/kvm/x86.c' l='8331' u='c' c='kvm_load_guest_fpu'/>
<use f='linux-4.18.y/arch/x86/kvm/x86.c' l='8343' u='c' c='kvm_put_guest_fpu'/>
