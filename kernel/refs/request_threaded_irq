<dec f='linux-4.18.y/include/linux/interrupt.h' l='139' type='int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long flags, const char * name, void * dev)'/>
<use f='linux-4.18.y/include/linux/interrupt.h' l='147' u='c' c='request_irq'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c' l='375' u='c' c='vmw_irq_install'/>
<use f='linux-4.18.y/drivers/iommu/amd_iommu_init.c' l='1889' u='c' c='iommu_setup_msi'/>
<use f='linux-4.18.y/drivers/iommu/intel-svm.c' l='138' u='c' c='intel_svm_enable_prq'/>
<use f='linux-4.18.y/drivers/net/phy/phy.c' l='726' u='c' c='phy_start_interrupts'/>
<use f='linux-4.18.y/drivers/pci/irq.c' l='94' u='c' c='pci_request_irq'/>
<use f='linux-4.18.y/kernel/irq/devres.c' l='67' u='c' c='devm_request_threaded_irq'/>
<def f='linux-4.18.y/kernel/irq/manage.c' l='1785' ll='1868' type='int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char * devname, void * dev_id)'/>
<dec f='linux-4.18.y/kernel/irq/manage.c' l='1869' type='int request_threaded_irq(unsigned int , irq_handler_t , irq_handler_t , unsigned long , const char * , void * )'/>
<use f='linux-4.18.y/kernel/irq/manage.c' l='1869' c='request_threaded_irq'/>
<use f='linux-4.18.y/kernel/irq/manage.c' l='1869' u='a'/>
<use f='linux-4.18.y/kernel/irq/manage.c' l='1869' u='a'/>
<use f='linux-4.18.y/kernel/irq/manage.c' l='1902' u='c' c='request_any_context_irq'/>
<doc f='linux-4.18.y/kernel/irq/manage.c' l='1743'>/**
 *	request_threaded_irq - allocate an interrupt line
 *	@irq: Interrupt line to allocate
 *	@handler: Function to be called when the IRQ occurs.
 *		  Primary handler for threaded interrupts
 *		  If NULL and thread_fn != NULL the default
 *		  primary handler is installed
 *	@thread_fn: Function called from the irq handler thread
 *		    If NULL, no irq thread is created
 *	@irqflags: Interrupt type flags
 *	@devname: An ascii name for the claiming device
 *	@dev_id: A cookie passed back to the handler function
 *
 *	This call allocates interrupt resources and enables the
 *	interrupt line and IRQ handling. From the point this
 *	call is made your handler function may be invoked. Since
 *	your handler function must clear any interrupt the board
 *	raises, you must take care both to initialise your hardware
 *	and to set up the interrupt handler in the right order.
 *
 *	If you want to set up a threaded irq handler for your device
 *	then you need to supply @handler and @thread_fn. @handler is
 *	still called in hard interrupt context and has to check
 *	whether the interrupt originates from the device. If yes it
 *	needs to disable the interrupt on the device and return
 *	IRQ_WAKE_THREAD which will wake up the handler thread and run
 *	@thread_fn. This split handler design is necessary to support
 *	shared interrupts.
 *
 *	Dev_id must be globally unique. Normally the address of the
 *	device data structure is used as the cookie. Since the handler
 *	receives this value it makes sense to use it.
 *
 *	If your interrupt is shared you must pass a non NULL dev_id
 *	as this is required when freeing the interrupt.
 *
 *	Flags:
 *
 *	IRQF_SHARED		Interrupt is shared
 *	IRQF_TRIGGER_*		Specify active edge(s) or level
 *
 */</doc>
