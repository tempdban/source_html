<dec f='linux-4.14.y/include/linux/trace_clock.h' l='19' type='u64 trace_clock()'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1166'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1166'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1166'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1166'/>
<def f='linux-4.14.y/kernel/trace/trace_clock.c' l='56' ll='59' type='u64 trace_clock()'/>
<dec f='linux-4.14.y/kernel/trace/trace_clock.c' l='60' type='u64 trace_clock()'/>
<use f='linux-4.14.y/kernel/trace/trace_clock.c' l='60' c='trace_clock'/>
<use f='linux-4.14.y/kernel/trace/trace_clock.c' l='60' u='a'/>
<use f='linux-4.14.y/kernel/trace/trace_clock.c' l='60' u='a'/>
<doc f='linux-4.14.y/kernel/trace/trace_clock.c' l='48'>/*
 * trace_clock(): &apos;between&apos; trace clock. Not completely serialized,
 * but not completely incorrect when crossing CPUs either.
 *
 * This is based on cpu_clock(), which will allow at most ~1 jiffy of
 * jitter between CPUs. So it&apos;s a pretty scalable clock, but there
 * can be offsets in the trace data.
 */</doc>
