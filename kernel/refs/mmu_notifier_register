<dec f='linux-4.18.y/include/linux/mmu_notifier.h' l='212' type='int mmu_notifier_register(struct mmu_notifier * mn, struct mm_struct * mm)'/>
<use f='linux-4.18.y/drivers/iommu/amd_iommu_v2.c' l='681' u='c' c='amd_iommu_bind_pasid'/>
<use f='linux-4.18.y/drivers/iommu/intel-svm.c' l='409' u='c' c='intel_svm_bind_mm'/>
<def f='linux-4.18.y/mm/mmu_notifier.c' l='334' ll='337' type='int mmu_notifier_register(struct mmu_notifier * mn, struct mm_struct * mm)'/>
<dec f='linux-4.18.y/mm/mmu_notifier.c' l='338' type='int mmu_notifier_register(struct mmu_notifier * , struct mm_struct * )'/>
<use f='linux-4.18.y/mm/mmu_notifier.c' l='338' c='mmu_notifier_register'/>
<use f='linux-4.18.y/mm/mmu_notifier.c' l='338' u='a'/>
<use f='linux-4.18.y/mm/mmu_notifier.c' l='338' u='a'/>
<doc f='linux-4.18.y/mm/mmu_notifier.c' l='321'>/*
 * Must not hold mmap_sem nor any other VM related lock when calling
 * this registration function. Must also ensure mm_users can&apos;t go down
 * to zero while this runs to avoid races with mmu_notifier_release,
 * so mm has to be current-&gt;mm or the mm should be pinned safely such
 * as with get_task_mm(). If the mm is not current-&gt;mm, the mm_users
 * pin should be released by calling mmput after mmu_notifier_register
 * returns. mmu_notifier_unregister must be always called to
 * unregister the notifier. mm_count is automatically pinned to allow
 * mmu_notifier_unregister to safely run at any time later, before or
 * after exit_mmap. -&gt;release will always be called before exit_mmap
 * frees the pages.
 */</doc>
<use f='linux-4.18.y/virt/kvm/kvm_main.c' l='509' u='c' c='kvm_init_mmu_notifier'/>
