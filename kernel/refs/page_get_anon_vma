<dec f='linux-4.14.y/include/linux/rmap.h' l='163' type='struct anon_vma * page_get_anon_vma(struct page * page)'/>
<def f='linux-4.14.y/mm/rmap.c' l='464' ll='498' type='struct anon_vma * page_get_anon_vma(struct page * page)'/>
<doc f='linux-4.14.y/mm/rmap.c' l='441'>/*
 * Getting a lock on a stable anon_vma from a page off the LRU is tricky!
 *
 * Since there is no serialization what so ever against page_remove_rmap()
 * the best this function can do is return a locked anon_vma that might
 * have been relevant to this page.
 *
 * The page might have been remapped to a different anon_vma or the anon_vma
 * returned may already be freed (and even reused).
 *
 * In case it was remapped to a different anon_vma, the new anon_vma will be a
 * child of the old anon_vma, and the anon_vma lifetime rules will therefore
 * ensure that any anon_vma obtained from the page will still be valid for as
 * long as we observe page_mapped() [ hence all those page_mapped() tests ].
 *
 * All users of this function must be very careful when walking the anon_vma
 * chain and verify that the page in question is indeed mapped in it
 * [ something equivalent to page_mapped_in_vma() ].
 *
 * Since anon_vma&apos;s slab is DESTROY_BY_RCU and we know from page_remove_rmap()
 * that the anon_vma pointer from page-&gt;mapping is valid if there is a
 * mapcount, we can dereference the anon_vma after observing those.
 */</doc>
<dec f='linux-4.14.y/include/linux/rmap.h' l='163' type='struct anon_vma * page_get_anon_vma(struct page * page)'/>
<def f='linux-4.14.y/mm/rmap.c' l='464' ll='498' type='struct anon_vma * page_get_anon_vma(struct page * page)'/>
<doc f='linux-4.14.y/mm/rmap.c' l='441'>/*
 * Getting a lock on a stable anon_vma from a page off the LRU is tricky!
 *
 * Since there is no serialization what so ever against page_remove_rmap()
 * the best this function can do is return a locked anon_vma that might
 * have been relevant to this page.
 *
 * The page might have been remapped to a different anon_vma or the anon_vma
 * returned may already be freed (and even reused).
 *
 * In case it was remapped to a different anon_vma, the new anon_vma will be a
 * child of the old anon_vma, and the anon_vma lifetime rules will therefore
 * ensure that any anon_vma obtained from the page will still be valid for as
 * long as we observe page_mapped() [ hence all those page_mapped() tests ].
 *
 * All users of this function must be very careful when walking the anon_vma
 * chain and verify that the page in question is indeed mapped in it
 * [ something equivalent to page_mapped_in_vma() ].
 *
 * Since anon_vma&apos;s slab is DESTROY_BY_RCU and we know from page_remove_rmap()
 * that the anon_vma pointer from page-&gt;mapping is valid if there is a
 * mapcount, we can dereference the anon_vma after observing those.
 */</doc>
