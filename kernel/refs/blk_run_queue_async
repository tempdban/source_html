<dec f='linux-4.14.y/include/linux/blkdev.h' l='994' type='void blk_run_queue_async(struct request_queue * q)'/>
<use f='linux-4.14.y/block/blk-core.c' l='267' u='c' c='blk_start_queue_async'/>
<def f='linux-4.14.y/block/blk-core.c' l='415' ll='422' type='void blk_run_queue_async(struct request_queue * q)'/>
<dec f='linux-4.14.y/block/blk-core.c' l='423' type='void blk_run_queue_async(struct request_queue * )'/>
<use f='linux-4.14.y/block/blk-core.c' l='423' c='blk_run_queue_async'/>
<use f='linux-4.14.y/block/blk-core.c' l='423' u='a'/>
<use f='linux-4.14.y/block/blk-core.c' l='423' u='a'/>
<use f='linux-4.14.y/block/blk-core.c' l='3308' u='c' c='queue_unplugged'/>
<doc f='linux-4.14.y/block/blk-core.c' l='402'>/**
 * blk_run_queue_async - run a single device queue in workqueue context
 * @q:	The queue to run
 *
 * Description:
 *    Tells kblockd to perform the equivalent of @blk_run_queue on behalf
 *    of us.
 *
 * Note:
 *    Since it is not allowed to run q-&gt;delay_work after blk_cleanup_queue()
 *    has canceled q-&gt;delay_work, callers must hold the queue lock to avoid
 *    race conditions between blk_cleanup_queue() and blk_run_queue_async().
 */</doc>
<use f='linux-4.14.y/block/blk-flush.c' l='268' u='c' c='flush_end_io'/>
<use f='linux-4.14.y/block/blk-flush.c' l='384' u='c' c='flush_data_end_io'/>
<use f='linux-4.14.y/drivers/md/dm-rq.c' l='199' u='c' c='rq_completed'/>
<use f='linux-4.14.y/drivers/md/dm-table.c' l='2019' u='c' c='dm_table_run_md_queue_async'/>
<use f='linux-4.14.y/drivers/scsi/scsi_transport_fc.c' l='3692' u='c' c='fc_bsg_goose_queue'/>
