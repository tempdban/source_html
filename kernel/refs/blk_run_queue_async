<dec f='linux-4.18.y/include/linux/blkdev.h' l='1001' type='void blk_run_queue_async(struct request_queue * q)'/>
<use f='linux-4.18.y/block/blk-core.c' l='340' u='c' c='blk_start_queue_async'/>
<def f='linux-4.18.y/block/blk-core.c' l='507' ll='514' type='void blk_run_queue_async(struct request_queue * q)'/>
<dec f='linux-4.18.y/block/blk-core.c' l='515' type='void blk_run_queue_async(struct request_queue * )'/>
<use f='linux-4.18.y/block/blk-core.c' l='515' c='blk_run_queue_async'/>
<use f='linux-4.18.y/block/blk-core.c' l='515' u='a'/>
<use f='linux-4.18.y/block/blk-core.c' l='515' u='a'/>
<use f='linux-4.18.y/block/blk-core.c' l='3637' u='c' c='queue_unplugged'/>
<doc f='linux-4.18.y/block/blk-core.c' l='494'>/**
 * blk_run_queue_async - run a single device queue in workqueue context
 * @q:	The queue to run
 *
 * Description:
 *    Tells kblockd to perform the equivalent of @blk_run_queue on behalf
 *    of us.
 *
 * Note:
 *    Since it is not allowed to run q-&gt;delay_work after blk_cleanup_queue()
 *    has canceled q-&gt;delay_work, callers must hold the queue lock to avoid
 *    race conditions between blk_cleanup_queue() and blk_run_queue_async().
 */</doc>
<use f='linux-4.18.y/block/blk-flush.c' l='275' u='c' c='flush_end_io'/>
<use f='linux-4.18.y/block/blk-flush.c' l='401' u='c' c='flush_data_end_io'/>
<use f='linux-4.18.y/drivers/md/dm-rq.c' l='199' u='c' c='rq_completed'/>
<use f='linux-4.18.y/drivers/md/dm-table.c' l='2098' u='c' c='dm_table_run_md_queue_async'/>
<use f='linux-4.18.y/drivers/scsi/scsi_transport_fc.c' l='3693' u='c' c='fc_bsg_goose_queue'/>
