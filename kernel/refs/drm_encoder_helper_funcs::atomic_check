<dec f='linux-4.18.y/include/drm/drm_modeset_helper_vtables.h' l='760' type='int (*)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *)'/>
<offset>704</offset>
<doc f='linux-4.18.y/include/drm/drm_modeset_helper_vtables.h' l='724'>/**
	 * @atomic_check:
	 *
	 * This callback is used to validate encoder state for atomic drivers.
	 * Since the encoder is the object connecting the CRTC and connector it
	 * gets passed both states, to be able to validate interactions and
	 * update the CRTC to match what the encoder needs for the requested
	 * connector.
	 *
	 * Since this provides a strict superset of the functionality of
	 * @mode_fixup (the requested and adjusted modes are both available
	 * through the passed in &amp;struct drm_crtc_state) @mode_fixup is not
	 * called when @atomic_check is implemented.
	 *
	 * This function is used by the atomic helpers, but it is optional.
	 *
	 * NOTE:
	 *
	 * This function is called in the check phase of an atomic update. The
	 * driver is not allowed to change anything outside of the free-standing
	 * state objects passed-in or assembled in the overall &amp;drm_atomic_state
	 * update tracking structure.
	 *
	 * Also beware that userspace can request its own custom modes, neither
	 * core nor helpers filter modes to the list of probe modes reported by
	 * the GETCONNECTOR IOCTL and stored in &amp;drm_connector.modes. To ensure
	 * that modes are filtered consistently put any encoder constraints and
	 * limits checks into @mode_valid.
	 *
	 * RETURNS:
	 *
	 * 0 on success, -EINVAL if the state or the transition can&apos;t be
	 * supported, -ENOMEM on memory allocation failure and -EDEADLK if an
	 * attempt to obtain another state object ran into a &amp;drm_modeset_lock
	 * deadlock.
	 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='411' u='r' c='mode_fixup'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='412' u='r' c='mode_fixup'/>
