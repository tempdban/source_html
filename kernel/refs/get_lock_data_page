<dec f='linux-4.14.y/fs/f2fs/f2fs.h' l='2610' type='struct page * get_lock_data_page(struct inode * inode, unsigned long index, bool for_write)'/>
<def f='linux-4.14.y/fs/f2fs/data.c' l='704' ll='725' type='struct page * get_lock_data_page(struct inode * inode, unsigned long index, bool for_write)'/>
<use f='linux-4.14.y/fs/f2fs/data.c' l='775' u='c' c='get_new_data_page'/>
<doc f='linux-4.14.y/fs/f2fs/data.c' l='699'>/*
 * If it tries to access a hole, return an error.
 * Because, the callers, functions in dir.c and GC, should be able to know
 * whether this page exists or not.
 */</doc>
<use f='linux-4.14.y/fs/f2fs/dir.c' l='766' u='c' c='f2fs_empty_dir'/>
<use f='linux-4.14.y/fs/f2fs/dir.c' l='876' u='c' c='f2fs_readdir'/>
<use f='linux-4.14.y/fs/f2fs/file.c' l='547' u='c' c='truncate_partial_data_page'/>
<use f='linux-4.14.y/fs/f2fs/file.c' l='1055' u='c' c='__clone_blkaddrs'/>
<use f='linux-4.14.y/fs/f2fs/file.c' l='2146' u='c' c='f2fs_defragment_range'/>
<use f='linux-4.14.y/fs/f2fs/gc.c' l='729' u='c' c='move_data_page'/>
