<dec f='linux-4.14.y/include/net/tcp.h' l='705' type='u32 __tcp_select_window(struct sock * sk)'/>
<doc f='linux-4.14.y/include/net/tcp.h' l='701'>/* Choose a new window, without checks for shrinking, and without
 * scaling applied to the result.  The caller does these things
 * if necessary.  This is a &quot;raw&quot; window selection.
 */</doc>
<use f='linux-4.14.y/net/ipv4/tcp.c' l='1569' u='c' c='tcp_cleanup_rbuf'/>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='5126' u='c' c='__tcp_ack_snd_check'/>
<use f='linux-4.14.y/net/ipv4/tcp_output.c' l='273' u='c' c='tcp_select_window'/>
<def f='linux-4.14.y/net/ipv4/tcp_output.c' l='2598' ll='2674' type='u32 __tcp_select_window(struct sock * sk)'/>
<doc f='linux-4.14.y/net/ipv4/tcp_output.c' l='2546'>/* This function returns the amount that we can raise the
 * usable window based on the following constraints
 *
 * 1. The window can never be shrunk once it is offered (RFC 793)
 * 2. We limit memory per socket
 *
 * RFC 1122:
 * &quot;the suggested [SWS] avoidance algorithm for the receiver is to keep
 *  RECV.NEXT + RCV.WIN fixed until:
 *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;
 *
 * i.e. don&apos;t raise the right edge of the window until you can raise
 * it at least MSS bytes.
 *
 * Unfortunately, the recommended algorithm breaks header prediction,
 * since header prediction assumes th-&gt;window stays fixed.
 *
 * Strictly speaking, keeping th-&gt;window fixed violates the receiver
 * side SWS prevention criteria. The problem is that under this rule
 * a stream of single byte packets will cause the right side of the
 * window to always advance by a single byte.
 *
 * Of course, if the sender implements sender side SWS prevention
 * then this will not be a problem.
 *
 * BSD seems to make the following compromise:
 *
 *	If the free space is less than the 1/4 of the maximum
 *	space available and the free space is less than 1/2 mss,
 *	then set the window to 0.
 *	[ Actually, bsd uses MSS and 1/4 of maximal _window_ ]
 *	Otherwise, just prevent the window from shrinking
 *	and from being larger than the largest representable value.
 *
 * This prevents incremental opening of the window in the regime
 * where TCP is limited by the speed of the reader side taking
 * data out of the TCP receive queue. It does nothing about
 * those cases where the window is constrained on the sender side
 * because the pipeline is full.
 *
 * BSD also seems to &quot;accidentally&quot; limit itself to windows that are a
 * multiple of MSS, at least until the free space gets quite small.
 * This would appear to be a side effect of the mbuf implementation.
 * Combining these two algorithms results in the observed behavior
 * of having a fixed window size at almost all times.
 *
 * Below we obtain similar behavior by forcing the offered window to
 * a multiple of the mss when it is feasible to do so.
 *
 * Note, we don&apos;t &quot;adjust&quot; for TIMESTAMP or SACK option bytes.
 * Regular options like TIMESTAMP are taken into account.
 */</doc>
