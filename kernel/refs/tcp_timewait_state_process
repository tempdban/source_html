<dec f='linux-4.14.y/include/net/tcp.h' l='404' type='enum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock * tw, struct sk_buff * skb, const struct tcphdr * th)'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1795' u='c' c='tcp_v4_rcv'/>
<def f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='91' ll='246' type='enum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock * tw, struct sk_buff * skb, const struct tcphdr * th)'/>
<dec f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='247' type='enum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock * , struct sk_buff * , const struct tcphdr * )'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='247' c='tcp_timewait_state_process'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='247' u='a'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='247' u='a'/>
<doc f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='61'>/*
 * * Main purpose of TIME-WAIT state is to close connection gracefully,
 *   when one of ends sits in LAST-ACK or CLOSING retransmitting FIN
 *   (and, probably, tail of data) and one or more our ACKs are lost.
 * * What is TIME-WAIT timeout? It is associated with maximal packet
 *   lifetime in the internet, which results in wrong conclusion, that
 *   it is set to catch &quot;old duplicate segments&quot; wandering out of their path.
 *   It is not quite correct. This timeout is calculated so that it exceeds
 *   maximal retransmission timeout enough to allow to lose one (or more)
 *   segments sent by peer and our ACKs. This time may be calculated from RTO.
 * * When TIME-WAIT socket receives RST, it means that another end
 *   finally closed and we are allowed to kill TIME-WAIT too.
 * * Second purpose of TIME-WAIT is catching old duplicate segments.
 *   Well, certainly it is pure paranoia, but if we load TIME-WAIT
 *   with this semantics, we MUST NOT kill TIME-WAIT state with RSTs.
 * * If we invented some more clever way to catch duplicates
 *   (f.e. based on PAWS), we could truncate TIME-WAIT to several RTOs.
 *
 * The algorithm below is based on FORMAL INTERPRETATION of RFCs.
 * When you compare it to RFCs, please, read section SEGMENT ARRIVES
 * from the very beginning.
 *
 * NOTE. With recycling (and later with fin-wait-2) TW bucket
 * is _not_ stateless. It means, that strictly speaking we must
 * spinlock it. I do not want! Well, probability of misbehaviour
 * is ridiculously low and, seems, we could use some mb() tricks
 * to avoid misread sequence numbers, states etc.  --ANK
 *
 * We don&apos;t need to initialize tmp_out.sack_ok as we don&apos;t use the results
 */</doc>
