<dec f='linux-4.18.y/mm/internal.h' l='56' type='unsigned int __do_page_cache_readahead(struct address_space * mapping, struct file * filp, unsigned long offset, unsigned long nr_to_read, unsigned long lookahead_size)'/>
<use f='linux-4.18.y/mm/internal.h' l='66' u='c' c='ra_submit'/>
<def f='linux-4.18.y/mm/readahead.c' l='150' ll='213' type='unsigned int __do_page_cache_readahead(struct address_space * mapping, struct file * filp, unsigned long offset, unsigned long nr_to_read, unsigned long lookahead_size)'/>
<use f='linux-4.18.y/mm/readahead.c' l='240' u='c' c='force_page_cache_readahead'/>
<use f='linux-4.18.y/mm/readahead.c' l='466' u='c' c='ondemand_readahead'/>
<doc f='linux-4.18.y/mm/readahead.c' l='142'>/*
 * __do_page_cache_readahead() actually reads a chunk of disk.  It allocates
 * the pages first, then submits them for I/O. This avoids the very bad
 * behaviour which would occur if page allocations are causing VM writeback.
 * We really don&apos;t want to intermingle reads and writes like that.
 *
 * Returns the number of pages requested, or the maximum amount of I/O allowed.
 */</doc>
