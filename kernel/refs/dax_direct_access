<dec f='linux-4.18.y/include/linux/dax.h' l='128' type='long dax_direct_access(struct dax_device * dax_dev, unsigned long pgoff, long nr_pages, void ** kaddr, pfn_t * pfn)'/>
<use f='linux-4.18.y/drivers/dax/super.c' l='125' u='c' c='__bdev_dax_supported'/>
<def f='linux-4.18.y/drivers/dax/super.c' l='266' ll='285' type='long dax_direct_access(struct dax_device * dax_dev, unsigned long pgoff, long nr_pages, void ** kaddr, pfn_t * pfn)'/>
<dec f='linux-4.18.y/drivers/dax/super.c' l='286' type='long dax_direct_access(struct dax_device * , unsigned long , long , void ** , pfn_t * )'/>
<use f='linux-4.18.y/drivers/dax/super.c' l='286' c='dax_direct_access'/>
<use f='linux-4.18.y/drivers/dax/super.c' l='286' u='a'/>
<use f='linux-4.18.y/drivers/dax/super.c' l='286' u='a'/>
<doc f='linux-4.18.y/drivers/dax/super.c' l='255'>/**
 * dax_direct_access() - translate a device pgoff to an absolute pfn
 * @dax_dev: a dax_device instance representing the logical memory range
 * @pgoff: offset in pages from the start of the device to translate
 * @nr_pages: number of consecutive pages caller can handle relative to @pfn
 * @kaddr: output parameter that returns a virtual address mapping of pfn
 * @pfn: output parameter that returns an absolute pfn translation of @pgoff
 *
 * Return: negative errno if an error occurs, otherwise the number of
 * pages accessible at the device relative @pgoff.
 */</doc>
