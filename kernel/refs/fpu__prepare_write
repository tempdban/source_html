<dec f='linux-4.18.y/arch/x86/include/asm/fpu/internal.h' l='29' type='void fpu__prepare_write(struct fpu * fpu)'/>
<def f='linux-4.18.y/arch/x86/kernel/fpu/core.c' l='287' ll='306' type='void fpu__prepare_write(struct fpu * fpu)'/>
<doc f='linux-4.18.y/arch/x86/kernel/fpu/core.c' l='274'>/*
 * This function must be called before we write a task&apos;s fpstate.
 *
 * If the task has used the FPU before then invalidate any cached FPU registers.
 * If the task has not used the FPU before then initialize its fpstate.
 *
 * After this function call, after registers in the fpstate are
 * modified and the child task has woken up, the child task will
 * restore the modified FPU state from the modified context. If we
 * didn&apos;t clear its cached status here then the cached in-registers
 * state pending on its former CPU could be restored, corrupting
 * the modifications.
 */</doc>
<use f='linux-4.18.y/arch/x86/kernel/fpu/regset.c' l='59' u='c' c='xfpregs_set'/>
<use f='linux-4.18.y/arch/x86/kernel/fpu/regset.c' l='136' u='c' c='xstateregs_set'/>
<use f='linux-4.18.y/arch/x86/kernel/fpu/regset.c' l='337' u='c' c='fpregs_set'/>
