<dec f='linux-4.18.y/include/linux/lz4.h' l='560' type='int LZ4_decompress_safe_continue(LZ4_streamDecode_t * LZ4_streamDecode, const char * source, char * dest, int compressedSize, int maxDecompressedSize)'/>
<doc f='linux-4.18.y/include/linux/lz4.h' l='524'>/**
 * LZ4_decompress_fast_continue() - Decompress blocks in streaming mode
 * @LZ4_streamDecode: the &apos;LZ4_streamDecode_t&apos; structure
 * @source: source address of the compressed data
 * @dest: output buffer address of the uncompressed data
 *	which must be already allocated
 * @compressedSize: is the precise full size of the compressed block
 * @maxDecompressedSize: is the size of &apos;dest&apos; buffer
 *
 * These decoding function allows decompression of multiple blocks
 * in &quot;streaming&quot; mode.
 * Previously decoded blocks *must* remain available at the memory position
 * where they were decoded (up to 64 KB)
 * In the case of a ring buffers, decoding buffer must be either :
 *    - Exactly same size as encoding buffer, with same update rule
 *      (block boundaries at same positions) In which case,
 *      the decoding &amp; encoding ring buffer can have any size,
 *      including very small ones ( &lt; 64 KB).
 *    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes.
 *      maxBlockSize is implementation dependent.
 *      It&apos;s the maximum size you intend to compress into a single block.
 *      In which case, encoding and decoding buffers do not need
 *      to be synchronized, and encoding ring buffer can have any size,
 *      including small ones ( &lt; 64 KB).
 *    - _At least_ 64 KB + 8 bytes + maxBlockSize.
 *      In which case, encoding and decoding buffers do not need to be
 *      synchronized, and encoding ring buffer can have any size,
 *      including larger than decoding buffer. W
 * Whenever these conditions are not possible, save the last 64KB of decoded
 * data into a safe buffer, and indicate where it is saved
 * using LZ4_setStreamDecode()
 *
 * Return: number of bytes decompressed into destination buffer
 *	(necessarily &lt;= maxDecompressedSize)
 *	or a negative result in case of error
 */</doc>
<def f='linux-4.18.y/lib/lz4/lz4_decompress.c' l='382' ll='417' type='int LZ4_decompress_safe_continue(LZ4_streamDecode_t * LZ4_streamDecode, const char * source, char * dest, int compressedSize, int maxOutputSize)'/>
<dec f='linux-4.18.y/lib/lz4/lz4_decompress.c' l='501' type='int LZ4_decompress_safe_continue(LZ4_streamDecode_t * , const char * , char * , int , int )'/>
<use f='linux-4.18.y/lib/lz4/lz4_decompress.c' l='501' c='LZ4_decompress_safe_continue'/>
<use f='linux-4.18.y/lib/lz4/lz4_decompress.c' l='501' u='a'/>
<use f='linux-4.18.y/lib/lz4/lz4_decompress.c' l='501' u='a'/>
<doc f='linux-4.18.y/lib/lz4/lz4_decompress.c' l='372'>/*
 * *_continue() :
 * These decoding functions allow decompression of multiple blocks
 * in &quot;streaming&quot; mode.
 * Previously decoded blocks must still be available at the memory
 * position where they were decoded.
 * If it&apos;s not possible, save the relevant part of
 * decoded data into a safe buffer,
 * and indicate where it stands using LZ4_setStreamDecode()
 */</doc>
