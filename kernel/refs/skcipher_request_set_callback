<def f='linux-4.18.y/include/crypto/skcipher.h' l='575' ll='583' type='void skcipher_request_set_callback(struct skcipher_request * req, u32 flags, crypto_completion_t compl, void * data)'/>
<doc f='linux-4.18.y/include/crypto/skcipher.h' l='550'>/**
 * skcipher_request_set_callback() - set asynchronous callback function
 * @req: request handle
 * @flags: specify zero or an ORing of the flags
 *	   CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and
 *	   increase the wait queue beyond the initial maximum size;
 *	   CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep
 * @compl: callback function pointer to be registered with the request handle
 * @data: The data pointer refers to memory that is not used by the kernel
 *	  crypto API, but provided to the callback function for it to use. Here,
 *	  the caller can provide a reference to memory the callback function can
 *	  operate on. As the callback function is invoked asynchronously to the
 *	  related functionality, it may need to access data structures of the
 *	  related functionality which can be referenced using this pointer. The
 *	  callback function can access the memory via the &quot;data&quot; field in the
 *	  crypto_async_request data structure provided to the callback function.
 *
 * This function allows setting the callback function that is triggered once the
 * cipher operation completes.
 *
 * The callback function is registered with the skcipher_request handle and
 * must comply with the following template::
 *
 *	void callback_function(struct crypto_async_request *req, int error)
 */</doc>
<use f='linux-4.18.y/crypto/ctr.c' l='306' u='c' c='crypto_rfc3686_crypt'/>
<use f='linux-4.18.y/crypto/cts.c' l='125' u='c' c='cts_cbc_encrypt'/>
<use f='linux-4.18.y/crypto/cts.c' l='161' u='c' c='crypto_cts_encrypt'/>
<use f='linux-4.18.y/crypto/cts.c' l='172' u='c' c='crypto_cts_encrypt'/>
<use f='linux-4.18.y/crypto/cts.c' l='216' u='c' c='cts_cbc_decrypt'/>
<use f='linux-4.18.y/crypto/cts.c' l='254' u='c' c='crypto_cts_decrypt'/>
<use f='linux-4.18.y/crypto/cts.c' l='262' u='c' c='crypto_cts_decrypt'/>
<use f='linux-4.18.y/crypto/echainiv.c' l='53' u='c' c='echainiv_encrypt'/>
<use f='linux-4.18.y/crypto/seqiv.c' l='79' u='c' c='seqiv_aead_encrypt'/>
<use f='linux-4.18.y/crypto/xts.c' l='225' u='c' c='init_crypt'/>
<use f='linux-4.18.y/drivers/block/cryptoloop.c' l='123' u='c' c='cryptoloop_transfer'/>
<use f='linux-4.18.y/drivers/md/dm-crypt.c' l='1256' u='c' c='crypt_alloc_req_skcipher'/>
<use f='linux-4.18.y/fs/crypto/crypto.c' l='168' u='c' c='fscrypt_do_page_crypto'/>
<use f='linux-4.18.y/fs/crypto/fname.c' l='64' u='c' c='fname_encrypt'/>
<use f='linux-4.18.y/fs/crypto/fname.c' l='105' u='c' c='fname_decrypt'/>
<use f='linux-4.18.y/fs/crypto/keyinfo.c' l='50' u='c' c='derive_key_aes'/>
