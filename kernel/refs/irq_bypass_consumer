<def f='linux-4.18.y/include/linux/irqbypass.h' l='74' ll='83'/>
<size>56</size>
<doc f='linux-4.18.y/include/linux/irqbypass.h' l='60'>/**
 * struct irq_bypass_consumer - IRQ bypass consumer definition
 * @node: IRQ bypass manager private list management
 * @token: opaque token to match between producer and consumer (non-NULL)
 * @add_producer: Connect the IRQ consumer to an IRQ producer
 * @del_producer: Disconnect the IRQ consumer from an IRQ producer
 * @stop: Perform any quiesce operations necessary prior to add/del (optional)
 * @start: Perform any startup operations necessary after add/del (optional)
 *
 * The IRQ bypass consumer structure represents an interrupt sink for
 * participation in possible host bypass, for instance a hypervisor may
 * support offloads to allow bypassing the host entirely or offload
 * portions of the interrupt handling to the VM.
 */</doc>
<mbr r='irq_bypass_consumer::node' o='0' t='struct list_head'/>
<mbr r='irq_bypass_consumer::token' o='128' t='void *'/>
<mbr r='irq_bypass_consumer::add_producer' o='192' t='int (*)(struct irq_bypass_consumer *, struct irq_bypass_producer *)'/>
<mbr r='irq_bypass_consumer::del_producer' o='256' t='void (*)(struct irq_bypass_consumer *, struct irq_bypass_producer *)'/>
<mbr r='irq_bypass_consumer::stop' o='320' t='void (*)(struct irq_bypass_consumer *)'/>
<mbr r='irq_bypass_consumer::start' o='384' t='void (*)(struct irq_bypass_consumer *)'/>
