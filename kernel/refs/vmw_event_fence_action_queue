<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h' l='123' type='int vmw_event_fence_action_queue(struct drm_file * filee_priv, struct vmw_fence_obj * fence, struct drm_pending_event * event, uint32_t * tv_sec, uint32_t * tv_usec, bool interruptible)'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='994' ll='1022' type='int vmw_event_fence_action_queue(struct drm_file * file_priv, struct vmw_fence_obj * fence, struct drm_pending_event * event, uint32_t * tv_sec, uint32_t * tv_usec, bool interruptible)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='1060' u='c' c='vmw_event_fence_action_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='1066' u='c' c='vmw_event_fence_action_create'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='979'>/**
 * vmw_event_fence_action_create - Post an event for sending when a fence
 * object seqno has passed.
 *
 * @file_priv: The file connection on which the event should be posted.
 * @fence: The fence object on which to post the event.
 * @event: Event to be posted. This event should&apos;ve been alloced
 * using k[mz]alloc, and should&apos;ve been completely initialized.
 * @interruptible: Interruptible waits if possible.
 *
 * As a side effect, the object pointed to by @event may have been
 * freed when this function returns. If this function returns with
 * an error code, the caller needs to free that object.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='361' u='c' c='vmw_sou_crtc_page_flip'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='550' u='c' c='vmw_stdu_crtc_page_flip'/>
<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.h' l='123' type='int vmw_event_fence_action_queue(struct drm_file * filee_priv, struct vmw_fence_obj * fence, struct drm_pending_event * event, uint32_t * tv_sec, uint32_t * tv_usec, bool interruptible)'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='994' ll='1022' type='int vmw_event_fence_action_queue(struct drm_file * file_priv, struct vmw_fence_obj * fence, struct drm_pending_event * event, uint32_t * tv_sec, uint32_t * tv_usec, bool interruptible)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='1060' u='c' c='vmw_event_fence_action_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='1066' u='c' c='vmw_event_fence_action_create'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='979'>/**
 * vmw_event_fence_action_create - Post an event for sending when a fence
 * object seqno has passed.
 *
 * @file_priv: The file connection on which the event should be posted.
 * @fence: The fence object on which to post the event.
 * @event: Event to be posted. This event should&apos;ve been alloced
 * using k[mz]alloc, and should&apos;ve been completely initialized.
 * @interruptible: Interruptible waits if possible.
 *
 * As a side effect, the object pointed to by @event may have been
 * freed when this function returns. If this function returns with
 * an error code, the caller needs to free that object.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='361' u='c' c='vmw_sou_crtc_page_flip'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='550' u='c' c='vmw_stdu_crtc_page_flip'/>
