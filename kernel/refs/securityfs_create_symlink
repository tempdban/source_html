<dec f='linux-4.14.y/include/linux/security.h' l='1697' type='struct dentry * securityfs_create_symlink(const char * name, struct dentry * parent, const char * target, const struct inode_operations * iops)'/>
<use f='linux-4.14.y/security/apparmor/apparmorfs.c' l='2500' u='c' c='aa_create_aafs'/>
<def f='linux-4.14.y/security/inode.c' l='254' ll='273' type='struct dentry * securityfs_create_symlink(const char * name, struct dentry * parent, const char * target, const struct inode_operations * iops)'/>
<dec f='linux-4.14.y/security/inode.c' l='274' type='struct dentry * securityfs_create_symlink(const char * , struct dentry * , const char * , const struct inode_operations * )'/>
<use f='linux-4.14.y/security/inode.c' l='274' c='securityfs_create_symlink'/>
<use f='linux-4.14.y/security/inode.c' l='274' u='a'/>
<use f='linux-4.14.y/security/inode.c' l='274' u='a'/>
<doc f='linux-4.14.y/security/inode.c' l='228'>/**
 * securityfs_create_symlink - create a symlink in the securityfs filesystem
 *
 * @name: a pointer to a string containing the name of the symlink to
 *        create.
 * @parent: a pointer to the parent dentry for the symlink.  This should be a
 *          directory dentry if set.  If this parameter is %NULL, then the
 *          directory will be created in the root of the securityfs filesystem.
 * @target: a pointer to a string containing the name of the symlink&apos;s target.
 *          If this parameter is %NULL, then the @iops parameter needs to be
 *          setup to handle .readlink and .get_link inode_operations.
 * @iops: a pointer to the struct inode_operations to use for the symlink. If
 *        this parameter is %NULL, then the default simple_symlink_inode
 *        operations will be used.
 *
 * This function creates a symlink in securityfs with the given @name.
 *
 * This function returns a pointer to a dentry if it succeeds.  This
 * pointer must be passed to the securityfs_remove() function when the file is
 * to be removed (no automatic cleanup happens if your module is unloaded,
 * you are responsible here).  If an error occurs, the function will return
 * the error value (via ERR_PTR).
 *
 * If securityfs is not enabled in the kernel, the value %-ENODEV is
 * returned.
 */</doc>
