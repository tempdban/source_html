<dec f='linux-4.18.y/fs/ntfs/aops.h' l='103' type='void mark_ntfs_record_dirty(struct page * page, const unsigned int ofs)'/>
<def f='linux-4.18.y/fs/ntfs/aops.c' l='1730' ll='1776' type='void mark_ntfs_record_dirty(struct page * page, const unsigned int ofs)'/>
<doc f='linux-4.18.y/fs/ntfs/aops.c' l='1715'>/**
 * mark_ntfs_record_dirty - mark an ntfs record dirty
 * @page:	page containing the ntfs record to mark dirty
 * @ofs:	byte offset within @page at which the ntfs record begins
 *
 * Set the buffers and the page in which the ntfs record is located dirty.
 *
 * The latter also marks the vfs inode the ntfs record belongs to dirty
 * (I_DIRTY_PAGES only).
 *
 * If the page does not have buffers, we create them and set them uptodate.
 * The page may not be locked which is why we need to handle the buffers under
 * the mapping-&gt;private_lock.  Once the buffers are marked dirty we no longer
 * need the lock since try_to_free_buffers() does not free dirty buffers.
 */</doc>
<use f='linux-4.18.y/fs/ntfs/index.h' l='142' u='c' c='ntfs_index_entry_mark_dirty'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='3046' u='c' c='__ntfs_write_inode'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='402' u='c' c='__mark_mft_record_dirty'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='2148' u='c' c='ntfs_mft_record_format'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='2604' u='c' c='ntfs_mft_record_alloc'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='2617' u='c' c='ntfs_mft_record_alloc'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='2638' u='c' c='ntfs_mft_record_alloc'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='2718' u='c' c='ntfs_mft_record_alloc'/>
