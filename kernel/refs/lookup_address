<dec f='linux-4.18.y/arch/x86/include/asm/pgtable_types.h' l='538' type='pte_t * lookup_address(unsigned long address, unsigned int * level)'/>
<doc f='linux-4.18.y/arch/x86/include/asm/pgtable_types.h' l='532'>/*
 * Helper function that returns the kernel pagetable entry controlling
 * the virtual address &apos;address&apos;. NULL means no pagetable entry present.
 * NOTE: the return type is pte_t but if the pmd is PSE then we return it
 * as a pte too.
 */</doc>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='228' u='c' c='cpa_flush_range'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='279' u='c' c='cpa_flush_array'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='359' u='c' c='static_protections'/>
<def f='linux-4.18.y/arch/x86/mm/pageattr.c' l='422' ll='425' type='pte_t * lookup_address(unsigned long address, unsigned int * level)'/>
<dec f='linux-4.18.y/arch/x86/mm/pageattr.c' l='426' type='pte_t * lookup_address(unsigned long , unsigned int * )'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='426' c='lookup_address'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='426' u='a'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='426' u='a'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='435' u='c' c='_lookup_address_cpa'/>
<use f='linux-4.18.y/arch/x86/mm/pageattr.c' l='482' u='c' c='slow_virt_to_phys'/>
<doc f='linux-4.18.y/arch/x86/mm/pageattr.c' l='414'>/*
 * Lookup the page table entry for a virtual address. Return a pointer
 * to the entry and the level of the mapping.
 *
 * Note: We return pud and pmd either when the entry is marked large
 * or when the present bit is not set. Otherwise we would return a
 * pointer to a nonexisting mapping.
 */</doc>
<use f='linux-4.18.y/arch/x86/mm/pti.c' l='279' u='c' c='pti_setup_vsyscall'/>
