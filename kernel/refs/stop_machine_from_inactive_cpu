<dec f='linux-4.18.y/include/linux/stop_machine.h' l='137' type='int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void * data, const struct cpumask * cpus)'/>
<use f='linux-4.18.y/arch/x86/kernel/cpu/mtrr/mtrr.c' l='262' u='c' c='set_mtrr_from_inactive_cpu'/>
<def f='linux-4.18.y/kernel/stop_machine.c' l='653' ll='682' type='int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void * data, const struct cpumask * cpus)'/>
<doc f='linux-4.18.y/kernel/stop_machine.c' l='631'>/**
 * stop_machine_from_inactive_cpu - stop_machine() from inactive CPU
 * @fn: the function to run
 * @data: the data ptr for the @fn()
 * @cpus: the cpus to run the @fn() on (NULL = any online cpu)
 *
 * This is identical to stop_machine() but can be called from a CPU which
 * is not active.  The local CPU is in the process of hotplug (so no other
 * CPU hotplug can start) and not marked active and doesn&apos;t have enough
 * context to sleep.
 *
 * This function provides stop_machine() functionality for such state by
 * using busy-wait for synchronization and executing @fn directly for local
 * CPU.
 *
 * CONTEXT:
 * Local CPU is inactive.  Temporarily stops all active CPUs.
 *
 * RETURNS:
 * 0 if all executions of @fn returned 0, any non zero return value if any
 * returned non zero.
 */</doc>
