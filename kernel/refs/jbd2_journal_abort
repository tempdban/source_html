<dec f='linux-4.18.y/include/linux/jbd2.h' l='1393' type='void jbd2_journal_abort(journal_t * , int )'/>
<use f='linux-4.18.y/fs/ext4/ioctl.c' l='492' u='c' c='ext4_shutdown'/>
<use f='linux-4.18.y/fs/ext4/ioctl.c' l='498' u='c' c='ext4_shutdown'/>
<use f='linux-4.18.y/fs/ext4/super.c' l='419' u='c' c='ext4_handle_error'/>
<use f='linux-4.18.y/fs/ext4/super.c' l='646' u='c' c='__ext4_abort'/>
<use f='linux-4.18.y/fs/jbd2/checkpoint.c' l='168' u='c' c='__jbd2_log_wait_for_space'/>
<use f='linux-4.18.y/fs/jbd2/checkpoint.c' l='359' u='c' c='jbd2_log_do_checkpoint'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='528' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='596' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='624' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='649' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='728' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='850' u='c' c='jbd2_journal_commit_transaction'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='872' u='c' c='jbd2_journal_commit_transaction'/>
<dec f='linux-4.18.y/fs/jbd2/journal.c' l='82' type='void jbd2_journal_abort(journal_t * , int )'/>
<use f='linux-4.18.y/fs/jbd2/journal.c' l='82' c='jbd2_journal_abort'/>
<use f='linux-4.18.y/fs/jbd2/journal.c' l='82' u='a'/>
<use f='linux-4.18.y/fs/jbd2/journal.c' l='82' u='a'/>
<use f='linux-4.18.y/fs/jbd2/journal.c' l='1398' u='c' c='jbd2_write_superblock'/>
<def f='linux-4.18.y/fs/jbd2/journal.c' l='2186' ll='2189' type='void jbd2_journal_abort(journal_t * journal, int errno)'/>
<doc f='linux-4.18.y/fs/jbd2/journal.c' l='2140'>/**
 * void jbd2_journal_abort () - Shutdown the journal immediately.
 * @journal: the journal to shutdown.
 * @errno:   an error number to record in the journal indicating
 *           the reason for the shutdown.
 *
 * Perform a complete, immediate shutdown of the ENTIRE
 * journal (not of a single transaction).  This operation cannot be
 * undone without closing and reopening the journal.
 *
 * The jbd2_journal_abort function is intended to support higher level error
 * recovery mechanisms such as the ext2/ext3 remount-readonly error
 * mode.
 *
 * Journal abort has very specific semantics.  Any existing dirty,
 * unjournaled buffers in the main filesystem will still be written to
 * disk by bdflush, but the journaling mechanism will be suspended
 * immediately and no further transaction commits will be honoured.
 *
 * Any dirty, journaled buffers will be written back to disk without
 * hitting the journal.  Atomicity cannot be guaranteed on an aborted
 * filesystem, but we _do_ attempt to leave as much data as possible
 * behind for fsck to use for cleanup.
 *
 * Any attempt to get a new transaction handle on a journal which is in
 * ABORT state will just result in an -EROFS error return.  A
 * jbd2_journal_stop on an existing handle will return -EIO if we have
 * entered abort state during the update.
 *
 * Recursive transactions are not disturbed by journal abort until the
 * final jbd2_journal_stop, which will receive the -EIO error.
 *
 * Finally, the jbd2_journal_abort call allows the caller to supply an errno
 * which will be recorded (if possible) in the journal superblock.  This
 * allows a client to record failure conditions in the middle of a
 * transaction without having to complete the transaction to record the
 * failure to disk.  ext3_error, for example, now uses this
 * functionality.
 *
 * Errors which originate from within the journaling layer will NOT
 * supply an errno; a null errno implies that absolutely no further
 * writes are done to the journal (unless there are any already in
 * progress).
 *
 */</doc>
<use f='linux-4.18.y/fs/jbd2/transaction.c' l='2611' u='c' c='jbd2_journal_begin_ordered_truncate'/>
