<def f='linux-4.14.y/include/asm-generic/pgtable.h' l='943' ll='950' type='int pmd_trans_unstable(pmd_t * pmd)'/>
<doc f='linux-4.14.y/include/asm-generic/pgtable.h' l='930'>/*
 * This is a noop if Transparent Hugepage Support is not built into
 * the kernel. Otherwise it is equivalent to
 * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in
 * places that already verified the pmd is not none and they want to
 * walk ptes while holding the mmap sem in read mode (write mode don&apos;t
 * need this). If THP is not enabled, the pmd can&apos;t go away under the
 * code even if MADV_DONTNEED runs, but if THP is enabled we need to
 * run a pmd_trans_unstable before walking the ptes after
 * split_huge_page_pmd returns (because it may have run when the pmd
 * become null, but then a page fault can map in a THP and not a
 * regular page).
 */</doc>
<use f='linux-4.14.y/fs/proc/task_mmu.c' l='618' u='c' c='smaps_pte_range'/>
<use f='linux-4.14.y/fs/proc/task_mmu.c' l='1039' u='c' c='clear_refs_pte_range'/>
<use f='linux-4.14.y/mm/gup.c' l='280' u='c' c='follow_pmd_mask'/>
<use f='linux-4.14.y/mm/madvise.c' l='328' u='c' c='madvise_free_pte_range'/>
<use f='linux-4.14.y/mm/memory.c' l='3077' u='c' c='do_anonymous_page'/>
<use f='linux-4.14.y/mm/memory.c' l='3199' u='c' c='pmd_devmap_trans_unstable'/>
<use f='linux-4.14.y/mm/mincore.c' l='130' u='c' c='mincore_pte_range'/>
<use f='linux-4.14.y/mm/mprotect.c' l='53' u='c' c='change_pte_range'/>
<use f='linux-4.14.y/mm/mremap.c' l='242' u='c' c='move_page_tables'/>
<use f='linux-4.14.y/mm/pagewalk.c' l='63' u='c' c='walk_pmd_range'/>
