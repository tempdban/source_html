<dec f='linux-4.14.y/include/linux/skbuff.h' l='3229' type='struct sk_buff * __skb_try_recv_datagram(struct sock * sk, unsigned int flags, void (*)(struct sock *, struct sk_buff *) destructor, int * peeked, int * off, int * err, struct sk_buff ** last)'/>
<def f='linux-4.14.y/net/core/datagram.c' l='246' ll='291' type='struct sk_buff * __skb_try_recv_datagram(struct sock * sk, unsigned int flags, void (*)(struct sock *, struct sk_buff *) destructor, int * peeked, int * off, int * err, struct sk_buff ** last)'/>
<dec f='linux-4.14.y/net/core/datagram.c' l='292' type='struct sk_buff * __skb_try_recv_datagram(struct sock * , unsigned int , void (*)(struct sock *, struct sk_buff *) , int * , int * , int * , struct sk_buff ** )'/>
<use f='linux-4.14.y/net/core/datagram.c' l='292' c='__skb_try_recv_datagram'/>
<use f='linux-4.14.y/net/core/datagram.c' l='292' u='a'/>
<use f='linux-4.14.y/net/core/datagram.c' l='292' u='a'/>
<use f='linux-4.14.y/net/core/datagram.c' l='305' u='c' c='__skb_recv_datagram'/>
<doc f='linux-4.14.y/net/core/datagram.c' l='210'>/**
 *	__skb_try_recv_datagram - Receive a datagram skbuff
 *	@sk: socket
 *	@flags: MSG\_ flags
 *	@destructor: invoked under the receive lock on successful dequeue
 *	@peeked: returns non-zero if this packet has been seen before
 *	@off: an offset in bytes to peek skb from. Returns an offset
 *	      within an skb where data actually starts
 *	@err: error code returned
 *	@last: set to last peeked message to inform the wait function
 *	       what to look for when peeking
 *
 *	Get a datagram skbuff, understands the peeking, nonblocking wakeups
 *	and possible races. This replaces identical code in packet, raw and
 *	udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
 *	the long standing peek and read race for datagram sockets. If you
 *	alter this routine remember it must be re-entrant.
 *
 *	This function will lock the socket if a skb is returned, so
 *	the caller needs to unlock the socket in that case (usually by
 *	calling skb_free_datagram). Returns NULL with @err set to
 *	-EAGAIN if no data was available or to some other value if an
 *	error was detected.
 *
 *	* It does not lock socket since today. This function is
 *	* free of race conditions. This measure should/can improve
 *	* significantly datagram socket latencies at high loads,
 *	* when data copying to user space takes lots of time.
 *	* (BTW I&apos;ve just killed the last cli() in IP/IPv6/core/netlink/packet
 *	*  8) Great win.)
 *	*			                    --ANK (980729)
 *
 *	The order of the tests when we find no data waiting are specified
 *	quite explicitly by POSIX 1003.1g, don&apos;t change them without having
 *	the standard around please.
 */</doc>
<use f='linux-4.14.y/net/unix/af_unix.c' l='2107' u='c' c='unix_dgram_recvmsg'/>
