<dec f='linux-4.18.y/include/linux/perf_event.h' l='1252' type='void perf_event_addr_filters_sync(struct perf_event * event)'/>
<use f='linux-4.18.y/arch/x86/events/intel/pt.c' l='438' u='c' c='pt_config_filters'/>
<def f='linux-4.18.y/kernel/events/core.c' l='2816' ll='2829' type='void perf_event_addr_filters_sync(struct perf_event * event)'/>
<dec f='linux-4.18.y/kernel/events/core.c' l='2830' type='void perf_event_addr_filters_sync(struct perf_event * )'/>
<use f='linux-4.18.y/kernel/events/core.c' l='2830' c='perf_event_addr_filters_sync'/>
<use f='linux-4.18.y/kernel/events/core.c' l='2830' u='a'/>
<use f='linux-4.18.y/kernel/events/core.c' l='2830' u='a'/>
<doc f='linux-4.18.y/kernel/events/core.c' l='2794'>/*
 * In order to contain the amount of racy and tricky in the address filter
 * configuration management, it is a two part process:
 *
 * (p1) when userspace mappings change as a result of (1) or (2) or (3) below,
 *      we update the addresses of corresponding vmas in
 *	event::addr_filters_offs array and bump the event::addr_filters_gen;
 * (p2) when an event is scheduled in (pmu::add), it calls
 *      perf_event_addr_filters_sync() which calls pmu::addr_filters_sync()
 *      if the generation has changed since the previous call.
 *
 * If (p1) happens while the event is active, we restart it to force (p2).
 *
 * (1) perf_addr_filters_apply(): adjusting filters&apos; offsets based on
 *     pre-existing mappings, called once when new filters arrive via SET_FILTER
 *     ioctl;
 * (2) perf_addr_filters_adjust(): adjusting filters&apos; offsets based on newly
 *     registered mapping, called for every new mmap(), with mm::mmap_sem down
 *     for reading;
 * (3) perf_event_addr_filters_exec(): clearing filters&apos; offsets in the process
 *     of exec.
 */</doc>
