<dec f='linux-4.18.y/include/linux/dcache.h' l='242' type='struct dentry * d_splice_alias(struct inode * , struct dentry * )'/>
<use f='linux-4.18.y/fs/dcache.c' l='2106' u='c' c='d_add_ci'/>
<def f='linux-4.18.y/fs/dcache.c' l='2975' ll='3023' type='struct dentry * d_splice_alias(struct inode * inode, struct dentry * dentry)'/>
<dec f='linux-4.18.y/fs/dcache.c' l='3024' type='struct dentry * d_splice_alias(struct inode * , struct dentry * )'/>
<use f='linux-4.18.y/fs/dcache.c' l='3024' c='d_splice_alias'/>
<use f='linux-4.18.y/fs/dcache.c' l='3024' u='a'/>
<use f='linux-4.18.y/fs/dcache.c' l='3024' u='a'/>
<doc f='linux-4.18.y/fs/dcache.c' l='2952'>/**
 * d_splice_alias - splice a disconnected dentry into the tree if one exists
 * @inode:  the inode which may have a disconnected dentry
 * @dentry: a negative dentry which we want to point to the inode.
 *
 * If inode is a directory and has an IS_ROOT alias, then d_move that in
 * place of the given dentry and return it, else simply d_add the inode
 * to the dentry and return NULL.
 *
 * If a non-IS_ROOT directory is found, the filesystem is corrupt, and
 * we should error out: directories can&apos;t have multiple aliases.
 *
 * This is needed in the lookup routine of any filesystem that is exportable
 * (via knfsd) so that we can build dcache paths to directories effectively.
 *
 * If a dentry was found and moved, then it is returned.  Otherwise NULL
 * is returned.  This matches the expected return value of -&gt;lookup.
 *
 * Cluster filesystems may call this function with a negative, hashed dentry.
 * In that case, we know that the inode will be a regular file, and also this
 * will only occur during atomic_open. So we need to check for the dentry
 * being already hashed only in the final case.
 */</doc>
<use f='linux-4.18.y/fs/ext4/namei.c' l='1590' u='c' c='ext4_lookup'/>
<use f='linux-4.18.y/fs/f2fs/namei.c' l='484' u='c' c='f2fs_lookup'/>
<use f='linux-4.18.y/fs/fat/namei_msdos.c' l='222' u='c' c='msdos_lookup'/>
<use f='linux-4.18.y/fs/fat/namei_vfat.c' l='752' u='c' c='vfat_lookup'/>
<use f='linux-4.18.y/fs/fuse/dir.c' l='375' u='c' c='fuse_lookup'/>
<use f='linux-4.18.y/fs/fuse/dir.c' l='1273' u='c' c='fuse_direntplus_link'/>
<use f='linux-4.18.y/fs/isofs/namei.c' l='172' u='c' c='isofs_lookup'/>
<use f='linux-4.18.y/fs/kernfs/dir.c' l='1080' u='c' c='kernfs_iop_lookup'/>
<use f='linux-4.18.y/fs/ntfs/namei.c' l='140' u='c' c='ntfs_lookup'/>
<use f='linux-4.18.y/fs/overlayfs/namei.c' l='1031' u='c' c='ovl_lookup'/>
<use f='linux-4.18.y/fs/proc/base.c' l='2071' u='c' c='proc_map_files_instantiate'/>
<use f='linux-4.18.y/fs/proc/base.c' l='2437' u='c' c='proc_pident_instantiate'/>
<use f='linux-4.18.y/fs/proc/base.c' l='3127' u='c' c='proc_pid_instantiate'/>
<use f='linux-4.18.y/fs/proc/base.c' l='3417' u='c' c='proc_task_instantiate'/>
<use f='linux-4.18.y/fs/proc/fd.c' l='203' u='c' c='proc_fd_instantiate'/>
<use f='linux-4.18.y/fs/proc/fd.c' l='339' u='c' c='proc_fdinfo_instantiate'/>
<use f='linux-4.18.y/fs/proc/generic.c' l='260' u='c' c='proc_lookup_de'/>
<use f='linux-4.18.y/fs/proc/namespaces.c' l='107' u='c' c='proc_ns_instantiate'/>
<use f='linux-4.18.y/fs/proc/proc_sysctl.c' l='558' u='c' c='proc_sys_lookup'/>
<use f='linux-4.18.y/fs/proc/proc_sysctl.c' l='694' u='c' c='proc_sys_fill_cache'/>
<use f='linux-4.18.y/fs/udf/namei.c' l='339' u='c' c='udf_lookup'/>
