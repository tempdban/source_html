<dec f='linux-4.18.y/include/linux/usb.h' l='1790' type='int usb_get_status(struct usb_device * dev, int recip, int type, int target, void * data)'/>
<use f='linux-4.18.y/include/linux/usb.h' l='1796' u='c' c='usb_get_std_status'/>
<use f='linux-4.18.y/include/linux/usb.h' l='1802' u='c' c='usb_get_ptm_status'/>
<def f='linux-4.18.y/drivers/usb/core/message.c' l='970' ll='1024' type='int usb_get_status(struct usb_device * dev, int recip, int type, int target, void * data)'/>
<dec f='linux-4.18.y/drivers/usb/core/message.c' l='1025' type='int usb_get_status(struct usb_device * , int , int , int , void * )'/>
<use f='linux-4.18.y/drivers/usb/core/message.c' l='1025' c='usb_get_status'/>
<use f='linux-4.18.y/drivers/usb/core/message.c' l='1025' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/message.c' l='1025' u='a'/>
<doc f='linux-4.18.y/drivers/usb/core/message.c' l='947'>/**
 * usb_get_status - issues a GET_STATUS call
 * @dev: the device whose status is being checked
 * @recip: USB_RECIP_*; for device, interface, or endpoint
 * @type: USB_STATUS_TYPE_*; for standard or PTM status types
 * @target: zero (for device), else interface or endpoint number
 * @data: pointer to two bytes of bitmap data
 * Context: !in_interrupt ()
 *
 * Returns device, interface, or endpoint status.  Normally only of
 * interest to see if the device is self powered, or has enabled the
 * remote wakeup facility; or whether a bulk or interrupt endpoint
 * is halted (&quot;stalled&quot;).
 *
 * Bits in these status bitmaps are set using the SET_FEATURE request,
 * and cleared using the CLEAR_FEATURE request.  The usb_clear_halt()
 * function should be used to clear halt (&quot;stall&quot;) status.
 *
 * This call is synchronous, and may not be used in an interrupt context.
 *
 * Returns 0 and the status value in *@data (in host byte order) on success,
 * or else the status code from the underlying usb_control_msg() call.
 */</doc>
