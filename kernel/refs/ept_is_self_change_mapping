<def f='linux-4.14.y/arch/x86/kvm/paging_tmpl.h' l='691' macro='1' type='bool ept_is_self_change_mapping(struct kvm_vcpu * vcpu, struct guest_walkerEPT * walker, int user_fault, bool * write_fault_to_shadow_pgtable)'/>
<use f='linux-4.14.y/arch/x86/kvm/paging_tmpl.h' l='775' macro='1' u='c'/>
<doc f='linux-4.14.y/arch/x86/kvm/paging_tmpl.h' l='673'>/*
 * To see whether the mapped gfn can write its page table in the current
 * mapping.
 *
 * It is the helper function of FNAME(page_fault). When guest uses large page
 * size to map the writable gfn which is used as current page table, we should
 * force kvm to use small page size to map it because new shadow page will be
 * created when kvm establishes shadow page table that stop kvm using large
 * page size. Do it early can avoid unnecessary #PF and emulation.
 *
 * @write_fault_to_shadow_pgtable will return true if the fault gfn is
 * currently used as its page table.
 *
 * Note: the PDPT page table is not checked for PAE-32 bit guest. It is ok
 * since the PDPT is always shadowed, that means, we can not use large page
 * size to map the gfn which is used as PDPT.
 */</doc>
