<dec f='linux-4.14.y/tools/include/linux/string.h' l='20' type='char * str_error_r(int errnum, char * buf, size_t buflen)'/>
<use f='linux-4.14.y/tools/lib/subcmd/run-command.c' l='114' u='c' c='start_command'/>
<use f='linux-4.14.y/tools/lib/subcmd/run-command.c' l='178' u='c' c='wait_or_whine'/>
<def f='linux-4.14.y/tools/lib/str_error_r.c' l='21' ll='27' type='char * str_error_r(int errnum, char * buf, size_t buflen)'/>
<doc f='linux-4.14.y/tools/lib/str_error_r.c' l='7'>/*
 * The tools so far have been using the strerror_r() GNU variant, that returns
 * a string, be it the buffer passed or something else.
 *
 * But that, besides being tricky in cases where we expect that the function
 * using strerror_r() returns the error formatted in a provided buffer (we have
 * to check if it returned something else and copy that instead), breaks the
 * build on systems not using glibc, like Alpine Linux, where musl libc is
 * used.
 *
 * So, introduce yet another wrapper, str_error_r(), that has the GNU
 * interface, but uses the portable XSI variant of strerror_r(), so that users
 * rest asured that the provided buffer is used and it is what is returned.
 */</doc>
