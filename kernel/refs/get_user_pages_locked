<dec f='linux-4.14.y/include/linux/mm.h' l='1367' type='long get_user_pages_locked(unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page ** pages, int * locked)'/>
<def f='linux-4.14.y/mm/gup.c' l='960' ll='967' type='long get_user_pages_locked(unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page ** pages, int * locked)'/>
<dec f='linux-4.14.y/mm/gup.c' l='968' type='long get_user_pages_locked(unsigned long , unsigned long , unsigned int , struct page ** , int * )'/>
<use f='linux-4.14.y/mm/gup.c' l='968' c='get_user_pages_locked'/>
<use f='linux-4.14.y/mm/gup.c' l='968' u='a'/>
<use f='linux-4.14.y/mm/gup.c' l='968' u='a'/>
<doc f='linux-4.14.y/mm/gup.c' l='939'>/*
 * We can leverage the VM_FAULT_RETRY functionality in the page fault
 * paths better by using either get_user_pages_locked() or
 * get_user_pages_unlocked().
 *
 * get_user_pages_locked() is suitable to replace the form:
 *
 *      down_read(&amp;mm-&gt;mmap_sem);
 *      do_something()
 *      get_user_pages(tsk, mm, ..., pages, NULL);
 *      up_read(&amp;mm-&gt;mmap_sem);
 *
 *  to:
 *
 *      int locked = 1;
 *      down_read(&amp;mm-&gt;mmap_sem);
 *      do_something()
 *      get_user_pages_locked(tsk, mm, ..., pages, &amp;locked);
 *      if (locked)
 *          up_read(&amp;mm-&gt;mmap_sem);
 */</doc>
