<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h' l='435' type='int vmw_kms_stdu_dma(struct vmw_private * dev_priv, struct drm_file * file_priv, struct vmw_framebuffer * vfb, struct drm_vmw_fence_rep * user_fence_rep, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, uint32_t num_clips, int increment, bool to_surface, bool interruptible)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='952' u='c' c='vmw_kms_readback'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1110' u='c' c='vmw_framebuffer_dmabuf_dirty'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='532' u='c' c='vmw_stdu_crtc_page_flip'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='812' ll='861' type='int vmw_kms_stdu_dma(struct vmw_private * dev_priv, struct drm_file * file_priv, struct vmw_framebuffer * vfb, struct drm_vmw_fence_rep * user_fence_rep, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, uint32_t num_clips, int increment, bool to_surface, bool interruptible)'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='789'>/**
 * vmw_kms_stdu_dma - Perform a DMA transfer between a dma-buffer backed
 * framebuffer and the screen target system.
 *
 * @dev_priv: Pointer to the device private structure.
 * @file_priv: Pointer to a struct drm-file identifying the caller. May be
 * set to NULL, but then @user_fence_rep must also be set to NULL.
 * @vfb: Pointer to the dma-buffer backed framebuffer.
 * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
 * @vclips: Alternate array of clip rects. Either @clips or @vclips must
 * be NULL.
 * @num_clips: Number of clip rects in @clips or @vclips.
 * @increment: Increment to use when looping over @clips or @vclips.
 * @to_surface: Whether to DMA to the screen target system as opposed to
 * from the screen target system.
 * @interruptible: Whether to perform waits interruptible if possible.
 *
 * If DMA-ing till the screen target system, the function will also notify
 * the screen target system that a bounding box of the cliprects has been
 * updated.
 * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
 * interrupted.
 */</doc>
<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h' l='435' type='int vmw_kms_stdu_dma(struct vmw_private * dev_priv, struct drm_file * file_priv, struct vmw_framebuffer * vfb, struct drm_vmw_fence_rep * user_fence_rep, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, uint32_t num_clips, int increment, bool to_surface, bool interruptible)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='952' u='c' c='vmw_kms_readback'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1110' u='c' c='vmw_framebuffer_dmabuf_dirty'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='532' u='c' c='vmw_stdu_crtc_page_flip'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='812' ll='861' type='int vmw_kms_stdu_dma(struct vmw_private * dev_priv, struct drm_file * file_priv, struct vmw_framebuffer * vfb, struct drm_vmw_fence_rep * user_fence_rep, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, uint32_t num_clips, int increment, bool to_surface, bool interruptible)'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='789'>/**
 * vmw_kms_stdu_dma - Perform a DMA transfer between a dma-buffer backed
 * framebuffer and the screen target system.
 *
 * @dev_priv: Pointer to the device private structure.
 * @file_priv: Pointer to a struct drm-file identifying the caller. May be
 * set to NULL, but then @user_fence_rep must also be set to NULL.
 * @vfb: Pointer to the dma-buffer backed framebuffer.
 * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
 * @vclips: Alternate array of clip rects. Either @clips or @vclips must
 * be NULL.
 * @num_clips: Number of clip rects in @clips or @vclips.
 * @increment: Increment to use when looping over @clips or @vclips.
 * @to_surface: Whether to DMA to the screen target system as opposed to
 * from the screen target system.
 * @interruptible: Whether to perform waits interruptible if possible.
 *
 * If DMA-ing till the screen target system, the function will also notify
 * the screen target system that a bounding box of the cliprects has been
 * updated.
 * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
 * interrupted.
 */</doc>
