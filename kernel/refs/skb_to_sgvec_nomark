<dec f='linux-4.18.y/include/linux/skbuff.h' l='1050' type='int skb_to_sgvec_nomark(struct sk_buff * skb, struct scatterlist * sg, int offset, int len)'/>
<def f='linux-4.18.y/net/core/skbuff.c' l='4060' ll='4064' type='int skb_to_sgvec_nomark(struct sk_buff * skb, struct scatterlist * sg, int offset, int len)'/>
<dec f='linux-4.18.y/net/core/skbuff.c' l='4065' type='int skb_to_sgvec_nomark(struct sk_buff * , struct scatterlist * , int , int )'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='4065' c='skb_to_sgvec_nomark'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='4065' u='a'/>
<use f='linux-4.18.y/net/core/skbuff.c' l='4065' u='a'/>
<doc f='linux-4.18.y/net/core/skbuff.c' l='4041'>/* As compared with skb_to_sgvec, skb_to_sgvec_nomark only map skb to given
 * sglist without mark the sg which contain last skb data as the end.
 * So the caller can mannipulate sg list as will when padding new data after
 * the first call without calling sg_unmark_end to expend sg list.
 *
 * Scenario to use skb_to_sgvec_nomark:
 * 1. sg_init_table
 * 2. skb_to_sgvec_nomark(payload1)
 * 3. skb_to_sgvec_nomark(payload2)
 *
 * This is equivalent to:
 * 1. sg_init_table
 * 2. skb_to_sgvec(payload1)
 * 3. sg_unmark_end
 * 4. skb_to_sgvec(payload2)
 *
 * When mapping mutilple payload conditionally, skb_to_sgvec_nomark
 * is more preferable.
 */</doc>
