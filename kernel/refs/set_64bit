<def f='linux-4.18.y/arch/x86/include/asm/cmpxchg_64.h' l='5' ll='8' type='void set_64bit(volatile u64 * ptr, u64 val)'/>
<def f='linux-4.18.y/arch/x86/include/asm/cmpxchg_32.h' l='24' ll='36' type='void set_64bit(volatile u64 * ptr, u64 value)'/>
<doc f='linux-4.18.y/arch/x86/include/asm/cmpxchg_32.h' l='10'>/*
 * CMPXCHG8B only writes to the target if we had the previous
 * value in registers, otherwise it acts as a read and gives us the
 * &quot;new previous&quot; value.  That is why there is a loop.  Preloading
 * EDX:EAX is a performance optimization: in the common case it means
 * we need only one locked operation.
 *
 * A SIMD/3DNOW!/MMX/FPU 64-bit store here would require at the very
 * least an FPU save and/or %cr0.ts manipulation.
 *
 * cmpxchg8b must be used with the lock prefix here to allow the
 * instruction to be executed atomically.  We need to have the reader
 * side to see the coherent 64bit value.
 */</doc>
<use f='linux-4.18.y/drivers/iommu/intel_irq_remapping.c' l='190' u='c' c='modify_irte'/>
<use f='linux-4.18.y/drivers/iommu/intel_irq_remapping.c' l='191' u='c' c='modify_irte'/>
<use f='linux-4.18.y/drivers/iommu/intel_irq_remapping.c' l='251' u='c' c='clear_entries'/>
<use f='linux-4.18.y/drivers/iommu/intel_irq_remapping.c' l='252' u='c' c='clear_entries'/>
