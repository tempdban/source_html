<def f='linux-4.18.y/include/crypto/kpp.h' l='76' ll='89'/>
<size>472</size>
<doc f='linux-4.18.y/include/crypto/kpp.h' l='51'>/**
 * struct kpp_alg - generic key-agreement protocol primitives
 *
 * @set_secret:		Function invokes the protocol specific function to
 *			store the secret private key along with parameters.
 *			The implementation knows how to decode the buffer
 * @generate_public_key: Function generate the public key to be sent to the
 *			counterpart. In case of error, where output is not big
 *			enough req-&gt;dst_len will be updated to the size
 *			required
 * @compute_shared_secret: Function compute the shared secret as defined by
 *			the algorithm. The result is given back to the user.
 *			In case of error, where output is not big enough,
 *			req-&gt;dst_len will be updated to the size required
 * @max_size:		Function returns the size of the output buffer
 * @init:		Initialize the object. This is called only once at
 *			instantiation time. In case the cryptographic hardware
 *			needs to be initialized. Software fallback should be
 *			put in place here.
 * @exit:		Undo everything @init did.
 *
 * @reqsize:		Request context size required by algorithm
 *			implementation
 * @base:		Common crypto API algorithm data structure
 */</doc>
<mbr r='kpp_alg::set_secret' o='0' t='int (*)(struct crypto_kpp *, const void *, unsigned int)'/>
<mbr r='kpp_alg::generate_public_key' o='64' t='int (*)(struct kpp_request *)'/>
<mbr r='kpp_alg::compute_shared_secret' o='128' t='int (*)(struct kpp_request *)'/>
<mbr r='kpp_alg::max_size' o='192' t='unsigned int (*)(struct crypto_kpp *)'/>
<mbr r='kpp_alg::init' o='256' t='int (*)(struct crypto_kpp *)'/>
<mbr r='kpp_alg::exit' o='320' t='void (*)(struct crypto_kpp *)'/>
<mbr r='kpp_alg::reqsize' o='384' t='unsigned int'/>
<mbr r='kpp_alg::base' o='448' t='struct crypto_alg'/>
