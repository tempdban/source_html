<dec f='linux-4.18.y/drivers/acpi/acpica/acevents.h' l='53' type='acpi_status acpi_ev_acquire_global_lock(u16 timeout)'/>
<def f='linux-4.18.y/drivers/acpi/acpica/evglock.c' l='170' ll='252' type='acpi_status acpi_ev_acquire_global_lock(u16 timeout)'/>
<doc f='linux-4.18.y/drivers/acpi/acpica/evglock.c' l='148'>/******************************************************************************
 *
 * FUNCTION:    acpi_ev_acquire_global_lock
 *
 * PARAMETERS:  timeout         - Max time to wait for the lock, in millisec.
 *
 * RETURN:      Status
 *
 * DESCRIPTION: Attempt to gain ownership of the Global Lock.
 *
 * MUTEX:       Interpreter must be locked
 *
 * Note: The original implementation allowed multiple threads to &quot;acquire&quot; the
 * Global Lock, and the OS would hold the lock until the last thread had
 * released it. However, this could potentially starve the BIOS out of the
 * lock, especially in the case where there is a tight handshake between the
 * Embedded Controller driver and the BIOS. Therefore, this implementation
 * allows only one thread to acquire the HW Global Lock at a time, and makes
 * the global lock appear as a standard mutex on the OS side.
 *
 *****************************************************************************/</doc>
<use f='linux-4.18.y/drivers/acpi/acpica/exmutex.c' l='152' u='c' c='acpi_ex_acquire_mutex_object'/>
