<dec f='linux-4.18.y/include/linux/mm.h' l='1342' type='void unmap_vmas(struct mmu_gather * tlb, struct vm_area_struct * start_vma, unsigned long start, unsigned long end)'/>
<def f='linux-4.18.y/mm/memory.c' l='1582' ll='1592' type='void unmap_vmas(struct mmu_gather * tlb, struct vm_area_struct * vma, unsigned long start_addr, unsigned long end_addr)'/>
<doc f='linux-4.18.y/mm/memory.c' l='1564'>/**
 * unmap_vmas - unmap a range of memory covered by a list of vma&apos;s
 * @tlb: address of the caller&apos;s struct mmu_gather
 * @vma: the starting vma
 * @start_addr: virtual address at which to start unmapping
 * @end_addr: virtual address at which to end unmapping
 *
 * Unmap all pages in the vma list.
 *
 * Only addresses between `start&apos; and `end&apos; will be unmapped.
 *
 * The VMA list must be sorted in ascending virtual address order.
 *
 * unmap_vmas() assumes that the caller will flush the whole unmapped address
 * range after unmap_vmas() returns.  So the only responsibility here is to
 * ensure that any thus-far unmapped pages are flushed before unmap_vmas()
 * drops the lock and schedules.
 */</doc>
<use f='linux-4.18.y/mm/mmap.c' l='2570' u='c' c='unmap_region'/>
<use f='linux-4.18.y/mm/mmap.c' l='3094' u='c' c='exit_mmap'/>
