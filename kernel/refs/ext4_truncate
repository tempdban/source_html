<dec f='linux-4.14.y/fs/ext4/ext4.h' l='2496' type='int ext4_truncate(struct inode * )'/>
<use f='linux-4.14.y/fs/ext4/truncate.h' l='16' u='c' c='ext4_truncate_failed_write'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='288' u='c' c='ext4_evict_inode'/>
<def f='linux-4.14.y/fs/ext4/inode.c' l='4341' ll='4440' type='int ext4_truncate(struct inode * inode)'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='5472' u='c' c='ext4_setattr'/>
<doc f='linux-4.14.y/fs/ext4/inode.c' l='4313'>/*
 * ext4_truncate()
 *
 * We block out ext4_get_block() block instantiations across the entire
 * transaction, and VFS/VM ensures that ext4_truncate() cannot run
 * simultaneously on behalf of the same inode.
 *
 * As we work through the truncate and commit bits of it to the journal there
 * is one core, guiding principle: the file&apos;s tree must always be consistent on
 * disk.  We must be able to restart the truncate after a crash.
 *
 * The file&apos;s tree may be transiently inconsistent in memory (although it
 * probably isn&apos;t), but whenever we close off and commit a journal transaction,
 * the contents of (the filesystem + the journal) must be consistent and
 * restartable.  It&apos;s pretty simple, really: bottom up, right to left (although
 * left-to-right works OK too).
 *
 * Note that at recovery time, journal replay occurs *before* the restart of
 * truncate against the orphan inode list.
 *
 * The committed inode has the new, desired i_size (which is the same as
 * i_disksize in this case).  After a crash, ext4_orphan_cleanup() will see
 * that this inode&apos;s truncate did not complete and it will again call
 * ext4_truncate() to have another go.  So there will be instantiated blocks
 * to the right of the truncation point in a crashed ext4 filesystem.  But
 * that&apos;s fine - as long as they are linked from the inode, the post-crash
 * ext4_truncate() run will find them and release them.
 */</doc>
<use f='linux-4.14.y/fs/ext4/ioctl.c' l='257' u='c' c='ext4_ioctl_setflags'/>
<use f='linux-4.14.y/fs/ext4/super.c' l='2538' u='c' c='ext4_orphan_cleanup'/>
<dec f='linux-4.14.y/fs/ext4/ext4.h' l='2496' type='int ext4_truncate(struct inode * )'/>
<use f='linux-4.14.y/fs/ext4/truncate.h' l='16' u='c' c='ext4_truncate_failed_write'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='288' u='c' c='ext4_evict_inode'/>
<def f='linux-4.14.y/fs/ext4/inode.c' l='4341' ll='4440' type='int ext4_truncate(struct inode * inode)'/>
<use f='linux-4.14.y/fs/ext4/inode.c' l='5472' u='c' c='ext4_setattr'/>
<doc f='linux-4.14.y/fs/ext4/inode.c' l='4313'>/*
 * ext4_truncate()
 *
 * We block out ext4_get_block() block instantiations across the entire
 * transaction, and VFS/VM ensures that ext4_truncate() cannot run
 * simultaneously on behalf of the same inode.
 *
 * As we work through the truncate and commit bits of it to the journal there
 * is one core, guiding principle: the file&apos;s tree must always be consistent on
 * disk.  We must be able to restart the truncate after a crash.
 *
 * The file&apos;s tree may be transiently inconsistent in memory (although it
 * probably isn&apos;t), but whenever we close off and commit a journal transaction,
 * the contents of (the filesystem + the journal) must be consistent and
 * restartable.  It&apos;s pretty simple, really: bottom up, right to left (although
 * left-to-right works OK too).
 *
 * Note that at recovery time, journal replay occurs *before* the restart of
 * truncate against the orphan inode list.
 *
 * The committed inode has the new, desired i_size (which is the same as
 * i_disksize in this case).  After a crash, ext4_orphan_cleanup() will see
 * that this inode&apos;s truncate did not complete and it will again call
 * ext4_truncate() to have another go.  So there will be instantiated blocks
 * to the right of the truncation point in a crashed ext4 filesystem.  But
 * that&apos;s fine - as long as they are linked from the inode, the post-crash
 * ext4_truncate() run will find them and release them.
 */</doc>
<use f='linux-4.14.y/fs/ext4/ioctl.c' l='257' u='c' c='ext4_ioctl_setflags'/>
<use f='linux-4.14.y/fs/ext4/super.c' l='2538' u='c' c='ext4_orphan_cleanup'/>
