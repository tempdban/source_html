<dec f='linux-4.18.y/include/linux/clocksource.h' l='199' type='u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 * max_cycles)'/>
<def f='linux-4.18.y/kernel/time/clocksource.c' l='539' ll='567' type='u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 * max_cyc)'/>
<use f='linux-4.18.y/kernel/time/clocksource.c' l='576' u='c' c='clocksource_update_max_deferment'/>
<doc f='linux-4.18.y/kernel/time/clocksource.c' l='524'>/**
 * clocks_calc_max_nsecs - Returns maximum nanoseconds that can be converted
 * @mult:	cycle to nanosecond multiplier
 * @shift:	cycle to nanosecond divisor (power of two)
 * @maxadj:	maximum adjustment value to mult (~11%)
 * @mask:	bitmask for two&apos;s complement subtraction of non 64 bit counters
 * @max_cyc:	maximum cycle value before potential overflow (does not include
 *		any safety margin)
 *
 * NOTE: This function includes a safety margin of 50%, in other words, we
 * return half the number of nanoseconds the hardware counter can technically
 * cover. This is done so that we can potentially detect problems caused by
 * delayed timers or bad hardware, which might result in time intervals that
 * are larger than what the math used can handle without overflows.
 */</doc>
