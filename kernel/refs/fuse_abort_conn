<dec f='linux-4.14.y/fs/fuse/fuse_i.h' l='854' type='void fuse_abort_conn(struct fuse_conn * fc)'/>
<doc f='linux-4.14.y/fs/fuse/fuse_i.h' l='853'>/* Abort all requests */</doc>
<use f='linux-4.14.y/fs/fuse/control.c' l='38' u='c' c='fuse_conn_abort_write'/>
<use f='linux-4.14.y/fs/fuse/cuse.c' l='409' u='c' c='cuse_process_init_reply'/>
<use f='linux-4.14.y/fs/fuse/cuse.c' l='584' u='c' c='cuse_class_abort_store'/>
<def f='linux-4.14.y/fs/fuse/dev.c' l='2078' ll='2137' type='void fuse_abort_conn(struct fuse_conn * fc)'/>
<dec f='linux-4.14.y/fs/fuse/dev.c' l='2138' type='void fuse_abort_conn(struct fuse_conn * )'/>
<use f='linux-4.14.y/fs/fuse/dev.c' l='2138' c='fuse_abort_conn'/>
<use f='linux-4.14.y/fs/fuse/dev.c' l='2138' u='a'/>
<use f='linux-4.14.y/fs/fuse/dev.c' l='2138' u='a'/>
<use f='linux-4.14.y/fs/fuse/dev.c' l='2153' u='c' c='fuse_dev_release'/>
<doc f='linux-4.14.y/fs/fuse/dev.c' l='2060'>/*
 * Abort all requests.
 *
 * Emergency exit in case of a malicious or accidental deadlock, or just a hung
 * filesystem.
 *
 * The same effect is usually achievable through killing the filesystem daemon
 * and all users of the filesystem.  The exception is the combination of an
 * asynchronous request and the tricky deadlock (see
 * Documentation/filesystems/fuse.txt).
 *
 * Aborting requests under I/O goes as follows: 1: Separate out unlocked
 * requests, they should be finished off immediately.  Locked requests will be
 * finished after unlock; see unlock_request(). 2: Finish off the unlocked
 * requests.  It is possible that some request will finish before we can.  This
 * is OK, the request will in that case be removed from the list before we touch
 * it.
 */</doc>
<use f='linux-4.14.y/fs/fuse/inode.c' l='374' u='c' c='fuse_umount_begin'/>
<use f='linux-4.14.y/fs/fuse/inode.c' l='396' u='c' c='fuse_put_super'/>
