<dec f='linux-4.18.y/fs/fuse/fuse_i.h' l='864' type='void fuse_abort_conn(struct fuse_conn * fc, bool is_abort)'/>
<doc f='linux-4.18.y/fs/fuse/fuse_i.h' l='863'>/* Abort all requests */</doc>
<use f='linux-4.18.y/fs/fuse/control.c' l='38' u='c' c='fuse_conn_abort_write'/>
<use f='linux-4.18.y/fs/fuse/cuse.c' l='410' u='c' c='cuse_process_init_reply'/>
<use f='linux-4.18.y/fs/fuse/cuse.c' l='589' u='c' c='cuse_class_abort_store'/>
<def f='linux-4.18.y/fs/fuse/dev.c' l='2096' ll='2156' type='void fuse_abort_conn(struct fuse_conn * fc, bool is_abort)'/>
<dec f='linux-4.18.y/fs/fuse/dev.c' l='2157' type='void fuse_abort_conn(struct fuse_conn * , bool )'/>
<use f='linux-4.18.y/fs/fuse/dev.c' l='2157' c='fuse_abort_conn'/>
<use f='linux-4.18.y/fs/fuse/dev.c' l='2157' u='a'/>
<use f='linux-4.18.y/fs/fuse/dev.c' l='2157' u='a'/>
<use f='linux-4.18.y/fs/fuse/dev.c' l='2183' u='c' c='fuse_dev_release'/>
<doc f='linux-4.18.y/fs/fuse/dev.c' l='2078'>/*
 * Abort all requests.
 *
 * Emergency exit in case of a malicious or accidental deadlock, or just a hung
 * filesystem.
 *
 * The same effect is usually achievable through killing the filesystem daemon
 * and all users of the filesystem.  The exception is the combination of an
 * asynchronous request and the tricky deadlock (see
 * Documentation/filesystems/fuse.txt).
 *
 * Aborting requests under I/O goes as follows: 1: Separate out unlocked
 * requests, they should be finished off immediately.  Locked requests will be
 * finished after unlock; see unlock_request(). 2: Finish off the unlocked
 * requests.  It is possible that some request will finish before we can.  This
 * is OK, the request will in that case be removed from the list before we touch
 * it.
 */</doc>
<use f='linux-4.18.y/fs/fuse/inode.c' l='380' u='c' c='fuse_umount_begin'/>
<use f='linux-4.18.y/fs/fuse/inode.c' l='1223' u='c' c='fuse_sb_destroy'/>
