<dec f='linux-4.14.y/include/drm/drm_blend.h' l='39' type='int drm_plane_create_rotation_property(struct drm_plane * plane, unsigned int rotation, unsigned int supported_rotations)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='140' ll='172' type='int drm_plane_create_rotation_property(struct drm_plane * plane, unsigned int rotation, unsigned int supported_rotations)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' type='int drm_plane_create_rotation_property(struct drm_plane * , unsigned int , unsigned int )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' c='drm_plane_create_rotation_property'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' u='a'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='106'>/**
 * drm_plane_create_rotation_property - create a new rotation property
 * @plane: drm plane
 * @rotation: initial value of the rotation property
 * @supported_rotations: bitmask of supported rotations and reflections
 *
 * This creates a new property with the selected support for transformations.
 *
 * Since a rotation by 180° degress is the same as reflecting both along the x
 * and the y axis the rotation property is somewhat redundant. Drivers can use
 * drm_rotation_simplify() to normalize values of this property.
 *
 * The property exposed to userspace is a bitmask property (see
 * drm_property_create_bitmask()) called &quot;rotation&quot; and has the following
 * bitmask enumaration values:
 *
 * DRM_MODE_ROTATE_0:
 * 	&quot;rotate-0&quot;
 * DRM_MODE_ROTATE_90:
 * 	&quot;rotate-90&quot;
 * DRM_MODE_ROTATE_180:
 * 	&quot;rotate-180&quot;
 * DRM_MODE_ROTATE_270:
 * 	&quot;rotate-270&quot;
 * DRM_MODE_REFLECT_X:
 * 	&quot;reflect-x&quot;
 * DRM_MODE_REFLECT_Y:
 * 	&quot;reflect-y&quot;
 *
 * Rotation is the specified amount in degrees in counter clockwise direction,
 * the X and Y axis are within the source rectangle, i.e.  the X/Y axis before
 * rotation. After reflection, the rotation is applied to the image sampled from
 * the source rectangle, before scaling it to fit the destination rectangle.
 */</doc>
<dec f='linux-4.14.y/include/drm/drm_blend.h' l='39' type='int drm_plane_create_rotation_property(struct drm_plane * plane, unsigned int rotation, unsigned int supported_rotations)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='140' ll='172' type='int drm_plane_create_rotation_property(struct drm_plane * plane, unsigned int rotation, unsigned int supported_rotations)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' type='int drm_plane_create_rotation_property(struct drm_plane * , unsigned int , unsigned int )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' c='drm_plane_create_rotation_property'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='173' u='a'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_blend.c' l='106'>/**
 * drm_plane_create_rotation_property - create a new rotation property
 * @plane: drm plane
 * @rotation: initial value of the rotation property
 * @supported_rotations: bitmask of supported rotations and reflections
 *
 * This creates a new property with the selected support for transformations.
 *
 * Since a rotation by 180° degress is the same as reflecting both along the x
 * and the y axis the rotation property is somewhat redundant. Drivers can use
 * drm_rotation_simplify() to normalize values of this property.
 *
 * The property exposed to userspace is a bitmask property (see
 * drm_property_create_bitmask()) called &quot;rotation&quot; and has the following
 * bitmask enumaration values:
 *
 * DRM_MODE_ROTATE_0:
 * 	&quot;rotate-0&quot;
 * DRM_MODE_ROTATE_90:
 * 	&quot;rotate-90&quot;
 * DRM_MODE_ROTATE_180:
 * 	&quot;rotate-180&quot;
 * DRM_MODE_ROTATE_270:
 * 	&quot;rotate-270&quot;
 * DRM_MODE_REFLECT_X:
 * 	&quot;reflect-x&quot;
 * DRM_MODE_REFLECT_Y:
 * 	&quot;reflect-y&quot;
 *
 * Rotation is the specified amount in degrees in counter clockwise direction,
 * the X and Y axis are within the source rectangle, i.e.  the X/Y axis before
 * rotation. After reflection, the rotation is applied to the image sampled from
 * the source rectangle, before scaling it to fit the destination rectangle.
 */</doc>
