<dec f='linux-4.18.y/include/linux/list_lru.h' l='86' type='bool list_lru_add(struct list_lru * lru, struct list_head * item)'/>
<doc f='linux-4.18.y/include/linux/list_lru.h' l='70'>/**
 * list_lru_add: add an element to the lru list&apos;s tail
 * @list_lru: the lru pointer
 * @item: the item to be added.
 *
 * If the element is already part of a list, this function returns doing
 * nothing. Therefore the caller does not need to keep state about whether or
 * not the element already belongs in the list and is allowed to lazy update
 * it. Note however that this is valid for *a* list, not *this* list. If
 * the caller organize itself in a way that elements can be in more than
 * one type of list, it is up to the caller to fully remove the item from
 * the previous list (with list_lru_del() for instance) before moving it
 * to @list_lru
 *
 * Return value: true if the list was updated, false otherwise
 */</doc>
<use f='linux-4.18.y/drivers/android/binder_alloc.c' l='307' u='c' c='binder_update_page_range'/>
<use f='linux-4.18.y/fs/dcache.c' l='397' u='c' c='d_lru_add'/>
<use f='linux-4.18.y/fs/inode.c' l='410' u='c' c='inode_lru_list_add'/>
<def f='linux-4.18.y/mm/list_lru.c' l='110' ll='127' type='bool list_lru_add(struct list_lru * lru, struct list_head * item)'/>
<dec f='linux-4.18.y/mm/list_lru.c' l='128' type='bool list_lru_add(struct list_lru * , struct list_head * )'/>
<use f='linux-4.18.y/mm/list_lru.c' l='128' c='list_lru_add'/>
<use f='linux-4.18.y/mm/list_lru.c' l='128' u='a'/>
<use f='linux-4.18.y/mm/list_lru.c' l='128' u='a'/>
<use f='linux-4.18.y/mm/workingset.c' l='355' u='c' c='workingset_update_node'/>
