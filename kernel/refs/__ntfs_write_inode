<dec f='linux-4.18.y/fs/ntfs/inode.h' l='310' type='int __ntfs_write_inode(struct inode * vi, int sync)'/>
<use f='linux-4.18.y/fs/ntfs/inode.h' l='315' u='c' c='ntfs_commit_inode'/>
<use f='linux-4.18.y/fs/ntfs/dir.c' l='1525' u='c' c='ntfs_dir_fsync'/>
<use f='linux-4.18.y/fs/ntfs/file.c' l='1999' u='c' c='ntfs_file_fsync'/>
<def f='linux-4.18.y/fs/ntfs/inode.c' l='2957' ll='3100' type='int __ntfs_write_inode(struct inode * vi, int sync)'/>
<doc f='linux-4.18.y/fs/ntfs/inode.c' l='2939'>/**
 * ntfs_write_inode - write out a dirty inode
 * @vi:		inode to write out
 * @sync:	if true, write out synchronously
 *
 * Write out a dirty inode to disk including any extent inodes if present.
 *
 * If @sync is true, commit the inode to disk and wait for io completion.  This
 * is done using write_mft_record().
 *
 * If @sync is false, just schedule the write to happen but do not wait for i/o
 * completion.  In 2.6 kernels, scheduling usually happens just by virtue of
 * marking the page (and in this case mft record) dirty but we do not implement
 * this yet as write_mft_record() largely ignores the @sync parameter and
 * always performs synchronous writes.
 *
 * Return 0 on success and -errno on error.
 */</doc>
<use f='linux-4.18.y/fs/ntfs/super.c' l='2670' u='c' c='ntfs_write_inode'/>
