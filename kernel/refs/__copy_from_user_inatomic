<def f='linux-4.14.y/include/linux/uaccess.h' l='61' ll='67' type='unsigned long __copy_from_user_inatomic(void * to, const void * from, unsigned long n)'/>
<doc f='linux-4.14.y/include/linux/uaccess.h' l='16'>/*
 * Architectures should provide two primitives (raw_copy_{to,from}_user())
 * and get rid of their private instances of copy_{to,from}_user() and
 * __copy_{to,from}_user{,_inatomic}().
 *
 * raw_copy_{to,from}_user(to, from, size) should copy up to size bytes and
 * return the amount left to copy.  They should assume that access_ok() has
 * already been checked (and succeeded); they should *not* zero-pad anything.
 * No KASAN or object size checks either - those belong here.
 *
 * Both of these functions should attempt to copy size bytes starting at from
 * into the area starting at to.  They must not fetch or store anything
 * outside of those areas.  Return value must be between 0 (everything
 * copied successfully) and size (nothing copied).
 *
 * If raw_copy_{to,from}_user(to, from, size) returns N, size - N bytes starting
 * at to must become equal to the bytes fetched from the corresponding area
 * starting at from.  All data past to + size - N must be left unmodified.
 *
 * If copying succeeds, the return value must be 0.  If some data cannot be
 * fetched, it is permitted to copy less than had been fetched; the only
 * hard requirement is that not storing anything at all (i.e. returning size)
 * should happen only when nothing could be copied.  In other words, you don&apos;t
 * have to squeeze as much as possible - it is allowed, but not necessary.
 *
 * For raw_copy_from_user() to always points to kernel memory and no faults
 * on store should happen.  Interpretation of from is affected by set_fs().
 * For raw_copy_to_user() it&apos;s the other way round.
 *
 * Both can be inlined - it&apos;s up to architectures whether it wants to bother
 * with that.  They should not be used directly; they are used to implement
 * the 6 functions (copy_{to,from}_user(), __copy_{to,from}_user_inatomic())
 * that are used instead.  Out of those, __... ones are inlined.  Plain
 * copy_{to,from}_user() might or might not be inlined.  If you want them
 * inlined, have asm/uaccess.h define INLINE_COPY_{TO,FROM}_USER.
 *
 * NOTE: only copy_from_user() zero-pads the destination in case of short copy.
 * Neither __copy_from_user() nor __copy_from_user_inatomic() zero anything
 * at all; their callers absolutely must check the return value.
 *
 * Biarch ones should also provide raw_copy_in_user() - similar to the above,
 * but both source and destination are __user pointers (affected by set_fs()
 * as usual) and both source and destination can trigger faults.
 */</doc>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2423' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2426' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2481' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2484' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/stacktrace.c' l='195' u='c' c='copy_stack_frame'/>
<use f='linux-4.14.y/arch/x86/lib/usercopy.c' l='28' u='c' c='copy_from_user_nmi'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='6108' u='c' c='tracing_mark_write'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='6179' u='c' c='tracing_mark_raw_write'/>
<use f='linux-4.14.y/mm/maccess.c' l='33' u='c' c='__probe_kernel_read'/>
<use f='linux-4.14.y/mm/memory.c' l='2317' u='c' c='cow_user_page'/>
<def f='linux-4.14.y/include/linux/uaccess.h' l='61' ll='67' type='unsigned long __copy_from_user_inatomic(void * to, const void * from, unsigned long n)'/>
<doc f='linux-4.14.y/include/linux/uaccess.h' l='16'>/*
 * Architectures should provide two primitives (raw_copy_{to,from}_user())
 * and get rid of their private instances of copy_{to,from}_user() and
 * __copy_{to,from}_user{,_inatomic}().
 *
 * raw_copy_{to,from}_user(to, from, size) should copy up to size bytes and
 * return the amount left to copy.  They should assume that access_ok() has
 * already been checked (and succeeded); they should *not* zero-pad anything.
 * No KASAN or object size checks either - those belong here.
 *
 * Both of these functions should attempt to copy size bytes starting at from
 * into the area starting at to.  They must not fetch or store anything
 * outside of those areas.  Return value must be between 0 (everything
 * copied successfully) and size (nothing copied).
 *
 * If raw_copy_{to,from}_user(to, from, size) returns N, size - N bytes starting
 * at to must become equal to the bytes fetched from the corresponding area
 * starting at from.  All data past to + size - N must be left unmodified.
 *
 * If copying succeeds, the return value must be 0.  If some data cannot be
 * fetched, it is permitted to copy less than had been fetched; the only
 * hard requirement is that not storing anything at all (i.e. returning size)
 * should happen only when nothing could be copied.  In other words, you don&apos;t
 * have to squeeze as much as possible - it is allowed, but not necessary.
 *
 * For raw_copy_from_user() to always points to kernel memory and no faults
 * on store should happen.  Interpretation of from is affected by set_fs().
 * For raw_copy_to_user() it&apos;s the other way round.
 *
 * Both can be inlined - it&apos;s up to architectures whether it wants to bother
 * with that.  They should not be used directly; they are used to implement
 * the 6 functions (copy_{to,from}_user(), __copy_{to,from}_user_inatomic())
 * that are used instead.  Out of those, __... ones are inlined.  Plain
 * copy_{to,from}_user() might or might not be inlined.  If you want them
 * inlined, have asm/uaccess.h define INLINE_COPY_{TO,FROM}_USER.
 *
 * NOTE: only copy_from_user() zero-pads the destination in case of short copy.
 * Neither __copy_from_user() nor __copy_from_user_inatomic() zero anything
 * at all; their callers absolutely must check the return value.
 *
 * Biarch ones should also provide raw_copy_in_user() - similar to the above,
 * but both source and destination are __user pointers (affected by set_fs()
 * as usual) and both source and destination can trigger faults.
 */</doc>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2423' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2426' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2481' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/events/core.c' l='2484' macro='1' u='c'/>
<use f='linux-4.14.y/arch/x86/kernel/stacktrace.c' l='195' u='c' c='copy_stack_frame'/>
<use f='linux-4.14.y/arch/x86/lib/usercopy.c' l='28' u='c' c='copy_from_user_nmi'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='6108' u='c' c='tracing_mark_write'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='6179' u='c' c='tracing_mark_raw_write'/>
<use f='linux-4.14.y/mm/maccess.c' l='33' u='c' c='__probe_kernel_read'/>
<use f='linux-4.14.y/mm/memory.c' l='2317' u='c' c='cow_user_page'/>
