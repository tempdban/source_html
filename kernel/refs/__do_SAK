<dec f='linux-4.18.y/include/linux/tty.h' l='496' type='void __do_SAK(struct tty_struct * tty)'/>
<def f='linux-4.18.y/drivers/tty/tty_io.c' l='2728' ll='2772' type='void __do_SAK(struct tty_struct * tty)'/>
<use f='linux-4.18.y/drivers/tty/tty_io.c' l='2778' u='c' c='do_SAK_work'/>
<doc f='linux-4.18.y/drivers/tty/tty_io.c' l='2709'>/*
 * This implements the &quot;Secure Attention Key&quot; ---  the idea is to
 * prevent trojan horses by killing all processes associated with this
 * tty when the user hits the &quot;Secure Attention Key&quot;.  Required for
 * super-paranoid applications --- see the Orange Book for more details.
 *
 * This code could be nicer; ideally it should send a HUP, wait a few
 * seconds, then send a INT, and then a KILL signal.  But you then
 * have to coordinate with the init process, since all processes associated
 * with the current tty must be dead before the new getty is allowed
 * to spawn.
 *
 * Now, if it would be correct ;-/ The current code has a nasty hole -
 * it doesn&apos;t catch files in flight. We may send the descriptor to ourselves
 * via AF_UNIX socket, close it and later fetch from socket. FIXME.
 *
 * Nasty bug: do_SAK is being called in interrupt context.  This can
 * deadlock.  We punt it up to process context.  AKPM - 16Mar2001
 */</doc>
<use f='linux-4.18.y/drivers/tty/vt/vt_ioctl.c' l='1063' u='c' c='vc_SAK'/>
