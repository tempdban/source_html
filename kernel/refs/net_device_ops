<def f='linux-4.18.y/include/linux/netdevice.h' l='1205' ll='1393'/>
<size>512</size>
<doc f='linux-4.18.y/include/linux/netdevice.h' l='902'>/*
 * This structure defines the management hooks for network devices.
 * The following hooks can be defined; unless noted otherwise, they are
 * optional and can be filled with a null pointer.
 *
 * int (*ndo_init)(struct net_device *dev);
 *     This function is called once when a network device is registered.
 *     The network device can use this for any late stage initialization
 *     or semantic validation. It can fail with an error code which will
 *     be propagated back to register_netdev.
 *
 * void (*ndo_uninit)(struct net_device *dev);
 *     This function is called when device is unregistered or when registration
 *     fails. It is not called if init fails.
 *
 * int (*ndo_open)(struct net_device *dev);
 *     This function is called when a network device transitions to the up
 *     state.
 *
 * int (*ndo_stop)(struct net_device *dev);
 *     This function is called when a network device transitions to the down
 *     state.
 *
 * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,
 *                               struct net_device *dev);
 *	Called when a packet needs to be transmitted.
 *	Returns NETDEV_TX_OK.  Can return NETDEV_TX_BUSY, but you should stop
 *	the queue before that can happen; it&apos;s for obsolete devices and weird
 *	corner cases, but the stack really does a non-trivial amount
 *	of useless work if you return NETDEV_TX_BUSY.
 *	Required; cannot be NULL.
 *
 * netdev_features_t (*ndo_features_check)(struct sk_buff *skb,
 *					   struct net_device *dev
 *					   netdev_features_t features);
 *	Called by core transmit path to determine if device is capable of
 *	performing offload operations on a given packet. This is to give
 *	the device an opportunity to implement any restrictions that cannot
 *	be otherwise expressed by feature flags. The check is called with
 *	the set of features that the stack has calculated and it returns
 *	those the driver believes to be appropriate.
 *
 * u16 (*ndo_select_queue)(struct net_device *dev, struct sk_buff *skb,
 *                         void *accel_priv, select_queue_fallback_t fallback);
 *	Called to decide which queue to use when device supports multiple
 *	transmit queues.
 *
 * void (*ndo_change_rx_flags)(struct net_device *dev, int flags);
 *	This function is called to allow device receiver to make
 *	changes to configuration when multicast or promiscuous is enabled.
 *
 * void (*ndo_set_rx_mode)(struct net_device *dev);
 *	This function is called device changes address list filtering.
 *	If driver handles unicast address filtering, it should set
 *	IFF_UNICAST_FLT in its priv_flags.
 *
 * int (*ndo_set_mac_address)(struct net_device *dev, void *addr);
 *	This function  is called when the Media Access Control address
 *	needs to be changed. If this interface is not defined, the
 *	MAC address can not be changed.
 *
 * int (*ndo_validate_addr)(struct net_device *dev);
 *	Test if Media Access Control address is valid for the device.
 *
 * int (*ndo_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd);
 *	Called when a user requests an ioctl which can&apos;t be handled by
 *	the generic interface code. If not defined ioctls return
 *	not supported error code.
 *
 * int (*ndo_set_config)(struct net_device *dev, struct ifmap *map);
 *	Used to set network devices bus interface parameters. This interface
 *	is retained for legacy reasons; new devices should use the bus
 *	interface (PCI) for low level management.
 *
 * int (*ndo_change_mtu)(struct net_device *dev, int new_mtu);
 *	Called when a user wants to change the Maximum Transfer Unit
 *	of a device.
 *
 * void (*ndo_tx_timeout)(struct net_device *dev);
 *	Callback used when the transmitter has not made any progress
 *	for dev-&gt;watchdog ticks.
 *
 * void (*ndo_get_stats64)(struct net_device *dev,
 *                         struct rtnl_link_stats64 *storage);
 * struct net_device_stats* (*ndo_get_stats)(struct net_device *dev);
 *	Called when a user wants to get the network device usage
 *	statistics. Drivers must do one of the following:
 *	1. Define @ndo_get_stats64 to fill in a zero-initialised
 *	   rtnl_link_stats64 structure passed by the caller.
 *	2. Define @ndo_get_stats to update a net_device_stats structure
 *	   (which should normally be dev-&gt;stats) and return a pointer to
 *	   it. The structure may be changed asynchronously only if each
 *	   field is written atomically.
 *	3. Update dev-&gt;stats asynchronously and atomically, and define
 *	   neither operation.
 *
 * bool (*ndo_has_offload_stats)(const struct net_device *dev, int attr_id)
 *	Return true if this device supports offload stats of this attr_id.
 *
 * int (*ndo_get_offload_stats)(int attr_id, const struct net_device *dev,
 *	void *attr_data)
 *	Get statistics for offload operations by attr_id. Write it into the
 *	attr_data pointer.
 *
 * int (*ndo_vlan_rx_add_vid)(struct net_device *dev, __be16 proto, u16 vid);
 *	If device supports VLAN filtering this function is called when a
 *	VLAN id is registered.
 *
 * int (*ndo_vlan_rx_kill_vid)(struct net_device *dev, __be16 proto, u16 vid);
 *	If device supports VLAN filtering this function is called when a
 *	VLAN id is unregistered.
 *
 * void (*ndo_poll_controller)(struct net_device *dev);
 *
 *	SR-IOV management functions.
 * int (*ndo_set_vf_mac)(struct net_device *dev, int vf, u8* mac);
 * int (*ndo_set_vf_vlan)(struct net_device *dev, int vf, u16 vlan,
 *			  u8 qos, __be16 proto);
 * int (*ndo_set_vf_rate)(struct net_device *dev, int vf, int min_tx_rate,
 *			  int max_tx_rate);
 * int (*ndo_set_vf_spoofchk)(struct net_device *dev, int vf, bool setting);
 * int (*ndo_set_vf_trust)(struct net_device *dev, int vf, bool setting);
 * int (*ndo_get_vf_config)(struct net_device *dev,
 *			    int vf, struct ifla_vf_info *ivf);
 * int (*ndo_set_vf_link_state)(struct net_device *dev, int vf, int link_state);
 * int (*ndo_set_vf_port)(struct net_device *dev, int vf,
 *			  struct nlattr *port[]);
 *
 *      Enable or disable the VF ability to query its RSS Redirection Table and
 *      Hash Key. This is needed since on some devices VF share this information
 *      with PF and querying it may introduce a theoretical security risk.
 * int (*ndo_set_vf_rss_query_en)(struct net_device *dev, int vf, bool setting);
 * int (*ndo_get_vf_port)(struct net_device *dev, int vf, struct sk_buff *skb);
 * int (*ndo_setup_tc)(struct net_device *dev, enum tc_setup_type type,
 *		       void *type_data);
 *	Called to setup any &apos;tc&apos; scheduler, classifier or action on @dev.
 *	This is always called from the stack with the rtnl lock held and netif
 *	tx queues stopped. This allows the netdevice to perform queue
 *	management safely.
 *
 *	Fiber Channel over Ethernet (FCoE) offload functions.
 * int (*ndo_fcoe_enable)(struct net_device *dev);
 *	Called when the FCoE protocol stack wants to start using LLD for FCoE
 *	so the underlying device can perform whatever needed configuration or
 *	initialization to support acceleration of FCoE traffic.
 *
 * int (*ndo_fcoe_disable)(struct net_device *dev);
 *	Called when the FCoE protocol stack wants to stop using LLD for FCoE
 *	so the underlying device can perform whatever needed clean-ups to
 *	stop supporting acceleration of FCoE traffic.
 *
 * int (*ndo_fcoe_ddp_setup)(struct net_device *dev, u16 xid,
 *			     struct scatterlist *sgl, unsigned int sgc);
 *	Called when the FCoE Initiator wants to initialize an I/O that
 *	is a possible candidate for Direct Data Placement (DDP). The LLD can
 *	perform necessary setup and returns 1 to indicate the device is set up
 *	successfully to perform DDP on this I/O, otherwise this returns 0.
 *
 * int (*ndo_fcoe_ddp_done)(struct net_device *dev,  u16 xid);
 *	Called when the FCoE Initiator/Target is done with the DDPed I/O as
 *	indicated by the FC exchange id &apos;xid&apos;, so the underlying device can
 *	clean up and reuse resources for later DDP requests.
 *
 * int (*ndo_fcoe_ddp_target)(struct net_device *dev, u16 xid,
 *			      struct scatterlist *sgl, unsigned int sgc);
 *	Called when the FCoE Target wants to initialize an I/O that
 *	is a possible candidate for Direct Data Placement (DDP). The LLD can
 *	perform necessary setup and returns 1 to indicate the device is set up
 *	successfully to perform DDP on this I/O, otherwise this returns 0.
 *
 * int (*ndo_fcoe_get_hbainfo)(struct net_device *dev,
 *			       struct netdev_fcoe_hbainfo *hbainfo);
 *	Called when the FCoE Protocol stack wants information on the underlying
 *	device. This information is utilized by the FCoE protocol stack to
 *	register attributes with Fiber Channel management service as per the
 *	FC-GS Fabric Device Management Information(FDMI) specification.
 *
 * int (*ndo_fcoe_get_wwn)(struct net_device *dev, u64 *wwn, int type);
 *	Called when the underlying device wants to override default World Wide
 *	Name (WWN) generation mechanism in FCoE protocol stack to pass its own
 *	World Wide Port Name (WWPN) or World Wide Node Name (WWNN) to the FCoE
 *	protocol stack to use.
 *
 *	RFS acceleration.
 * int (*ndo_rx_flow_steer)(struct net_device *dev, const struct sk_buff *skb,
 *			    u16 rxq_index, u32 flow_id);
 *	Set hardware filter for RFS.  rxq_index is the target queue index;
 *	flow_id is a flow ID to be passed to rps_may_expire_flow() later.
 *	Return the filter ID on success, or a negative error code.
 *
 *	Slave management functions (for bridge, bonding, etc).
 * int (*ndo_add_slave)(struct net_device *dev, struct net_device *slave_dev);
 *	Called to make another netdev an underling.
 *
 * int (*ndo_del_slave)(struct net_device *dev, struct net_device *slave_dev);
 *	Called to release previously enslaved netdev.
 *
 *      Feature/offload setting functions.
 * netdev_features_t (*ndo_fix_features)(struct net_device *dev,
 *		netdev_features_t features);
 *	Adjusts the requested feature flags according to device-specific
 *	constraints, and returns the resulting flags. Must not modify
 *	the device state.
 *
 * int (*ndo_set_features)(struct net_device *dev, netdev_features_t features);
 *	Called to update device configuration to new features. Passed
 *	feature set might be less than what was returned by ndo_fix_features()).
 *	Must return &gt;0 or -errno if it changed dev-&gt;features itself.
 *
 * int (*ndo_fdb_add)(struct ndmsg *ndm, struct nlattr *tb[],
 *		      struct net_device *dev,
 *		      const unsigned char *addr, u16 vid, u16 flags)
 *	Adds an FDB entry to dev for addr.
 * int (*ndo_fdb_del)(struct ndmsg *ndm, struct nlattr *tb[],
 *		      struct net_device *dev,
 *		      const unsigned char *addr, u16 vid)
 *	Deletes the FDB entry from dev coresponding to addr.
 * int (*ndo_fdb_dump)(struct sk_buff *skb, struct netlink_callback *cb,
 *		       struct net_device *dev, struct net_device *filter_dev,
 *		       int *idx)
 *	Used to add FDB entries to dump requests. Implementers should add
 *	entries to skb and update idx with the number of entries.
 *
 * int (*ndo_bridge_setlink)(struct net_device *dev, struct nlmsghdr *nlh,
 *			     u16 flags)
 * int (*ndo_bridge_getlink)(struct sk_buff *skb, u32 pid, u32 seq,
 *			     struct net_device *dev, u32 filter_mask,
 *			     int nlflags)
 * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh,
 *			     u16 flags);
 *
 * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier);
 *	Called to change device carrier. Soft-devices (like dummy, team, etc)
 *	which do not represent real hardware may define this to allow their
 *	userspace components to manage their virtual carrier state. Devices
 *	that determine carrier state from physical hardware properties (eg
 *	network cables) or protocol-dependent mechanisms (eg
 *	USB_CDC_NOTIFY_NETWORK_CONNECTION) should NOT implement this function.
 *
 * int (*ndo_get_phys_port_id)(struct net_device *dev,
 *			       struct netdev_phys_item_id *ppid);
 *	Called to get ID of physical port of this device. If driver does
 *	not implement this, it is assumed that the hw is not able to have
 *	multiple net devices on single physical port.
 *
 * void (*ndo_udp_tunnel_add)(struct net_device *dev,
 *			      struct udp_tunnel_info *ti);
 *	Called by UDP tunnel to notify a driver about the UDP port and socket
 *	address family that a UDP tunnel is listnening to. It is called only
 *	when a new port starts listening. The operation is protected by the
 *	RTNL.
 *
 * void (*ndo_udp_tunnel_del)(struct net_device *dev,
 *			      struct udp_tunnel_info *ti);
 *	Called by UDP tunnel to notify the driver about a UDP port and socket
 *	address family that the UDP tunnel is not listening to anymore. The
 *	operation is protected by the RTNL.
 *
 * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
 *				 struct net_device *dev)
 *	Called by upper layer devices to accelerate switching or other
 *	station functionality into hardware. &apos;pdev is the lowerdev
 *	to use for the offload and &apos;dev&apos; is the net device that will
 *	back the offload. Returns a pointer to the private structure
 *	the upper layer will maintain.
 * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
 *	Called by upper layer device to delete the station created
 *	by &apos;ndo_dfwd_add_station&apos;. &apos;pdev&apos; is the net device backing
 *	the station and priv is the structure returned by the add
 *	operation.
 * int (*ndo_set_tx_maxrate)(struct net_device *dev,
 *			     int queue_index, u32 maxrate);
 *	Called when a user wants to set a max-rate limitation of specific
 *	TX queue.
 * int (*ndo_get_iflink)(const struct net_device *dev);
 *	Called to get the iflink value of this device.
 * void (*ndo_change_proto_down)(struct net_device *dev,
 *				 bool proto_down);
 *	This function is used to pass protocol port error state information
 *	to the switch driver. The switch driver can react to the proto_down
 *      by doing a phys down on the associated switch port.
 * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
 *	This function is used to get egress tunnel information for given skb.
 *	This is useful for retrieving outer tunnel header parameters while
 *	sampling packet.
 * void (*ndo_set_rx_headroom)(struct net_device *dev, int needed_headroom);
 *	This function is used to specify the headroom that the skb must
 *	consider when allocation skb during packet reception. Setting
 *	appropriate rx headroom value allows avoiding skb head copy on
 *	forward. Setting a negative value resets the rx headroom to the
 *	default value.
 * int (*ndo_bpf)(struct net_device *dev, struct netdev_bpf *bpf);
 *	This function is used to set or query state related to XDP on the
 *	netdevice and manage BPF offload. See definition of
 *	enum bpf_netdev_command for details.
 * int (*ndo_xdp_xmit)(struct net_device *dev, int n, struct xdp_frame **xdp,
 *			u32 flags);
 *	This function is used to submit @n XDP packets for transmit on a
 *	netdevice. Returns number of frames successfully transmitted, frames
 *	that got dropped are freed/returned via xdp_return_frame().
 *	Returns negative number, means general error invoking ndo, meaning
 *	no frames were xmit&apos;ed and core-caller will free all frames.
 */</doc>
<mbr r='net_device_ops::ndo_init' o='0' t='int (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_uninit' o='64' t='void (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_open' o='128' t='int (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_stop' o='192' t='int (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_start_xmit' o='256' t='netdev_tx_t (*)(struct sk_buff *, struct net_device *)'/>
<mbr r='net_device_ops::ndo_features_check' o='320' t='netdev_features_t (*)(struct sk_buff *, struct net_device *, netdev_features_t)'/>
<mbr r='net_device_ops::ndo_select_queue' o='384' t='u16 (*)(struct net_device *, struct sk_buff *, void *, select_queue_fallback_t)'/>
<mbr r='net_device_ops::ndo_change_rx_flags' o='448' t='void (*)(struct net_device *, int)'/>
<mbr r='net_device_ops::ndo_set_rx_mode' o='512' t='void (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_set_mac_address' o='576' t='int (*)(struct net_device *, void *)'/>
<mbr r='net_device_ops::ndo_validate_addr' o='640' t='int (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_do_ioctl' o='704' t='int (*)(struct net_device *, struct ifreq *, int)'/>
<mbr r='net_device_ops::ndo_set_config' o='768' t='int (*)(struct net_device *, struct ifmap *)'/>
<mbr r='net_device_ops::ndo_change_mtu' o='832' t='int (*)(struct net_device *, int)'/>
<mbr r='net_device_ops::ndo_neigh_setup' o='896' t='int (*)(struct net_device *, struct neigh_parms *)'/>
<mbr r='net_device_ops::ndo_tx_timeout' o='960' t='void (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_get_stats64' o='1024' t='void (*)(struct net_device *, struct rtnl_link_stats64 *)'/>
<mbr r='net_device_ops::ndo_has_offload_stats' o='1088' t='bool (*)(const struct net_device *, int)'/>
<mbr r='net_device_ops::ndo_get_offload_stats' o='1152' t='int (*)(int, const struct net_device *, void *)'/>
<mbr r='net_device_ops::ndo_get_stats' o='1216' t='struct net_device_stats *(*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_vlan_rx_add_vid' o='1280' t='int (*)(struct net_device *, __be16, u16)'/>
<mbr r='net_device_ops::ndo_vlan_rx_kill_vid' o='1344' t='int (*)(struct net_device *, __be16, u16)'/>
<mbr r='net_device_ops::ndo_set_vf_mac' o='1408' t='int (*)(struct net_device *, int, u8 *)'/>
<mbr r='net_device_ops::ndo_set_vf_vlan' o='1472' t='int (*)(struct net_device *, int, u16, u8, __be16)'/>
<mbr r='net_device_ops::ndo_set_vf_rate' o='1536' t='int (*)(struct net_device *, int, int, int)'/>
<mbr r='net_device_ops::ndo_set_vf_spoofchk' o='1600' t='int (*)(struct net_device *, int, bool)'/>
<mbr r='net_device_ops::ndo_set_vf_trust' o='1664' t='int (*)(struct net_device *, int, bool)'/>
<mbr r='net_device_ops::ndo_get_vf_config' o='1728' t='int (*)(struct net_device *, int, struct ifla_vf_info *)'/>
<mbr r='net_device_ops::ndo_set_vf_link_state' o='1792' t='int (*)(struct net_device *, int, int)'/>
<mbr r='net_device_ops::ndo_get_vf_stats' o='1856' t='int (*)(struct net_device *, int, struct ifla_vf_stats *)'/>
<mbr r='net_device_ops::ndo_set_vf_port' o='1920' t='int (*)(struct net_device *, int, struct nlattr **)'/>
<mbr r='net_device_ops::ndo_get_vf_port' o='1984' t='int (*)(struct net_device *, int, struct sk_buff *)'/>
<mbr r='net_device_ops::ndo_set_vf_guid' o='2048' t='int (*)(struct net_device *, int, u64, int)'/>
<mbr r='net_device_ops::ndo_set_vf_rss_query_en' o='2112' t='int (*)(struct net_device *, int, bool)'/>
<mbr r='net_device_ops::ndo_setup_tc' o='2176' t='int (*)(struct net_device *, enum tc_setup_type, void *)'/>
<mbr r='net_device_ops::ndo_rx_flow_steer' o='2240' t='int (*)(struct net_device *, const struct sk_buff *, u16, u32)'/>
<mbr r='net_device_ops::ndo_add_slave' o='2304' t='int (*)(struct net_device *, struct net_device *, struct netlink_ext_ack *)'/>
<mbr r='net_device_ops::ndo_del_slave' o='2368' t='int (*)(struct net_device *, struct net_device *)'/>
<mbr r='net_device_ops::ndo_fix_features' o='2432' t='netdev_features_t (*)(struct net_device *, netdev_features_t)'/>
<mbr r='net_device_ops::ndo_set_features' o='2496' t='int (*)(struct net_device *, netdev_features_t)'/>
<mbr r='net_device_ops::ndo_neigh_construct' o='2560' t='int (*)(struct net_device *, struct neighbour *)'/>
<mbr r='net_device_ops::ndo_neigh_destroy' o='2624' t='void (*)(struct net_device *, struct neighbour *)'/>
<mbr r='net_device_ops::ndo_fdb_add' o='2688' t='int (*)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16)'/>
<mbr r='net_device_ops::ndo_fdb_del' o='2752' t='int (*)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16)'/>
<mbr r='net_device_ops::ndo_fdb_dump' o='2816' t='int (*)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *)'/>
<mbr r='net_device_ops::ndo_bridge_setlink' o='2880' t='int (*)(struct net_device *, struct nlmsghdr *, u16)'/>
<mbr r='net_device_ops::ndo_bridge_getlink' o='2944' t='int (*)(struct sk_buff *, u32, u32, struct net_device *, u32, int)'/>
<mbr r='net_device_ops::ndo_bridge_dellink' o='3008' t='int (*)(struct net_device *, struct nlmsghdr *, u16)'/>
<mbr r='net_device_ops::ndo_change_carrier' o='3072' t='int (*)(struct net_device *, bool)'/>
<mbr r='net_device_ops::ndo_get_phys_port_id' o='3136' t='int (*)(struct net_device *, struct netdev_phys_item_id *)'/>
<mbr r='net_device_ops::ndo_get_phys_port_name' o='3200' t='int (*)(struct net_device *, char *, size_t)'/>
<mbr r='net_device_ops::ndo_udp_tunnel_add' o='3264' t='void (*)(struct net_device *, struct udp_tunnel_info *)'/>
<mbr r='net_device_ops::ndo_udp_tunnel_del' o='3328' t='void (*)(struct net_device *, struct udp_tunnel_info *)'/>
<mbr r='net_device_ops::ndo_dfwd_add_station' o='3392' t='void *(*)(struct net_device *, struct net_device *)'/>
<mbr r='net_device_ops::ndo_dfwd_del_station' o='3456' t='void (*)(struct net_device *, void *)'/>
<mbr r='net_device_ops::ndo_get_lock_subclass' o='3520' t='int (*)(struct net_device *)'/>
<mbr r='net_device_ops::ndo_set_tx_maxrate' o='3584' t='int (*)(struct net_device *, int, u32)'/>
<mbr r='net_device_ops::ndo_get_iflink' o='3648' t='int (*)(const struct net_device *)'/>
<mbr r='net_device_ops::ndo_change_proto_down' o='3712' t='int (*)(struct net_device *, bool)'/>
<mbr r='net_device_ops::ndo_fill_metadata_dst' o='3776' t='int (*)(struct net_device *, struct sk_buff *)'/>
<mbr r='net_device_ops::ndo_set_rx_headroom' o='3840' t='void (*)(struct net_device *, int)'/>
<mbr r='net_device_ops::ndo_bpf' o='3904' t='int (*)(struct net_device *, struct netdev_bpf *)'/>
<mbr r='net_device_ops::ndo_xdp_xmit' o='3968' t='int (*)(struct net_device *, int, struct xdp_frame **, u32)'/>
<mbr r='net_device_ops::ndo_xsk_async_xmit' o='4032' t='int (*)(struct net_device *, u32)'/>
