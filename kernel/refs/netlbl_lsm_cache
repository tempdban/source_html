<def f='linux-4.14.y/include/net/netlabel.h' l='138' ll='142'/>
<size>24</size>
<doc f='linux-4.14.y/include/net/netlabel.h' l='123'>/**
 * struct netlbl_lsm_cache - NetLabel LSM security attribute cache
 * @refcount: atomic reference counter
 * @free: LSM supplied function to free the cache data
 * @data: LSM supplied cache data
 *
 * Description:
 * This structure is provided for LSMs which wish to make use of the NetLabel
 * caching mechanism to store LSM specific data/attributes in the NetLabel
 * cache.  If the LSM has to perform a lot of translation from the NetLabel
 * security attributes into it&apos;s own internal representation then the cache
 * mechanism can provide a way to eliminate some or all of that translation
 * overhead on a cache hit.
 *
 */</doc>
<mbr r='netlbl_lsm_cache::refcount' o='0' t='refcount_t'/>
<mbr r='netlbl_lsm_cache::free' o='64' t='void (*)(const void *)'/>
<mbr r='netlbl_lsm_cache::data' o='128' t='void *'/>
<def f='linux-4.14.y/include/net/netlabel.h' l='138' ll='142'/>
<size>24</size>
<doc f='linux-4.14.y/include/net/netlabel.h' l='123'>/**
 * struct netlbl_lsm_cache - NetLabel LSM security attribute cache
 * @refcount: atomic reference counter
 * @free: LSM supplied function to free the cache data
 * @data: LSM supplied cache data
 *
 * Description:
 * This structure is provided for LSMs which wish to make use of the NetLabel
 * caching mechanism to store LSM specific data/attributes in the NetLabel
 * cache.  If the LSM has to perform a lot of translation from the NetLabel
 * security attributes into it&apos;s own internal representation then the cache
 * mechanism can provide a way to eliminate some or all of that translation
 * overhead on a cache hit.
 *
 */</doc>
<mbr r='netlbl_lsm_cache::refcount' o='0' t='refcount_t'/>
<mbr r='netlbl_lsm_cache::free' o='64' t='void (*)(const void *)'/>
<mbr r='netlbl_lsm_cache::data' o='128' t='void *'/>
