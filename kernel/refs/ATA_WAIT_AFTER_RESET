<dec f='linux-4.14.y/include/linux/libata.h' l='307' type='150'/>
<doc f='linux-4.14.y/include/linux/libata.h' l='297'>/* Spec mandates to wait for &quot;&gt;= 2ms&quot; before checking status
	 * after reset.  We wait 150ms, because that was the magic
	 * delay used for ATAPI devices in Hale Landis&apos;s ATADRVR, for
	 * the period of time between when the ATA command register is
	 * written, and then status is checked.  Because waiting for
	 * &quot;a while&quot; before checking status is fine, post SRST, we
	 * perform this magic delay here as well.
	 *
	 * Old drivers/ide uses the 2mS rule and then waits for ready.
	 */</doc>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='3784' u='r' c='ata_wait_after_reset'/>
<use f='linux-4.14.y/drivers/ata/libata-sff.c' l='1928' u='r' c='ata_sff_wait_after_reset'/>
<dec f='linux-4.14.y/include/linux/libata.h' l='307' type='150'/>
<doc f='linux-4.14.y/include/linux/libata.h' l='297'>/* Spec mandates to wait for &quot;&gt;= 2ms&quot; before checking status
	 * after reset.  We wait 150ms, because that was the magic
	 * delay used for ATAPI devices in Hale Landis&apos;s ATADRVR, for
	 * the period of time between when the ATA command register is
	 * written, and then status is checked.  Because waiting for
	 * &quot;a while&quot; before checking status is fine, post SRST, we
	 * perform this magic delay here as well.
	 *
	 * Old drivers/ide uses the 2mS rule and then waits for ready.
	 */</doc>
<use f='linux-4.14.y/drivers/ata/libata-core.c' l='3784' u='r' c='ata_wait_after_reset'/>
<use f='linux-4.14.y/drivers/ata/libata-sff.c' l='1928' u='r' c='ata_sff_wait_after_reset'/>
