<def f='linux-4.14.y/include/linux/skbuff.h' l='658' ll='837'/>
<size>216</size>
<doc f='linux-4.14.y/include/linux/skbuff.h' l='585'>/** 
 *	struct sk_buff - socket buffer
 *	@next: Next buffer in list
 *	@prev: Previous buffer in list
 *	@tstamp: Time we arrived/left
 *	@rbnode: RB tree node, alternative to next/prev for netem/tcp
 *	@sk: Socket we are owned by
 *	@dev: Device we arrived on/are leaving by
 *	@cb: Control buffer. Free for use by every layer. Put private vars here
 *	@_skb_refdst: destination entry (with norefcount bit)
 *	@sp: the security path, used for xfrm
 *	@len: Length of actual data
 *	@data_len: Data length
 *	@mac_len: Length of link layer header
 *	@hdr_len: writable header length of cloned skb
 *	@csum: Checksum (must include start/offset pair)
 *	@csum_start: Offset from skb-&gt;head where checksumming should start
 *	@csum_offset: Offset from csum_start where checksum should be stored
 *	@priority: Packet queueing priority
 *	@ignore_df: allow local fragmentation
 *	@cloned: Head may be cloned (check refcnt to be sure)
 *	@ip_summed: Driver fed us an IP checksum
 *	@nohdr: Payload reference only, must not modify header
 *	@pkt_type: Packet class
 *	@fclone: skbuff clone status
 *	@ipvs_property: skbuff is owned by ipvs
 *	@tc_skip_classify: do not classify packet. set by IFB device
 *	@tc_at_ingress: used within tc_classify to distinguish in/egress
 *	@tc_redirected: packet was redirected by a tc action
 *	@tc_from_ingress: if tc_redirected, tc_at_ingress at time of redirect
 *	@peeked: this packet has been seen already, so stats have been
 *		done for it, don&apos;t do them again
 *	@nf_trace: netfilter packet trace flag
 *	@protocol: Packet protocol from driver
 *	@destructor: Destruct function
 *	@_nfct: Associated connection, if any (with nfctinfo bits)
 *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
 *	@skb_iif: ifindex of device we arrived on
 *	@tc_index: Traffic control index
 *	@hash: the packet hash
 *	@queue_mapping: Queue mapping for multiqueue devices
 *	@xmit_more: More SKBs are pending for this queue
 *	@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves
 *	@ndisc_nodetype: router type (from link layer)
 *	@ooo_okay: allow the mapping of a socket to a queue to be changed
 *	@l4_hash: indicate hash is a canonical 4-tuple hash over transport
 *		ports.
 *	@sw_hash: indicates hash was computed in software stack
 *	@wifi_acked_valid: wifi_acked was set
 *	@wifi_acked: whether frame was acked on wifi or not
 *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS
 *	@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL
 *	@dst_pending_confirm: need to confirm neighbour
  *	@napi_id: id of the NAPI struct this skb came from
 *	@secmark: security marking
 *	@mark: Generic packet mark
 *	@vlan_proto: vlan encapsulation protocol
 *	@vlan_tci: vlan tag control information
 *	@inner_protocol: Protocol (encapsulation)
 *	@inner_transport_header: Inner transport layer header (encapsulation)
 *	@inner_network_header: Network layer header (encapsulation)
 *	@inner_mac_header: Link layer header (encapsulation)
 *	@transport_header: Transport layer header
 *	@network_header: Network layer header
 *	@mac_header: Link layer header
 *	@tail: Tail pointer
 *	@end: End pointer
 *	@head: Head of buffer
 *	@data: Data head pointer
 *	@truesize: Buffer size
 *	@users: User count - see {datagram,tcp}.c
 */</doc>
<mbr r='sk_buff::sk' o='192' t='struct sock *'/>
<mbr r='sk_buff::cb' o='320' t='char [48]'/>
<mbr r='sk_buff::_skb_refdst' o='704' t='unsigned long'/>
<mbr r='sk_buff::destructor' o='768' t='void (*)(struct sk_buff *)'/>
<mbr r='sk_buff::_nfct' o='832' t='unsigned long'/>
<mbr r='sk_buff::len' o='896' t='unsigned int'/>
<mbr r='sk_buff::data_len' o='928' t='unsigned int'/>
<mbr r='sk_buff::mac_len' o='960' t='__u16'/>
<mbr r='sk_buff::hdr_len' o='976' t='__u16'/>
<mbr r='sk_buff::queue_mapping' o='992' t='__u16'/>
<mbr r='sk_buff::__cloned_offset' o='1008' t='__u8 [0]'/>
<mbr r='sk_buff::cloned' o='1008' t='__u8'/>
<mbr r='sk_buff::nohdr' o='1009' t='__u8'/>
<mbr r='sk_buff::fclone' o='1010' t='__u8'/>
<mbr r='sk_buff::peeked' o='1012' t='__u8'/>
<mbr r='sk_buff::head_frag' o='1013' t='__u8'/>
<mbr r='sk_buff::xmit_more' o='1014' t='__u8'/>
<mbr r='sk_buff::pfmemalloc' o='1015' t='__u8'/>
<mbr r='sk_buff::headers_start' o='1024' t='__u32 [0]'/>
<mbr r='sk_buff::__pkt_type_offset' o='1024' t='__u8 [0]'/>
<mbr r='sk_buff::pkt_type' o='1024' t='__u8'/>
<mbr r='sk_buff::ignore_df' o='1027' t='__u8'/>
<mbr r='sk_buff::nf_trace' o='1028' t='__u8'/>
<mbr r='sk_buff::ip_summed' o='1029' t='__u8'/>
<mbr r='sk_buff::ooo_okay' o='1031' t='__u8'/>
<mbr r='sk_buff::l4_hash' o='1032' t='__u8'/>
<mbr r='sk_buff::sw_hash' o='1033' t='__u8'/>
<mbr r='sk_buff::wifi_acked_valid' o='1034' t='__u8'/>
<mbr r='sk_buff::wifi_acked' o='1035' t='__u8'/>
<mbr r='sk_buff::no_fcs' o='1036' t='__u8'/>
<mbr r='sk_buff::encapsulation' o='1037' t='__u8'/>
<mbr r='sk_buff::encap_hdr_csum' o='1038' t='__u8'/>
<mbr r='sk_buff::csum_valid' o='1039' t='__u8'/>
<mbr r='sk_buff::csum_complete_sw' o='1040' t='__u8'/>
<mbr r='sk_buff::csum_level' o='1041' t='__u8'/>
<mbr r='sk_buff::csum_not_inet' o='1043' t='__u8'/>
<mbr r='sk_buff::dst_pending_confirm' o='1044' t='__u8'/>
<mbr r='sk_buff::ipvs_property' o='1045' t='__u8'/>
<mbr r='sk_buff::inner_protocol_type' o='1046' t='__u8'/>
<mbr r='sk_buff::remcsum_offload' o='1047' t='__u8'/>
<mbr r='sk_buff::priority' o='1088' t='__u32'/>
<mbr r='sk_buff::skb_iif' o='1120' t='int'/>
<mbr r='sk_buff::hash' o='1152' t='__u32'/>
<mbr r='sk_buff::vlan_proto' o='1184' t='__be16'/>
<mbr r='sk_buff::vlan_tci' o='1200' t='__u16'/>
<mbr r='sk_buff::secmark' o='1248' t='__u32'/>
<mbr r='sk_buff::inner_transport_header' o='1328' t='__u16'/>
<mbr r='sk_buff::inner_network_header' o='1344' t='__u16'/>
<mbr r='sk_buff::inner_mac_header' o='1360' t='__u16'/>
<mbr r='sk_buff::protocol' o='1376' t='__be16'/>
<mbr r='sk_buff::transport_header' o='1392' t='__u16'/>
<mbr r='sk_buff::network_header' o='1408' t='__u16'/>
<mbr r='sk_buff::mac_header' o='1424' t='__u16'/>
<mbr r='sk_buff::headers_end' o='1440' t='__u32 [0]'/>
<mbr r='sk_buff::tail' o='1440' t='sk_buff_data_t'/>
<mbr r='sk_buff::end' o='1472' t='sk_buff_data_t'/>
<mbr r='sk_buff::head' o='1536' t='unsigned char *'/>
<mbr r='sk_buff::data' o='1600' t='unsigned char *'/>
<mbr r='sk_buff::truesize' o='1664' t='unsigned int'/>
<mbr r='sk_buff::users' o='1696' t='refcount_t'/>
<def f='linux-4.14.y/include/linux/skbuff.h' l='658' ll='837'/>
<size>216</size>
<doc f='linux-4.14.y/include/linux/skbuff.h' l='585'>/** 
 *	struct sk_buff - socket buffer
 *	@next: Next buffer in list
 *	@prev: Previous buffer in list
 *	@tstamp: Time we arrived/left
 *	@rbnode: RB tree node, alternative to next/prev for netem/tcp
 *	@sk: Socket we are owned by
 *	@dev: Device we arrived on/are leaving by
 *	@cb: Control buffer. Free for use by every layer. Put private vars here
 *	@_skb_refdst: destination entry (with norefcount bit)
 *	@sp: the security path, used for xfrm
 *	@len: Length of actual data
 *	@data_len: Data length
 *	@mac_len: Length of link layer header
 *	@hdr_len: writable header length of cloned skb
 *	@csum: Checksum (must include start/offset pair)
 *	@csum_start: Offset from skb-&gt;head where checksumming should start
 *	@csum_offset: Offset from csum_start where checksum should be stored
 *	@priority: Packet queueing priority
 *	@ignore_df: allow local fragmentation
 *	@cloned: Head may be cloned (check refcnt to be sure)
 *	@ip_summed: Driver fed us an IP checksum
 *	@nohdr: Payload reference only, must not modify header
 *	@pkt_type: Packet class
 *	@fclone: skbuff clone status
 *	@ipvs_property: skbuff is owned by ipvs
 *	@tc_skip_classify: do not classify packet. set by IFB device
 *	@tc_at_ingress: used within tc_classify to distinguish in/egress
 *	@tc_redirected: packet was redirected by a tc action
 *	@tc_from_ingress: if tc_redirected, tc_at_ingress at time of redirect
 *	@peeked: this packet has been seen already, so stats have been
 *		done for it, don&apos;t do them again
 *	@nf_trace: netfilter packet trace flag
 *	@protocol: Packet protocol from driver
 *	@destructor: Destruct function
 *	@_nfct: Associated connection, if any (with nfctinfo bits)
 *	@nf_bridge: Saved data about a bridged frame - see br_netfilter.c
 *	@skb_iif: ifindex of device we arrived on
 *	@tc_index: Traffic control index
 *	@hash: the packet hash
 *	@queue_mapping: Queue mapping for multiqueue devices
 *	@xmit_more: More SKBs are pending for this queue
 *	@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves
 *	@ndisc_nodetype: router type (from link layer)
 *	@ooo_okay: allow the mapping of a socket to a queue to be changed
 *	@l4_hash: indicate hash is a canonical 4-tuple hash over transport
 *		ports.
 *	@sw_hash: indicates hash was computed in software stack
 *	@wifi_acked_valid: wifi_acked was set
 *	@wifi_acked: whether frame was acked on wifi or not
 *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS
 *	@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL
 *	@dst_pending_confirm: need to confirm neighbour
  *	@napi_id: id of the NAPI struct this skb came from
 *	@secmark: security marking
 *	@mark: Generic packet mark
 *	@vlan_proto: vlan encapsulation protocol
 *	@vlan_tci: vlan tag control information
 *	@inner_protocol: Protocol (encapsulation)
 *	@inner_transport_header: Inner transport layer header (encapsulation)
 *	@inner_network_header: Network layer header (encapsulation)
 *	@inner_mac_header: Link layer header (encapsulation)
 *	@transport_header: Transport layer header
 *	@network_header: Network layer header
 *	@mac_header: Link layer header
 *	@tail: Tail pointer
 *	@end: End pointer
 *	@head: Head of buffer
 *	@data: Data head pointer
 *	@truesize: Buffer size
 *	@users: User count - see {datagram,tcp}.c
 */</doc>
<mbr r='sk_buff::sk' o='192' t='struct sock *'/>
<mbr r='sk_buff::cb' o='320' t='char [48]'/>
<mbr r='sk_buff::_skb_refdst' o='704' t='unsigned long'/>
<mbr r='sk_buff::destructor' o='768' t='void (*)(struct sk_buff *)'/>
<mbr r='sk_buff::_nfct' o='832' t='unsigned long'/>
<mbr r='sk_buff::len' o='896' t='unsigned int'/>
<mbr r='sk_buff::data_len' o='928' t='unsigned int'/>
<mbr r='sk_buff::mac_len' o='960' t='__u16'/>
<mbr r='sk_buff::hdr_len' o='976' t='__u16'/>
<mbr r='sk_buff::queue_mapping' o='992' t='__u16'/>
<mbr r='sk_buff::__cloned_offset' o='1008' t='__u8 [0]'/>
<mbr r='sk_buff::cloned' o='1008' t='__u8'/>
<mbr r='sk_buff::nohdr' o='1009' t='__u8'/>
<mbr r='sk_buff::fclone' o='1010' t='__u8'/>
<mbr r='sk_buff::peeked' o='1012' t='__u8'/>
<mbr r='sk_buff::head_frag' o='1013' t='__u8'/>
<mbr r='sk_buff::xmit_more' o='1014' t='__u8'/>
<mbr r='sk_buff::pfmemalloc' o='1015' t='__u8'/>
<mbr r='sk_buff::headers_start' o='1024' t='__u32 [0]'/>
<mbr r='sk_buff::__pkt_type_offset' o='1024' t='__u8 [0]'/>
<mbr r='sk_buff::pkt_type' o='1024' t='__u8'/>
<mbr r='sk_buff::ignore_df' o='1027' t='__u8'/>
<mbr r='sk_buff::nf_trace' o='1028' t='__u8'/>
<mbr r='sk_buff::ip_summed' o='1029' t='__u8'/>
<mbr r='sk_buff::ooo_okay' o='1031' t='__u8'/>
<mbr r='sk_buff::l4_hash' o='1032' t='__u8'/>
<mbr r='sk_buff::sw_hash' o='1033' t='__u8'/>
<mbr r='sk_buff::wifi_acked_valid' o='1034' t='__u8'/>
<mbr r='sk_buff::wifi_acked' o='1035' t='__u8'/>
<mbr r='sk_buff::no_fcs' o='1036' t='__u8'/>
<mbr r='sk_buff::encapsulation' o='1037' t='__u8'/>
<mbr r='sk_buff::encap_hdr_csum' o='1038' t='__u8'/>
<mbr r='sk_buff::csum_valid' o='1039' t='__u8'/>
<mbr r='sk_buff::csum_complete_sw' o='1040' t='__u8'/>
<mbr r='sk_buff::csum_level' o='1041' t='__u8'/>
<mbr r='sk_buff::csum_not_inet' o='1043' t='__u8'/>
<mbr r='sk_buff::dst_pending_confirm' o='1044' t='__u8'/>
<mbr r='sk_buff::ipvs_property' o='1045' t='__u8'/>
<mbr r='sk_buff::inner_protocol_type' o='1046' t='__u8'/>
<mbr r='sk_buff::remcsum_offload' o='1047' t='__u8'/>
<mbr r='sk_buff::priority' o='1088' t='__u32'/>
<mbr r='sk_buff::skb_iif' o='1120' t='int'/>
<mbr r='sk_buff::hash' o='1152' t='__u32'/>
<mbr r='sk_buff::vlan_proto' o='1184' t='__be16'/>
<mbr r='sk_buff::vlan_tci' o='1200' t='__u16'/>
<mbr r='sk_buff::secmark' o='1248' t='__u32'/>
<mbr r='sk_buff::inner_transport_header' o='1328' t='__u16'/>
<mbr r='sk_buff::inner_network_header' o='1344' t='__u16'/>
<mbr r='sk_buff::inner_mac_header' o='1360' t='__u16'/>
<mbr r='sk_buff::protocol' o='1376' t='__be16'/>
<mbr r='sk_buff::transport_header' o='1392' t='__u16'/>
<mbr r='sk_buff::network_header' o='1408' t='__u16'/>
<mbr r='sk_buff::mac_header' o='1424' t='__u16'/>
<mbr r='sk_buff::headers_end' o='1440' t='__u32 [0]'/>
<mbr r='sk_buff::tail' o='1440' t='sk_buff_data_t'/>
<mbr r='sk_buff::end' o='1472' t='sk_buff_data_t'/>
<mbr r='sk_buff::head' o='1536' t='unsigned char *'/>
<mbr r='sk_buff::data' o='1600' t='unsigned char *'/>
<mbr r='sk_buff::truesize' o='1664' t='unsigned int'/>
<mbr r='sk_buff::users' o='1696' t='refcount_t'/>
