<dec f='linux-4.14.y/include/drm/drm_simple_kms_helper.h' l='59' type='int (*)(struct drm_simple_display_pipe *, struct drm_plane_state *, struct drm_crtc_state *)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='116' u='r' c='drm_simple_kms_plane_atomic_check'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='119' u='r' c='drm_simple_kms_plane_atomic_check'/>
<offset>128</offset>
<doc f='linux-4.14.y/include/drm/drm_simple_kms_helper.h' l='42'>/**
	 * @check:
	 *
	 * This function is called in the check phase of an atomic update,
	 * specifically when the underlying plane is checked.
	 * The simple display pipeline helpers already check that the plane is
	 * not scaled, fills the entire visible area and is always enabled
	 * when the crtc is also enabled.
	 * This hook is optional.
	 *
	 * RETURNS:
	 *
	 * 0 on success, -EINVAL if the state or the transition can&apos;t be
	 * supported, -ENOMEM on memory allocation failure and -EDEADLK if an
	 * attempt to obtain another state object ran into a &amp;drm_modeset_lock
	 * deadlock.
	 */</doc>
<dec f='linux-4.14.y/include/drm/drm_simple_kms_helper.h' l='59' type='int (*)(struct drm_simple_display_pipe *, struct drm_plane_state *, struct drm_crtc_state *)'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='116' u='r' c='drm_simple_kms_plane_atomic_check'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_simple_kms_helper.c' l='119' u='r' c='drm_simple_kms_plane_atomic_check'/>
<offset>128</offset>
<doc f='linux-4.14.y/include/drm/drm_simple_kms_helper.h' l='42'>/**
	 * @check:
	 *
	 * This function is called in the check phase of an atomic update,
	 * specifically when the underlying plane is checked.
	 * The simple display pipeline helpers already check that the plane is
	 * not scaled, fills the entire visible area and is always enabled
	 * when the crtc is also enabled.
	 * This hook is optional.
	 *
	 * RETURNS:
	 *
	 * 0 on success, -EINVAL if the state or the transition can&apos;t be
	 * supported, -ENOMEM on memory allocation failure and -EDEADLK if an
	 * attempt to obtain another state object ran into a &amp;drm_modeset_lock
	 * deadlock.
	 */</doc>
