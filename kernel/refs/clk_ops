<def f='linux-4.14.y/include/linux/clk-provider.h' l='192' ll='220'/>
<size>160</size>
<doc f='linux-4.14.y/include/linux/clk-provider.h' l='66'>/**
 * struct clk_ops -  Callback operations for hardware clocks; these are to
 * be provided by the clock implementation, and will be called by drivers
 * through the clk_* api.
 *
 * @prepare:	Prepare the clock for enabling. This must not return until
 *		the clock is fully prepared, and it&apos;s safe to call clk_enable.
 *		This callback is intended to allow clock implementations to
 *		do any initialisation that may sleep. Called with
 *		prepare_lock held.
 *
 * @unprepare:	Release the clock from its prepared state. This will typically
 *		undo any work done in the @prepare callback. Called with
 *		prepare_lock held.
 *
 * @is_prepared: Queries the hardware to determine if the clock is prepared.
 *		This function is allowed to sleep. Optional, if this op is not
 *		set then the prepare count will be used.
 *
 * @unprepare_unused: Unprepare the clock atomically.  Only called from
 *		clk_disable_unused for prepare clocks with special needs.
 *		Called with prepare mutex held. This function may sleep.
 *
 * @enable:	Enable the clock atomically. This must not return until the
 *		clock is generating a valid clock signal, usable by consumer
 *		devices. Called with enable_lock held. This function must not
 *		sleep.
 *
 * @disable:	Disable the clock atomically. Called with enable_lock held.
 *		This function must not sleep.
 *
 * @is_enabled:	Queries the hardware to determine if the clock is enabled.
 *		This function must not sleep. Optional, if this op is not
 *		set then the enable count will be used.
 *
 * @disable_unused: Disable the clock atomically.  Only called from
 *		clk_disable_unused for gate clocks with special needs.
 *		Called with enable_lock held.  This function must not
 *		sleep.
 *
 * @recalc_rate	Recalculate the rate of this clock, by querying hardware. The
 *		parent rate is an input parameter.  It is up to the caller to
 *		ensure that the prepare_mutex is held across this call.
 *		Returns the calculated rate.  Optional, but recommended - if
 *		this op is not set then clock rate will be initialized to 0.
 *
 * @round_rate:	Given a target rate as input, returns the closest rate actually
 *		supported by the clock. The parent rate is an input/output
 *		parameter.
 *
 * @determine_rate: Given a target rate as input, returns the closest rate
 *		actually supported by the clock, and optionally the parent clock
 *		that should be used to provide the clock rate.
 *
 * @set_parent:	Change the input source of this clock; for clocks with multiple
 *		possible parents specify a new parent by passing in the index
 *		as a u8 corresponding to the parent in either the .parent_names
 *		or .parents arrays.  This function in affect translates an
 *		array index into the value programmed into the hardware.
 *		Returns 0 on success, -EERROR otherwise.
 *
 * @get_parent:	Queries the hardware to determine the parent of a clock.  The
 *		return value is a u8 which specifies the index corresponding to
 *		the parent clock.  This index can be applied to either the
 *		.parent_names or .parents arrays.  In short, this function
 *		translates the parent value read from hardware into an array
 *		index.  Currently only called when the clock is initialized by
 *		__clk_init.  This callback is mandatory for clocks with
 *		multiple parents.  It is optional (and unnecessary) for clocks
 *		with 0 or 1 parents.
 *
 * @set_rate:	Change the rate of this clock. The requested rate is specified
 *		by the second argument, which should typically be the return
 *		of .round_rate call.  The third argument gives the parent rate
 *		which is likely helpful for most .set_rate implementation.
 *		Returns 0 on success, -EERROR otherwise.
 *
 * @set_rate_and_parent: Change the rate and the parent of this clock. The
 *		requested rate is specified by the second argument, which
 *		should typically be the return of .round_rate call.  The
 *		third argument gives the parent rate which is likely helpful
 *		for most .set_rate_and_parent implementation. The fourth
 *		argument gives the parent index. This callback is optional (and
 *		unnecessary) for clocks with 0 or 1 parents as well as
 *		for clocks that can tolerate switching the rate and the parent
 *		separately via calls to .set_parent and .set_rate.
 *		Returns 0 on success, -EERROR otherwise.
 *
 * @recalc_accuracy: Recalculate the accuracy of this clock. The clock accuracy
 *		is expressed in ppb (parts per billion). The parent accuracy is
 *		an input parameter.
 *		Returns the calculated accuracy.  Optional - if	this op is not
 *		set then clock accuracy will be initialized to parent accuracy
 *		or 0 (perfect clock) if clock has no parent.
 *
 * @get_phase:	Queries the hardware to get the current phase of a clock.
 *		Returned values are 0-359 degrees on success, negative
 *		error codes on failure.
 *
 * @set_phase:	Shift the phase this clock signal in degrees specified
 *		by the second argument. Valid values for degrees are
 *		0-359. Return 0 on success, otherwise -EERROR.
 *
 * @init:	Perform platform-specific initialization magic.
 *		This is not not used by any of the basic clock types.
 *		Please consider other ways of solving initialization problems
 *		before using this callback, as its use is discouraged.
 *
 * @debug_init:	Set up type-specific debugfs entries for this clock.  This
 *		is called once, after the debugfs directory entry for this
 *		clock has been created.  The dentry pointer representing that
 *		directory is provided as an argument.  Called with
 *		prepare_lock held.  Returns 0 on success, -EERROR otherwise.
 *
 *
 * The clk_enable/clk_disable and clk_prepare/clk_unprepare pairs allow
 * implementations to split any work between atomic (enable) and sleepable
 * (prepare) contexts.  If enabling a clock requires code that might sleep,
 * this must be done in clk_prepare.  Clock enable code that will never be
 * called in a sleepable context may be implemented in clk_enable.
 *
 * Typically, drivers will call clk_prepare when a clock may be needed later
 * (eg. when a device is opened), and clk_enable when the clock is actually
 * required (eg. from an interrupt). Note that clk_prepare MUST have been
 * called before clk_enable.
 */</doc>
<mbr r='clk_ops::prepare' o='0' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::unprepare' o='64' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::is_prepared' o='128' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::unprepare_unused' o='192' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::enable' o='256' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::disable' o='320' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::is_enabled' o='384' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::disable_unused' o='448' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::recalc_rate' o='512' t='unsigned long (*)(struct clk_hw *, unsigned long)'/>
<mbr r='clk_ops::round_rate' o='576' t='long (*)(struct clk_hw *, unsigned long, unsigned long *)'/>
<mbr r='clk_ops::determine_rate' o='640' t='int (*)(struct clk_hw *, struct clk_rate_request *)'/>
<mbr r='clk_ops::set_parent' o='704' t='int (*)(struct clk_hw *, u8)'/>
<mbr r='clk_ops::get_parent' o='768' t='u8 (*)(struct clk_hw *)'/>
<mbr r='clk_ops::set_rate' o='832' t='int (*)(struct clk_hw *, unsigned long, unsigned long)'/>
<mbr r='clk_ops::set_rate_and_parent' o='896' t='int (*)(struct clk_hw *, unsigned long, unsigned long, u8)'/>
<mbr r='clk_ops::recalc_accuracy' o='960' t='unsigned long (*)(struct clk_hw *, unsigned long)'/>
<mbr r='clk_ops::get_phase' o='1024' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::set_phase' o='1088' t='int (*)(struct clk_hw *, int)'/>
<mbr r='clk_ops::init' o='1152' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::debug_init' o='1216' t='int (*)(struct clk_hw *, struct dentry *)'/>
<def f='linux-4.14.y/include/linux/clk-provider.h' l='192' ll='220'/>
<size>160</size>
<doc f='linux-4.14.y/include/linux/clk-provider.h' l='66'>/**
 * struct clk_ops -  Callback operations for hardware clocks; these are to
 * be provided by the clock implementation, and will be called by drivers
 * through the clk_* api.
 *
 * @prepare:	Prepare the clock for enabling. This must not return until
 *		the clock is fully prepared, and it&apos;s safe to call clk_enable.
 *		This callback is intended to allow clock implementations to
 *		do any initialisation that may sleep. Called with
 *		prepare_lock held.
 *
 * @unprepare:	Release the clock from its prepared state. This will typically
 *		undo any work done in the @prepare callback. Called with
 *		prepare_lock held.
 *
 * @is_prepared: Queries the hardware to determine if the clock is prepared.
 *		This function is allowed to sleep. Optional, if this op is not
 *		set then the prepare count will be used.
 *
 * @unprepare_unused: Unprepare the clock atomically.  Only called from
 *		clk_disable_unused for prepare clocks with special needs.
 *		Called with prepare mutex held. This function may sleep.
 *
 * @enable:	Enable the clock atomically. This must not return until the
 *		clock is generating a valid clock signal, usable by consumer
 *		devices. Called with enable_lock held. This function must not
 *		sleep.
 *
 * @disable:	Disable the clock atomically. Called with enable_lock held.
 *		This function must not sleep.
 *
 * @is_enabled:	Queries the hardware to determine if the clock is enabled.
 *		This function must not sleep. Optional, if this op is not
 *		set then the enable count will be used.
 *
 * @disable_unused: Disable the clock atomically.  Only called from
 *		clk_disable_unused for gate clocks with special needs.
 *		Called with enable_lock held.  This function must not
 *		sleep.
 *
 * @recalc_rate	Recalculate the rate of this clock, by querying hardware. The
 *		parent rate is an input parameter.  It is up to the caller to
 *		ensure that the prepare_mutex is held across this call.
 *		Returns the calculated rate.  Optional, but recommended - if
 *		this op is not set then clock rate will be initialized to 0.
 *
 * @round_rate:	Given a target rate as input, returns the closest rate actually
 *		supported by the clock. The parent rate is an input/output
 *		parameter.
 *
 * @determine_rate: Given a target rate as input, returns the closest rate
 *		actually supported by the clock, and optionally the parent clock
 *		that should be used to provide the clock rate.
 *
 * @set_parent:	Change the input source of this clock; for clocks with multiple
 *		possible parents specify a new parent by passing in the index
 *		as a u8 corresponding to the parent in either the .parent_names
 *		or .parents arrays.  This function in affect translates an
 *		array index into the value programmed into the hardware.
 *		Returns 0 on success, -EERROR otherwise.
 *
 * @get_parent:	Queries the hardware to determine the parent of a clock.  The
 *		return value is a u8 which specifies the index corresponding to
 *		the parent clock.  This index can be applied to either the
 *		.parent_names or .parents arrays.  In short, this function
 *		translates the parent value read from hardware into an array
 *		index.  Currently only called when the clock is initialized by
 *		__clk_init.  This callback is mandatory for clocks with
 *		multiple parents.  It is optional (and unnecessary) for clocks
 *		with 0 or 1 parents.
 *
 * @set_rate:	Change the rate of this clock. The requested rate is specified
 *		by the second argument, which should typically be the return
 *		of .round_rate call.  The third argument gives the parent rate
 *		which is likely helpful for most .set_rate implementation.
 *		Returns 0 on success, -EERROR otherwise.
 *
 * @set_rate_and_parent: Change the rate and the parent of this clock. The
 *		requested rate is specified by the second argument, which
 *		should typically be the return of .round_rate call.  The
 *		third argument gives the parent rate which is likely helpful
 *		for most .set_rate_and_parent implementation. The fourth
 *		argument gives the parent index. This callback is optional (and
 *		unnecessary) for clocks with 0 or 1 parents as well as
 *		for clocks that can tolerate switching the rate and the parent
 *		separately via calls to .set_parent and .set_rate.
 *		Returns 0 on success, -EERROR otherwise.
 *
 * @recalc_accuracy: Recalculate the accuracy of this clock. The clock accuracy
 *		is expressed in ppb (parts per billion). The parent accuracy is
 *		an input parameter.
 *		Returns the calculated accuracy.  Optional - if	this op is not
 *		set then clock accuracy will be initialized to parent accuracy
 *		or 0 (perfect clock) if clock has no parent.
 *
 * @get_phase:	Queries the hardware to get the current phase of a clock.
 *		Returned values are 0-359 degrees on success, negative
 *		error codes on failure.
 *
 * @set_phase:	Shift the phase this clock signal in degrees specified
 *		by the second argument. Valid values for degrees are
 *		0-359. Return 0 on success, otherwise -EERROR.
 *
 * @init:	Perform platform-specific initialization magic.
 *		This is not not used by any of the basic clock types.
 *		Please consider other ways of solving initialization problems
 *		before using this callback, as its use is discouraged.
 *
 * @debug_init:	Set up type-specific debugfs entries for this clock.  This
 *		is called once, after the debugfs directory entry for this
 *		clock has been created.  The dentry pointer representing that
 *		directory is provided as an argument.  Called with
 *		prepare_lock held.  Returns 0 on success, -EERROR otherwise.
 *
 *
 * The clk_enable/clk_disable and clk_prepare/clk_unprepare pairs allow
 * implementations to split any work between atomic (enable) and sleepable
 * (prepare) contexts.  If enabling a clock requires code that might sleep,
 * this must be done in clk_prepare.  Clock enable code that will never be
 * called in a sleepable context may be implemented in clk_enable.
 *
 * Typically, drivers will call clk_prepare when a clock may be needed later
 * (eg. when a device is opened), and clk_enable when the clock is actually
 * required (eg. from an interrupt). Note that clk_prepare MUST have been
 * called before clk_enable.
 */</doc>
<mbr r='clk_ops::prepare' o='0' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::unprepare' o='64' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::is_prepared' o='128' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::unprepare_unused' o='192' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::enable' o='256' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::disable' o='320' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::is_enabled' o='384' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::disable_unused' o='448' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::recalc_rate' o='512' t='unsigned long (*)(struct clk_hw *, unsigned long)'/>
<mbr r='clk_ops::round_rate' o='576' t='long (*)(struct clk_hw *, unsigned long, unsigned long *)'/>
<mbr r='clk_ops::determine_rate' o='640' t='int (*)(struct clk_hw *, struct clk_rate_request *)'/>
<mbr r='clk_ops::set_parent' o='704' t='int (*)(struct clk_hw *, u8)'/>
<mbr r='clk_ops::get_parent' o='768' t='u8 (*)(struct clk_hw *)'/>
<mbr r='clk_ops::set_rate' o='832' t='int (*)(struct clk_hw *, unsigned long, unsigned long)'/>
<mbr r='clk_ops::set_rate_and_parent' o='896' t='int (*)(struct clk_hw *, unsigned long, unsigned long, u8)'/>
<mbr r='clk_ops::recalc_accuracy' o='960' t='unsigned long (*)(struct clk_hw *, unsigned long)'/>
<mbr r='clk_ops::get_phase' o='1024' t='int (*)(struct clk_hw *)'/>
<mbr r='clk_ops::set_phase' o='1088' t='int (*)(struct clk_hw *, int)'/>
<mbr r='clk_ops::init' o='1152' t='void (*)(struct clk_hw *)'/>
<mbr r='clk_ops::debug_init' o='1216' t='int (*)(struct clk_hw *, struct dentry *)'/>
