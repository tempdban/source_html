<dec f='linux-4.18.y/include/linux/rmap.h' l='249' type='struct anon_vma * page_lock_anon_vma_read(struct page * page)'/>
<doc f='linux-4.18.y/include/linux/rmap.h' l='246'>/*
 * Called by memory-failure.c to kill processes.
 */</doc>
<def f='linux-4.18.y/mm/rmap.c' l='507' ll='567' type='struct anon_vma * page_lock_anon_vma_read(struct page * page)'/>
<use f='linux-4.18.y/mm/rmap.c' l='849' u='r' c='page_referenced'/>
<use f='linux-4.18.y/mm/rmap.c' l='849' u='r' c='page_referenced'/>
<use f='linux-4.18.y/mm/rmap.c' l='1669' u='r' c='try_to_unmap'/>
<use f='linux-4.18.y/mm/rmap.c' l='1669' u='r' c='try_to_unmap'/>
<use f='linux-4.18.y/mm/rmap.c' l='1712' u='r' c='try_to_munlock'/>
<use f='linux-4.18.y/mm/rmap.c' l='1712' u='r' c='try_to_munlock'/>
<doc f='linux-4.18.y/mm/rmap.c' l='500'>/*
 * Similar to page_get_anon_vma() except it locks the anon_vma.
 *
 * Its a little more complex as it tries to keep the fast path to a single
 * atomic op -- the trylock. If we fail the trylock, we fall back to getting a
 * reference like with page_get_anon_vma() and then block on the mutex.
 */</doc>
