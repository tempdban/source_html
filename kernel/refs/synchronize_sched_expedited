<dec f='linux-4.14.y/include/linux/rcutree.h' l='48' type='void synchronize_sched_expedited()'/>
<use f='linux-4.14.y/include/linux/rcutree.h' l='71' u='c' c='synchronize_rcu_bh_expedited'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3222' u='c' c='synchronize_sched'/>
<def f='linux-4.14.y/kernel/rcu/tree_exp.h' l='639' ll='653' type='void synchronize_sched_expedited()'/>
<dec f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' type='void synchronize_sched_expedited()'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' c='synchronize_sched_expedited'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='736' u='c' c='synchronize_rcu_expedited'/>
<doc f='linux-4.14.y/kernel/rcu/tree_exp.h' l='623'>/**
 * synchronize_sched_expedited - Brute-force RCU-sched grace period
 *
 * Wait for an RCU-sched grace period to elapse, but use a &quot;big hammer&quot;
 * approach to force the grace period to end quickly.  This consumes
 * significant time on all CPUs and is unfriendly to real-time workloads,
 * so is thus not recommended for any sort of common-case code.  In fact,
 * if you are using synchronize_sched_expedited() in a loop, please
 * restructure your code to batch your updates, and then use a single
 * synchronize_sched() instead.
 *
 * This implementation can be thought of as an application of sequence
 * locking to expedited grace periods, but using the sequence counter to
 * determine when someone else has already done the work instead of for
 * retrying readers.
 */</doc>
<use f='linux-4.14.y/kernel/rcu/update.c' l='209' u='c' c='rcu_test_sync_prims'/>
<dec f='linux-4.14.y/include/linux/rcutree.h' l='48' type='void synchronize_sched_expedited()'/>
<use f='linux-4.14.y/include/linux/rcutree.h' l='71' u='c' c='synchronize_rcu_bh_expedited'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3222' u='c' c='synchronize_sched'/>
<def f='linux-4.14.y/kernel/rcu/tree_exp.h' l='639' ll='653' type='void synchronize_sched_expedited()'/>
<dec f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' type='void synchronize_sched_expedited()'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' c='synchronize_sched_expedited'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='654' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree_exp.h' l='736' u='c' c='synchronize_rcu_expedited'/>
<doc f='linux-4.14.y/kernel/rcu/tree_exp.h' l='623'>/**
 * synchronize_sched_expedited - Brute-force RCU-sched grace period
 *
 * Wait for an RCU-sched grace period to elapse, but use a &quot;big hammer&quot;
 * approach to force the grace period to end quickly.  This consumes
 * significant time on all CPUs and is unfriendly to real-time workloads,
 * so is thus not recommended for any sort of common-case code.  In fact,
 * if you are using synchronize_sched_expedited() in a loop, please
 * restructure your code to batch your updates, and then use a single
 * synchronize_sched() instead.
 *
 * This implementation can be thought of as an application of sequence
 * locking to expedited grace periods, but using the sequence counter to
 * determine when someone else has already done the work instead of for
 * retrying readers.
 */</doc>
<use f='linux-4.14.y/kernel/rcu/update.c' l='209' u='c' c='rcu_test_sync_prims'/>
