<dec f='linux-4.18.y/include/linux/skbuff.h' l='3255' type='__poll_t datagram_poll(struct file * file, struct socket * sock, struct poll_table_struct * wait)'/>
<def f='linux-4.18.y/net/core/datagram.c' l='834' ll='873' type='__poll_t datagram_poll(struct file * file, struct socket * sock, poll_table * wait)'/>
<dec f='linux-4.18.y/net/core/datagram.c' l='874' type='__poll_t datagram_poll(struct file * , struct socket * , struct poll_table_struct * )'/>
<use f='linux-4.18.y/net/core/datagram.c' l='874' c='datagram_poll'/>
<use f='linux-4.18.y/net/core/datagram.c' l='874' u='a'/>
<use f='linux-4.18.y/net/core/datagram.c' l='874' u='a'/>
<doc f='linux-4.18.y/net/core/datagram.c' l='820'>/**
 * 	datagram_poll - generic datagram poll
 *	@file: file struct
 *	@sock: socket
 *	@wait: poll table
 *
 *	Datagram poll: Again totally generic. This also handles
 *	sequenced packet sockets providing the socket receive queue
 *	is only ever holding data ready to receive.
 *
 *	Note: when you *don&apos;t* use this routine for this protocol,
 *	and you use a different write policy from sock_writeable()
 *	then please supply your own write_space callback.
 */</doc>
<use f='linux-4.18.y/net/ipv4/af_inet.c' l='1056'/>
<use f='linux-4.18.y/net/ipv4/af_inet.c' l='1056'/>
<use f='linux-4.18.y/net/ipv4/udp.c' l='2608' u='c' c='udp_poll'/>
<use f='linux-4.18.y/net/netlink/af_netlink.c' l='2668'/>
<use f='linux-4.18.y/net/netlink/af_netlink.c' l='2668'/>
<use f='linux-4.18.y/net/packet/af_packet.c' l='4086' u='c' c='packet_poll'/>
<use f='linux-4.18.y/net/packet/af_packet.c' l='4430'/>
<use f='linux-4.18.y/net/packet/af_packet.c' l='4430'/>
