<dec f='linux-4.18.y/include/linux/buffer_head.h' l='242' type='int block_page_mkwrite(struct vm_area_struct * vma, struct vm_fault * vmf, get_block_t * get_block)'/>
<def f='linux-4.18.y/fs/buffer.c' l='2447' ll='2483' type='int block_page_mkwrite(struct vm_area_struct * vma, struct vm_fault * vmf, get_block_t * get_block)'/>
<dec f='linux-4.18.y/fs/buffer.c' l='2484' type='int block_page_mkwrite(struct vm_area_struct * , struct vm_fault * , get_block_t * )'/>
<use f='linux-4.18.y/fs/buffer.c' l='2484' c='block_page_mkwrite'/>
<use f='linux-4.18.y/fs/buffer.c' l='2484' u='a'/>
<use f='linux-4.18.y/fs/buffer.c' l='2484' u='a'/>
<doc f='linux-4.18.y/fs/buffer.c' l='2429'>/*
 * block_page_mkwrite() is not allowed to change the file size as it gets
 * called from a page fault handler when a page is first dirtied. Hence we must
 * be careful to check for EOF conditions here. We set the page up correctly
 * for a written page which means we get ENOSPC checking when writing into
 * holes and correct delalloc and unwritten extent mapping on filesystems that
 * support these features.
 *
 * We are not allowed to take the i_mutex here so we have to play games to
 * protect against truncate races as the page could now be beyond EOF.  Because
 * truncate writes the inode size before removing pages, once we have the
 * page lock we can determine safely if the page is beyond EOF. If it is not
 * beyond EOF, then the page is guaranteed safe against truncation until we
 * unlock the page.
 *
 * Direct callers of this function should protect against filesystem freezing
 * using sb_start_pagefault() - sb_end_pagefault() functions.
 */</doc>
<use f='linux-4.18.y/fs/ext4/inode.c' l='6143' u='c' c='ext4_page_mkwrite'/>
<use f='linux-4.18.y/fs/ext4/inode.c' l='6190' u='c' c='ext4_page_mkwrite'/>
