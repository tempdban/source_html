<def f='linux-4.14.y/include/linux/seqlock.h' l='364' ll='369' type='void raw_write_seqcount_latch(seqcount_t * s)'/>
<doc f='linux-4.14.y/include/linux/seqlock.h' l='287'>/**
 * raw_write_seqcount_latch - redirect readers to even/odd copy
 * @s: pointer to seqcount_t
 *
 * The latch technique is a multiversion concurrency control method that allows
 * queries during non-atomic modifications. If you can guarantee queries never
 * interrupt the modification -- e.g. the concurrency is strictly between CPUs
 * -- you most likely do not need this.
 *
 * Where the traditional RCU/lockless data structures rely on atomic
 * modifications to ensure queries observe either the old or the new state the
 * latch allows the same for non-atomic updates. The trade-off is doubling the
 * cost of storage; we have to maintain two copies of the entire data
 * structure.
 *
 * Very simply put: we first modify one copy and then the other. This ensures
 * there is always one copy in a stable state, ready to give us an answer.
 *
 * The basic form is a data structure like:
 *
 * struct latch_struct {
 *	seqcount_t		seq;
 *	struct data_struct	data[2];
 * };
 *
 * Where a modification, which is assumed to be externally serialized, does the
 * following:
 *
 * void latch_modify(struct latch_struct *latch, ...)
 * {
 *	smp_wmb();	&lt;- Ensure that the last data[1] update is visible
 *	latch-&gt;seq++;
 *	smp_wmb();	&lt;- Ensure that the seqcount update is visible
 *
 *	modify(latch-&gt;data[0], ...);
 *
 *	smp_wmb();	&lt;- Ensure that the data[0] update is visible
 *	latch-&gt;seq++;
 *	smp_wmb();	&lt;- Ensure that the seqcount update is visible
 *
 *	modify(latch-&gt;data[1], ...);
 * }
 *
 * The query will have a form like:
 *
 * struct entry *latch_query(struct latch_struct *latch, ...)
 * {
 *	struct entry *entry;
 *	unsigned seq, idx;
 *
 *	do {
 *		seq = raw_read_seqcount_latch(&amp;latch-&gt;seq);
 *
 *		idx = seq &amp; 0x01;
 *		entry = data_query(latch-&gt;data[idx], ...);
 *
 *		smp_rmb();
 *	} while (seq != latch-&gt;seq);
 *
 *	return entry;
 * }
 *
 * So during the modification, queries are first redirected to data[1]. Then we
 * modify data[0]. When that is complete, we redirect queries back to data[0]
 * and we can modify data[1].
 *
 * NOTE: The non-requirement for atomic modifications does _NOT_ include
 *       the publishing of new entries in the case where data is a dynamic
 *       data structure.
 *
 *       An iteration might start in data[0] and get suspended long enough
 *       to miss an entire modification sequence, once it resumes it might
 *       observe the new entry.
 *
 * NOTE: When data is a dynamic data structure; one should use regular RCU
 *       patterns to manage the lifetimes of the objects within.
 */</doc>
<use f='linux-4.14.y/include/linux/rbtree_latch.h' l='147' u='c' c='latch_tree_insert'/>
<use f='linux-4.14.y/include/linux/rbtree_latch.h' l='149' u='c' c='latch_tree_insert'/>
<use f='linux-4.14.y/include/linux/rbtree_latch.h' l='174' u='c' c='latch_tree_erase'/>
<use f='linux-4.14.y/include/linux/rbtree_latch.h' l='176' u='c' c='latch_tree_erase'/>
<use f='linux-4.14.y/arch/x86/kernel/tsc.c' l='180' u='c' c='set_cyc2ns_scale'/>
<use f='linux-4.14.y/arch/x86/kernel/tsc.c' l='182' u='c' c='set_cyc2ns_scale'/>
<use f='linux-4.14.y/kernel/time/timekeeping.c' l='374' u='c' c='update_fast_timekeeper'/>
<use f='linux-4.14.y/kernel/time/timekeeping.c' l='380' u='c' c='update_fast_timekeeper'/>
