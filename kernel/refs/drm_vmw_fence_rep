<def f='linux-4.18.y/include/uapi/drm/vmwgfx_drm.h' l='348' ll='355'/>
<size>24</size>
<doc f='linux-4.18.y/include/uapi/drm/vmwgfx_drm.h' l='322'>/**
 * struct drm_vmw_fence_rep
 *
 * @handle: Fence object handle for fence associated with a command submission.
 * @mask: Fence flags relevant for this fence object.
 * @seqno: Fence sequence number in fifo. A fence object with a lower
 * seqno will signal the EXEC flag before a fence object with a higher
 * seqno. This can be used by user-space to avoid kernel calls to determine
 * whether a fence has signaled the EXEC flag. Note that @seqno will
 * wrap at 32-bit.
 * @passed_seqno: The highest seqno number processed by the hardware
 * so far. This can be used to mark user-space fence objects as signaled, and
 * to determine whether a fence seqno might be stale.
 * @fd: FD associated with the fence, -1 if not exported
 * @error: This member should&apos;ve been set to -EFAULT on submission.
 * The following actions should be take on completion:
 * error == -EFAULT: Fence communication failed. The host is synchronized.
 * Use the last fence id read from the FIFO fence register.
 * error != 0 &amp;&amp; error != -EFAULT:
 * Fence submission failed. The host is synchronized. Use the fence_seq member.
 * error == 0: All is OK, The host may not be synchronized.
 * Use the fence_seq member.
 *
 * Input / Output data to the DRM_VMW_EXECBUF Ioctl.
 */</doc>
<mbr r='drm_vmw_fence_rep::handle' o='0' t='__u32'/>
<mbr r='drm_vmw_fence_rep::mask' o='32' t='__u32'/>
<mbr r='drm_vmw_fence_rep::seqno' o='64' t='__u32'/>
<mbr r='drm_vmw_fence_rep::passed_seqno' o='96' t='__u32'/>
<mbr r='drm_vmw_fence_rep::fd' o='128' t='__s32'/>
<mbr r='drm_vmw_fence_rep::error' o='160' t='__s32'/>
