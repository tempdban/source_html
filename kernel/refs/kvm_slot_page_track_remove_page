<dec f='linux-4.14.y/arch/x86/include/asm/kvm_page_track.h' l='60' type='void kvm_slot_page_track_remove_page(struct kvm * kvm, struct kvm_memory_slot * slot, gfn_t gfn, enum kvm_page_track_mode mode)'/>
<use f='linux-4.14.y/arch/x86/kvm/mmu.c' l='1035' u='c' c='unaccount_shadowed'/>
<def f='linux-4.14.y/arch/x86/kvm/page_track.c' l='126' ll='140' type='void kvm_slot_page_track_remove_page(struct kvm * kvm, struct kvm_memory_slot * slot, gfn_t gfn, enum kvm_page_track_mode mode)'/>
<dec f='linux-4.14.y/arch/x86/kvm/page_track.c' l='141' type='void kvm_slot_page_track_remove_page(struct kvm * , struct kvm_memory_slot * , gfn_t , enum kvm_page_track_mode )'/>
<use f='linux-4.14.y/arch/x86/kvm/page_track.c' l='141' c='kvm_slot_page_track_remove_page'/>
<use f='linux-4.14.y/arch/x86/kvm/page_track.c' l='141' u='a'/>
<use f='linux-4.14.y/arch/x86/kvm/page_track.c' l='141' u='a'/>
<doc f='linux-4.14.y/arch/x86/kvm/page_track.c' l='113'>/*
 * remove the guest page from the tracking pool which stops the interception
 * of corresponding access on that page. It is the opposed operation of
 * kvm_slot_page_track_add_page().
 *
 * It should be called under the protection both of mmu-lock and kvm-&gt;srcu
 * or kvm-&gt;slots_lock.
 *
 * @kvm: the guest instance we are interested in.
 * @slot: the @gfn belongs to.
 * @gfn: the guest page.
 * @mode: tracking mode, currently only write track is supported.
 */</doc>
