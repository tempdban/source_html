<dec f='linux-4.18.y/include/linux/rcutree.h' l='81' type='void cond_synchronize_sched(unsigned long oldstate)'/>
<def f='linux-4.18.y/kernel/rcu/tree.c' l='3218' ll='3229' type='void cond_synchronize_sched(unsigned long oldstate)'/>
<dec f='linux-4.18.y/kernel/rcu/tree.c' l='3230' type='void cond_synchronize_sched(unsigned long )'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3230' c='cond_synchronize_sched'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3230' u='a'/>
<use f='linux-4.18.y/kernel/rcu/tree.c' l='3230' u='a'/>
<doc f='linux-4.18.y/kernel/rcu/tree.c' l='3204'>/**
 * cond_synchronize_sched - Conditionally wait for an RCU-sched grace period
 *
 * @oldstate: return value from earlier call to get_state_synchronize_sched()
 *
 * If a full RCU-sched grace period has elapsed since the earlier call to
 * get_state_synchronize_sched(), just return.  Otherwise, invoke
 * synchronize_sched() to wait for a full grace period.
 *
 * Yes, this function does not take counter wrap into account.  But
 * counter wrap is harmless.  If the counter wraps, we have waited for
 * more than 2 billion grace periods (and way more on a 64-bit system!),
 * so waiting for one additional grace period should be just fine.
 */</doc>
