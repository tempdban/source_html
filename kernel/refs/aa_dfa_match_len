<dec f='linux-4.18.y/security/apparmor/include/match.h' l='128' type='unsigned int aa_dfa_match_len(struct aa_dfa * dfa, unsigned int start, const char * str, int len)'/>
<use f='linux-4.18.y/security/apparmor/include/policy.h' l='225' u='c' c='PROFILE_MEDIATES_AF'/>
<use f='linux-4.18.y/security/apparmor/apparmorfs.c' l='614' u='c' c='profile_query_cb'/>
<use f='linux-4.18.y/security/apparmor/apparmorfs.c' l='626' u='c' c='profile_query_cb'/>
<use f='linux-4.18.y/security/apparmor/domain.c' l='114' u='c' c='match_component'/>
<use f='linux-4.18.y/security/apparmor/domain.c' l='116' u='c' c='match_component'/>
<use f='linux-4.18.y/security/apparmor/domain.c' l='337' u='c' c='aa_xattrs_match'/>
<use f='linux-4.18.y/security/apparmor/label.c' l='1256' u='c' c='match_component'/>
<use f='linux-4.18.y/security/apparmor/label.c' l='1258' u='c' c='match_component'/>
<def f='linux-4.18.y/security/apparmor/match.c' l='404' ll='430' type='unsigned int aa_dfa_match_len(struct aa_dfa * dfa, unsigned int start, const char * str, int len)'/>
<doc f='linux-4.18.y/security/apparmor/match.c' l='388'>/**
 * aa_dfa_match_len - traverse @dfa to find state @str stops at
 * @dfa: the dfa to match @str against  (NOT NULL)
 * @start: the state of the dfa to start matching in
 * @str: the string of bytes to match against the dfa  (NOT NULL)
 * @len: length of the string of bytes to match
 *
 * aa_dfa_match_len will match @str against the dfa and return the state it
 * finished matching in. The final state can be used to look up the accepting
 * label, or as the start state of a continuing match.
 *
 * This function will happily match again the 0 byte and only finishes
 * when @len input is consumed.
 *
 * Returns: final state reached after input is consumed
 */</doc>
<use f='linux-4.18.y/security/apparmor/net.c' l='127' u='c' c='aa_profile_af_perm'/>
