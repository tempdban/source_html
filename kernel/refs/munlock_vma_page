<dec f='linux-4.18.y/mm/internal.h' l='301' type='unsigned int munlock_vma_page(struct page * page)'/>
<use f='linux-4.18.y/kernel/events/uprobes.c' l='208' u='c' c='__replace_page'/>
<use f='linux-4.18.y/mm/memory.c' l='2621' u='c' c='wp_page_copy'/>
<def f='linux-4.18.y/mm/mlock.c' l='182' ll='220' type='unsigned int munlock_vma_page(struct page * page)'/>
<use f='linux-4.18.y/mm/mlock.c' l='479' u='c' c='munlock_vma_pages_range'/>
<doc f='linux-4.18.y/mm/mlock.c' l='164'>/**
 * munlock_vma_page - munlock a vma page
 * @page: page to be unlocked, either a normal page or THP page head
 *
 * returns the size of the page as a page mask (0 for normal page,
 *         HPAGE_PMD_NR - 1 for THP head page)
 *
 * called from munlock()/munmap() path with page supposedly on the LRU.
 * When we munlock a page, because the vma where we found the page is being
 * munlock()ed or munmap()ed, we want to check whether other vmas hold the
 * page locked so that we can leave it on the unevictable lru list and not
 * bother vmscan with it.  However, to walk the page&apos;s rmap list in
 * try_to_munlock() we must isolate the page from the LRU.  If some other
 * task has removed the page from the LRU, we won&apos;t be able to do that.
 * So we clear the PageMlocked as we might not get another chance.  If we
 * can&apos;t isolate the page, we leave it for putback_lru_page() and vmscan
 * [page_referenced()/try_to_unmap()] to deal with.
 */</doc>
