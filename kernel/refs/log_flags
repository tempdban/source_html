<def f='linux-4.18.y/kernel/printk/printk.c' l='351' ll='356'/>
<doc f='linux-4.18.y/kernel/printk/printk.c' l='284'>/*
 * The printk log buffer consists of a chain of concatenated variable
 * length records. Every record starts with a record header, containing
 * the overall length of the record.
 *
 * The heads to the first and last entry in the buffer, as well as the
 * sequence numbers of these entries are maintained when messages are
 * stored.
 *
 * If the heads indicate available messages, the length in the header
 * tells the start next message. A length == 0 for the next message
 * indicates a wrap-around to the beginning of the buffer.
 *
 * Every record carries the monotonic timestamp in microseconds, as well as
 * the standard userspace syslog level and syslog facility. The usual
 * kernel messages use LOG_KERN; userspace-injected messages always carry
 * a matching syslog facility, by default LOG_USER. The origin of every
 * message can be reliably determined that way.
 *
 * The human readable log message directly follows the message header. The
 * length of the message text is stored in the header, the stored message
 * is not terminated.
 *
 * Optionally, a message can carry a dictionary of properties (key/value pairs),
 * to provide userspace with a machine-readable message context.
 *
 * Examples for well-defined, commonly used property names are:
 *   DEVICE=b12:8               device identifier
 *                                b12:8         block dev_t
 *                                c127:3        char dev_t
 *                                n8            netdev ifindex
 *                                +sound:card0  subsystem:devname
 *   SUBSYSTEM=pci              driver-core subsystem name
 *
 * Valid characters in property names are [a-zA-Z0-9.-_]. The plain text value
 * follows directly after a &apos;=&apos; character. Every property is terminated by
 * a &apos;\0&apos; character. The last property is not terminated.
 *
 * Example of a message structure:
 *   0000  ff 8f 00 00 00 00 00 00      monotonic time in nsec
 *   0008  34 00                        record is 52 bytes long
 *   000a        0b 00                  text is 11 bytes long
 *   000c              1f 00            dictionary is 23 bytes long
 *   000e                    03 00      LOG_KERN (facility) LOG_ERR (level)
 *   0010  69 74 27 73 20 61 20 6c      &quot;it&apos;s a l&quot;
 *         69 6e 65                     &quot;ine&quot;
 *   001b           44 45 56 49 43      &quot;DEVIC&quot;
 *         45 3d 62 38 3a 32 00 44      &quot;E=b8:2\0D&quot;
 *         52 49 56 45 52 3d 62 75      &quot;RIVER=bu&quot;
 *         67                           &quot;g&quot;
 *   0032     00 00 00                  padding to next message header
 *
 * The &apos;struct printk_log&apos; buffer header must never be directly exported to
 * userspace, it is a kernel-private implementation detail that might
 * need to be changed in the future, when the requirements change.
 *
 * /dev/kmsg exports the structured data in the following line format:
 *   &quot;&lt;level&gt;,&lt;sequnum&gt;,&lt;timestamp&gt;,&lt;contflag&gt;[,additional_values, ... ];&lt;message text&gt;\n&quot;
 *
 * Users of the export format should ignore possible additional values
 * separated by &apos;,&apos;, and find the message after the &apos;;&apos; character.
 *
 * The optional key/value pairs are attached as continuation lines starting
 * with a space character and terminated by a newline. All possible
 * non-prinatable characters are escaped in the &quot;\xff&quot; notation.
 */</doc>
