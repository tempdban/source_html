<dec f='linux-4.14.y/include/linux/assoc_array.h' l='86' type='int assoc_array_gc(struct assoc_array * array, const struct assoc_array_ops * ops, bool (*)(void *, void *) iterator, void * iterator_data)'/>
<def f='linux-4.14.y/lib/assoc_array.c' l='1468' ll='1734' type='int assoc_array_gc(struct assoc_array * array, const struct assoc_array_ops * ops, bool (*)(void *, void *) iterator, void * iterator_data)'/>
<doc f='linux-4.14.y/lib/assoc_array.c' l='1444'>/**
 * assoc_array_gc - Garbage collect an associative array.
 * @array: The array to clean.
 * @ops: The operations to use.
 * @iterator: A callback function to pass judgement on each object.
 * @iterator_data: Private data for the callback function.
 *
 * Collect garbage from an associative array and pack down the internal tree to
 * save memory.
 *
 * The iterator function is asked to pass judgement upon each object in the
 * array.  If it returns false, the object is discard and if it returns true,
 * the object is kept.  If it returns true, it must increment the object&apos;s
 * usage count (or whatever it needs to do to retain it) before returning.
 *
 * This function returns 0 if successful or -ENOMEM if out of memory.  In the
 * latter case, the array is not changed.
 *
 * The caller should lock against other modifications and must continue to hold
 * the lock until assoc_array_apply_edit() has been called.
 *
 * Accesses to the tree may take place concurrently with this function,
 * provided they hold the RCU read lock.
 */</doc>
<use f='linux-4.14.y/security/keys/keyring.c' l='1539' u='c' c='keyring_gc'/>
