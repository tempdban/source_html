<dec f='linux-4.18.y/include/drm/drm_modeset_helper_vtables.h' l='704' type='void (*)(struct drm_encoder *)'/>
<offset>576</offset>
<doc f='linux-4.18.y/include/drm/drm_modeset_helper_vtables.h' l='676'>/**
	 * @disable:
	 *
	 * This callback should be used to disable the encoder. With the atomic
	 * drivers it is called before this encoder&apos;s CRTC has been shut off
	 * using their own &amp;drm_crtc_helper_funcs.disable hook.  If that
	 * sequence is too simple drivers can just add their own driver private
	 * encoder hooks and call them from CRTC&apos;s callback by looping over all
	 * encoders connected to it using for_each_encoder_on_crtc().
	 *
	 * This hook is used both by legacy CRTC helpers and atomic helpers.
	 * Atomic drivers don&apos;t need to implement it if there&apos;s no need to
	 * disable anything at the encoder level. To ensure that runtime PM
	 * handling (using either DPMS or the new &quot;ACTIVE&quot; property) works
	 * @disable must be the inverse of @enable for atomic drivers.
	 *
	 * NOTE:
	 *
	 * With legacy CRTC helpers there&apos;s a big semantic difference between
	 * @disable and other hooks (like @prepare or @dpms) used to shut down a
	 * encoder: @disable is only called when also logically disabling the
	 * display pipeline and needs to release any resources acquired in
	 * @mode_set (like shared PLLs, or again release pinned framebuffers).
	 *
	 * Therefore @disable must be the inverse of @mode_set plus @commit for
	 * drivers still using legacy CRTC helpers, which is different from the
	 * rules under atomic.
	 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='959' u='r' c='disable_outputs'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_atomic_helper.c' l='960' u='r' c='disable_outputs'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_crtc_helper.c' l='157' u='r' c='drm_encoder_disable'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_crtc_helper.c' l='158' u='r' c='drm_encoder_disable'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='236' u='w'/>
