<dec f='linux-4.18.y/include/linux/usb.h' l='742' type='int usb_lock_device_for_reset(struct usb_device * udev, const struct usb_interface * iface)'/>
<use f='linux-4.18.y/drivers/usb/core/message.c' l='1749' u='c' c='__usb_queue_reset_device'/>
<def f='linux-4.18.y/drivers/usb/core/usb.c' l='773' ll='803' type='int usb_lock_device_for_reset(struct usb_device * udev, const struct usb_interface * iface)'/>
<dec f='linux-4.18.y/drivers/usb/core/usb.c' l='804' type='int usb_lock_device_for_reset(struct usb_device * , const struct usb_interface * )'/>
<use f='linux-4.18.y/drivers/usb/core/usb.c' l='804' c='usb_lock_device_for_reset'/>
<use f='linux-4.18.y/drivers/usb/core/usb.c' l='804' u='a'/>
<use f='linux-4.18.y/drivers/usb/core/usb.c' l='804' u='a'/>
<doc f='linux-4.18.y/drivers/usb/core/usb.c' l='759'>/**
 * usb_lock_device_for_reset - cautiously acquire the lock for a usb device structure
 * @udev: device that&apos;s being locked
 * @iface: interface bound to the driver making the request (optional)
 *
 * Attempts to acquire the device lock, but fails if the device is
 * NOTATTACHED or SUSPENDED, or if iface is specified and the interface
 * is neither BINDING nor BOUND.  Rather than sleeping to wait for the
 * lock, the routine polls repeatedly.  This is to prevent deadlock with
 * disconnect; in some drivers (such as usb-storage) the disconnect()
 * or suspend() method will block waiting for a device reset to complete.
 *
 * Return: A negative error code for failure, otherwise 0.
 */</doc>
<use f='linux-4.18.y/drivers/usb/storage/transport.c' l='1422' u='c' c='usb_stor_port_reset'/>
