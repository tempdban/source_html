<dec f='linux-4.14.y/include/linux/signal.h' l='261' type='int sigprocmask(int , sigset_t * , sigset_t * )'/>
<use f='linux-4.14.y/drivers/md/raid1.c' l='1320' u='c' c='raid1_write_request'/>
<use f='linux-4.14.y/drivers/md/raid1.c' l='1322' u='c' c='raid1_write_request'/>
<use f='linux-4.14.y/fs/select.c' l='730' u='c' c='do_pselect'/>
<use f='linux-4.14.y/fs/select.c' l='748' u='c' c='do_pselect'/>
<use f='linux-4.14.y/fs/select.c' l='1076' u='c' c='SYSC_ppoll'/>
<use f='linux-4.14.y/fs/select.c' l='1095' u='c' c='SYSC_ppoll'/>
<use f='linux-4.14.y/fs/select.c' l='1338' u='c' c='do_compat_pselect'/>
<use f='linux-4.14.y/fs/select.c' l='1356' u='c' c='do_compat_pselect'/>
<use f='linux-4.14.y/fs/select.c' l='1407' u='c' c='C_SYSC_ppoll'/>
<use f='linux-4.14.y/fs/select.c' l='1426' u='c' c='C_SYSC_ppoll'/>
<dec f='linux-4.14.y/kernel/signal.c' l='2480' type='int sigprocmask(int , sigset_t * , sigset_t * )'/>
<use f='linux-4.14.y/kernel/signal.c' l='2480' c='sigprocmask'/>
<use f='linux-4.14.y/kernel/signal.c' l='2480' u='a'/>
<use f='linux-4.14.y/kernel/signal.c' l='2480' u='a'/>
<def f='linux-4.14.y/kernel/signal.c' l='2549' ll='2574' type='int sigprocmask(int how, sigset_t * set, sigset_t * oldset)'/>
<use f='linux-4.14.y/kernel/signal.c' l='2600' u='c' c='SYSC_rt_sigprocmask'/>
<doc f='linux-4.14.y/kernel/signal.c' l='2541'>/*
 * This is also useful for kernel threads that want to temporarily
 * (or permanently) block certain signals.
 *
 * NOTE! Unlike the user-mode sys_sigprocmask(), the kernel
 * interface happily blocks &quot;unblockable&quot; signals like SIGKILL
 * and friends.
 */</doc>
<dec f='include/signal.h' l='256' type='int sigprocmask(int __how, const sigset_t *restrict __set, sigset_t *restrict __oset)'/>
<doc f='include/signal.h' l='255'>/* Get and/or change the set of blocked signals.  */</doc>
