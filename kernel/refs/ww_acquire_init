<def f='linux-4.18.y/include/linux/ww_mutex.h' l='120' ll='141' type='void ww_acquire_init(struct ww_acquire_ctx * ctx, struct ww_class * ww_class)'/>
<doc f='linux-4.18.y/include/linux/ww_mutex.h' l='96'>/**
 * ww_acquire_init - initialize a w/w acquire context
 * @ctx: w/w acquire context to initialize
 * @ww_class: w/w class of the context
 *
 * Initializes an context to acquire multiple mutexes of the given w/w class.
 *
 * Context-based w/w mutex acquiring can be done in any order whatsoever within
 * a given lock class. Deadlocks will be detected and handled with the
 * wait/wound logic.
 *
 * Mixing of context-based w/w mutex acquiring and single w/w mutex locking can
 * result in undetected deadlocks and is so forbidden. Mixing different contexts
 * for the same w/w class when acquiring mutexes can also result in undetected
 * deadlocks, and is hence also forbidden. Both types of abuse will be caught by
 * enabling CONFIG_PROVE_LOCKING.
 *
 * Nesting of acquire contexts for _different_ w/w classes is possible, subject
 * to the usual locking rules between different lock classes.
 *
 * An acquire context must be released with ww_acquire_fini by the same task
 * before the memory is freed. It is recommended to allocate the context itself
 * on the stack.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/drm_modeset_lock.c' l='197' u='c' c='drm_modeset_acquire_init'/>
<use f='linux-4.18.y/drivers/gpu/drm/ttm/ttm_execbuf_util.c' l='109' u='c' c='ttm_eu_reserve_buffers'/>
