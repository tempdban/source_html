<dec f='linux-4.14.y/include/linux/intel-svm.h' l='85' type='int intel_svm_bind_mm(struct device * dev, int * pasid, int flags, struct svm_dev_ops * ops)'/>
<def f='linux-4.14.y/drivers/iommu/intel-svm.c' l='289' ll='428' type='int intel_svm_bind_mm(struct device * dev, int * pasid, int flags, struct svm_dev_ops * ops)'/>
<dec f='linux-4.14.y/drivers/iommu/intel-svm.c' l='429' type='int intel_svm_bind_mm(struct device * , int * , int , struct svm_dev_ops * )'/>
<use f='linux-4.14.y/drivers/iommu/intel-svm.c' l='429' c='intel_svm_bind_mm'/>
<use f='linux-4.14.y/drivers/iommu/intel-svm.c' l='429' u='a'/>
<use f='linux-4.14.y/drivers/iommu/intel-svm.c' l='429' u='a'/>
<doc f='linux-4.14.y/include/linux/intel-svm.h' l='58'>/**
 * intel_svm_bind_mm() - Bind the current process to a PASID
 * @dev:	Device to be granted acccess
 * @pasid:	Address for allocated PASID
 * @flags:	Flags. Later for requesting supervisor mode, etc.
 * @ops:	Callbacks to device driver
 *
 * This function attempts to enable PASID support for the given device.
 * If the @pasid argument is non-%NULL, a PASID is allocated for access
 * to the MM of the current process.
 *
 * By using a %NULL value for the @pasid argument, this function can
 * be used to simply validate that PASID support is available for the
 * given device â€” i.e. that it is behind an IOMMU which has the
 * requisite support, and is enabled.
 *
 * Page faults are handled transparently by the IOMMU code, and there
 * should be no need for the device driver to be involved. If a page
 * fault cannot be handled (i.e. is an invalid address rather than
 * just needs paging in), then the page request will be completed by
 * the core IOMMU code with appropriate status, and the device itself
 * can then report the resulting fault to its driver via whatever
 * mechanism is appropriate.
 *
 * Multiple calls from the same process may result in the same PASID
 * being re-used. A reference count is kept.
 */</doc>
