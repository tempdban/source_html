<def f='linux-4.14.y/include/linux/skbuff.h' l='1578' ll='1585' type='struct sk_buff * skb_peek(const struct sk_buff_head * list_)'/>
<use f='linux-4.14.y/include/linux/skbuff.h' l='1862' u='c' c='__skb_dequeue'/>
<doc f='linux-4.14.y/include/linux/skbuff.h' l='1565'>/**
 *	skb_peek - peek at the head of an &amp;sk_buff_head
 *	@list_: list to peek at
 *
 *	Peek an &amp;sk_buff. Unlike most other operations you _MUST_
 *	be careful with this one. A peek leaves the buffer on the
 *	list and someone else may run off with it. You must hold
 *	the appropriate locks or have a private queue to do this.
 *
 *	Returns %NULL for an empty list or a pointer to the head element.
 *	The reference count is not incremented and the reference is therefore
 *	volatile. Use with caution.
 */</doc>
<use f='linux-4.14.y/include/net/tcp.h' l='1631' u='c' c='tcp_write_queue_head'/>
<use f='linux-4.14.y/net/core/skbuff.c' l='4196' u='c' c='sock_dequeue_err_skb'/>
<use f='linux-4.14.y/net/ipv4/icmp.c' l='381' u='c' c='icmp_push_reply'/>
<use f='linux-4.14.y/net/ipv4/ip_output.c' l='1574' u='c' c='ip_send_unicast_reply'/>
<use f='linux-4.14.y/net/ipv4/ping.c' l='644' u='c' c='ping_v4_push_pending_frames'/>
<use f='linux-4.14.y/net/ipv4/raw.c' l='912' u='c' c='raw_ioctl'/>
<use f='linux-4.14.y/net/ipv4/tcp.c' l='1531' u='c' c='tcp_cleanup_rbuf'/>
<use f='linux-4.14.y/net/ipv4/tcp.c' l='1589' u='c' c='tcp_recv_skb'/>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='5023' u='c' c='tcp_prune_queue'/>
<use f='linux-4.14.y/net/ipv4/tcp_input.c' l='5208' u='c' c='tcp_check_urg'/>
<use f='linux-4.14.y/net/ipv4/udp.c' l='1418' u='c' c='__first_packet_length'/>
<use f='linux-4.14.y/net/packet/af_packet.c' l='4087' u='c' c='packet_ioctl'/>
<use f='linux-4.14.y/net/unix/af_unix.c' l='2299' u='c' c='unix_stream_read_generic'/>
<use f='linux-4.14.y/net/unix/af_unix.c' l='2561' u='c' c='unix_inq_len'/>
