<dec f='linux-4.14.y/fs/ext4/ext4.h' l='2484' type='int ext4_write_inode(struct inode * , struct writeback_control * )'/>
<def f='linux-4.14.y/fs/ext4/inode.c' l='5214' ll='5257' type='int ext4_write_inode(struct inode * inode, struct writeback_control * wbc)'/>
<doc f='linux-4.14.y/fs/ext4/inode.c' l='5180'>/*
 * ext4_write_inode()
 *
 * We are called from a few places:
 *
 * - Within generic_file_aio_write() -&gt; generic_write_sync() for O_SYNC files.
 *   Here, there will be no transaction running. We wait for any running
 *   transaction to commit.
 *
 * - Within flush work (sys_sync(), kupdate and such).
 *   We wait on commit, if told to.
 *
 * - Within iput_final() -&gt; write_inode_now()
 *   We wait on commit, if told to.
 *
 * In all cases it is actually safe for us to return without doing anything,
 * because the inode has been copied into a raw inode buffer in
 * ext4_mark_inode_dirty().  This is a correctness thing for WB_SYNC_ALL
 * writeback.
 *
 * Note that we are absolutely dependent upon all inode dirtiers doing the
 * right thing: they *must* call mark_inode_dirty() after dirtying info in
 * which we are interested.
 *
 * It would be a bug for them to not do this.  The code:
 *
 *	mark_inode_dirty(inode)
 *	stuff();
 *	inode-&gt;i_size = expr;
 *
 * is in error because write_inode() could occur while `stuff()&apos; is running,
 * and the new i_size will be lost.  Plus the inode will no longer be on the
 * superblock&apos;s dirty inode list.
 */</doc>
<use f='linux-4.14.y/fs/ext4/super.c' l='1306'/>
<use f='linux-4.14.y/fs/ext4/super.c' l='1306'/>
