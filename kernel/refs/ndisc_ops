<def f='linux-4.14.y/include/net/ndisc.h' l='198' ll='220'/>
<size>48</size>
<doc f='linux-4.14.y/include/net/ndisc.h' l='141'>/*
 * This structure defines the hooks for IPv6 neighbour discovery.
 * The following hooks can be defined; unless noted otherwise, they are
 * optional and can be filled with a null pointer.
 *
 * int (*is_useropt)(u8 nd_opt_type):
 *     This function is called when IPv6 decide RA userspace options. if
 *     this function returns 1 then the option given by nd_opt_type will
 *     be handled as userspace option additional to the IPv6 options.
 *
 * int (*parse_options)(const struct net_device *dev,
 *			struct nd_opt_hdr *nd_opt,
 *			struct ndisc_options *ndopts):
 *     This function is called while parsing ndisc ops and put each position
 *     as pointer into ndopts. If this function return unequal 0, then this
 *     function took care about the ndisc option, if 0 then the IPv6 ndisc
 *     option parser will take care about that option.
 *
 * void (*update)(const struct net_device *dev, struct neighbour *n,
 *		  u32 flags, u8 icmp6_type,
 *		  const struct ndisc_options *ndopts):
 *     This function is called when IPv6 ndisc updates the neighbour cache
 *     entry. Additional options which can be updated may be previously
 *     parsed by parse_opts callback and accessible over ndopts parameter.
 *
 * int (*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,
 *			 struct neighbour *neigh, u8 *ha_buf,
 *			 u8 **ha):
 *     This function is called when the necessary option space will be
 *     calculated before allocating a skb. The parameters neigh, ha_buf
 *     abd ha are available on NDISC_REDIRECT messages only.
 *
 * void (*fill_addr_option)(const struct net_device *dev,
 *			    struct sk_buff *skb, u8 icmp6_type,
 *			    const u8 *ha):
 *     This function is called when the skb will finally fill the option
 *     fields inside skb. NOTE: this callback should fill the option
 *     fields to the skb which are previously indicated by opt_space
 *     parameter. That means the decision to add such option should
 *     not lost between these two callbacks, e.g. protected by interface
 *     up state.
 *
 * void (*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,
 *			       const struct prefix_info *pinfo,
 *			       struct inet6_dev *in6_dev,
 *			       struct in6_addr *addr,
 *			       int addr_type, u32 addr_flags,
 *			       bool sllao, bool tokenized,
 *			       __u32 valid_lft, u32 prefered_lft,
 *			       bool dev_addr_generated):
 *     This function is called when a RA messages is received with valid
 *     PIO option fields and an IPv6 address will be added to the interface
 *     for autoconfiguration. The parameter dev_addr_generated reports about
 *     if the address was based on dev-&gt;dev_addr or not. This can be used
 *     to add a second address if link-layer operates with two link layer
 *     addresses. E.g. 802.15.4 6LoWPAN.
 */</doc>
<mbr r='ndisc_ops::is_useropt' o='0' t='int (*)(u8)'/>
<mbr r='ndisc_ops::parse_options' o='64' t='int (*)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *)'/>
<mbr r='ndisc_ops::update' o='128' t='void (*)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *)'/>
<mbr r='ndisc_ops::opt_addr_space' o='192' t='int (*)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **)'/>
<mbr r='ndisc_ops::fill_addr_option' o='256' t='void (*)(const struct net_device *, struct sk_buff *, u8, const u8 *)'/>
<mbr r='ndisc_ops::prefix_rcv_add_addr' o='320' t='void (*)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool)'/>
