<dec f='linux-4.14.y/include/linux/clk.h' l='345' type='int clk_enable(struct clk * clk)'/>
<use f='linux-4.14.y/include/linux/clk.h' l='646' u='c' c='clk_prepare_enable'/>
<doc f='linux-4.14.y/include/linux/clk.h' l='335'>/**
 * clk_enable - inform the system when the clock source should be running.
 * @clk: clock source
 *
 * If the clock can not be enabled/disabled, this should return success.
 *
 * May be called from atomic contexts.
 *
 * Returns success (0) or negative errno.
 */</doc>
<use f='linux-4.14.y/drivers/clk/clk-bulk.c' l='143' u='c' c='clk_bulk_enable'/>
<def f='linux-4.14.y/drivers/clk/clk.c' l='704' ll='710' type='int clk_enable(struct clk * clk)'/>
<dec f='linux-4.14.y/drivers/clk/clk.c' l='711' type='int clk_enable(struct clk * )'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='711' c='clk_enable'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='711' u='a'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='711' u='a'/>
<doc f='linux-4.14.y/drivers/clk/clk.c' l='691'>/**
 * clk_enable - ungate a clock
 * @clk: the clk being ungated
 *
 * clk_enable must not sleep, which differentiates it from clk_prepare.  In a
 * simple case, clk_enable can be used instead of clk_prepare to ungate a clk
 * if the operation will never sleep.  One example is a SoC-internal clk which
 * is controlled via simple register writes.  In the complex case a clk ungate
 * operation may require a fast and a slow part.  It is this reason that
 * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare
 * must be called before clk_enable.  Returns 0 on success, -EERROR
 * otherwise.
 */</doc>
<use f='linux-4.14.y/include/linux/amba/bus.h' l='102' u='c' c='amba_pclk_enable'/>
<dec f='linux-4.14.y/include/linux/clk.h' l='345' type='int clk_enable(struct clk * clk)'/>
<use f='linux-4.14.y/include/linux/clk.h' l='646' u='c' c='clk_prepare_enable'/>
<doc f='linux-4.14.y/include/linux/clk.h' l='335'>/**
 * clk_enable - inform the system when the clock source should be running.
 * @clk: clock source
 *
 * If the clock can not be enabled/disabled, this should return success.
 *
 * May be called from atomic contexts.
 *
 * Returns success (0) or negative errno.
 */</doc>
<use f='linux-4.14.y/drivers/clk/clk-bulk.c' l='143' u='c' c='clk_bulk_enable'/>
<def f='linux-4.14.y/drivers/clk/clk.c' l='704' ll='710' type='int clk_enable(struct clk * clk)'/>
<dec f='linux-4.14.y/drivers/clk/clk.c' l='711' type='int clk_enable(struct clk * )'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='711' c='clk_enable'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='711' u='a'/>
<use f='linux-4.14.y/drivers/clk/clk.c' l='711' u='a'/>
<doc f='linux-4.14.y/drivers/clk/clk.c' l='691'>/**
 * clk_enable - ungate a clock
 * @clk: the clk being ungated
 *
 * clk_enable must not sleep, which differentiates it from clk_prepare.  In a
 * simple case, clk_enable can be used instead of clk_prepare to ungate a clk
 * if the operation will never sleep.  One example is a SoC-internal clk which
 * is controlled via simple register writes.  In the complex case a clk ungate
 * operation may require a fast and a slow part.  It is this reason that
 * clk_enable and clk_prepare are not mutually exclusive.  In fact clk_prepare
 * must be called before clk_enable.  Returns 0 on success, -EERROR
 * otherwise.
 */</doc>
<use f='linux-4.14.y/include/linux/amba/bus.h' l='102' u='c' c='amba_pclk_enable'/>
