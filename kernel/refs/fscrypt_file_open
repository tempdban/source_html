<dec f='linux-4.18.y/include/linux/fscrypt_supp.h' l='186' type='int fscrypt_file_open(struct inode * inode, struct file * filp)'/>
<doc f='linux-4.18.y/include/linux/fscrypt_supp.h' l='185'>/* hooks.c */</doc>
<def f='linux-4.18.y/fs/crypto/hooks.c' l='30' ll='49' type='int fscrypt_file_open(struct inode * inode, struct file * filp)'/>
<dec f='linux-4.18.y/fs/crypto/hooks.c' l='50' type='int fscrypt_file_open(struct inode * , struct file * )'/>
<use f='linux-4.18.y/fs/crypto/hooks.c' l='50' c='fscrypt_file_open'/>
<use f='linux-4.18.y/fs/crypto/hooks.c' l='50' u='a'/>
<use f='linux-4.18.y/fs/crypto/hooks.c' l='50' u='a'/>
<doc f='linux-4.18.y/fs/crypto/hooks.c' l='10'>/**
 * fscrypt_file_open - prepare to open a possibly-encrypted regular file
 * @inode: the inode being opened
 * @filp: the struct file being set up
 *
 * Currently, an encrypted regular file can only be opened if its encryption key
 * is available; access to the raw encrypted contents is not supported.
 * Therefore, we first set up the inode&apos;s encryption key (if not already done)
 * and return an error if it&apos;s unavailable.
 *
 * We also verify that if the parent directory (from the path via which the file
 * is being opened) is encrypted, then the inode being opened uses the same
 * encryption policy.  This is needed as part of the enforcement that all files
 * in an encrypted directory tree use the same encryption policy, as a
 * protection against certain types of offline attacks.  Note that this check is
 * needed even when opening an *unencrypted* file, since it&apos;s forbidden to have
 * an unencrypted file in an encrypted directory.
 *
 * Return: 0 on success, -ENOKEY if the key is missing, or another -errno code
 */</doc>
<use f='linux-4.18.y/fs/ext4/file.c' l='443' u='c' c='ext4_file_open'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='484' u='c' c='f2fs_file_open'/>
