<dec f='linux-4.14.y/include/linux/rmap.h' l='143' type='int __anon_vma_prepare(struct vm_area_struct * )'/>
<use f='linux-4.14.y/include/linux/rmap.h' l='153' u='c' c='anon_vma_prepare'/>
<def f='linux-4.14.y/mm/rmap.c' l='175' ll='221' type='int __anon_vma_prepare(struct vm_area_struct * vma)'/>
<doc f='linux-4.14.y/mm/rmap.c' l='147'>/**
 * __anon_vma_prepare - attach an anon_vma to a memory region
 * @vma: the memory region in question
 *
 * This makes sure the memory mapping described by &apos;vma&apos; has
 * an &apos;anon_vma&apos; attached to it, so that we can associate the
 * anonymous pages mapped into it with that anon_vma.
 *
 * The common case will be that we already have one, which
 * is handled inline by anon_vma_prepare(). But if
 * not we either need to find an adjacent mapping that we
 * can re-use the anon_vma from (very common when the only
 * reason for splitting a vma has been mprotect()), or we
 * allocate a new one.
 *
 * Anon-vma allocations are very subtle, because we may have
 * optimistically looked up an anon_vma in page_lock_anon_vma_read()
 * and that may actually touch the spinlock even in the newly
 * allocated vma (it depends on RCU to make sure that the
 * anon_vma isn&apos;t actually destroyed).
 *
 * As a result, we need to do proper anon_vma locking even
 * for the new allocation. At the same time, we do not want
 * to do any locking for the common case of already having
 * an anon_vma.
 *
 * This must be called with the mmap_sem held for reading.
 */</doc>
