<dec f='linux-4.14.y/include/net/ipv6.h' l='731' type='__be32 ipv6_proxy_select_ident(struct net * net, struct sk_buff * skb)'/>
<def f='linux-4.14.y/net/ipv6/output_core.c' l='42' ll='62' type='__be32 ipv6_proxy_select_ident(struct net * net, struct sk_buff * skb)'/>
<dec f='linux-4.14.y/net/ipv6/output_core.c' l='63' type='__be32 ipv6_proxy_select_ident(struct net * , struct sk_buff * )'/>
<use f='linux-4.14.y/net/ipv6/output_core.c' l='63' c='ipv6_proxy_select_ident'/>
<use f='linux-4.14.y/net/ipv6/output_core.c' l='63' u='a'/>
<use f='linux-4.14.y/net/ipv6/output_core.c' l='63' u='a'/>
<doc f='linux-4.14.y/net/ipv6/output_core.c' l='34'>/* This function exists only for tap drivers that must support broken
 * clients requesting UFO without specifying an IPv6 fragment ID.
 *
 * This is similar to ipv6_select_ident() but we use an independent hash
 * seed to limit information leakage.
 *
 * The network header must be set before calling this.
 */</doc>
<dec f='linux-4.14.y/include/net/ipv6.h' l='731' type='__be32 ipv6_proxy_select_ident(struct net * net, struct sk_buff * skb)'/>
<def f='linux-4.14.y/net/ipv6/output_core.c' l='42' ll='62' type='__be32 ipv6_proxy_select_ident(struct net * net, struct sk_buff * skb)'/>
<dec f='linux-4.14.y/net/ipv6/output_core.c' l='63' type='__be32 ipv6_proxy_select_ident(struct net * , struct sk_buff * )'/>
<use f='linux-4.14.y/net/ipv6/output_core.c' l='63' c='ipv6_proxy_select_ident'/>
<use f='linux-4.14.y/net/ipv6/output_core.c' l='63' u='a'/>
<use f='linux-4.14.y/net/ipv6/output_core.c' l='63' u='a'/>
<doc f='linux-4.14.y/net/ipv6/output_core.c' l='34'>/* This function exists only for tap drivers that must support broken
 * clients requesting UFO without specifying an IPv6 fragment ID.
 *
 * This is similar to ipv6_select_ident() but we use an independent hash
 * seed to limit information leakage.
 *
 * The network header must be set before calling this.
 */</doc>
