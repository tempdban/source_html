<dec f='linux-4.18.y/include/drm/drm_gem.h' l='282' type='int drm_gem_create_mmap_offset(struct drm_gem_object * obj)'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='335' u='c' c='drm_gem_dumb_map_offset'/>
<def f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='517' ll='520' type='int drm_gem_create_mmap_offset(struct drm_gem_object * obj)'/>
<dec f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='521' type='int drm_gem_create_mmap_offset(struct drm_gem_object * )'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='521' c='drm_gem_create_mmap_offset'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='521' u='a'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='521' u='a'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='503'>/**
 * drm_gem_create_mmap_offset - create a fake mmap offset for an object
 * @obj: obj in question
 *
 * GEM memory mapping works by handing back to userspace a fake mmap offset
 * it can use in a subsequent mmap(2) call.  The DRM core code then looks
 * up the object based on the offset and sets up the various memory mapping
 * structures.
 *
 * This routine allocates and attaches a fake offset for @obj.
 *
 * Drivers can call drm_gem_free_mmap_offset() before freeing @obj to release
 * the fake offset again.
 */</doc>
