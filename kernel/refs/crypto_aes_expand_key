<dec f='linux-4.18.y/include/crypto/aes.h' l='38' type='int crypto_aes_expand_key(struct crypto_aes_ctx * ctx, const u8 * in_key, unsigned int key_len)'/>
<def f='linux-4.18.y/crypto/aes_generic.c' l='1217' ll='1273' type='int crypto_aes_expand_key(struct crypto_aes_ctx * ctx, const u8 * in_key, unsigned int key_len)'/>
<dec f='linux-4.18.y/crypto/aes_generic.c' l='1274' type='int crypto_aes_expand_key(struct crypto_aes_ctx * , const u8 * , unsigned int )'/>
<use f='linux-4.18.y/crypto/aes_generic.c' l='1274' c='crypto_aes_expand_key'/>
<use f='linux-4.18.y/crypto/aes_generic.c' l='1274' u='a'/>
<use f='linux-4.18.y/crypto/aes_generic.c' l='1274' u='a'/>
<use f='linux-4.18.y/crypto/aes_generic.c' l='1294' u='c' c='crypto_aes_set_key'/>
<doc f='linux-4.18.y/crypto/aes_generic.c' l='1203'>/**
 * crypto_aes_expand_key - Expands the AES key as described in FIPS-197
 * @ctx:	The location where the computed key will be stored.
 * @in_key:	The supplied key.
 * @key_len:	The length of the supplied key.
 *
 * Returns 0 on success. The function fails only if an invalid key size (or
 * pointer) is supplied.
 * The expanded key size is 240 bytes (max of 14 rounds with a unique 16 bytes
 * key schedule plus a 16 bytes key which is used before the first round).
 * The decryption key is prepared for the &quot;Equivalent Inverse Cipher&quot; as
 * described in FIPS-197. The first slot (16 bytes) of each key (enc or dec) is
 * for the initial combination, the second slot for the first round and so on.
 */</doc>
