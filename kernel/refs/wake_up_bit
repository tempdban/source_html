<dec f='linux-4.18.y/include/linux/wait_bit.h' l='29' type='void wake_up_bit(void * word, int bit)'/>
<use f='linux-4.18.y/include/linux/wait_bit.h' l='322' u='c' c='clear_and_wake_up_bit'/>
<use f='linux-4.18.y/include/linux/fs.h' l='3058' u='c' c='inode_dio_end'/>
<use f='linux-4.18.y/drivers/md/dm-bufio.c' l='677' u='c' c='write_endio'/>
<use f='linux-4.18.y/drivers/md/dm-bufio.c' l='1055' u='c' c='read_endio'/>
<use f='linux-4.18.y/drivers/md/dm-snap.c' l='842' u='c' c='merge_shutdown'/>
<use f='linux-4.18.y/drivers/md/dm.c' l='2774' u='c' c='__dm_internal_resume'/>
<use f='linux-4.18.y/fs/block_dev.c' l='1641' u='c' c='blkdev_get'/>
<use f='linux-4.18.y/fs/buffer.c' l='73' u='c' c='unlock_buffer'/>
<use f='linux-4.18.y/fs/dcache.c' l='1895' u='c' c='d_instantiate_new'/>
<use f='linux-4.18.y/fs/fs-writeback.c' l='1073' u='c' c='inode_sync_complete'/>
<use f='linux-4.18.y/fs/inode.c' l='571' u='c' c='evict'/>
<use f='linux-4.18.y/fs/inode.c' l='966' u='c' c='unlock_new_inode'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='44' u='c' c='journal_end_buffer_io_sync'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='239' u='c' c='journal_submit_data_buffers'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='270' u='c' c='journal_finish_inode_data_buffers'/>
<def f='linux-4.18.y/kernel/sched/wait_bit.c' l='146' ll='149' type='void wake_up_bit(void * word, int bit)'/>
<dec f='linux-4.18.y/kernel/sched/wait_bit.c' l='150' type='void wake_up_bit(void * , int )'/>
<use f='linux-4.18.y/kernel/sched/wait_bit.c' l='150' c='wake_up_bit'/>
<use f='linux-4.18.y/kernel/sched/wait_bit.c' l='150' u='a'/>
<use f='linux-4.18.y/kernel/sched/wait_bit.c' l='150' u='a'/>
<doc f='linux-4.18.y/kernel/sched/wait_bit.c' l='129'>/**
 * wake_up_bit - wake up a waiter on a bit
 * @word: the word being waited on, a kernel virtual address
 * @bit: the bit of the word being waited on
 *
 * There is a standard hashed waitqueue table for generic use. This
 * is the part of the hashtable&apos;s accessor API that wakes up waiters
 * on a bit. For instance, if one were to have waiters on a bitflag,
 * one would call wake_up_bit() after clearing the bit.
 *
 * In order for this to function properly, as it uses waitqueue_active()
 * internally, some kind of memory barrier must be done prior to calling
 * this. Typically, this will be smp_mb__after_atomic(), but in some
 * cases where bitflags are manipulated non-atomically under a lock, one
 * may need to use a less regular barrier, such fs/inode.c&apos;s smp_mb(),
 * because spin_unlock() does not guarantee a memory barrier.
 */</doc>
<use f='linux-4.18.y/kernel/signal.c' l='291' u='c' c='task_clear_jobctl_trapping'/>
<use f='linux-4.18.y/security/keys/gc.c' l='318' u='c' c='key_garbage_collector'/>
<use f='linux-4.18.y/security/keys/key.c' l='474' u='c' c='__key_instantiate_and_link'/>
<use f='linux-4.18.y/security/keys/key.c' l='619' u='c' c='key_reject_and_link'/>
