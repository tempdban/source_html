<dec f='linux-4.14.y/include/linux/wait_bit.h' l='32' type='void wake_up_bit(void * word, int bit)'/>
<use f='linux-4.14.y/include/linux/wait_bit.h' l='276' u='c' c='clear_and_wake_up_bit'/>
<use f='linux-4.14.y/include/linux/fs.h' l='3018' u='c' c='inode_dio_end'/>
<use f='linux-4.14.y/drivers/md/dm-bufio.c' l='714' u='c' c='write_endio'/>
<use f='linux-4.14.y/drivers/md/dm-bufio.c' l='1091' u='c' c='read_endio'/>
<use f='linux-4.14.y/drivers/md/dm-snap.c' l='841' u='c' c='merge_shutdown'/>
<use f='linux-4.14.y/drivers/md/dm.c' l='2595' u='c' c='__dm_internal_resume'/>
<use f='linux-4.14.y/fs/block_dev.c' l='1629' u='c' c='blkdev_get'/>
<use f='linux-4.14.y/fs/buffer.c' l='80' u='c' c='unlock_buffer'/>
<use f='linux-4.14.y/fs/dcache.c' l='1887' u='c' c='d_instantiate_new'/>
<use f='linux-4.14.y/fs/fs-writeback.c' l='1070' u='c' c='inode_sync_complete'/>
<use f='linux-4.14.y/fs/inode.c' l='567' u='c' c='evict'/>
<use f='linux-4.14.y/fs/inode.c' l='962' u='c' c='unlock_new_inode'/>
<use f='linux-4.14.y/fs/jbd2/commit.c' l='47' u='c' c='journal_end_buffer_io_sync'/>
<use f='linux-4.14.y/fs/jbd2/commit.c' l='242' u='c' c='journal_submit_data_buffers'/>
<use f='linux-4.14.y/fs/jbd2/commit.c' l='273' u='c' c='journal_finish_inode_data_buffers'/>
<def f='linux-4.14.y/kernel/sched/wait_bit.c' l='145' ll='148' type='void wake_up_bit(void * word, int bit)'/>
<dec f='linux-4.14.y/kernel/sched/wait_bit.c' l='149' type='void wake_up_bit(void * , int )'/>
<use f='linux-4.14.y/kernel/sched/wait_bit.c' l='149' c='wake_up_bit'/>
<use f='linux-4.14.y/kernel/sched/wait_bit.c' l='149' u='a'/>
<use f='linux-4.14.y/kernel/sched/wait_bit.c' l='149' u='a'/>
<doc f='linux-4.14.y/kernel/sched/wait_bit.c' l='128'>/**
 * wake_up_bit - wake up a waiter on a bit
 * @word: the word being waited on, a kernel virtual address
 * @bit: the bit of the word being waited on
 *
 * There is a standard hashed waitqueue table for generic use. This
 * is the part of the hashtable&apos;s accessor API that wakes up waiters
 * on a bit. For instance, if one were to have waiters on a bitflag,
 * one would call wake_up_bit() after clearing the bit.
 *
 * In order for this to function properly, as it uses waitqueue_active()
 * internally, some kind of memory barrier must be done prior to calling
 * this. Typically, this will be smp_mb__after_atomic(), but in some
 * cases where bitflags are manipulated non-atomically under a lock, one
 * may need to use a less regular barrier, such fs/inode.c&apos;s smp_mb(),
 * because spin_unlock() does not guarantee a memory barrier.
 */</doc>
<use f='linux-4.14.y/kernel/signal.c' l='289' u='c' c='task_clear_jobctl_trapping'/>
<use f='linux-4.14.y/security/keys/gc.c' l='318' u='c' c='key_garbage_collector'/>
<use f='linux-4.14.y/security/keys/key.c' l='474' u='c' c='__key_instantiate_and_link'/>
<use f='linux-4.14.y/security/keys/key.c' l='621' u='c' c='key_reject_and_link'/>
