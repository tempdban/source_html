<dec f='linux-4.18.y/include/linux/vmalloc.h' l='60' type='void * vm_map_ram(struct page ** pages, unsigned int count, int node, pgprot_t prot)'/>
<def f='linux-4.18.y/mm/vmalloc.c' l='1160' ll='1186' type='void * vm_map_ram(struct page ** pages, unsigned int count, int node, pgprot_t prot)'/>
<dec f='linux-4.18.y/mm/vmalloc.c' l='1187' type='void * vm_map_ram(struct page ** , unsigned int , int , pgprot_t )'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='1187' c='vm_map_ram'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='1187' u='a'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='1187' u='a'/>
<doc f='linux-4.18.y/mm/vmalloc.c' l='1145'>/**
 * vm_map_ram - map pages linearly into kernel virtual address (vmalloc space)
 * @pages: an array of pointers to the pages to be mapped
 * @count: number of pages
 * @node: prefer to allocate data structures on this node
 * @prot: memory protection to use. PAGE_KERNEL for regular RAM
 *
 * If you use this function for less than VMAP_MAX_ALLOC pages, it could be
 * faster than vmap so it&apos;s good.  But if you mix long-life and short-life
 * objects with vm_map_ram(), it could consume lots of address space through
 * fragmentation (especially on a 32bit machine).  You could see failures in
 * the end.  Please use this function for short-lived objects.
 *
 * Returns: a pointer to the address that has been mapped, or %NULL on failure
 */</doc>
