<dec f='linux-4.18.y/include/linux/hrtimer.h' l='302' type='void hrtimer_interrupt(struct clock_event_device * dev)'/>
<doc f='linux-4.18.y/include/linux/hrtimer.h' l='173'>/**
 * struct hrtimer_cpu_base - the per cpu clock bases
 * @lock:		lock protecting the base and associated clock bases
 *			and timers
 * @cpu:		cpu number
 * @active_bases:	Bitfield to mark bases with active timers
 * @clock_was_set_seq:	Sequence counter of clock was set events
 * @hres_active:	State of high resolution mode
 * @in_hrtirq:		hrtimer_interrupt() is currently executing
 * @hang_detected:	The last hrtimer interrupt detected a hang
 * @softirq_activated:	displays, if the softirq is raised - update of softirq
 *			related settings is not required then.
 * @nr_events:		Total number of hrtimer interrupt events
 * @nr_retries:		Total number of hrtimer interrupt retries
 * @nr_hangs:		Total number of hrtimer interrupt hangs
 * @max_hang_time:	Maximum time spent in hrtimer_interrupt
 * @expires_next:	absolute time of the next event, is required for remote
 *			hrtimer enqueue; it is the total first expiry time (hard
 *			and soft hrtimer are taken into account)
 * @next_timer:		Pointer to the first expiring timer
 * @softirq_expires_next: Time to check, if soft queues needs also to be expired
 * @softirq_next_timer: Pointer to the first expiring softirq based timer
 * @clock_base:		array of clock bases for this cpu
 *
 * Note: next_timer is just an optimization for __remove_hrtimer().
 *	 Do not dereference the pointer because it is not reliable on
 *	 cross cpu removals.
 */</doc>
<def f='linux-4.18.y/kernel/time/hrtimer.c' l='1488' ll='1578' type='void hrtimer_interrupt(struct clock_event_device * dev)'/>
<use f='linux-4.18.y/kernel/time/hrtimer.c' l='1590' u='c' c='__hrtimer_peek_ahead_timers'/>
<doc f='linux-4.18.y/kernel/time/hrtimer.c' l='1484'>/*
 * High resolution timer interrupt
 * Called with interrupts disabled
 */</doc>
<use f='linux-4.18.y/kernel/time/tick-oneshot.c' l='130' u='r' c='tick_init_highres'/>
