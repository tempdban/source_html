<dec f='linux-4.18.y/include/linux/timekeeping.h' l='37' type='time64_t ktime_get_seconds()'/>
<doc f='linux-4.18.y/include/linux/timekeeping.h' l='34'>/*
 * time64_t base interfaces
 */</doc>
<use f='linux-4.18.y/drivers/md/raid10.c' l='2307' u='c' c='check_decay_read_errors'/>
<use f='linux-4.18.y/kernel/cgroup/cpuset.c' l='1420' u='c' c='fmeter_update'/>
<def f='linux-4.18.y/kernel/time/timekeeping.c' l='898' ll='904' type='time64_t ktime_get_seconds()'/>
<dec f='linux-4.18.y/kernel/time/timekeeping.c' l='905' type='time64_t ktime_get_seconds()'/>
<use f='linux-4.18.y/kernel/time/timekeeping.c' l='905' c='ktime_get_seconds'/>
<use f='linux-4.18.y/kernel/time/timekeeping.c' l='905' u='a'/>
<use f='linux-4.18.y/kernel/time/timekeeping.c' l='905' u='a'/>
<doc f='linux-4.18.y/kernel/time/timekeeping.c' l='889'>/**
 * ktime_get_seconds - Get the seconds portion of CLOCK_MONOTONIC
 *
 * Returns the seconds portion of CLOCK_MONOTONIC with a single non
 * serialized read. tk-&gt;ktime_sec is of type &apos;unsigned long&apos; so this
 * works on both 32 and 64 bit systems. On 32 bit systems the readout
 * covers ~136 years of uptime which should be enough to prevent
 * premature wrap arounds.
 */</doc>
