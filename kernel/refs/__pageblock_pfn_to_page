<dec f='linux-4.18.y/mm/internal.h' l='151' type='struct page * __pageblock_pfn_to_page(unsigned long start_pfn, unsigned long end_pfn, struct zone * zone)'/>
<use f='linux-4.18.y/mm/internal.h' l='160' u='c' c='pageblock_pfn_to_page'/>
<def f='linux-4.18.y/mm/page_alloc.c' l='1354' ll='1380' type='struct page * __pageblock_pfn_to_page(unsigned long start_pfn, unsigned long end_pfn, struct zone * zone)'/>
<use f='linux-4.18.y/mm/page_alloc.c' l='1394' u='c' c='set_zone_contiguous'/>
<doc f='linux-4.18.y/mm/page_alloc.c' l='1337'>/*
 * Check that the whole (or subset of) a pageblock given by the interval of
 * [start_pfn, end_pfn) is valid and within the same zone, before scanning it
 * with the migration of free compaction scanner. The scanners then need to
 * use only pfn_valid_within() check for arches that allow holes within
 * pageblocks.
 *
 * Return struct page pointer of start_pfn, or NULL if checks were not passed.
 *
 * It&apos;s possible on some configurations to have a setup like node0 node1 node0
 * i.e. it&apos;s possible that all pages within a zones range of pages do not
 * belong to a single zone. We assume that a border between node0 and node1
 * can occur within a single pageblock, but not a node0 node1 node0
 * interleaving within a single pageblock. It is therefore sufficient to check
 * the first and last page of a pageblock and avoid checking each individual
 * page in a pageblock.
 */</doc>
