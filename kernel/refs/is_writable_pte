<def f='linux-4.18.y/arch/x86/kvm/mmu.h' l='121' ll='124' type='int is_writable_pte(unsigned long pte)'/>
<doc f='linux-4.18.y/arch/x86/kvm/mmu.h' l='88'>/*
 * Currently, we have two sorts of write-protection, a) the first one
 * write-protects guest page to sync the guest modification, b) another one is
 * used to sync dirty bitmap when we do KVM_GET_DIRTY_LOG. The differences
 * between these two sorts are:
 * 1) the first case clears SPTE_MMU_WRITEABLE bit.
 * 2) the first case requires flushing tlb immediately avoiding corrupting
 *    shadow page table between all vcpus so it should be in the protection of
 *    mmu-lock. And the another case does not need to flush tlb until returning
 *    the dirty bitmap to userspace since it only write-protects the page
 *    logged in the bitmap, that means the page in the dirty bitmap is not
 *    missed, so it can flush tlb out of mmu-lock.
 *
 * So, there is the problem: the first case can meet the corrupted tlb caused
 * by another case which write-protects pages but without flush tlb
 * immediately. In order to making the first case be aware this problem we let
 * it flush tlb if we try to write-protect a spte whose SPTE_MMU_WRITEABLE bit
 * is set, it works since another case never touches SPTE_MMU_WRITEABLE bit.
 *
 * Anyway, whenever a spte is updated (only permission and status bits are
 * changed) we need to check whether the spte with SPTE_MMU_WRITEABLE becomes
 * readonly, if that happens, we need to flush tlb. Fortunately,
 * mmu_spte_update() has already handled it perfectly.
 *
 * The rules to use SPTE_MMU_WRITEABLE and PT_WRITABLE_MASK:
 * - if we want to see if it has writable tlb entry or if the spte can be
 *   writable on the mmu mapping, check SPTE_MMU_WRITEABLE, this is the most
 *   case, otherwise
 * - if we fix page fault on the spte or do write-protection by dirty logging,
 *   check PT_WRITABLE_MASK.
 *
 * TODO: introduce APIs to split these two cases.
 */</doc>
<use f='linux-4.18.y/arch/x86/kvm/mmutrace.h' l='248' u='c' c='trace_raw_output_fast_page_fault'/>
<use f='linux-4.18.y/arch/x86/kvm/mmutrace.h' l='248' u='c' c='trace_raw_output_fast_page_fault'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='635' u='c' c='spte_has_volatile_bits'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='719' u='c' c='mmu_spte_update'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='854' u='c' c='mmu_spte_age'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='1439' u='c' c='spte_write_protect'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='2830' u='c' c='set_spte'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='3187' u='c' c='fast_pf_fix_direct_spte'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='3187' u='c' c='fast_pf_fix_direct_spte'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='3205' u='c' c='is_access_allowed'/>
