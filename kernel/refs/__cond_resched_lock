<dec f='linux-4.14.y/include/linux/sched.h' l='1632' type='int __cond_resched_lock(spinlock_t * lock)'/>
<use f='linux-4.14.y/fs/jbd2/commit.c' l='1017' macro='1' u='c'/>
<def f='linux-4.14.y/kernel/sched/core.c' l='4860' ll='4877' type='int __cond_resched_lock(spinlock_t * lock)'/>
<dec f='linux-4.14.y/kernel/sched/core.c' l='4878' type='int __cond_resched_lock(spinlock_t * )'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4878' c='__cond_resched_lock'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4878' u='a'/>
<use f='linux-4.14.y/kernel/sched/core.c' l='4878' u='a'/>
<doc f='linux-4.14.y/kernel/sched/core.c' l='4852'>/*
 * __cond_resched_lock() - if a reschedule is pending, drop the given lock,
 * call schedule, and on return reacquire the lock.
 *
 * This works OK both with and without CONFIG_PREEMPT. We do strange low-level
 * operations here to prevent schedule() from being called twice (once via
 * spin_unlock(), once by hand).
 */</doc>
<use f='linux-4.14.y/mm/hugetlb.c' l='1807' macro='1' u='c'/>
<use f='linux-4.14.y/mm/hugetlb.c' l='2351' macro='1' u='c'/>
<use f='linux-4.14.y/mm/vmalloc.c' l='704' macro='1' u='c'/>
