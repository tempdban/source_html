<dec f='linux-4.18.y/include/linux/sched.h' l='1695' type='int __cond_resched_lock(spinlock_t * lock)'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='2317' macro='1' u='c'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='5153' macro='1' u='c'/>
<use f='linux-4.18.y/arch/x86/kvm/mmu.c' l='5395' macro='1' u='c'/>
<use f='linux-4.18.y/fs/jbd2/commit.c' l='1014' macro='1' u='c'/>
<def f='linux-4.18.y/kernel/sched/core.c' l='5008' ll='5025' type='int __cond_resched_lock(spinlock_t * lock)'/>
<dec f='linux-4.18.y/kernel/sched/core.c' l='5026' type='int __cond_resched_lock(spinlock_t * )'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='5026' c='__cond_resched_lock'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='5026' u='a'/>
<use f='linux-4.18.y/kernel/sched/core.c' l='5026' u='a'/>
<doc f='linux-4.18.y/kernel/sched/core.c' l='5000'>/*
 * __cond_resched_lock() - if a reschedule is pending, drop the given lock,
 * call schedule, and on return reacquire the lock.
 *
 * This works OK both with and without CONFIG_PREEMPT. We do strange low-level
 * operations here to prevent schedule() from being called twice (once via
 * spin_unlock(), once by hand).
 */</doc>
<use f='linux-4.18.y/mm/hugetlb.c' l='1823' macro='1' u='c'/>
<use f='linux-4.18.y/mm/hugetlb.c' l='2352' macro='1' u='c'/>
<use f='linux-4.18.y/mm/vmalloc.c' l='684' macro='1' u='c'/>
