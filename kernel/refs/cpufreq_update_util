<def f='linux-4.14.y/kernel/sched/sched.h' l='2086' ll='2094' type='void cpufreq_update_util(struct rq * rq, unsigned int flags)'/>
<doc f='linux-4.14.y/kernel/sched/sched.h' l='2064'>/**
 * cpufreq_update_util - Take a note about CPU utilization changes.
 * @rq: Runqueue to carry out the update for.
 * @flags: Update reason flags.
 *
 * This function is called by the scheduler on the CPU whose utilization is
 * being updated.
 *
 * It can only be called from RCU-sched read-side critical sections.
 *
 * The way cpufreq is currently arranged requires it to evaluate the CPU
 * performance state (frequency/voltage) on a regular basis to prevent it from
 * being stuck in a completely inadequate performance level for too long.
 * That is not guaranteed to happen if the updates are only triggered from CFS,
 * though, because they may not be coming in if RT or deadline tasks are active
 * all the time (or there are RT and DL tasks only).
 *
 * As a workaround for that issue, this function is called by the RT and DL
 * sched classes to trigger extra cpufreq updates to prevent it from stalling,
 * but that really is a band-aid.  Going forward it should be replaced with
 * solutions targeted more specifically at RT and DL tasks.
 */</doc>
<use f='linux-4.14.y/kernel/sched/deadline.c' l='1138' u='c' c='update_curr_dl'/>
<use f='linux-4.14.y/kernel/sched/fair.c' l='2813' u='c' c='cfs_rq_util_change'/>
<use f='linux-4.14.y/kernel/sched/fair.c' l='4890' u='c' c='enqueue_task_fair'/>
<use f='linux-4.14.y/kernel/sched/rt.c' l='965' u='c' c='update_curr_rt'/>
