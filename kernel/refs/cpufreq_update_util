<def f='linux-4.18.y/kernel/sched/sched.h' l='2158' ll='2166' type='void cpufreq_update_util(struct rq * rq, unsigned int flags)'/>
<doc f='linux-4.18.y/kernel/sched/sched.h' l='2136'>/**
 * cpufreq_update_util - Take a note about CPU utilization changes.
 * @rq: Runqueue to carry out the update for.
 * @flags: Update reason flags.
 *
 * This function is called by the scheduler on the CPU whose utilization is
 * being updated.
 *
 * It can only be called from RCU-sched read-side critical sections.
 *
 * The way cpufreq is currently arranged requires it to evaluate the CPU
 * performance state (frequency/voltage) on a regular basis to prevent it from
 * being stuck in a completely inadequate performance level for too long.
 * That is not guaranteed to happen if the updates are only triggered from CFS
 * and DL, though, because they may not be coming in if only RT tasks are
 * active all the time (or there are RT tasks only).
 *
 * As a workaround for that issue, this function is called periodically by the
 * RT sched class to trigger extra cpufreq updates to prevent it from stalling,
 * but that really is a band-aid.  Going forward it should be replaced with
 * solutions targeted more specifically at RT tasks.
 */</doc>
<use f='linux-4.18.y/kernel/sched/deadline.c' l='87' u='c' c='__add_running_bw'/>
<use f='linux-4.18.y/kernel/sched/deadline.c' l='101' u='c' c='__sub_running_bw'/>
<use f='linux-4.18.y/kernel/sched/fair.c' l='3062' u='c' c='cfs_rq_util_change'/>
<use f='linux-4.18.y/kernel/sched/fair.c' l='5403' u='c' c='enqueue_task_fair'/>
<use f='linux-4.18.y/kernel/sched/rt.c' l='1030' u='c' c='enqueue_top_rt_rq'/>
