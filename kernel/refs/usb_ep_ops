<def f='linux-4.18.y/include/linux/usb/gadget.h' l='128' ll='147'/>
<size>88</size>
<doc f='linux-4.18.y/include/linux/usb/gadget.h' l='121'>/* endpoint-specific parts of the api to the usb controller hardware.
 * unlike the urb model, (de)multiplexing layers are not required.
 * (so this api could slash overhead if used on the host side...)
 *
 * note that device side usb controllers commonly differ in how many
 * endpoints they support, as well as their capabilities.
 */</doc>
<mbr r='usb_ep_ops::enable' o='0' t='int (*)(struct usb_ep *, const struct usb_endpoint_descriptor *)'/>
<mbr r='usb_ep_ops::disable' o='64' t='int (*)(struct usb_ep *)'/>
<mbr r='usb_ep_ops::dispose' o='128' t='void (*)(struct usb_ep *)'/>
<mbr r='usb_ep_ops::alloc_request' o='192' t='struct usb_request *(*)(struct usb_ep *, gfp_t)'/>
<mbr r='usb_ep_ops::free_request' o='256' t='void (*)(struct usb_ep *, struct usb_request *)'/>
<mbr r='usb_ep_ops::queue' o='320' t='int (*)(struct usb_ep *, struct usb_request *, gfp_t)'/>
<mbr r='usb_ep_ops::dequeue' o='384' t='int (*)(struct usb_ep *, struct usb_request *)'/>
<mbr r='usb_ep_ops::set_halt' o='448' t='int (*)(struct usb_ep *, int)'/>
<mbr r='usb_ep_ops::set_wedge' o='512' t='int (*)(struct usb_ep *)'/>
<mbr r='usb_ep_ops::fifo_status' o='576' t='int (*)(struct usb_ep *)'/>
<mbr r='usb_ep_ops::fifo_flush' o='640' t='void (*)(struct usb_ep *)'/>
