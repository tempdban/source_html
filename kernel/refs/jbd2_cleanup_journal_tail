<dec f='linux-4.18.y/include/linux/jbd2.h' l='1482' type='int jbd2_cleanup_journal_tail(journal_t * )'/>
<use f='linux-4.18.y/fs/jbd2/checkpoint.c' l='147' u='c' c='__jbd2_log_wait_for_space'/>
<use f='linux-4.18.y/fs/jbd2/checkpoint.c' l='220' u='c' c='jbd2_log_do_checkpoint'/>
<use f='linux-4.18.y/fs/jbd2/checkpoint.c' l='361' u='c' c='jbd2_log_do_checkpoint'/>
<def f='linux-4.18.y/fs/jbd2/checkpoint.c' l='384' ll='408' type='int jbd2_cleanup_journal_tail(journal_t * journal)'/>
<doc f='linux-4.18.y/fs/jbd2/checkpoint.c' l='366'>/*
 * Check the list of checkpoint transactions for the journal to see if
 * we have already got rid of any since the last update of the log tail
 * in the journal superblock.  If so, we can instantly roll the
 * superblock forward to remove those transactions from the log.
 *
 * Return &lt;0 on error, 0 on success, 1 if there was nothing to clean up.
 *
 * Called with the journal lock held.
 *
 * This is the only part of the journaling code which really needs to be
 * aware of transaction aborts.  Checkpointing involves writing to the
 * main filesystem area rather than to the journal, so it can proceed
 * even in abort state, but we must not update the super block if
 * checkpointing may have failed.  Otherwise, we would lose some metadata
 * buffers which should be written-back to the filesystem.
 */</doc>
<use f='linux-4.18.y/fs/jbd2/journal.c' l='2012' u='c' c='jbd2_journal_flush'/>
