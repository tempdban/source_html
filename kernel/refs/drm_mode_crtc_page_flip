<def f='linux-4.14.y/include/uapi/drm/drm_mode.h' l='627' ll='633'/>
<size>24</size>
<doc f='linux-4.14.y/include/uapi/drm/drm_mode.h' l='603'>/*
 * Request a page flip on the specified crtc.
 *
 * This ioctl will ask KMS to schedule a page flip for the specified
 * crtc.  Once any pending rendering targeting the specified fb (as of
 * ioctl time) has completed, the crtc will be reprogrammed to display
 * that fb after the next vertical refresh.  The ioctl returns
 * immediately, but subsequent rendering to the current fb will block
 * in the execbuffer ioctl until the page flip happens.  If a page
 * flip is already pending as the ioctl is called, EBUSY will be
 * returned.
 *
 * Flag DRM_MODE_PAGE_FLIP_EVENT requests that drm sends back a vblank
 * event (see drm.h: struct drm_event_vblank) when the page flip is
 * done.  The user_data field passed in with this ioctl will be
 * returned as the user_data field in the vblank event struct.
 *
 * Flag DRM_MODE_PAGE_FLIP_ASYNC requests that the flip happen
 * &apos;as soon as possible&apos;, meaning that it not delay waiting for vblank.
 * This may cause tearing on the screen.
 *
 * The reserved field must be zero.
 */</doc>
<mbr r='drm_mode_crtc_page_flip::crtc_id' o='0' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::fb_id' o='32' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::flags' o='64' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::reserved' o='96' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::user_data' o='128' t='__u64'/>
<def f='linux-4.14.y/include/uapi/drm/drm_mode.h' l='627' ll='633'/>
<size>24</size>
<doc f='linux-4.14.y/include/uapi/drm/drm_mode.h' l='603'>/*
 * Request a page flip on the specified crtc.
 *
 * This ioctl will ask KMS to schedule a page flip for the specified
 * crtc.  Once any pending rendering targeting the specified fb (as of
 * ioctl time) has completed, the crtc will be reprogrammed to display
 * that fb after the next vertical refresh.  The ioctl returns
 * immediately, but subsequent rendering to the current fb will block
 * in the execbuffer ioctl until the page flip happens.  If a page
 * flip is already pending as the ioctl is called, EBUSY will be
 * returned.
 *
 * Flag DRM_MODE_PAGE_FLIP_EVENT requests that drm sends back a vblank
 * event (see drm.h: struct drm_event_vblank) when the page flip is
 * done.  The user_data field passed in with this ioctl will be
 * returned as the user_data field in the vblank event struct.
 *
 * Flag DRM_MODE_PAGE_FLIP_ASYNC requests that the flip happen
 * &apos;as soon as possible&apos;, meaning that it not delay waiting for vblank.
 * This may cause tearing on the screen.
 *
 * The reserved field must be zero.
 */</doc>
<mbr r='drm_mode_crtc_page_flip::crtc_id' o='0' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::fb_id' o='32' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::flags' o='64' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::reserved' o='96' t='__u32'/>
<mbr r='drm_mode_crtc_page_flip::user_data' o='128' t='__u64'/>
