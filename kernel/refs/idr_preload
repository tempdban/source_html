<dec f='linux-4.18.y/include/linux/idr.h' l='101' type='void idr_preload(gfp_t gfp_mask)'/>
<doc f='linux-4.18.y/include/linux/idr.h' l='84'>/**
 * DOC: idr sync
 * idr synchronization (stolen from radix-tree.h)
 *
 * idr_find() is able to be called locklessly, using RCU. The caller must
 * ensure calls to this function are made within rcu_read_lock() regions.
 * Other readers (lock-free or otherwise) and modifications may be running
 * concurrently.
 *
 * It is still required that the caller manage the synchronization and
 * lifetimes of the items. So if RCU lock-free lookups are used, typically
 * this would mean that the items have their own locks, or are amenable to
 * lock-free access; and that the items are freed by RCU (or only freed after
 * having been deleted from the idr tree *and* a synchronize_rcu() grace
 * period).
 */</doc>
<use f='linux-4.18.y/block/genhd.c' l='486' u='c' c='blk_alloc_devt'/>
<use f='linux-4.18.y/drivers/dca/dca-sysfs.c' l='58' u='c' c='dca_sysfs_add_provider'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='120' u='c' c='drm_minor_alloc'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_gem.c' l='395' u='c' c='drm_gem_handle_create_tail'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_syncobj.c' l='342' u='c' c='drm_syncobj_get_handle'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_syncobj.c' l='470' u='c' c='drm_syncobj_fd_to_handle'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_cmd.c' l='424' u='c' c='qxl_surface_id_alloc'/>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_release.c' l='145' u='c' c='qxl_release_alloc'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_kms.c' l='60' u='c' c='virtio_gpu_ctx_id_get'/>
<use f='linux-4.18.y/drivers/gpu/drm/virtio/virtgpu_vq.c' l='46' u='c' c='virtio_gpu_resource_id_get'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c' l='166' u='c' c='vmw_resource_alloc_id'/>
<use f='linux-4.18.y/drivers/md/dm.c' l='1760' u='c' c='specific_minor'/>
<use f='linux-4.18.y/drivers/md/dm.c' l='1776' u='c' c='next_free_minor'/>
<use f='linux-4.18.y/drivers/scsi/sg.c' l='1463' u='c' c='sg_alloc'/>
<use f='linux-4.18.y/drivers/scsi/st.c' l='4373' u='c' c='st_probe'/>
<use f='linux-4.18.y/fs/kernfs/dir.c' l='637' u='c' c='__kernfs_new_node'/>
<use f='linux-4.18.y/fs/notify/inotify/inotify_user.c' l='363' u='c' c='inotify_add_to_idr'/>
<use f='linux-4.18.y/ipc/util.c' l='261' u='c' c='ipc_addid'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='302' u='c' c='cgroup_idr_alloc'/>
<use f='linux-4.18.y/kernel/pid.c' l='178' u='c' c='alloc_pid'/>
<def f='linux-4.18.y/lib/radix-tree.c' l='2102' ll='2106' type='void idr_preload(gfp_t gfp_mask)'/>
<dec f='linux-4.18.y/lib/radix-tree.c' l='2107' type='void idr_preload(gfp_t )'/>
<use f='linux-4.18.y/lib/radix-tree.c' l='2107' c='idr_preload'/>
<use f='linux-4.18.y/lib/radix-tree.c' l='2107' u='a'/>
<use f='linux-4.18.y/lib/radix-tree.c' l='2107' u='a'/>
<doc f='linux-4.18.y/lib/radix-tree.c' l='2095'>/**
 * idr_preload - preload for idr_alloc()
 * @gfp_mask: allocation mask to use for preloading
 *
 * Preallocate memory to use for the next call to idr_alloc().  This function
 * returns with preemption disabled.  It will be enabled by idr_preload_end().
 */</doc>
<use f='linux-4.18.y/security/apparmor/secid.c' l='135' u='c' c='aa_alloc_secid'/>
