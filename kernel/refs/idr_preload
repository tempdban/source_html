<dec f='linux-4.14.y/include/linux/idr.h' l='82' type='void idr_preload(gfp_t gfp_mask)'/>
<doc f='linux-4.14.y/include/linux/idr.h' l='65'>/**
 * DOC: idr sync
 * idr synchronization (stolen from radix-tree.h)
 *
 * idr_find() is able to be called locklessly, using RCU. The caller must
 * ensure calls to this function are made within rcu_read_lock() regions.
 * Other readers (lock-free or otherwise) and modifications may be running
 * concurrently.
 *
 * It is still required that the caller manage the synchronization and
 * lifetimes of the items. So if RCU lock-free lookups are used, typically
 * this would mean that the items have their own locks, or are amenable to
 * lock-free access; and that the items are freed by RCU (or only freed after
 * having been deleted from the idr tree *and* a synchronize_rcu() grace
 * period).
 */</doc>
<use f='linux-4.14.y/block/genhd.c' l='483' u='c' c='blk_alloc_devt'/>
<use f='linux-4.14.y/drivers/dca/dca-sysfs.c' l='58' u='c' c='dca_sysfs_add_provider'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_drv.c' l='165' u='c' c='drm_minor_alloc'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_gem.c' l='397' u='c' c='drm_gem_handle_create_tail'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_syncobj.c' l='287' u='c' c='drm_syncobj_create'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_syncobj.c' l='383' u='c' c='drm_syncobj_fd_to_handle'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_cmd.c' l='456' u='c' c='qxl_surface_id_alloc'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_release.c' l='145' u='c' c='qxl_release_alloc'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_kms.c' l='60' u='c' c='virtio_gpu_ctx_id_get'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_vq.c' l='46' u='c' c='virtio_gpu_resource_id_get'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c' l='166' u='c' c='vmw_resource_alloc_id'/>
<use f='linux-4.14.y/drivers/md/dm.c' l='1585' u='c' c='specific_minor'/>
<use f='linux-4.14.y/drivers/md/dm.c' l='1601' u='c' c='next_free_minor'/>
<use f='linux-4.14.y/drivers/scsi/sg.c' l='1464' u='c' c='sg_alloc'/>
<use f='linux-4.14.y/drivers/scsi/st.c' l='4373' u='c' c='st_probe'/>
<use f='linux-4.14.y/fs/kernfs/dir.c' l='637' u='c' c='__kernfs_new_node'/>
<use f='linux-4.14.y/fs/notify/inotify/inotify_user.c' l='349' u='c' c='inotify_add_to_idr'/>
<use f='linux-4.14.y/ipc/util.c' l='245' u='c' c='ipc_addid'/>
<use f='linux-4.14.y/kernel/cgroup/cgroup.c' l='297' u='c' c='cgroup_idr_alloc'/>
<def f='linux-4.14.y/lib/radix-tree.c' l='2105' ll='2109' type='void idr_preload(gfp_t gfp_mask)'/>
<dec f='linux-4.14.y/lib/radix-tree.c' l='2110' type='void idr_preload(gfp_t )'/>
<use f='linux-4.14.y/lib/radix-tree.c' l='2110' c='idr_preload'/>
<use f='linux-4.14.y/lib/radix-tree.c' l='2110' u='a'/>
<use f='linux-4.14.y/lib/radix-tree.c' l='2110' u='a'/>
<doc f='linux-4.14.y/lib/radix-tree.c' l='2098'>/**
 * idr_preload - preload for idr_alloc()
 * @gfp_mask: allocation mask to use for preloading
 *
 * Preallocate memory to use for the next call to idr_alloc().  This function
 * returns with preemption disabled.  It will be enabled by idr_preload_end().
 */</doc>
