<dec f='linux-4.14.y/include/linux/refcount.h' l='99' type='bool refcount_dec_and_mutex_lock(refcount_t * r, struct mutex * lock)'/>
<use f='linux-4.14.y/include/linux/kref.h' l='80' u='c' c='kref_put_mutex'/>
<def f='linux-4.14.y/lib/refcount.c' l='307' ll='319' type='bool refcount_dec_and_mutex_lock(refcount_t * r, struct mutex * lock)'/>
<dec f='linux-4.14.y/lib/refcount.c' l='320' type='bool refcount_dec_and_mutex_lock(refcount_t * , struct mutex * )'/>
<use f='linux-4.14.y/lib/refcount.c' l='320' c='refcount_dec_and_mutex_lock'/>
<use f='linux-4.14.y/lib/refcount.c' l='320' u='a'/>
<use f='linux-4.14.y/lib/refcount.c' l='320' u='a'/>
<doc f='linux-4.14.y/lib/refcount.c' l='291'>/**
 * refcount_dec_and_mutex_lock - return holding mutex if able to decrement
 *                               refcount to 0
 * @r: the refcount
 * @lock: the mutex to be locked
 *
 * Similar to atomic_dec_and_mutex_lock(), it will WARN on underflow and fail
 * to decrement when saturated at UINT_MAX.
 *
 * Provides release memory ordering, such that prior loads and stores are done
 * before, and provides a control dependency such that free() must come after.
 * See the comment on top.
 *
 * Return: true and hold mutex if able to decrement refcount to 0, false
 *         otherwise
 */</doc>
<dec f='linux-4.14.y/include/linux/refcount.h' l='99' type='bool refcount_dec_and_mutex_lock(refcount_t * r, struct mutex * lock)'/>
<use f='linux-4.14.y/include/linux/kref.h' l='80' u='c' c='kref_put_mutex'/>
<def f='linux-4.14.y/lib/refcount.c' l='307' ll='319' type='bool refcount_dec_and_mutex_lock(refcount_t * r, struct mutex * lock)'/>
<dec f='linux-4.14.y/lib/refcount.c' l='320' type='bool refcount_dec_and_mutex_lock(refcount_t * , struct mutex * )'/>
<use f='linux-4.14.y/lib/refcount.c' l='320' c='refcount_dec_and_mutex_lock'/>
<use f='linux-4.14.y/lib/refcount.c' l='320' u='a'/>
<use f='linux-4.14.y/lib/refcount.c' l='320' u='a'/>
<doc f='linux-4.14.y/lib/refcount.c' l='291'>/**
 * refcount_dec_and_mutex_lock - return holding mutex if able to decrement
 *                               refcount to 0
 * @r: the refcount
 * @lock: the mutex to be locked
 *
 * Similar to atomic_dec_and_mutex_lock(), it will WARN on underflow and fail
 * to decrement when saturated at UINT_MAX.
 *
 * Provides release memory ordering, such that prior loads and stores are done
 * before, and provides a control dependency such that free() must come after.
 * See the comment on top.
 *
 * Return: true and hold mutex if able to decrement refcount to 0, false
 *         otherwise
 */</doc>
