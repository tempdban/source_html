<dec f='linux-4.18.y/include/linux/libata.h' l='1094' type='int ata_std_prereset(struct ata_link * link, unsigned long deadline)'/>
<use f='linux-4.18.y/drivers/ata/libata-core.c' l='88'/>
<use f='linux-4.18.y/drivers/ata/libata-core.c' l='88'/>
<def f='linux-4.18.y/drivers/ata/libata-core.c' l='4017' ll='4043' type='int ata_std_prereset(struct ata_link * link, unsigned long deadline)'/>
<dec f='linux-4.18.y/drivers/ata/libata-core.c' l='7332' type='int ata_std_prereset(struct ata_link * , unsigned long )'/>
<use f='linux-4.18.y/drivers/ata/libata-core.c' l='7332' c='ata_std_prereset'/>
<use f='linux-4.18.y/drivers/ata/libata-core.c' l='7332' u='a'/>
<use f='linux-4.18.y/drivers/ata/libata-core.c' l='7332' u='a'/>
<doc f='linux-4.18.y/drivers/ata/libata-core.c' l='4000'>/**
 *	ata_std_prereset - prepare for reset
 *	@link: ATA link to be reset
 *	@deadline: deadline jiffies for the operation
 *
 *	@link is about to be reset.  Initialize it.  Failure from
 *	prereset makes libata abort whole reset sequence and give up
 *	that port, so prereset should be best-effort.  It does its
 *	best to prepare for reset sequence but if things go wrong, it
 *	should just whine, not fail.
 *
 *	LOCKING:
 *	Kernel thread context (may sleep)
 *
 *	RETURNS:
 *	0 on success, -errno otherwise.
 */</doc>
<use f='linux-4.18.y/drivers/ata/libata-pmp.c' l='19'/>
<use f='linux-4.18.y/drivers/ata/libata-pmp.c' l='19'/>
<use f='linux-4.18.y/drivers/ata/libata-sff.c' l='1766' u='c' c='ata_sff_prereset'/>
<use f='linux-4.18.y/drivers/scsi/libsas/sas_ata.c' l='531'/>
<use f='linux-4.18.y/drivers/scsi/libsas/sas_ata.c' l='531'/>
