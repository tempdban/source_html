<dec f='linux-4.14.y/include/drm/drm_modeset_helper_vtables.h' l='822' type='int (*)(struct drm_connector *)'/>
<offset>0</offset>
<doc f='linux-4.14.y/include/drm/drm_modeset_helper_vtables.h' l='783'>/**
	 * @get_modes:
	 *
	 * This function should fill in all modes currently valid for the sink
	 * into the &amp;drm_connector.probed_modes list. It should also update the
	 * EDID property by calling drm_mode_connector_update_edid_property().
	 *
	 * The usual way to implement this is to cache the EDID retrieved in the
	 * probe callback somewhere in the driver-private connector structure.
	 * In this function drivers then parse the modes in the EDID and add
	 * them by calling drm_add_edid_modes(). But connectors that driver a
	 * fixed panel can also manually add specific modes using
	 * drm_mode_probed_add(). Drivers which manually add modes should also
	 * make sure that the &amp;drm_connector.display_info,
	 * &amp;drm_connector.width_mm and &amp;drm_connector.height_mm fields are
	 * filled in.
	 *
	 * Virtual drivers that just want some standard VESA mode with a given
	 * resolution can call drm_add_modes_noedid(), and mark the preferred
	 * one using drm_set_preferred_mode().
	 *
	 * Finally drivers that support audio probably want to update the ELD
	 * data, too, using drm_edid_to_eld().
	 *
	 * This function is only called after the @detect hook has indicated
	 * that a sink is connected and when the EDID isn&apos;t overridden through
	 * sysfs or the kernel commandline.
	 *
	 * This callback is used by the probe helpers in e.g.
	 * drm_helper_probe_single_connector_modes().
	 *
	 * To avoid races with concurrent connector state updates, the helper
	 * libraries always call this with the &amp;drm_mode_config.connection_mutex
	 * held. Because of this it&apos;s safe to inspect &amp;drm_connector-&gt;state.
	 *
	 * RETURNS:
	 *
	 * The number of modes added by calling drm_mode_probed_add().
	 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_kms.c' l='221' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/bridge/panel.c' l='49' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/cirrus/cirrus_mode.c' l='477' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_probe_helper.c' l='500' u='r' c='drm_helper_probe_single_connector_modes'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='1082' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='227' u='w'/>
<dec f='linux-4.14.y/include/drm/drm_modeset_helper_vtables.h' l='822' type='int (*)(struct drm_connector *)'/>
<offset>0</offset>
<doc f='linux-4.14.y/include/drm/drm_modeset_helper_vtables.h' l='783'>/**
	 * @get_modes:
	 *
	 * This function should fill in all modes currently valid for the sink
	 * into the &amp;drm_connector.probed_modes list. It should also update the
	 * EDID property by calling drm_mode_connector_update_edid_property().
	 *
	 * The usual way to implement this is to cache the EDID retrieved in the
	 * probe callback somewhere in the driver-private connector structure.
	 * In this function drivers then parse the modes in the EDID and add
	 * them by calling drm_add_edid_modes(). But connectors that driver a
	 * fixed panel can also manually add specific modes using
	 * drm_mode_probed_add(). Drivers which manually add modes should also
	 * make sure that the &amp;drm_connector.display_info,
	 * &amp;drm_connector.width_mm and &amp;drm_connector.height_mm fields are
	 * filled in.
	 *
	 * Virtual drivers that just want some standard VESA mode with a given
	 * resolution can call drm_add_modes_noedid(), and mark the preferred
	 * one using drm_set_preferred_mode().
	 *
	 * Finally drivers that support audio probably want to update the ELD
	 * data, too, using drm_edid_to_eld().
	 *
	 * This function is only called after the @detect hook has indicated
	 * that a sink is connected and when the EDID isn&apos;t overridden through
	 * sysfs or the kernel commandline.
	 *
	 * This callback is used by the probe helpers in e.g.
	 * drm_helper_probe_single_connector_modes().
	 *
	 * To avoid races with concurrent connector state updates, the helper
	 * libraries always call this with the &amp;drm_mode_config.connection_mutex
	 * held. Because of this it&apos;s safe to inspect &amp;drm_connector-&gt;state.
	 *
	 * RETURNS:
	 *
	 * The number of modes added by calling drm_mode_probed_add().
	 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/bochs/bochs_kms.c' l='221' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/bridge/panel.c' l='49' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/cirrus/cirrus_mode.c' l='477' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_probe_helper.c' l='500' u='r' c='drm_helper_probe_single_connector_modes'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_display.c' l='1082' u='w'/>
<use f='linux-4.14.y/drivers/gpu/drm/virtio/virtgpu_display.c' l='227' u='w'/>
