<dec f='linux-4.18.y/include/linux/clk.h' l='316' type='struct clk * devm_clk_get(struct device * dev, const char * id)'/>
<doc f='linux-4.18.y/include/linux/clk.h' l='298'>/**
 * devm_clk_get - lookup and obtain a managed reference to a clock producer.
 * @dev: device for clock &quot;consumer&quot;
 * @id: clock consumer ID
 *
 * Returns a struct clk corresponding to the clock producer, or
 * valid IS_ERR() condition containing errno.  The implementation
 * uses @dev and @id to determine the clock consumer, and thereby
 * the clock producer.  (IOW, @id may be identical strings, but
 * clk_get may return different clock producers depending on @dev.)
 *
 * Drivers must assume that the clock source is not enabled.
 *
 * devm_clk_get should not be called from within interrupt context.
 *
 * The clock will automatically be freed when the device is unbound
 * from the bus.
 */</doc>
<def f='linux-4.18.y/drivers/clk/clk-devres.c' l='17' ll='34' type='struct clk * devm_clk_get(struct device * dev, const char * id)'/>
<dec f='linux-4.18.y/drivers/clk/clk-devres.c' l='35' type='struct clk * devm_clk_get(struct device * , const char * )'/>
<use f='linux-4.18.y/drivers/clk/clk-devres.c' l='35' c='devm_clk_get'/>
<use f='linux-4.18.y/drivers/clk/clk-devres.c' l='35' u='a'/>
<use f='linux-4.18.y/drivers/clk/clk-devres.c' l='35' u='a'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/bdc/bdc_core.c' l='494' u='c' c='bdc_probe'/>
<use f='linux-4.18.y/drivers/usb/host/xhci-plat.c' l='233' u='c' c='xhci_plat_probe'/>
<use f='linux-4.18.y/drivers/usb/host/xhci-plat.c' l='243' u='c' c='xhci_plat_probe'/>
