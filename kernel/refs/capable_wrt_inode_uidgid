<dec f='linux-4.14.y/include/linux/capability.h' l='245' type='bool capable_wrt_inode_uidgid(const struct inode * inode, int cap)'/>
<use f='linux-4.14.y/fs/attr.c' l='58' u='c' c='setattr_prepare'/>
<use f='linux-4.14.y/fs/attr.c' l='65' u='c' c='setattr_prepare'/>
<use f='linux-4.14.y/fs/attr.c' l='75' u='c' c='setattr_prepare'/>
<use f='linux-4.14.y/fs/attr.c' l='178' u='c' c='setattr_copy'/>
<use f='linux-4.14.y/fs/inode.c' l='2015' u='c' c='inode_init_owner'/>
<use f='linux-4.14.y/fs/namei.c' l='346' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='349' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='359' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='367' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='2752' u='c' c='__check_sticky'/>
<use f='linux-4.14.y/fs/posix_acl.c' l='655' u='c' c='posix_acl_update_mode'/>
<def f='linux-4.14.y/kernel/capability.c' l='483' ll='488' type='bool capable_wrt_inode_uidgid(const struct inode * inode, int cap)'/>
<dec f='linux-4.14.y/kernel/capability.c' l='489' type='bool capable_wrt_inode_uidgid(const struct inode * , int )'/>
<use f='linux-4.14.y/kernel/capability.c' l='489' c='capable_wrt_inode_uidgid'/>
<use f='linux-4.14.y/kernel/capability.c' l='489' u='a'/>
<use f='linux-4.14.y/kernel/capability.c' l='489' u='a'/>
<doc f='linux-4.14.y/kernel/capability.c' l='474'>/**
 * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped
 * @inode: The inode in question
 * @cap: The capability in question
 *
 * Return true if the current task has the given capability targeted at
 * its own user namespace and that the given inode&apos;s uid and gid are
 * mapped into the current user namespace.
 */</doc>
<use f='linux-4.14.y/security/commoncap.c' l='499' u='c' c='cap_convert_nscap'/>
<use f='linux-4.14.y/security/commoncap.c' l='899' u='c' c='cap_inode_removexattr'/>
<dec f='linux-4.14.y/include/linux/capability.h' l='245' type='bool capable_wrt_inode_uidgid(const struct inode * inode, int cap)'/>
<use f='linux-4.14.y/fs/attr.c' l='58' u='c' c='setattr_prepare'/>
<use f='linux-4.14.y/fs/attr.c' l='65' u='c' c='setattr_prepare'/>
<use f='linux-4.14.y/fs/attr.c' l='75' u='c' c='setattr_prepare'/>
<use f='linux-4.14.y/fs/attr.c' l='178' u='c' c='setattr_copy'/>
<use f='linux-4.14.y/fs/inode.c' l='2015' u='c' c='inode_init_owner'/>
<use f='linux-4.14.y/fs/namei.c' l='346' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='349' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='359' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='367' u='c' c='generic_permission'/>
<use f='linux-4.14.y/fs/namei.c' l='2752' u='c' c='__check_sticky'/>
<use f='linux-4.14.y/fs/overlayfs/super.c' l='743' u='c' c='ovl_posix_acl_xattr_set'/>
<use f='linux-4.14.y/fs/posix_acl.c' l='655' u='c' c='posix_acl_update_mode'/>
<def f='linux-4.14.y/kernel/capability.c' l='483' ll='488' type='bool capable_wrt_inode_uidgid(const struct inode * inode, int cap)'/>
<dec f='linux-4.14.y/kernel/capability.c' l='489' type='bool capable_wrt_inode_uidgid(const struct inode * , int )'/>
<use f='linux-4.14.y/kernel/capability.c' l='489' c='capable_wrt_inode_uidgid'/>
<use f='linux-4.14.y/kernel/capability.c' l='489' u='a'/>
<use f='linux-4.14.y/kernel/capability.c' l='489' u='a'/>
<doc f='linux-4.14.y/kernel/capability.c' l='474'>/**
 * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped
 * @inode: The inode in question
 * @cap: The capability in question
 *
 * Return true if the current task has the given capability targeted at
 * its own user namespace and that the given inode&apos;s uid and gid are
 * mapped into the current user namespace.
 */</doc>
<use f='linux-4.14.y/security/commoncap.c' l='499' u='c' c='cap_convert_nscap'/>
<use f='linux-4.14.y/security/commoncap.c' l='899' u='c' c='cap_inode_removexattr'/>
