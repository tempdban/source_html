<dec f='linux-4.18.y/include/linux/capability.h' l='245' type='bool capable_wrt_inode_uidgid(const struct inode * inode, int cap)'/>
<use f='linux-4.18.y/fs/attr.c' l='26' u='c' c='chown_ok'/>
<use f='linux-4.18.y/fs/attr.c' l='39' u='c' c='chgrp_ok'/>
<use f='linux-4.18.y/fs/attr.c' l='95' u='c' c='setattr_prepare'/>
<use f='linux-4.18.y/fs/attr.c' l='198' u='c' c='setattr_copy'/>
<use f='linux-4.18.y/fs/inode.c' l='2008' u='c' c='inode_init_owner'/>
<use f='linux-4.18.y/fs/namei.c' l='348' u='c' c='generic_permission'/>
<use f='linux-4.18.y/fs/namei.c' l='351' u='c' c='generic_permission'/>
<use f='linux-4.18.y/fs/namei.c' l='361' u='c' c='generic_permission'/>
<use f='linux-4.18.y/fs/namei.c' l='369' u='c' c='generic_permission'/>
<use f='linux-4.18.y/fs/namei.c' l='2747' u='c' c='__check_sticky'/>
<use f='linux-4.18.y/fs/overlayfs/super.c' l='866' u='c' c='ovl_posix_acl_xattr_set'/>
<use f='linux-4.18.y/fs/posix_acl.c' l='655' u='c' c='posix_acl_update_mode'/>
<def f='linux-4.18.y/kernel/capability.c' l='483' ll='488' type='bool capable_wrt_inode_uidgid(const struct inode * inode, int cap)'/>
<dec f='linux-4.18.y/kernel/capability.c' l='489' type='bool capable_wrt_inode_uidgid(const struct inode * , int )'/>
<use f='linux-4.18.y/kernel/capability.c' l='489' c='capable_wrt_inode_uidgid'/>
<use f='linux-4.18.y/kernel/capability.c' l='489' u='a'/>
<use f='linux-4.18.y/kernel/capability.c' l='489' u='a'/>
<doc f='linux-4.18.y/kernel/capability.c' l='474'>/**
 * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped
 * @inode: The inode in question
 * @cap: The capability in question
 *
 * Return true if the current task has the given capability targeted at
 * its own user namespace and that the given inode&apos;s uid and gid are
 * mapped into the current user namespace.
 */</doc>
<use f='linux-4.18.y/security/commoncap.c' l='499' u='c' c='cap_convert_nscap'/>
<use f='linux-4.18.y/security/commoncap.c' l='966' u='c' c='cap_inode_removexattr'/>
