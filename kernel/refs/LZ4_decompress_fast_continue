<dec f='linux-4.14.y/include/linux/lz4.h' l='599' type='int LZ4_decompress_fast_continue(LZ4_streamDecode_t * LZ4_streamDecode, const char * source, char * dest, int originalSize)'/>
<doc f='linux-4.14.y/include/linux/lz4.h' l='564'>/**
 * LZ4_decompress_fast_continue() - Decompress blocks in streaming mode
 * @LZ4_streamDecode: the &apos;LZ4_streamDecode_t&apos; structure
 * @source: source address of the compressed data
 * @dest: output buffer address of the uncompressed data
 *	which must be already allocated with &apos;originalSize&apos; bytes
 * @originalSize: is the original and therefore uncompressed size
 *
 * These decoding function allows decompression of multiple blocks
 * in &quot;streaming&quot; mode.
 * Previously decoded blocks *must* remain available at the memory position
 * where they were decoded (up to 64 KB)
 * In the case of a ring buffers, decoding buffer must be either :
 *    - Exactly same size as encoding buffer, with same update rule
 *      (block boundaries at same positions) In which case,
 *      the decoding &amp; encoding ring buffer can have any size,
 *      including very small ones ( &lt; 64 KB).
 *    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes.
 *      maxBlockSize is implementation dependent.
 *      It&apos;s the maximum size you intend to compress into a single block.
 *      In which case, encoding and decoding buffers do not need
 *      to be synchronized, and encoding ring buffer can have any size,
 *      including small ones ( &lt; 64 KB).
 *    - _At least_ 64 KB + 8 bytes + maxBlockSize.
 *      In which case, encoding and decoding buffers do not need to be
 *      synchronized, and encoding ring buffer can have any size,
 *      including larger than decoding buffer. W
 * Whenever these conditions are not possible, save the last 64KB of decoded
 * data into a safe buffer, and indicate where it is saved
 * using LZ4_setStreamDecode()
 *
 * Return: number of bytes decompressed into destination buffer
 *	(necessarily &lt;= maxDecompressedSize)
 *	or a negative result in case of error
 */</doc>
<def f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='419' ll='451' type='int LZ4_decompress_fast_continue(LZ4_streamDecode_t * LZ4_streamDecode, const char * source, char * dest, int originalSize)'/>
<dec f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' type='int LZ4_decompress_fast_continue(LZ4_streamDecode_t * , const char * , char * , int )'/>
<use f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' c='LZ4_decompress_fast_continue'/>
<use f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' u='a'/>
<use f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' u='a'/>
<dec f='linux-4.14.y/include/linux/lz4.h' l='599' type='int LZ4_decompress_fast_continue(LZ4_streamDecode_t * LZ4_streamDecode, const char * source, char * dest, int originalSize)'/>
<doc f='linux-4.14.y/include/linux/lz4.h' l='564'>/**
 * LZ4_decompress_fast_continue() - Decompress blocks in streaming mode
 * @LZ4_streamDecode: the &apos;LZ4_streamDecode_t&apos; structure
 * @source: source address of the compressed data
 * @dest: output buffer address of the uncompressed data
 *	which must be already allocated with &apos;originalSize&apos; bytes
 * @originalSize: is the original and therefore uncompressed size
 *
 * These decoding function allows decompression of multiple blocks
 * in &quot;streaming&quot; mode.
 * Previously decoded blocks *must* remain available at the memory position
 * where they were decoded (up to 64 KB)
 * In the case of a ring buffers, decoding buffer must be either :
 *    - Exactly same size as encoding buffer, with same update rule
 *      (block boundaries at same positions) In which case,
 *      the decoding &amp; encoding ring buffer can have any size,
 *      including very small ones ( &lt; 64 KB).
 *    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes.
 *      maxBlockSize is implementation dependent.
 *      It&apos;s the maximum size you intend to compress into a single block.
 *      In which case, encoding and decoding buffers do not need
 *      to be synchronized, and encoding ring buffer can have any size,
 *      including small ones ( &lt; 64 KB).
 *    - _At least_ 64 KB + 8 bytes + maxBlockSize.
 *      In which case, encoding and decoding buffers do not need to be
 *      synchronized, and encoding ring buffer can have any size,
 *      including larger than decoding buffer. W
 * Whenever these conditions are not possible, save the last 64KB of decoded
 * data into a safe buffer, and indicate where it is saved
 * using LZ4_setStreamDecode()
 *
 * Return: number of bytes decompressed into destination buffer
 *	(necessarily &lt;= maxDecompressedSize)
 *	or a negative result in case of error
 */</doc>
<def f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='419' ll='451' type='int LZ4_decompress_fast_continue(LZ4_streamDecode_t * LZ4_streamDecode, const char * source, char * dest, int originalSize)'/>
<dec f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' type='int LZ4_decompress_fast_continue(LZ4_streamDecode_t * , const char * , char * , int )'/>
<use f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' c='LZ4_decompress_fast_continue'/>
<use f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' u='a'/>
<use f='linux-4.14.y/lib/lz4/lz4_decompress.c' l='502' u='a'/>
