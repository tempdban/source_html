<dec f='linux-4.18.y/include/linux/mm.h' l='2367' type='vm_fault_t filemap_fault(struct vm_fault * vmf)'/>
<doc f='linux-4.18.y/include/linux/mm.h' l='2366'>/* generic vm_area_ops exported for stackable file systems */</doc>
<use f='linux-4.18.y/fs/aio.c' l='345'/>
<use f='linux-4.18.y/fs/aio.c' l='345'/>
<use f='linux-4.18.y/fs/ext4/inode.c' l='6218' u='c' c='ext4_filemap_fault'/>
<use f='linux-4.18.y/fs/f2fs/file.c' l='42' u='c' c='f2fs_filemap_fault'/>
<use f='linux-4.18.y/fs/fuse/file.c' l='2070'/>
<use f='linux-4.18.y/fs/fuse/file.c' l='2070'/>
<def f='linux-4.18.y/mm/filemap.c' l='2492' ll='2610' type='vm_fault_t filemap_fault(struct vm_fault * vmf)'/>
<dec f='linux-4.18.y/mm/filemap.c' l='2611' type='vm_fault_t filemap_fault(struct vm_fault * )'/>
<use f='linux-4.18.y/mm/filemap.c' l='2611' c='filemap_fault'/>
<use f='linux-4.18.y/mm/filemap.c' l='2611' u='a'/>
<use f='linux-4.18.y/mm/filemap.c' l='2611' u='a'/>
<use f='linux-4.18.y/mm/filemap.c' l='2723'/>
<use f='linux-4.18.y/mm/filemap.c' l='2723'/>
<doc f='linux-4.18.y/mm/filemap.c' l='2469'>/**
 * filemap_fault - read in file data for page fault handling
 * @vmf:	struct vm_fault containing details of the fault
 *
 * filemap_fault() is invoked via the vma operations vector for a
 * mapped memory region to read in file data during a page fault.
 *
 * The goto&apos;s are kind of ugly, but this streamlines the normal case of having
 * it in the page cache, and handles the special cases reasonably without
 * having a lot of duplicated code.
 *
 * vma-&gt;vm_mm-&gt;mmap_sem must be held on entry.
 *
 * If our return value has VM_FAULT_RETRY set, it&apos;s because
 * lock_page_or_retry() returned 0.
 * The mmap_sem has usually been released in this case.
 * See __lock_page_or_retry() for the exception.
 *
 * If our return value does not have VM_FAULT_RETRY set, the mmap_sem
 * has not been released.
 *
 * We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.
 */</doc>
