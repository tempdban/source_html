<def f='linux-4.18.y/include/media/rc-core.h' l='170' ll='237'/>
<size>984</size>
<doc f='linux-4.18.y/include/media/rc-core.h' l='91'>/**
 * struct rc_dev - represents a remote control device
 * @dev: driver model&apos;s view of this device
 * @managed_alloc: devm_rc_allocate_device was used to create rc_dev
 * @sysfs_groups: sysfs attribute groups
 * @device_name: name of the rc child device
 * @input_phys: physical path to the input child device
 * @input_id: id of the input child device (struct input_id)
 * @driver_name: name of the hardware driver which registered this device
 * @map_name: name of the default keymap
 * @rc_map: current scan/key table
 * @lock: used to ensure we&apos;ve filled in all protocol details before
 *	anyone can call show_protocols or store_protocols
 * @minor: unique minor remote control device number
 * @raw: additional data for raw pulse/space devices
 * @input_dev: the input child device used to communicate events to userspace
 * @driver_type: specifies if protocol decoding is done in hardware or software
 * @idle: used to keep track of RX state
 * @encode_wakeup: wakeup filtering uses IR encode API, therefore the allowed
 *	wakeup protocols is the set of all raw encoders
 * @allowed_protocols: bitmask with the supported RC_PROTO_BIT_* protocols
 * @enabled_protocols: bitmask with the enabled RC_PROTO_BIT_* protocols
 * @allowed_wakeup_protocols: bitmask with the supported RC_PROTO_BIT_* wakeup
 *	protocols
 * @wakeup_protocol: the enabled RC_PROTO_* wakeup protocol or
 *	RC_PROTO_UNKNOWN if disabled.
 * @scancode_filter: scancode filter
 * @scancode_wakeup_filter: scancode wakeup filters
 * @scancode_mask: some hardware decoders are not capable of providing the full
 *	scancode to the application. As this is a hardware limit, we can&apos;t do
 *	anything with it. Yet, as the same keycode table can be used with other
 *	devices, a mask is provided to allow its usage. Drivers should generally
 *	leave this field in blank
 * @users: number of current users of the device
 * @priv: driver-specific data
 * @keylock: protects the remaining members of the struct
 * @keypressed: whether a key is currently pressed
 * @keyup_jiffies: time (in jiffies) when the current keypress should be released
 * @timer_keyup: timer for releasing a keypress
 * @timer_repeat: timer for autorepeat events. This is needed for CEC, which
 *	has non-standard repeats.
 * @last_keycode: keycode of last keypress
 * @last_protocol: protocol of last keypress
 * @last_scancode: scancode of last keypress
 * @last_toggle: toggle value of last command
 * @timeout: optional time after which device stops sending data
 * @min_timeout: minimum timeout supported by device
 * @max_timeout: maximum timeout supported by device
 * @rx_resolution : resolution (in ns) of input sampler
 * @tx_resolution: resolution (in ns) of output sampler
 * @lirc_dev: lirc device
 * @lirc_cdev: lirc char cdev
 * @gap_start: time when gap starts
 * @gap_duration: duration of initial gap
 * @gap: true if we&apos;re in a gap
 * @lirc_fh_lock: protects lirc_fh list
 * @lirc_fh: list of open files
 * @registered: set to true by rc_register_device(), false by
 *	rc_unregister_device
 * @change_protocol: allow changing the protocol used on hardware decoders
 * @open: callback to allow drivers to enable polling/irq when IR input device
 *	is opened.
 * @close: callback to allow drivers to disable polling/irq when IR input device
 *	is opened.
 * @s_tx_mask: set transmitter mask (for devices with multiple tx outputs)
 * @s_tx_carrier: set transmit carrier frequency
 * @s_tx_duty_cycle: set transmit duty cycle (0% - 100%)
 * @s_rx_carrier_range: inform driver about carrier it is expected to handle
 * @tx_ir: transmit IR
 * @s_idle: enable/disable hardware idle mode, upon which,
 *	device doesn&apos;t interrupt host until it sees IR pulses
 * @s_learning_mode: enable wide band receiver used for learning
 * @s_carrier_report: enable carrier reports
 * @s_filter: set the scancode filter
 * @s_wakeup_filter: set the wakeup scancode filter. If the mask is zero
 *	then wakeup should be disabled. wakeup_protocol will be set to
 *	a valid protocol if mask is nonzero.
 * @s_timeout: set hardware timeout in ns
 */</doc>
<mbr r='rc_dev::dev' o='0' t='struct device'/>
<mbr r='rc_dev::managed_alloc' o='3840' t='bool'/>
<mbr r='rc_dev::sysfs_groups' o='3904' t='const struct attribute_group *[5]'/>
<mbr r='rc_dev::device_name' o='4224' t='const char *'/>
<mbr r='rc_dev::input_phys' o='4288' t='const char *'/>
<mbr r='rc_dev::input_id' o='4352' t='struct input_id'/>
<mbr r='rc_dev::driver_name' o='4416' t='const char *'/>
<mbr r='rc_dev::map_name' o='4480' t='const char *'/>
<mbr r='rc_dev::rc_map' o='4544' t='struct rc_map'/>
<mbr r='rc_dev::lock' o='4864' t='struct mutex'/>
<mbr r='rc_dev::minor' o='5120' t='unsigned int'/>
<mbr r='rc_dev::raw' o='5184' t='struct ir_raw_event_ctrl *'/>
<mbr r='rc_dev::input_dev' o='5248' t='struct input_dev *'/>
<mbr r='rc_dev::driver_type' o='5312' t='enum rc_driver_type'/>
<mbr r='rc_dev::idle' o='5344' t='bool'/>
<mbr r='rc_dev::encode_wakeup' o='5352' t='bool'/>
<mbr r='rc_dev::allowed_protocols' o='5376' t='u64'/>
<mbr r='rc_dev::enabled_protocols' o='5440' t='u64'/>
<mbr r='rc_dev::allowed_wakeup_protocols' o='5504' t='u64'/>
<mbr r='rc_dev::wakeup_protocol' o='5568' t='enum rc_proto'/>
<mbr r='rc_dev::scancode_filter' o='5600' t='struct rc_scancode_filter'/>
<mbr r='rc_dev::scancode_wakeup_filter' o='5664' t='struct rc_scancode_filter'/>
<mbr r='rc_dev::scancode_mask' o='5728' t='u32'/>
<mbr r='rc_dev::users' o='5760' t='u32'/>
<mbr r='rc_dev::priv' o='5824' t='void *'/>
<mbr r='rc_dev::keylock' o='5888' t='spinlock_t'/>
<mbr r='rc_dev::keypressed' o='5920' t='bool'/>
<mbr r='rc_dev::keyup_jiffies' o='5952' t='unsigned long'/>
<mbr r='rc_dev::timer_keyup' o='6016' t='struct timer_list'/>
<mbr r='rc_dev::timer_repeat' o='6336' t='struct timer_list'/>
<mbr r='rc_dev::last_keycode' o='6656' t='u32'/>
<mbr r='rc_dev::last_protocol' o='6688' t='enum rc_proto'/>
<mbr r='rc_dev::last_scancode' o='6720' t='u32'/>
<mbr r='rc_dev::last_toggle' o='6752' t='u8'/>
<mbr r='rc_dev::timeout' o='6784' t='u32'/>
<mbr r='rc_dev::min_timeout' o='6816' t='u32'/>
<mbr r='rc_dev::max_timeout' o='6848' t='u32'/>
<mbr r='rc_dev::rx_resolution' o='6880' t='u32'/>
<mbr r='rc_dev::tx_resolution' o='6912' t='u32'/>
<mbr r='rc_dev::registered' o='6944' t='bool'/>
<mbr r='rc_dev::change_protocol' o='6976' t='int (*)(struct rc_dev *, u64 *)'/>
<mbr r='rc_dev::open' o='7040' t='int (*)(struct rc_dev *)'/>
<mbr r='rc_dev::close' o='7104' t='void (*)(struct rc_dev *)'/>
<mbr r='rc_dev::s_tx_mask' o='7168' t='int (*)(struct rc_dev *, u32)'/>
<mbr r='rc_dev::s_tx_carrier' o='7232' t='int (*)(struct rc_dev *, u32)'/>
<mbr r='rc_dev::s_tx_duty_cycle' o='7296' t='int (*)(struct rc_dev *, u32)'/>
<mbr r='rc_dev::s_rx_carrier_range' o='7360' t='int (*)(struct rc_dev *, u32, u32)'/>
<mbr r='rc_dev::tx_ir' o='7424' t='int (*)(struct rc_dev *, unsigned int *, unsigned int)'/>
<mbr r='rc_dev::s_idle' o='7488' t='void (*)(struct rc_dev *, bool)'/>
<mbr r='rc_dev::s_learning_mode' o='7552' t='int (*)(struct rc_dev *, int)'/>
<mbr r='rc_dev::s_carrier_report' o='7616' t='int (*)(struct rc_dev *, int)'/>
<mbr r='rc_dev::s_filter' o='7680' t='int (*)(struct rc_dev *, struct rc_scancode_filter *)'/>
<mbr r='rc_dev::s_wakeup_filter' o='7744' t='int (*)(struct rc_dev *, struct rc_scancode_filter *)'/>
<mbr r='rc_dev::s_timeout' o='7808' t='int (*)(struct rc_dev *, unsigned int)'/>
