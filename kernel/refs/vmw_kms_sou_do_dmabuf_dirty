<dec f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h' l='411' type='int vmw_kms_sou_do_dmabuf_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, unsigned int num_clips, int increment, bool interruptible, struct vmw_fence_obj ** out_fence, struct drm_crtc * crtc)'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1095' u='c' c='vmw_framebuffer_dmabuf_dirty'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='516' u='c' c='vmw_sou_primary_plane_atomic_update'/>
<def f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='1035' ll='1074' type='int vmw_kms_sou_do_dmabuf_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, unsigned int num_clips, int increment, bool interruptible, struct vmw_fence_obj ** out_fence, struct drm_crtc * crtc)'/>
<doc f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='1016'>/**
 * vmw_kms_do_dmabuf_dirty - Dirty part of a dma-buffer backed framebuffer
 *
 * @dev_priv: Pointer to the device private structure.
 * @framebuffer: Pointer to the dma-buffer backed framebuffer.
 * @clips: Array of clip rects.
 * @vclips: Alternate array of clip rects. Either @clips or @vclips must
 * be NULL.
 * @num_clips: Number of clip rects in @clips.
 * @increment: Increment to use when looping over @clips.
 * @interruptible: Whether to perform waits interruptible if possible.
 * @out_fence: If non-NULL, will return a ref-counted pointer to a
 * struct vmw_fence_obj. The returned fence pointer may be NULL in which
 * case the device has already synchronized.
 * @crtc: If crtc is passed, perform dmabuf dirty on that crtc only.
 *
 * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
 * interrupted.
 */</doc>
