<dec f='linux-4.14.y/include/linux/mm.h' l='1332' type='int fixup_user_fault(struct task_struct * tsk, struct mm_struct * mm, unsigned long address, unsigned int fault_flags, bool * unlocked)'/>
<use f='linux-4.14.y/kernel/futex.c' l='730' u='c' c='fault_in_user_writeable'/>
<def f='linux-4.14.y/mm/gup.c' l='800' ll='845' type='int fixup_user_fault(struct task_struct * tsk, struct mm_struct * mm, unsigned long address, unsigned int fault_flags, bool * unlocked)'/>
<dec f='linux-4.14.y/mm/gup.c' l='846' type='int fixup_user_fault(struct task_struct * , struct mm_struct * , unsigned long , unsigned int , bool * )'/>
<use f='linux-4.14.y/mm/gup.c' l='846' c='fixup_user_fault'/>
<use f='linux-4.14.y/mm/gup.c' l='846' u='a'/>
<use f='linux-4.14.y/mm/gup.c' l='846' u='a'/>
<doc f='linux-4.14.y/mm/gup.c' l='770'>/*
 * fixup_user_fault() - manually resolve a user page fault
 * @tsk:	the task_struct to use for page fault accounting, or
 *		NULL if faults are not to be recorded.
 * @mm:		mm_struct of target mm
 * @address:	user address
 * @fault_flags:flags to pass down to handle_mm_fault()
 * @unlocked:	did we unlock the mmap_sem while retrying, maybe NULL if caller
 *		does not allow retry
 *
 * This is meant to be called in the specific scenario where for locking reasons
 * we try to access user memory in atomic context (within a pagefault_disable()
 * section), this returns -EFAULT, and we want to resolve the user fault before
 * trying again.
 *
 * Typically this is meant to be used by the futex code.
 *
 * The main difference with get_user_pages() is that this function will
 * unconditionally call handle_mm_fault() which will in turn perform all the
 * necessary SW fixup of the dirty and young bits in the PTE, while
 * get_user_pages() only guarantees to update these in the struct page.
 *
 * This is important for some architectures where those bits also gate the
 * access permission to the page because they are maintained in software.  On
 * such architectures, gup() will not be enough to make a subsequent access
 * succeed.
 *
 * This function will not return with an unlocked mmap_sem. So it has not the
 * same semantics wrt the @mm-&gt;mmap_sem as does filemap_fault().
 */</doc>
<use f='linux-4.14.y/virt/kvm/kvm_main.c' l='1450' u='c' c='hva_to_pfn_remapped'/>
