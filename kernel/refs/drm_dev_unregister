<dec f='linux-4.18.y/include/drm/drm_drv.h' l='621' type='void drm_dev_unregister(struct drm_device * dev)'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='317' u='c' c='drm_put_dev'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='381' u='c' c='drm_dev_unplug'/>
<def f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='852' ll='876' type='void drm_dev_unregister(struct drm_device * dev)'/>
<dec f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='877' type='void drm_dev_unregister(struct drm_device * )'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='877' c='drm_dev_unregister'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='877' u='a'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='877' u='a'/>
<doc f='linux-4.18.y/drivers/gpu/drm/drm_drv.c' l='838'>/**
 * drm_dev_unregister - Unregister DRM device
 * @dev: Device to unregister
 *
 * Unregister the DRM device from the system. This does the reverse of
 * drm_dev_register() but does not deallocate the device. The caller must call
 * drm_dev_put() to drop their final reference.
 *
 * A special form of unregistering for hotpluggable devices is drm_dev_unplug(),
 * which can be called while there are still open users of @dev.
 *
 * This should be called first in the device teardown code to make sure
 * userspace can&apos;t access the device instance any more.
 */</doc>
<use f='linux-4.18.y/drivers/gpu/drm/qxl/qxl_drv.c' l='115' u='c' c='qxl_pci_remove'/>
