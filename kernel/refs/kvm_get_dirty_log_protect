<dec f='linux-4.18.y/include/linux/kvm_host.h' l='750' type='int kvm_get_dirty_log_protect(struct kvm * kvm, struct kvm_dirty_log * log, bool * is_dirty)'/>
<use f='linux-4.18.y/arch/x86/kvm/x86.c' l='4206' u='c' c='kvm_vm_ioctl_get_dirty_log'/>
<def f='linux-4.18.y/virt/kvm/kvm_main.c' l='1148' ll='1200' type='int kvm_get_dirty_log_protect(struct kvm * kvm, struct kvm_dirty_log * log, bool * is_dirty)'/>
<dec f='linux-4.18.y/virt/kvm/kvm_main.c' l='1201' type='int kvm_get_dirty_log_protect(struct kvm * , struct kvm_dirty_log * , bool * )'/>
<use f='linux-4.18.y/virt/kvm/kvm_main.c' l='1201' c='kvm_get_dirty_log_protect'/>
<use f='linux-4.18.y/virt/kvm/kvm_main.c' l='1201' u='a'/>
<use f='linux-4.18.y/virt/kvm/kvm_main.c' l='1201' u='a'/>
<doc f='linux-4.18.y/virt/kvm/kvm_main.c' l='1126'>/**
 * kvm_get_dirty_log_protect - get a snapshot of dirty pages, and if any pages
 *	are dirty write protect them for next write.
 * @kvm:	pointer to kvm instance
 * @log:	slot id and address to which we copy the log
 * @is_dirty:	flag set if any page is dirty
 *
 * We need to keep it in mind that VCPU threads can write to the bitmap
 * concurrently. So, to avoid losing track of dirty pages we keep the
 * following order:
 *
 *    1. Take a snapshot of the bit and clear it if needed.
 *    2. Write protect the corresponding page.
 *    3. Copy the snapshot to the userspace.
 *    4. Upon return caller flushes TLB&apos;s if needed.
 *
 * Between 2 and 4, the guest may write to the page using the remaining TLB
 * entry.  This is not a problem because the page is reported dirty using
 * the snapshot taken before and step 4 ensures that writes done after
 * exiting to userspace will be logged for the next call.
 *
 */</doc>
