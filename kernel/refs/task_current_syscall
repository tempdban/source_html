<dec f='linux-4.18.y/include/linux/ptrace.h' l='407' type='int task_current_syscall(struct task_struct * target, long * callno, unsigned long * args, unsigned int maxargs, unsigned long * sp, unsigned long * pc)'/>
<use f='linux-4.18.y/fs/proc/base.c' l='607' u='c' c='proc_pid_syscall'/>
<def f='linux-4.18.y/lib/syscall.c' l='64' ll='88' type='int task_current_syscall(struct task_struct * target, long * callno, unsigned long * args, unsigned int maxargs, unsigned long * sp, unsigned long * pc)'/>
<doc f='linux-4.18.y/lib/syscall.c' l='38'>/**
 * task_current_syscall - Discover what a blocked task is doing.
 * @target:		thread to examine
 * @callno:		filled with system call number or -1
 * @args:		filled with @maxargs system call arguments
 * @maxargs:		number of elements in @args to fill
 * @sp:			filled with user stack pointer
 * @pc:			filled with user PC
 *
 * If @target is blocked in a system call, returns zero with *@callno
 * set to the the call&apos;s number and @args filled in with its arguments.
 * Registers not used for system call arguments may not be available and
 * it is not kosher to use &amp;struct user_regset calls while the system
 * call is still in progress.  Note we may get this result if @target
 * has finished its system call but not yet returned to user mode, such
 * as when it&apos;s stopped for signal handling or syscall exit tracing.
 *
 * If @target is blocked in the kernel during a fault or exception,
 * returns zero with *@callno set to -1 and does not fill in @args.
 * If so, it&apos;s now safe to examine @target using &amp;struct user_regset
 * get() calls as long as we&apos;re sure @target won&apos;t return to user mode.
 *
 * Returns -%EAGAIN if @target does not remain blocked.
 *
 * Returns -%EINVAL if @maxargs is too large (maximum is six).
 */</doc>
