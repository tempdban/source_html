<dec f='linux-4.18.y/include/linux/iomap.h' l='114' type='ssize_t iomap_dio_rw(struct kiocb * iocb, struct iov_iter * iter, const struct iomap_ops * ops, iomap_dio_end_io_t * end_io)'/>
<def f='linux-4.18.y/fs/iomap.c' l='1105' ll='1251' type='ssize_t iomap_dio_rw(struct kiocb * iocb, struct iov_iter * iter, const struct iomap_ops * ops, iomap_dio_end_io_t * end_io)'/>
<dec f='linux-4.18.y/fs/iomap.c' l='1252' type='ssize_t iomap_dio_rw(struct kiocb * , struct iov_iter * , const struct iomap_ops * , iomap_dio_end_io_t * )'/>
<use f='linux-4.18.y/fs/iomap.c' l='1252' c='iomap_dio_rw'/>
<use f='linux-4.18.y/fs/iomap.c' l='1252' u='a'/>
<use f='linux-4.18.y/fs/iomap.c' l='1252' u='a'/>
<doc f='linux-4.18.y/fs/iomap.c' l='1096'>/*
 * iomap_dio_rw() always completes O_[D]SYNC writes regardless of whether the IO
 * is being issued as AIO or not.  This allows us to optimise pure data writes
 * to use REQ_FUA rather than requiring generic_write_sync() to issue a
 * REQ_FLUSH post write. This is slightly tricky because a single request here
 * can be mapped into multiple disjoint IOs and only a subset of the IOs issued
 * may be pure data writes. In that case, we still need to do a full data sync
 * completion.
 */</doc>
