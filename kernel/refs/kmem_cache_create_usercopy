<dec f='linux-4.18.y/include/linux/slab.h' l='143' type='struct kmem_cache * kmem_cache_create_usercopy(const char * name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*)(void *) ctor)'/>
<use f='linux-4.18.y/drivers/scsi/scsi_lib.c' l='88' u='c' c='scsi_init_sense_cache'/>
<use f='linux-4.18.y/fs/dcache.c' l='3145' macro='1' u='c'/>
<use f='linux-4.18.y/fs/dcache.c' l='3183' u='c' c='vfs_caches_init'/>
<use f='linux-4.18.y/fs/ext4/super.c' l='1079' u='c' c='init_inodecache'/>
<use f='linux-4.18.y/fs/proc/inode.c' l='107' u='c' c='proc_init_kmemcache'/>
<use f='linux-4.18.y/kernel/fork.c' l='749' u='c' c='fork_init'/>
<use f='linux-4.18.y/kernel/fork.c' l='2303' u='c' c='proc_caches_init'/>
<use f='linux-4.18.y/kernel/utsname.c' l='177' u='c' c='uts_ns_init'/>
<def f='linux-4.18.y/mm/slab_common.c' l='435' ll='514' type='struct kmem_cache * kmem_cache_create_usercopy(const char * name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*)(void *) ctor)'/>
<dec f='linux-4.18.y/mm/slab_common.c' l='515' type='struct kmem_cache * kmem_cache_create_usercopy(const char * , unsigned int , unsigned int , slab_flags_t , unsigned int , unsigned int , void (*)(void *) )'/>
<use f='linux-4.18.y/mm/slab_common.c' l='515' c='kmem_cache_create_usercopy'/>
<use f='linux-4.18.y/mm/slab_common.c' l='515' u='a'/>
<use f='linux-4.18.y/mm/slab_common.c' l='515' u='a'/>
<use f='linux-4.18.y/mm/slab_common.c' l='521' u='c' c='kmem_cache_create'/>
<doc f='linux-4.18.y/mm/slab_common.c' l='409'>/*
 * kmem_cache_create_usercopy - Create a cache.
 * @name: A string which is used in /proc/slabinfo to identify this cache.
 * @size: The size of objects to be created in this cache.
 * @align: The required alignment for the objects.
 * @flags: SLAB flags
 * @useroffset: Usercopy region offset
 * @usersize: Usercopy region size
 * @ctor: A constructor for the objects.
 *
 * Returns a ptr to the cache on success, NULL on failure.
 * Cannot be called within a interrupt, but can be interrupted.
 * The @ctor is run when new pages are allocated by the cache.
 *
 * The flags are
 *
 * %SLAB_POISON - Poison the slab with a known test pattern (a5a5a5a5)
 * to catch references to uninitialised memory.
 *
 * %SLAB_RED_ZONE - Insert `Red&apos; zones around the allocated memory to check
 * for buffer overruns.
 *
 * %SLAB_HWCACHE_ALIGN - Align the objects in this cache to a hardware
 * cacheline.  This can be beneficial if you&apos;re counting cycles as closely
 * as davem.
 */</doc>
<use f='linux-4.18.y/net/core/skbuff.c' l='3930' u='c' c='skb_init'/>
<use f='linux-4.18.y/net/core/sock.c' l='3260' u='c' c='proto_register'/>
<use f='linux-4.18.y/virt/kvm/kvm_main.c' l='4026' u='c' c='kvm_init'/>
