<dec f='linux-4.18.y/fs/ntfs/runlist.h' l='94' type='int ntfs_rl_truncate_nolock(const ntfs_volume * vol, runlist *const runlist, const s64 new_length)'/>
<use f='linux-4.18.y/fs/ntfs/attrib.c' l='2433' u='c' c='ntfs_attr_extend_allocation'/>
<use f='linux-4.18.y/fs/ntfs/inode.c' l='2707' u='c' c='ntfs_truncate'/>
<use f='linux-4.18.y/fs/ntfs/mft.c' l='1965' u='c' c='ntfs_mft_data_extend_allocation_nolock'/>
<def f='linux-4.18.y/fs/ntfs/runlist.c' l='1499' ll='1621' type='int ntfs_rl_truncate_nolock(const ntfs_volume * vol, runlist *const runlist, const s64 new_length)'/>
<doc f='linux-4.18.y/fs/ntfs/runlist.c' l='1475'>/**
 * ntfs_rl_truncate_nolock - truncate a runlist starting at a specified vcn
 * @vol:	ntfs volume (needed for error output)
 * @runlist:	runlist to truncate
 * @new_length:	the new length of the runlist in VCNs
 *
 * Truncate the runlist described by @runlist as well as the memory buffer
 * holding the runlist elements to a length of @new_length VCNs.
 *
 * If @new_length lies within the runlist, the runlist elements with VCNs of
 * @new_length and above are discarded.  As a special case if @new_length is
 * zero, the runlist is discarded and set to NULL.
 *
 * If @new_length lies beyond the runlist, a sparse runlist element is added to
 * the end of the runlist @runlist or if the last runlist element is a sparse
 * one already, this is extended.
 *
 * Note, no checking is done for unmapped runlist elements.  It is assumed that
 * the caller has mapped any elements that need to be mapped already.
 *
 * Return 0 on success and -errno on error.
 *
 * Locking: The caller must hold @runlist-&gt;lock for writing.
 */</doc>
