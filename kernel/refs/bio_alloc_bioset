<dec f='linux-4.18.y/include/linux/bio.h' l='427' type='struct bio * bio_alloc_bioset(gfp_t , unsigned int , struct bio_set * )'/>
<use f='linux-4.18.y/include/linux/bio.h' l='438' u='c' c='bio_alloc'/>
<use f='linux-4.18.y/include/linux/bio.h' l='443' u='c' c='bio_kmalloc'/>
<def f='linux-4.18.y/block/bio.c' l='436' ll='530' type='struct bio * bio_alloc_bioset(gfp_t gfp_mask, unsigned int nr_iovecs, struct bio_set * bs)'/>
<dec f='linux-4.18.y/block/bio.c' l='531' type='struct bio * bio_alloc_bioset(gfp_t , unsigned int , struct bio_set * )'/>
<use f='linux-4.18.y/block/bio.c' l='531' c='bio_alloc_bioset'/>
<use f='linux-4.18.y/block/bio.c' l='531' u='a'/>
<use f='linux-4.18.y/block/bio.c' l='531' u='a'/>
<use f='linux-4.18.y/block/bio.c' l='626' u='c' c='bio_clone_fast'/>
<use f='linux-4.18.y/block/bio.c' l='685' u='c' c='bio_clone_bioset'/>
<doc f='linux-4.18.y/block/bio.c' l='401'>/**
 * bio_alloc_bioset - allocate a bio for I/O
 * @gfp_mask:   the GFP_* mask given to the slab allocator
 * @nr_iovecs:	number of iovecs to pre-allocate
 * @bs:		the bio_set to allocate from.
 *
 * Description:
 *   If @bs is NULL, uses kmalloc() to allocate the bio; else the allocation is
 *   backed by the @bs&apos;s mempool.
 *
 *   When @bs is not NULL, if %__GFP_DIRECT_RECLAIM is set then bio_alloc will
 *   always be able to allocate a bio. This is due to the mempool guarantees.
 *   To make this work, callers must never allocate more than 1 bio at a time
 *   from this pool. Callers that need to allocate more than 1 bio must always
 *   submit the previously allocated bio for IO before attempting to allocate
 *   a new one. Failure to do so can cause deadlocks under memory pressure.
 *
 *   Note that when running under generic_make_request() (i.e. any block
 *   driver), bios are not submitted until after you return - see the code in
 *   generic_make_request() that converts recursion into iteration, to prevent
 *   stack overflows.
 *
 *   This would normally mean allocating multiple bios under
 *   generic_make_request() would be susceptible to deadlocks, but we have
 *   deadlock avoidance code that resubmits any blocked bios from a rescuer
 *   thread.
 *
 *   However, we do not guarantee forward progress for allocations from other
 *   mempools. Doing multiple allocations from the same mempool under
 *   generic_make_request() should be avoided - instead, use bio_set&apos;s front_pad
 *   for per bio allocations.
 *
 *   RETURNS:
 *   Pointer to new bio on success, NULL on failure.
 */</doc>
<use f='linux-4.18.y/drivers/md/dm-crypt.c' l='1412' u='c' c='crypt_alloc_buffer'/>
<use f='linux-4.18.y/drivers/md/dm-io.c' l='348' u='c' c='do_region'/>
<use f='linux-4.18.y/drivers/md/dm.c' l='540' u='c' c='alloc_io'/>
<use f='linux-4.18.y/drivers/md/dm.c' l='575' u='c' c='alloc_tio'/>
<use f='linux-4.18.y/drivers/md/md.c' l='219' u='c' c='bio_alloc_mddev'/>
<use f='linux-4.18.y/drivers/md/md.c' l='231' u='c' c='md_bio_alloc_sync'/>
<use f='linux-4.18.y/drivers/md/raid5-cache.c' l='751' u='c' c='r5l_bio_alloc'/>
<use f='linux-4.18.y/drivers/md/raid5-cache.c' l='1650' u='c' c='r5l_recovery_allocate_ra_pool'/>
<use f='linux-4.18.y/drivers/md/raid5-ppl.c' l='505' u='c' c='ppl_submit_iounit'/>
<use f='linux-4.18.y/drivers/md/raid5-ppl.c' l='645' u='c' c='ppl_do_flush'/>
<use f='linux-4.18.y/fs/block_dev.c' l='340' u='c' c='__blkdev_direct_IO'/>
