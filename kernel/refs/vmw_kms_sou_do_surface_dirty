<dec f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.h' l='401' type='int vmw_kms_sou_do_surface_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, struct vmw_resource * srf, s32 dest_x, s32 dest_y, unsigned int num_clips, int inc, struct vmw_fence_obj ** out_fence, struct drm_crtc * crtc)'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='887' u='c' c='vmw_framebuffer_surface_dirty'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1570' u='c' c='vmw_kms_generic_present'/>
<use f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='520' u='c' c='vmw_sou_primary_plane_atomic_update'/>
<def f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='929' ll='972' type='int vmw_kms_sou_do_surface_dirty(struct vmw_private * dev_priv, struct vmw_framebuffer * framebuffer, struct drm_clip_rect * clips, struct drm_vmw_rect * vclips, struct vmw_resource * srf, s32 dest_x, s32 dest_y, unsigned int num_clips, int inc, struct vmw_fence_obj ** out_fence, struct drm_crtc * crtc)'/>
<doc f='linux-4.18.y/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c' l='907'>/**
 * vmw_kms_sou_do_surface_dirty - Dirty part of a surface backed framebuffer
 *
 * @dev_priv: Pointer to the device private structure.
 * @framebuffer: Pointer to the surface-buffer backed framebuffer.
 * @clips: Array of clip rects. Either @clips or @vclips must be NULL.
 * @vclips: Alternate array of clip rects. Either @clips or @vclips must
 * be NULL.
 * @srf: Pointer to surface to blit from. If NULL, the surface attached
 * to @framebuffer will be used.
 * @dest_x: X coordinate offset to align @srf with framebuffer coordinates.
 * @dest_y: Y coordinate offset to align @srf with framebuffer coordinates.
 * @num_clips: Number of clip rects in @clips.
 * @inc: Increment to use when looping over @clips.
 * @out_fence: If non-NULL, will return a ref-counted pointer to a
 * struct vmw_fence_obj. The returned fence pointer may be NULL in which
 * case the device has already synchronized.
 * @crtc: If crtc is passed, perform surface dirty on that crtc only.
 *
 * Returns 0 on success, negative error code on failure. -ERESTARTSYS if
 * interrupted.
 */</doc>
