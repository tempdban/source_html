<dec f='linux-4.18.y/include/linux/filter.h' l='732' type='int bpf_prog_create(struct bpf_prog ** pfp, struct sock_fprog_kern * fprog)'/>
<def f='linux-4.18.y/net/core/filter.c' l='1336' ll='1367' type='int bpf_prog_create(struct bpf_prog ** pfp, struct sock_fprog_kern * fprog)'/>
<dec f='linux-4.18.y/net/core/filter.c' l='1368' type='int bpf_prog_create(struct bpf_prog ** , struct sock_fprog_kern * )'/>
<use f='linux-4.18.y/net/core/filter.c' l='1368' c='bpf_prog_create'/>
<use f='linux-4.18.y/net/core/filter.c' l='1368' u='a'/>
<use f='linux-4.18.y/net/core/filter.c' l='1368' u='a'/>
<doc f='linux-4.18.y/net/core/filter.c' l='1326'>/**
 *	bpf_prog_create - create an unattached filter
 *	@pfp: the unattached filter that is created
 *	@fprog: the filter program
 *
 * Create a filter independent of any socket. We first run some
 * sanity checks on it to make sure it does not explode on us later.
 * If an error occurs or there is insufficient memory for the filter
 * a negative errno code is returned. On success the return is zero.
 */</doc>
<use f='linux-4.18.y/net/core/ptp_classifier.c' l='192' u='c' c='ptp_classifier_init'/>
<use f='linux-4.18.y/net/netfilter/xt_bpf.c' l='38' u='c' c='__bpf_mt_check_bytecode'/>
