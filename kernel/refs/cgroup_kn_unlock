<dec f='linux-4.18.y/kernel/cgroup/cgroup-internal.h' l='167' type='void cgroup_kn_unlock(struct kernfs_node * kn)'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup-v1.c' l='555' u='c' c='__cgroup1_procs_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup-v1.c' l='586' u='c' c='cgroup_release_agent_write'/>
<def f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1484' ll='1497' type='void cgroup_kn_unlock(struct kernfs_node * kn)'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1543' u='c' c='cgroup_kn_lock_live'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='3179' u='c' c='cgroup_subtree_control_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='3269' u='c' c='cgroup_type_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='3311' u='c' c='cgroup_max_descendants_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='3354' u='c' c='cgroup_max_depth_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='4421' u='c' c='cgroup_procs_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='4470' u='c' c='cgroup_threads_write'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='4991' u='c' c='cgroup_mkdir'/>
<use f='linux-4.18.y/kernel/cgroup/cgroup.c' l='5172' u='c' c='cgroup_rmdir'/>
<doc f='linux-4.18.y/kernel/cgroup/cgroup.c' l='1474'>/**
 * cgroup_kn_unlock - unlocking helper for cgroup kernfs methods
 * @kn: the kernfs_node being serviced
 *
 * This helper undoes cgroup_kn_lock_live() and should be invoked before
 * the method finishes if locking succeeded.  Note that once this function
 * returns the cgroup returned by cgroup_kn_lock_live() may become
 * inaccessible any time.  If the caller intends to continue to access the
 * cgroup, it should pin it before invoking this function.
 */</doc>
