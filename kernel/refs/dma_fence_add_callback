<dec f='linux-4.18.y/include/linux/dma-fence.h' l='350' type='int dma_fence_add_callback(struct dma_fence * fence, struct dma_fence_cb * cb, dma_fence_func_t func)'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-buf.c' l='216' u='c' c='dma_buf_poll'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-buf.c' l='260' u='c' c='dma_buf_poll'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence-array.c' l='72' u='c' c='dma_fence_array_enable_signaling'/>
<def f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='241' ll='280' type='int dma_fence_add_callback(struct dma_fence * fence, struct dma_fence_cb * cb, dma_fence_func_t func)'/>
<dec f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='281' type='int dma_fence_add_callback(struct dma_fence * , struct dma_fence_cb * , dma_fence_func_t )'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='281' c='dma_fence_add_callback'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='281' u='a'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='281' u='a'/>
<use f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='505' u='c' c='dma_fence_wait_any_timeout'/>
<doc f='linux-4.18.y/drivers/dma-buf/dma-fence.c' l='216'>/**
 * dma_fence_add_callback - add a callback to be called when the fence
 * is signaled
 * @fence:	[in]	the fence to wait on
 * @cb:		[in]	the callback to register
 * @func:	[in]	the function to call
 *
 * cb will be initialized by dma_fence_add_callback, no initialization
 * by the caller is required. Any number of callbacks can be registered
 * to a fence, but a callback can only be registered to one fence at a time.
 *
 * Note that the callback can be called from an atomic context.  If
 * fence is already signaled, this function will return -ENOENT (and
 * *not* call the callback)
 *
 * Add a software callback to the fence. Same restrictions apply to
 * refcount as it does to dma_fence_wait, however the caller doesn&apos;t need to
 * keep a refcount to fence afterwards: when software access is enabled,
 * the creator of the fence is required to keep the fence alive until
 * after it signals with dma_fence_signal. The callback itself can be called
 * from irq context.
 *
 * Returns 0 in case of success, -ENOENT if the fence is already signaled
 * and -EINVAL in case of error.
 */</doc>
<use f='linux-4.18.y/drivers/dma-buf/sync_file.c' l='323' u='c' c='sync_file_poll'/>
<use f='linux-4.18.y/drivers/gpu/drm/drm_syncobj.c' l='765' u='c' c='drm_syncobj_array_wait_timeout'/>
