<dec f='linux-4.14.y/include/net/tcp.h' l='409' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1477' u='c' c='tcp_v4_do_rcv'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1705' u='c' c='tcp_v4_rcv'/>
<def f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='810' ll='836' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<dec f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' type='int tcp_child_process(struct sock * , struct sock * , struct sk_buff * )'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' c='tcp_child_process'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' u='a'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' u='a'/>
<doc f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='798'>/*
 * Queue segment on the new socket if the new socket is active,
 * otherwise we just shortcircuit this and continue with
 * the new socket.
 *
 * For the vast majority of cases child-&gt;sk_state will be TCP_SYN_RECV
 * when entering. But other states are possible due to a race condition
 * where after __inet_lookup_established() fails but before the listener
 * locked is obtained, other packets cause the same connection to
 * be created.
 */</doc>
<dec f='linux-4.14.y/include/net/tcp.h' l='409' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1477' u='c' c='tcp_v4_do_rcv'/>
<use f='linux-4.14.y/net/ipv4/tcp_ipv4.c' l='1705' u='c' c='tcp_v4_rcv'/>
<def f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='810' ll='836' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<dec f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' type='int tcp_child_process(struct sock * , struct sock * , struct sk_buff * )'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' c='tcp_child_process'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' u='a'/>
<use f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='837' u='a'/>
<doc f='linux-4.14.y/net/ipv4/tcp_minisocks.c' l='798'>/*
 * Queue segment on the new socket if the new socket is active,
 * otherwise we just shortcircuit this and continue with
 * the new socket.
 *
 * For the vast majority of cases child-&gt;sk_state will be TCP_SYN_RECV
 * when entering. But other states are possible due to a race condition
 * where after __inet_lookup_established() fails but before the listener
 * locked is obtained, other packets cause the same connection to
 * be created.
 */</doc>
