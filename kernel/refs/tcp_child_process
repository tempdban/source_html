<dec f='linux-4.18.y/include/net/tcp.h' l='380' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<use f='linux-4.18.y/net/ipv4/tcp_ipv4.c' l='1544' u='c' c='tcp_v4_do_rcv'/>
<use f='linux-4.18.y/net/ipv4/tcp_ipv4.c' l='1783' u='c' c='tcp_v4_rcv'/>
<def f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='831' ll='857' type='int tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb)'/>
<dec f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='858' type='int tcp_child_process(struct sock * , struct sock * , struct sk_buff * )'/>
<use f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='858' c='tcp_child_process'/>
<use f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='858' u='a'/>
<use f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='858' u='a'/>
<doc f='linux-4.18.y/net/ipv4/tcp_minisocks.c' l='819'>/*
 * Queue segment on the new socket if the new socket is active,
 * otherwise we just shortcircuit this and continue with
 * the new socket.
 *
 * For the vast majority of cases child-&gt;sk_state will be TCP_SYN_RECV
 * when entering. But other states are possible due to a race condition
 * where after __inet_lookup_established() fails but before the listener
 * locked is obtained, other packets cause the same connection to
 * be created.
 */</doc>
