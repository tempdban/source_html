<dec f='linux-4.18.y/drivers/pci/pci.h' l='70' type='void pci_update_current_state(struct pci_dev * dev, pci_power_t state)'/>
<def f='linux-4.18.y/drivers/pci/pci.c' l='749' ll='762' type='void pci_update_current_state(struct pci_dev * dev, pci_power_t state)'/>
<use f='linux-4.18.y/drivers/pci/pci.c' l='774' u='c' c='pci_power_up'/>
<use f='linux-4.18.y/drivers/pci/pci.c' l='789' u='c' c='pci_platform_power_transition'/>
<doc f='linux-4.18.y/drivers/pci/pci.c' l='737'>/**
 * pci_update_current_state - Read power state of given device and cache it
 * @dev: PCI device to handle.
 * @state: State to cache in case the device doesn&apos;t have the PM capability
 *
 * The power state is read from the PMCSR register, which however is
 * inaccessible in D3cold.  The platform firmware is therefore queried first
 * to detect accessibility of the register.  In case the platform firmware
 * reports an incorrect state or the device isn&apos;t power manageable by the
 * platform at all, we try to detect D3cold by testing accessibility of the
 * vendor ID in config space.
 */</doc>
