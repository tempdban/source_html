<dec f='linux-4.18.y/include/linux/perf_event.h' l='849' type='void perf_aux_output_end(struct perf_output_handle * handle, unsigned long size)'/>
<use f='linux-4.18.y/arch/x86/events/intel/bts.c' l='279' u='c' c='bts_event_start'/>
<use f='linux-4.18.y/arch/x86/events/intel/bts.c' l='322' u='c' c='bts_event_stop'/>
<use f='linux-4.18.y/arch/x86/events/intel/bts.c' l='486' u='c' c='intel_bts_interrupt'/>
<use f='linux-4.18.y/arch/x86/events/intel/bts.c' l='501' u='c' c='intel_bts_interrupt'/>
<use f='linux-4.18.y/arch/x86/events/intel/pt.c' l='1276' u='c' c='intel_pt_interrupt'/>
<use f='linux-4.18.y/arch/x86/events/intel/pt.c' l='1291' u='c' c='intel_pt_interrupt'/>
<use f='linux-4.18.y/arch/x86/events/intel/pt.c' l='1367' u='c' c='pt_event_start'/>
<use f='linux-4.18.y/arch/x86/events/intel/pt.c' l='1408' u='c' c='pt_event_stop'/>
<def f='linux-4.18.y/kernel/events/ring_buffer.c' l='440' ll='484' type='void perf_aux_output_end(struct perf_output_handle * handle, unsigned long size)'/>
<dec f='linux-4.18.y/kernel/events/ring_buffer.c' l='485' type='void perf_aux_output_end(struct perf_output_handle * , unsigned long )'/>
<use f='linux-4.18.y/kernel/events/ring_buffer.c' l='485' c='perf_aux_output_end'/>
<use f='linux-4.18.y/kernel/events/ring_buffer.c' l='485' u='a'/>
<use f='linux-4.18.y/kernel/events/ring_buffer.c' l='485' u='a'/>
<doc f='linux-4.18.y/kernel/events/ring_buffer.c' l='430'>/*
 * Commit the data written by hardware into the ring buffer by adjusting
 * aux_head and posting a PERF_RECORD_AUX into the perf buffer. It is the
 * pmu driver&apos;s responsibility to observe ordering rules of the hardware,
 * so that all the data is externally visible before this is called.
 *
 * Note: this has to be called from pmu::stop() callback, as the assumption
 * of the AUX buffer management code is that after pmu::stop(), the AUX
 * transaction must be stopped and therefore drop the AUX reference count.
 */</doc>
