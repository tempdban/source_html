<def f='linux-4.14.y/include/linux/fscrypt_supp.h' l='101' ll='105'/>
<size>24</size>
<doc f='linux-4.14.y/include/linux/fscrypt_supp.h' l='75'>/**
 * fscrypt_digested_name - alternate identifier for an on-disk filename
 *
 * When userspace lists an encrypted directory without access to the key,
 * filenames whose ciphertext is longer than FSCRYPT_FNAME_MAX_UNDIGESTED_SIZE
 * bytes are shown in this abbreviated form (base64-encoded) rather than as the
 * full ciphertext (base64-encoded).  This is necessary to allow supporting
 * filenames up to NAME_MAX bytes, since base64 encoding expands the length.
 *
 * To make it possible for filesystems to still find the correct directory entry
 * despite not knowing the full on-disk name, we encode any filesystem-specific
 * &apos;hash&apos; and/or &apos;minor_hash&apos; which the filesystem may need for its lookups,
 * followed by the second-to-last ciphertext block of the filename.  Due to the
 * use of the CBC-CTS encryption mode, the second-to-last ciphertext block
 * depends on the full plaintext.  (Note that ciphertext stealing causes the
 * last two blocks to appear &quot;flipped&quot;.)  This makes accidental collisions very
 * unlikely: just a 1 in 2^128 chance for two filenames to collide even if they
 * share the same filesystem-specific hashes.
 *
 * However, this scheme isn&apos;t immune to intentional collisions, which can be
 * created by anyone able to create arbitrary plaintext filenames and view them
 * without the key.  Making the &quot;digest&quot; be a real cryptographic hash like
 * SHA-256 over the full ciphertext would prevent this, although it would be
 * less efficient and harder to implement, especially since the filesystem would
 * need to calculate it for each directory entry examined during a search.
 */</doc>
<mbr r='fscrypt_digested_name::hash' o='0' t='u32'/>
<mbr r='fscrypt_digested_name::minor_hash' o='32' t='u32'/>
<mbr r='fscrypt_digested_name::digest' o='64' t='u8 [16]'/>
