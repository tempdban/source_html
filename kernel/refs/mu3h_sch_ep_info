<def f='linux-4.14.y/drivers/usb/host/xhci-mtk.h' l='70' ll='85'/>
<size>64</size>
<doc f='linux-4.14.y/drivers/usb/host/xhci-mtk.h' l='45'>/**
 * struct mu3h_sch_ep_info: schedule information for endpoint
 *
 * @esit: unit is 125us, equal to 2 &lt;&lt; Interval field in ep-context
 * @num_budget_microframes: number of continuous uframes
 *		(@repeat==1) scheduled within the interval
 * @bw_cost_per_microframe: bandwidth cost per microframe
 * @endpoint: linked into bandwidth domain which it belongs to
 * @ep: address of usb_host_endpoint struct
 * @offset: which uframe of the interval that transfer should be
 *		scheduled first time within the interval
 * @repeat: the time gap between two uframes that transfers are
 *		scheduled within a interval. in the simple algorithm, only
 *		assign 0 or 1 to it; 0 means using only one uframe in a
 *		interval, and 1 means using @num_budget_microframes
 *		continuous uframes
 * @pkts: number of packets to be transferred in the scheduled uframes
 * @cs_count: number of CS that host will trigger
 * @burst_mode: burst mode for scheduling. 0: normal burst mode,
 *		distribute the bMaxBurst+1 packets for a single burst
 *		according to @pkts and @repeat, repeate the burst multiple
 *		times; 1: distribute the (bMaxBurst+1)*(Mult+1) packets
 *		according to @pkts and @repeat. normal mode is used by
 *		default
 */</doc>
<mbr r='mu3h_sch_ep_info::esit' o='0' t='u32'/>
<mbr r='mu3h_sch_ep_info::num_budget_microframes' o='32' t='u32'/>
<mbr r='mu3h_sch_ep_info::bw_cost_per_microframe' o='64' t='u32'/>
<mbr r='mu3h_sch_ep_info::endpoint' o='128' t='struct list_head'/>
<mbr r='mu3h_sch_ep_info::ep' o='256' t='void *'/>
<mbr r='mu3h_sch_ep_info::offset' o='320' t='u32'/>
<mbr r='mu3h_sch_ep_info::repeat' o='352' t='u32'/>
<mbr r='mu3h_sch_ep_info::pkts' o='384' t='u32'/>
<mbr r='mu3h_sch_ep_info::cs_count' o='416' t='u32'/>
<mbr r='mu3h_sch_ep_info::burst_mode' o='448' t='u32'/>
