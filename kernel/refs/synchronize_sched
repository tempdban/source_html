<dec f='linux-4.14.y/include/linux/rcupdate.h' l='60' type='void synchronize_sched()'/>
<use f='linux-4.14.y/include/linux/rcupdate.h' l='94' u='c' c='synchronize_rcu'/>
<use f='linux-4.14.y/include/linux/tracepoint.h' l='80' u='c' c='tracepoint_synchronize_unregister'/>
<use f='linux-4.14.y/drivers/cpufreq/intel_pstate.c' l='1727' u='c' c='intel_pstate_clear_update_util_hook'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='5840' u='c' c='ixgbe_down'/>
<use f='linux-4.14.y/drivers/net/ethernet/realtek/8139too.c' l='1666' u='c' c='rtl8139_tx_timeout_task'/>
<use f='linux-4.14.y/fs/file.c' l='166' u='c' c='expand_fdtable'/>
<use f='linux-4.14.y/kernel/events/core.c' l='9463' u='c' c='account_event'/>
<use f='linux-4.14.y/kernel/module.c' l='2160' u='c' c='free_module'/>
<use f='linux-4.14.y/kernel/module.c' l='3526' u='c' c='do_init_module'/>
<use f='linux-4.14.y/kernel/module.c' l='3799' u='c' c='load_module'/>
<use f='linux-4.14.y/kernel/module.c' l='3814' u='c' c='load_module'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<def f='linux-4.14.y/kernel/rcu/tree.c' l='3213' ll='3225' type='void synchronize_sched()'/>
<dec f='linux-4.14.y/kernel/rcu/tree.c' l='3226' type='void synchronize_sched()'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3226' c='synchronize_sched'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3226' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3226' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3355' u='c' c='cond_synchronize_sched'/>
<doc f='linux-4.14.y/kernel/rcu/tree.c' l='3178'>/**
 * synchronize_sched - wait until an rcu-sched grace period has elapsed.
 *
 * Control will return to the caller some time after a full rcu-sched
 * grace period has elapsed, in other words after all currently executing
 * rcu-sched read-side critical sections have completed.   These read-side
 * critical sections are delimited by rcu_read_lock_sched() and
 * rcu_read_unlock_sched(), and may be nested.  Note that preempt_disable(),
 * local_irq_disable(), and so on may be used in place of
 * rcu_read_lock_sched().
 *
 * This means that all preempt_disable code sequences, including NMI and
 * non-threaded hardware-interrupt handlers, in progress on entry will
 * have completed before this primitive returns.  However, this does not
 * guarantee that softirq handlers will have completed, since in some
 * kernels, these handlers can run in process context, and can block.
 *
 * Note that this guarantee implies further memory-ordering guarantees.
 * On systems with more than one CPU, when synchronize_sched() returns,
 * each CPU is guaranteed to have executed a full memory barrier since the
 * end of its last RCU-sched read-side critical section whose beginning
 * preceded the call to synchronize_sched().  In addition, each CPU having
 * an RCU read-side critical section that extends beyond the return from
 * synchronize_sched() is guaranteed to have executed a full memory barrier
 * after the beginning of synchronize_sched() and before the beginning of
 * that RCU read-side critical section.  Note that these guarantees include
 * CPUs that are offline, idle, or executing in user mode, as well as CPUs
 * that are executing in the kernel.
 *
 * Furthermore, if CPU A invoked synchronize_sched(), which returned
 * to its caller on CPU B, then both CPU A and CPU B are guaranteed
 * to have executed a full memory barrier during the execution of
 * synchronize_sched() -- even if CPU A and CPU B are the same CPU (but
 * again only if the system has more than one CPU).
 */</doc>
<use f='linux-4.14.y/kernel/rcu/update.c' l='206' u='c' c='rcu_test_sync_prims'/>
<use f='linux-4.14.y/kernel/sched/membarrier.c' l='170' u='c' c='SYSC_membarrier'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='2902' macro='1' u='c'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='4571' u='c' c='unregister_ftrace_function_probe_func'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='5391' u='c' c='ftrace_graph_release'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='6227' u='c' c='clear_ftrace_pids'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='6374' u='c' c='ftrace_pid_write'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='1768' u='c' c='ring_buffer_resize'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4045' u='c' c='ring_buffer_read_prepare_sync'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4217' u='c' c='ring_buffer_reset_cpu'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1672' u='c' c='tracing_reset'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1689' u='c' c='tracing_reset_online_cpus'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='2240' u='c' c='trace_buffered_event_disable'/>
<use f='linux-4.14.y/kernel/trace/trace_events.c' l='639' u='c' c='__ftrace_clear_event_pids'/>
<use f='linux-4.14.y/kernel/trace/trace_events.c' l='1627' u='c' c='ftrace_event_pid_write'/>
<use f='linux-4.14.y/kernel/trace/trace_events.c' l='3027' u='c' c='event_trace_del_tracer'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='1864' u='c' c='replace_system_preds'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='1882' u='c' c='replace_system_preds'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='2032' u='c' c='apply_event_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='2059' u='c' c='apply_event_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='2089' u='c' c='apply_subsystem_event_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_events_trigger.c' l='37' u='c' c='trigger_data_free'/>
<use f='linux-4.14.y/kernel/trace/trace_events_trigger.c' l='752' u='c' c='set_trigger_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_uprobe.c' l='970' u='c' c='probe_event_disable'/>
<use f='linux-4.14.y/mm/slab.c' l='968' u='c' c='setup_kmem_cache_node'/>
<dec f='linux-4.14.y/include/linux/rcupdate.h' l='60' type='void synchronize_sched()'/>
<use f='linux-4.14.y/include/linux/rcupdate.h' l='94' u='c' c='synchronize_rcu'/>
<use f='linux-4.14.y/include/linux/tracepoint.h' l='80' u='c' c='tracepoint_synchronize_unregister'/>
<use f='linux-4.14.y/drivers/cpufreq/intel_pstate.c' l='1727' u='c' c='intel_pstate_clear_update_util_hook'/>
<use f='linux-4.14.y/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c' l='5840' u='c' c='ixgbe_down'/>
<use f='linux-4.14.y/drivers/net/ethernet/realtek/8139too.c' l='1666' u='c' c='rtl8139_tx_timeout_task'/>
<use f='linux-4.14.y/fs/file.c' l='166' u='c' c='expand_fdtable'/>
<use f='linux-4.14.y/kernel/events/core.c' l='9463' u='c' c='account_event'/>
<use f='linux-4.14.y/kernel/module.c' l='2160' u='c' c='free_module'/>
<use f='linux-4.14.y/kernel/module.c' l='3526' u='c' c='do_init_module'/>
<use f='linux-4.14.y/kernel/module.c' l='3799' u='c' c='load_module'/>
<use f='linux-4.14.y/kernel/module.c' l='3814' u='c' c='load_module'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<use f='linux-4.14.y/kernel/rcu/sync.c' l='47' u='r'/>
<def f='linux-4.14.y/kernel/rcu/tree.c' l='3213' ll='3225' type='void synchronize_sched()'/>
<dec f='linux-4.14.y/kernel/rcu/tree.c' l='3226' type='void synchronize_sched()'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3226' c='synchronize_sched'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3226' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3226' u='a'/>
<use f='linux-4.14.y/kernel/rcu/tree.c' l='3355' u='c' c='cond_synchronize_sched'/>
<doc f='linux-4.14.y/kernel/rcu/tree.c' l='3178'>/**
 * synchronize_sched - wait until an rcu-sched grace period has elapsed.
 *
 * Control will return to the caller some time after a full rcu-sched
 * grace period has elapsed, in other words after all currently executing
 * rcu-sched read-side critical sections have completed.   These read-side
 * critical sections are delimited by rcu_read_lock_sched() and
 * rcu_read_unlock_sched(), and may be nested.  Note that preempt_disable(),
 * local_irq_disable(), and so on may be used in place of
 * rcu_read_lock_sched().
 *
 * This means that all preempt_disable code sequences, including NMI and
 * non-threaded hardware-interrupt handlers, in progress on entry will
 * have completed before this primitive returns.  However, this does not
 * guarantee that softirq handlers will have completed, since in some
 * kernels, these handlers can run in process context, and can block.
 *
 * Note that this guarantee implies further memory-ordering guarantees.
 * On systems with more than one CPU, when synchronize_sched() returns,
 * each CPU is guaranteed to have executed a full memory barrier since the
 * end of its last RCU-sched read-side critical section whose beginning
 * preceded the call to synchronize_sched().  In addition, each CPU having
 * an RCU read-side critical section that extends beyond the return from
 * synchronize_sched() is guaranteed to have executed a full memory barrier
 * after the beginning of synchronize_sched() and before the beginning of
 * that RCU read-side critical section.  Note that these guarantees include
 * CPUs that are offline, idle, or executing in user mode, as well as CPUs
 * that are executing in the kernel.
 *
 * Furthermore, if CPU A invoked synchronize_sched(), which returned
 * to its caller on CPU B, then both CPU A and CPU B are guaranteed
 * to have executed a full memory barrier during the execution of
 * synchronize_sched() -- even if CPU A and CPU B are the same CPU (but
 * again only if the system has more than one CPU).
 */</doc>
<use f='linux-4.14.y/kernel/rcu/update.c' l='206' u='c' c='rcu_test_sync_prims'/>
<use f='linux-4.14.y/kernel/sched/membarrier.c' l='170' u='c' c='SYSC_membarrier'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='2902' macro='1' u='c'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='4571' u='c' c='unregister_ftrace_function_probe_func'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='5391' u='c' c='ftrace_graph_release'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='6227' u='c' c='clear_ftrace_pids'/>
<use f='linux-4.14.y/kernel/trace/ftrace.c' l='6374' u='c' c='ftrace_pid_write'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='1768' u='c' c='ring_buffer_resize'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4045' u='c' c='ring_buffer_read_prepare_sync'/>
<use f='linux-4.14.y/kernel/trace/ring_buffer.c' l='4217' u='c' c='ring_buffer_reset_cpu'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1672' u='c' c='tracing_reset'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='1689' u='c' c='tracing_reset_online_cpus'/>
<use f='linux-4.14.y/kernel/trace/trace.c' l='2240' u='c' c='trace_buffered_event_disable'/>
<use f='linux-4.14.y/kernel/trace/trace_events.c' l='639' u='c' c='__ftrace_clear_event_pids'/>
<use f='linux-4.14.y/kernel/trace/trace_events.c' l='1627' u='c' c='ftrace_event_pid_write'/>
<use f='linux-4.14.y/kernel/trace/trace_events.c' l='3027' u='c' c='event_trace_del_tracer'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='1864' u='c' c='replace_system_preds'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='1882' u='c' c='replace_system_preds'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='2032' u='c' c='apply_event_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='2059' u='c' c='apply_event_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_events_filter.c' l='2089' u='c' c='apply_subsystem_event_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_events_trigger.c' l='37' u='c' c='trigger_data_free'/>
<use f='linux-4.14.y/kernel/trace/trace_events_trigger.c' l='752' u='c' c='set_trigger_filter'/>
<use f='linux-4.14.y/kernel/trace/trace_uprobe.c' l='970' u='c' c='probe_event_disable'/>
<use f='linux-4.14.y/mm/slab.c' l='968' u='c' c='setup_kmem_cache_node'/>
