<dec f='linux-4.18.y/include/linux/ioport.h' l='247' type='int devm_request_resource(struct device * dev, struct resource * root, struct resource * new)'/>
<use f='linux-4.18.y/drivers/pci/bus.c' l='113' u='c' c='devm_request_pci_bus_resources'/>
<def f='linux-4.18.y/kernel/resource.c' l='1347' ll='1368' type='int devm_request_resource(struct device * dev, struct resource * root, struct resource * new)'/>
<dec f='linux-4.18.y/kernel/resource.c' l='1369' type='int devm_request_resource(struct device * , struct resource * , struct resource * )'/>
<use f='linux-4.18.y/kernel/resource.c' l='1369' c='devm_request_resource'/>
<use f='linux-4.18.y/kernel/resource.c' l='1369' u='a'/>
<use f='linux-4.18.y/kernel/resource.c' l='1369' u='a'/>
<doc f='linux-4.18.y/kernel/resource.c' l='1329'>/**
 * devm_request_resource() - request and reserve an I/O or memory resource
 * @dev: device for which to request the resource
 * @root: root of the resource tree from which to request the resource
 * @new: descriptor of the resource to request
 *
 * This is a device-managed version of request_resource(). There is usually
 * no need to release resources requested by this function explicitly since
 * that will be taken care of when the device is unbound from its driver.
 * If for some reason the resource needs to be released explicitly, because
 * of ordering issues for example, drivers must call devm_release_resource()
 * rather than the regular release_resource().
 *
 * When a conflict is detected between any existing resources and the newly
 * requested resource, an error message will be printed.
 *
 * Returns 0 on success or a negative error code on failure.
 */</doc>
