<dec f='linux-4.18.y/include/linux/uprobes.h' l='125' type='int uprobe_register(struct inode * inode, loff_t offset, struct uprobe_consumer * uc)'/>
<def f='linux-4.18.y/kernel/events/uprobes.c' l='880' ll='917' type='int uprobe_register(struct inode * inode, loff_t offset, struct uprobe_consumer * uc)'/>
<dec f='linux-4.18.y/kernel/events/uprobes.c' l='918' type='int uprobe_register(struct inode * , loff_t , struct uprobe_consumer * )'/>
<use f='linux-4.18.y/kernel/events/uprobes.c' l='918' c='uprobe_register'/>
<use f='linux-4.18.y/kernel/events/uprobes.c' l='918' u='a'/>
<use f='linux-4.18.y/kernel/events/uprobes.c' l='918' u='a'/>
<doc f='linux-4.18.y/kernel/events/uprobes.c' l='862'>/*
 * uprobe_register - register a probe
 * @inode: the file in which the probe has to be placed.
 * @offset: offset from the start of the file.
 * @uc: information on howto handle the probe..
 *
 * Apart from the access refcount, uprobe_register() takes a creation
 * refcount (thro alloc_uprobe) if and only if this @uprobe is getting
 * inserted into the rbtree (i.e first consumer for a @inode:@offset
 * tuple).  Creation refcount stops uprobe_unregister from freeing the
 * @uprobe even before the register operation is complete. Creation
 * refcount is released when the last @uc for the @uprobe
 * unregisters. Caller of uprobe_register() is required to keep @inode
 * (and the containing mount) referenced.
 *
 * Return errno if it cannot successully install probes
 * else return 0 (success)
 */</doc>
<use f='linux-4.18.y/kernel/trace/trace_uprobe.c' l='920' u='c' c='probe_event_enable'/>
