<dec f='linux-4.14.y/drivers/scsi/scsi_priv.h' l='89' type='void scsi_io_completion(struct scsi_cmnd * , unsigned int )'/>
<use f='linux-4.14.y/drivers/scsi/scsi.c' l='248' u='c' c='scsi_finish_command'/>
<def f='linux-4.14.y/drivers/scsi/scsi_lib.c' l='770' ll='1037' type='void scsi_io_completion(struct scsi_cmnd * cmd, unsigned int good_bytes)'/>
<doc f='linux-4.14.y/drivers/scsi/scsi_lib.c' l='741'>/*
 * Function:    scsi_io_completion()
 *
 * Purpose:     Completion processing for block device I/O requests.
 *
 * Arguments:   cmd   - command that is finished.
 *
 * Lock status: Assumed that no lock is held upon entry.
 *
 * Returns:     Nothing
 *
 * Notes:       We will finish off the specified number of sectors.  If we
 *		are done, the command block will be released and the queue
 *		function will be goosed.  If we are not done then we have to
 *		figure out what to do next:
 *
 *		a) We can call scsi_requeue_command().  The request
 *		   will be unprepared and put back on the queue.  Then
 *		   a new command will be created for it.  This should
 *		   be used if we made forward progress, or if we want
 *		   to switch from READ(10) to READ(6) for example.
 *
 *		b) We can call __scsi_queue_insert().  The request will
 *		   be put back on the queue and retried using the same
 *		   command as before, possibly after a delay.
 *
 *		c) We can call scsi_end_request() with -EIO to fail
 *		   the remainder of the request.
 */</doc>
<dec f='linux-4.14.y/drivers/scsi/scsi_priv.h' l='89' type='void scsi_io_completion(struct scsi_cmnd * , unsigned int )'/>
<use f='linux-4.14.y/drivers/scsi/scsi.c' l='248' u='c' c='scsi_finish_command'/>
<def f='linux-4.14.y/drivers/scsi/scsi_lib.c' l='770' ll='1037' type='void scsi_io_completion(struct scsi_cmnd * cmd, unsigned int good_bytes)'/>
<doc f='linux-4.14.y/drivers/scsi/scsi_lib.c' l='741'>/*
 * Function:    scsi_io_completion()
 *
 * Purpose:     Completion processing for block device I/O requests.
 *
 * Arguments:   cmd   - command that is finished.
 *
 * Lock status: Assumed that no lock is held upon entry.
 *
 * Returns:     Nothing
 *
 * Notes:       We will finish off the specified number of sectors.  If we
 *		are done, the command block will be released and the queue
 *		function will be goosed.  If we are not done then we have to
 *		figure out what to do next:
 *
 *		a) We can call scsi_requeue_command().  The request
 *		   will be unprepared and put back on the queue.  Then
 *		   a new command will be created for it.  This should
 *		   be used if we made forward progress, or if we want
 *		   to switch from READ(10) to READ(6) for example.
 *
 *		b) We can call __scsi_queue_insert().  The request will
 *		   be put back on the queue and retried using the same
 *		   command as before, possibly after a delay.
 *
 *		c) We can call scsi_end_request() with -EIO to fail
 *		   the remainder of the request.
 */</doc>
