<dec f='linux-4.14.y/include/linux/dma-fence.h' l='275' type='int dma_fence_signal(struct dma_fence * fence)'/>
<use f='linux-4.14.y/include/linux/dma-fence.h' l='333' u='c' c='dma_fence_is_signaled'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence-array.c' l='38' u='c' c='irq_dma_fence_array_work'/>
<def f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='109' ll='134' type='int dma_fence_signal(struct dma_fence * fence)'/>
<dec f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='135' type='int dma_fence_signal(struct dma_fence * )'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='135' c='dma_fence_signal'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='135' u='a'/>
<use f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='135' u='a'/>
<doc f='linux-4.14.y/drivers/dma-buf/dma-fence.c' l='99'>/**
 * dma_fence_signal - signal completion of a fence
 * @fence: the fence to signal
 *
 * Signal completion for software callbacks on a fence, this will unblock
 * dma_fence_wait() calls and run all the callbacks added with
 * dma_fence_add_callback(). Can be called multiple times, but since a fence
 * can only go from unsignaled to signaled state, it will only be effective
 * the first time.
 */</doc>
<use f='linux-4.14.y/drivers/gpu/drm/drm_file.c' l='711' u='c' c='drm_send_event_locked'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_syncobj.c' l='221' u='c' c='drm_syncobj_assign_null_handle'/>
<use f='linux-4.14.y/drivers/gpu/drm/qxl/qxl_release.c' l='196' u='c' c='qxl_release_free'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c' l='720' u='c' c='vmw_fence_fifo_down'/>
