<dec f='linux-4.14.y/include/linux/fs.h' l='3166' type='void setattr_copy(struct inode * inode, const struct iattr * attr)'/>
<def f='linux-4.14.y/fs/attr.c' l='157' ll='182' type='void setattr_copy(struct inode * inode, const struct iattr * attr)'/>
<dec f='linux-4.14.y/fs/attr.c' l='183' type='void setattr_copy(struct inode * , const struct iattr * )'/>
<use f='linux-4.14.y/fs/attr.c' l='183' c='setattr_copy'/>
<use f='linux-4.14.y/fs/attr.c' l='183' u='a'/>
<use f='linux-4.14.y/fs/attr.c' l='183' u='a'/>
<doc f='linux-4.14.y/fs/attr.c' l='142'>/**
 * setattr_copy - copy simple metadata updates into the generic inode
 * @inode:	the inode to be updated
 * @attr:	the new attributes
 *
 * setattr_copy must be called with i_mutex held.
 *
 * setattr_copy updates the inode&apos;s metadata with that specified
 * in attr. Noticeably missing is inode size update, which is more complex
 * as it requires pagecache updates.
 *
 * The inode is not marked as dirty after this operation. The rationale is
 * that for &quot;simple&quot; filesystems, the struct inode is the inode storage.
 * The caller is free to mark the inode dirty afterwards if needed.
 */</doc>
<use f='linux-4.14.y/fs/ext4/inode.c' l='5480' u='c' c='ext4_setattr'/>
<use f='linux-4.14.y/fs/kernfs/inode.c' l='131' u='c' c='kernfs_iop_setattr'/>
<use f='linux-4.14.y/fs/libfs.c' l='410' u='c' c='simple_setattr'/>
<use f='linux-4.14.y/fs/proc/base.c' l='678' u='c' c='proc_setattr'/>
<use f='linux-4.14.y/fs/proc/generic.c' l='115' u='c' c='proc_notify_change'/>
<use f='linux-4.14.y/fs/proc/proc_sysctl.c' l='817' u='c' c='proc_sys_setattr'/>
<use f='linux-4.14.y/fs/udf/file.c' l='273' u='c' c='udf_setattr'/>
<use f='linux-4.14.y/mm/shmem.c' l='1062' u='c' c='shmem_setattr'/>
<dec f='linux-4.14.y/include/linux/fs.h' l='3166' type='void setattr_copy(struct inode * inode, const struct iattr * attr)'/>
<def f='linux-4.14.y/fs/attr.c' l='157' ll='182' type='void setattr_copy(struct inode * inode, const struct iattr * attr)'/>
<dec f='linux-4.14.y/fs/attr.c' l='183' type='void setattr_copy(struct inode * , const struct iattr * )'/>
<use f='linux-4.14.y/fs/attr.c' l='183' c='setattr_copy'/>
<use f='linux-4.14.y/fs/attr.c' l='183' u='a'/>
<use f='linux-4.14.y/fs/attr.c' l='183' u='a'/>
<doc f='linux-4.14.y/fs/attr.c' l='142'>/**
 * setattr_copy - copy simple metadata updates into the generic inode
 * @inode:	the inode to be updated
 * @attr:	the new attributes
 *
 * setattr_copy must be called with i_mutex held.
 *
 * setattr_copy updates the inode&apos;s metadata with that specified
 * in attr. Noticeably missing is inode size update, which is more complex
 * as it requires pagecache updates.
 *
 * The inode is not marked as dirty after this operation. The rationale is
 * that for &quot;simple&quot; filesystems, the struct inode is the inode storage.
 * The caller is free to mark the inode dirty afterwards if needed.
 */</doc>
<use f='linux-4.14.y/fs/ext4/inode.c' l='5480' u='c' c='ext4_setattr'/>
<use f='linux-4.14.y/fs/fat/file.c' l='512' u='c' c='fat_setattr'/>
<use f='linux-4.14.y/fs/hugetlbfs/inode.c' l='694' u='c' c='hugetlbfs_setattr'/>
<use f='linux-4.14.y/fs/kernfs/inode.c' l='131' u='c' c='kernfs_iop_setattr'/>
<use f='linux-4.14.y/fs/libfs.c' l='410' u='c' c='simple_setattr'/>
<use f='linux-4.14.y/fs/proc/base.c' l='678' u='c' c='proc_setattr'/>
<use f='linux-4.14.y/fs/proc/generic.c' l='115' u='c' c='proc_notify_change'/>
<use f='linux-4.14.y/fs/proc/proc_sysctl.c' l='817' u='c' c='proc_sys_setattr'/>
<use f='linux-4.14.y/fs/udf/file.c' l='273' u='c' c='udf_setattr'/>
<use f='linux-4.14.y/mm/shmem.c' l='1062' u='c' c='shmem_setattr'/>
