<dec f='linux-4.14.y/include/linux/usb/gadget.h' l='243' type='int usb_ep_set_halt(struct usb_ep * ep)'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_acm.c' l='324' u='c' c='acm_complete_set_line_coding'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_fs.c' l='312' u='c' c='__ffs_ep0_stall'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_fs.c' l='970' u='c' c='ffs_epfile_io'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_mass_storage.c' l='386' u='c' c='fsg_set_halt'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_mass_storage.c' l='1411' u='c' c='halt_bulk_in_endpoint'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_ncm.c' l='682' u='c' c='ncm_ep0out_complete'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_sourcesink.c' l='499' u='c' c='check_read_data'/>
<use f='linux-4.14.y/drivers/usb/gadget/function/f_sourcesink.c' l='575' u='c' c='source_sink_complete'/>
<def f='linux-4.14.y/drivers/usb/gadget/udc/core.c' l='325' ll='333' type='int usb_ep_set_halt(struct usb_ep * ep)'/>
<dec f='linux-4.14.y/drivers/usb/gadget/udc/core.c' l='334' type='int usb_ep_set_halt(struct usb_ep * )'/>
<use f='linux-4.14.y/drivers/usb/gadget/udc/core.c' l='334' c='usb_ep_set_halt'/>
<use f='linux-4.14.y/drivers/usb/gadget/udc/core.c' l='334' u='a'/>
<use f='linux-4.14.y/drivers/usb/gadget/udc/core.c' l='334' u='a'/>
<doc f='linux-4.14.y/drivers/usb/gadget/udc/core.c' l='304'>/**
 * usb_ep_set_halt - sets the endpoint halt feature.
 * @ep: the non-isochronous endpoint being stalled
 *
 * Use this to stall an endpoint, perhaps as an error report.
 * Except for control endpoints,
 * the endpoint stays halted (will not stream any data) until the host
 * clears this feature; drivers may need to empty the endpoint&apos;s request
 * queue first, to make sure no inappropriate transfers happen.
 *
 * Note that while an endpoint CLEAR_FEATURE will be invisible to the
 * gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
 * current altsetting, see usb_ep_clear_halt().  When switching altsettings,
 * it&apos;s simplest to use usb_ep_enable() or usb_ep_disable() for the endpoints.
 *
 * Returns zero, or a negative error code.  On success, this call sets
 * underlying hardware state that blocks data transfers.
 * Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
 * transfer requests are still queued, or if the controller hardware
 * (usually a FIFO) still holds bytes that the host hasn&apos;t collected.
 */</doc>
