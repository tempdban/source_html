<dec f='linux-4.18.y/include/linux/usb/gadget.h' l='247' type='int usb_ep_set_halt(struct usb_ep * ep)'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_acm.c' l='321' u='c' c='acm_complete_set_line_coding'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_fs.c' l='310' u='c' c='__ffs_ep0_stall'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_fs.c' l='970' u='c' c='ffs_epfile_io'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_mass_storage.c' l='387' u='c' c='fsg_set_halt'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_mass_storage.c' l='1412' u='c' c='halt_bulk_in_endpoint'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_ncm.c' l='676' u='c' c='ncm_ep0out_complete'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_sourcesink.c' l='495' u='c' c='check_read_data'/>
<use f='linux-4.18.y/drivers/usb/gadget/function/f_sourcesink.c' l='571' u='c' c='source_sink_complete'/>
<def f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='320' ll='328' type='int usb_ep_set_halt(struct usb_ep * ep)'/>
<dec f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='329' type='int usb_ep_set_halt(struct usb_ep * )'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='329' c='usb_ep_set_halt'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='329' u='a'/>
<use f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='329' u='a'/>
<doc f='linux-4.18.y/drivers/usb/gadget/udc/core.c' l='299'>/**
 * usb_ep_set_halt - sets the endpoint halt feature.
 * @ep: the non-isochronous endpoint being stalled
 *
 * Use this to stall an endpoint, perhaps as an error report.
 * Except for control endpoints,
 * the endpoint stays halted (will not stream any data) until the host
 * clears this feature; drivers may need to empty the endpoint&apos;s request
 * queue first, to make sure no inappropriate transfers happen.
 *
 * Note that while an endpoint CLEAR_FEATURE will be invisible to the
 * gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
 * current altsetting, see usb_ep_clear_halt().  When switching altsettings,
 * it&apos;s simplest to use usb_ep_enable() or usb_ep_disable() for the endpoints.
 *
 * Returns zero, or a negative error code.  On success, this call sets
 * underlying hardware state that blocks data transfers.
 * Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
 * transfer requests are still queued, or if the controller hardware
 * (usually a FIFO) still holds bytes that the host hasn&apos;t collected.
 */</doc>
