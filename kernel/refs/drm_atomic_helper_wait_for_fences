<dec f='linux-4.14.y/include/drm/drm_atomic_helper.h' l='55' type='int drm_atomic_helper_wait_for_fences(struct drm_device * dev, struct drm_atomic_state * state, bool pre_swap)'/>
<def f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1156' ll='1184' type='int drm_atomic_helper_wait_for_fences(struct drm_device * dev, struct drm_atomic_state * state, bool pre_swap)'/>
<dec f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1185' type='int drm_atomic_helper_wait_for_fences(struct drm_device * , struct drm_atomic_state * , bool )'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1185' c='drm_atomic_helper_wait_for_fences'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1185' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1185' u='a'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1351' u='c' c='commit_tail'/>
<use f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1527' u='c' c='drm_atomic_helper_commit'/>
<doc f='linux-4.14.y/drivers/gpu/drm/drm_atomic_helper.c' l='1135'>/**
 * drm_atomic_helper_wait_for_fences - wait for fences stashed in plane state
 * @dev: DRM device
 * @state: atomic state object with old state structures
 * @pre_swap: If true, do an interruptible wait, and @state is the new state.
 * 	Otherwise @state is the old state.
 *
 * For implicit sync, driver should fish the exclusive fence out from the
 * incoming fb&apos;s and stash it in the drm_plane_state.  This is called after
 * drm_atomic_helper_swap_state() so it uses the current plane state (and
 * just uses the atomic state to find the changed planes)
 *
 * Note that @pre_swap is needed since the point where we block for fences moves
 * around depending upon whether an atomic commit is blocking or
 * non-blocking. For non-blocking commit all waiting needs to happen after
 * drm_atomic_helper_swap_state() is called, but for blocking commits we want
 * to wait **before** we do anything that can&apos;t be easily rolled back. That is
 * before we call drm_atomic_helper_swap_state().
 *
 * Returns zero if success or &lt; 0 if dma_fence_wait() fails.
 */</doc>
