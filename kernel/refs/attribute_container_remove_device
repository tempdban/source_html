<dec f='linux-4.14.y/include/linux/attribute_container.h' l='50' type='void attribute_container_remove_device(struct device * dev, void (*)(struct attribute_container *, struct device *, struct device *) fn)'/>
<def f='linux-4.14.y/drivers/base/attribute_container.c' l='206' ll='238' type='void attribute_container_remove_device(struct device * dev, void (*)(struct attribute_container *, struct device *, struct device *) fn)'/>
<doc f='linux-4.14.y/drivers/base/attribute_container.c' l='191'>/**
 * attribute_container_remove_device - make device eligible for removal.
 *
 * @dev:  The generic device
 * @fn:	  A function to call to remove the device
 *
 * This routine triggers device removal.  If fn is NULL, then it is
 * simply done via device_unregister (note that if something
 * still has a reference to the classdev, then the memory occupied
 * will not be freed until the classdev is released).  If you want a
 * two phase release: remove from visibility and then delete the
 * device, then you should use this routine with a fn that calls
 * device_del() and then use attribute_container_device_trigger()
 * to do the final put on the classdev.
 */</doc>
<use f='linux-4.14.y/drivers/base/transport_class.c' l='278' u='c' c='transport_destroy_device'/>
