<dec f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h' l='1061' type='int vmw_surface_gb_priv_define(struct drm_device * dev, uint32_t user_accounting_size, uint32_t svga3d_flags, SVGA3dSurfaceFormat format, bool for_scanout, uint32_t num_mip_levels, uint32_t multisample_count, uint32_t array_size, struct drm_vmw_size size, struct vmw_surface ** srf_out)'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c' l='1247' u='c' c='vmw_create_dmabuf_proxy'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c' l='1235' u='c' c='vmw_stdu_primary_plane_prepare_fb'/>
<use f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c' l='1293' u='c' c='vmw_gb_surface_define_ioctl'/>
<def f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c' l='1469' ll='1595' type='int vmw_surface_gb_priv_define(struct drm_device * dev, uint32_t user_accounting_size, uint32_t svga3d_flags, SVGA3dSurfaceFormat format, bool for_scanout, uint32_t num_mip_levels, uint32_t multisample_count, uint32_t array_size, struct drm_vmw_size size, struct vmw_surface ** srf_out)'/>
<doc f='linux-4.14.y/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c' l='1449'>/**
 * vmw_surface_gb_priv_define - Define a private GB surface
 *
 * @dev:  Pointer to a struct drm_device
 * @user_accounting_size:  Used to track user-space memory usage, set
 *                         to 0 for kernel mode only memory
 * @svga3d_flags: SVGA3d surface flags for the device
 * @format: requested surface format
 * @for_scanout: true if inteded to be used for scanout buffer
 * @num_mip_levels:  number of MIP levels
 * @multisample_count:
 * @array_size: Surface array size.
 * @size: width, heigh, depth of the surface requested
 * @user_srf_out: allocated user_srf.  Set to NULL on failure.
 *
 * GB surfaces allocated by this function will not have a user mode handle, and
 * thus will only be visible to vmwgfx.  For optimization reasons the
 * surface may later be given a user mode handle by another function to make
 * it available to user mode drivers.
 */</doc>
