<def f='vpp_1804/src/vnet/ip/ip_source_and_port_range_check.h' l='102' ll='126'/>
<size>320</size>
<doc f='vpp_1804/src/vnet/ip/ip_source_and_port_range_check.h' l='68'>/**
 * @brief
 *  The object that is in the data-path to perform the check.
 *
 * Some trade-offs here; memory vs performance.
 *
 * performance:
 *  the principle factor is d-cache line misses/hits.
 *  so we want the data layout to minimise the d-cache misses. This
 *  means not following dependent reads. i.e. not doing
 *
 *   struct B {
 *     u16 n_ranges;
 *     range_t *ragnes; // vector of ranges.
 *   }
 *
 *   so to read ranges[0] we would first d-cache miss on the address
 *   of the object of type B, for which we would need to wait before we
 *   can get the address of B-&gt;ranges.
 *   So this layout is better:
 *
 *  struct B {
 *    u16 n_ranges;
 *    range_t ragnes[N];
 *  }
 *
 * memory:
 *  the latter layout above is more memory hungry. And N needs to be:
 *   1 - sized for the maximum required
 *   2 - fixed, so that objects of type B can be pool allocated and so
 *       &apos;get&apos;-able using an index.
 *       An option over fixed might be to allocate contiguous chunk from
 *       the pool (like we used to do for multi-path adjs).
 */</doc>
<mbr r='protocol_port_range_dpo_t_::cacheline0' o='0' t='u8 [0]'/>
<mbr r='protocol_port_range_dpo_t_::n_used_blocks' o='0' t='u16'/>
<mbr r='protocol_port_range_dpo_t_::n_free_ranges' o='16' t='u16'/>
<mbr r='protocol_port_range_dpo_t_::blocks' o='128' t='protocol_port_range_t [8]'/>
