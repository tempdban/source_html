<dec f='vpp_1804/src/vnet/session/session_lookup.h' l='42' type='transport_connection_t * session_lookup_connection_wt6(u32 fib_index, ip6_address_t * lcl, ip6_address_t * rmt, u16 lcl_port, u16 rmt_port, u8 proto, u32 thread_index, u8 * is_filtered)'/>
<use f='vpp_1804/src/vnet/sctp/sctp_input.c' l='191' u='c' c='sctp_lookup_connection'/>
<use f='vpp_1804/src/vnet/sctp/sctp_input.c' l='2162' u='c' c='sctp46_input_dispatcher'/>
<def f='vpp_1804/src/vnet/session/session_lookup.c' l='1105' ll='1155' type='transport_connection_t * session_lookup_connection_wt6(u32 fib_index, ip6_address_t * lcl, ip6_address_t * rmt, u16 lcl_port, u16 rmt_port, u8 proto, u32 thread_index, u8 * is_filtered)'/>
<doc f='vpp_1804/src/vnet/session/session_lookup.c' l='1080'>/**
 * Lookup connection with ip6 and transport layer information
 *
 * This is used on the fast path so it needs to be fast. Thereby,
 * duplication of code and &apos;hacks&apos; allowed.
 *
 * The lookup is incremental and returns whenever something is matched. The
 * steps are:
 * - Try to find an established session
 * - Try to find a half-open connection
 * - Try session rules table
 * - Try to find a fully-formed or local source wildcarded (listener bound to
 *   all interfaces) listener session
 * - return 0
 *
 * @param fib_index	index of the fib wherein the connection was received
 * @param lcl		local ip6 address
 * @param rmt		remote ip6 address
 * @param lcl_port	local port
 * @param rmt_port	remote port
 * @param proto		transport protocol (e.g., tcp, udp)
 * @param thread_index	thread index for request
 *
 * @return pointer to transport connection, if one is found, 0 otherwise
 */</doc>
<use f='vpp_1804/src/vnet/tcp/tcp_input.c' l='1942' u='c' c='tcp_lookup_connection'/>
<use f='vpp_1804/src/vnet/tcp/tcp_input.c' l='3001' u='c' c='tcp46_input_inline'/>
