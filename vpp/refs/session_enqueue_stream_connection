<dec f='vpp_1804/src/vnet/session/session.h' l='460' type='int session_enqueue_stream_connection(transport_connection_t * tc, vlib_buffer_t * b, u32 offset, u8 queue_event, u8 is_in_order)'/>
<use f='vpp_1804/src/vnet/sctp/sctp_input.c' l='616' u='c' c='sctp_session_enqueue_data_ooo'/>
<use f='vpp_1804/src/vnet/sctp/sctp_input.c' l='671' u='c' c='sctp_session_enqueue_data'/>
<def f='vpp_1804/src/vnet/session/session.c' l='303' ll='356' type='int session_enqueue_stream_connection(transport_connection_t * tc, vlib_buffer_t * b, u32 offset, u8 queue_event, u8 is_in_order)'/>
<doc f='vpp_1804/src/vnet/session/session.c' l='289'>/*
 * Enqueue data for delivery to session peer. Does not notify peer of enqueue
 * event but on request can queue notification events for later delivery by
 * calling stream_server_flush_enqueue_events().
 *
 * @param tc Transport connection which is to be enqueued data
 * @param b Buffer to be enqueued
 * @param offset Offset at which to start enqueueing if out-of-order
 * @param queue_event Flag to indicate if peer is to be notified or if event
 *                    is to be queued. The former is useful when more data is
 *                    enqueued and only one event is to be generated.
 * @param is_in_order Flag to indicate if data is in order
 * @return Number of bytes enqueued or a negative value if enqueueing failed.
 */</doc>
<use f='vpp_1804/src/vnet/tcp/tcp_input.c' l='1395' u='c' c='tcp_session_enqueue_data'/>
<use f='vpp_1804/src/vnet/tcp/tcp_input.c' l='1457' u='c' c='tcp_session_enqueue_ooo'/>
