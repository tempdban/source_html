<dec f='vpp_1804/src/vnet/fib/fib_path.h' l='170' type='int fib_path_recursive_loop_detect(fib_node_index_t path_index, fib_node_index_t ** entry_indicies)'/>
<def f='vpp_1804/src/vnet/fib/fib_path.c' l='1743' ll='1826' type='int fib_path_recursive_loop_detect(fib_node_index_t path_index, fib_node_index_t ** entry_indicies)'/>
<doc f='vpp_1804/src/vnet/fib/fib_path.c' l='1724'>/*
 * fib_path_recursive_loop_detect
 *
 * A forward walk of the FIB object graph to detect for a cycle/loop. This
 * walk is initiated when an entry is linking to a new path list or from an old.
 * The entry vector passed contains all the FIB entrys that are children of this
 * path (it is all the entries encountered on the walk so far). If this vector
 * contains the entry this path resolve via, then a loop is about to form.
 * The loop must be allowed to form, since we need the dependencies in place
 * so that we can track when the loop breaks.
 * However, we MUST not produce a loop in the forwarding graph (else packets
 * would loop around the switch path until the loop breaks), so we mark recursive
 * paths as looped so that they do not contribute forwarding information.
 * By marking the path as looped, an etry such as;
 *    X/Y
 *     via a.a.a.a (looped)
 *     via b.b.b.b (not looped)
 * can still forward using the info provided by b.b.b.b only
 */</doc>
<use f='vpp_1804/src/vnet/fib/fib_path_list.c' l='1202' u='c' c='fib_path_list_recursive_loop_detect'/>
