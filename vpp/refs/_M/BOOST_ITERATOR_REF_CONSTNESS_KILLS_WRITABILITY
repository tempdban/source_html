<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<use f='include/boost/iterator/detail/facade_iterator_category.hpp' l='25' u='a'/>
<use f='include/boost/iterator/detail/facade_iterator_category.hpp' l='60' u='a'/>
<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<use f='include/boost/iterator/iterator_adaptor.hpp' l='25' u='a'/>
<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<use f='include/boost/iterator/iterator_adaptor.hpp' l='184' u='a'/>
<dec f='include/boost/iterator/detail/config_def.hpp' l='45'/>
<doc f='include/boost/iterator/detail/config_def.hpp' l='32'>// Recall that in general, compilers without partial specialization
// can&apos;t strip constness.  Consider counting_iterator, which normally
// passes a const Value to iterator_facade.  As a result, any code
// which makes a std::vector of the iterator&apos;s value_type will fail
// when its allocator declares functions overloaded on reference and
// const_reference (the same type).
//
// Furthermore, Borland 5.5.1 drops constness in enough ways that we
// end up using a proxy for operator[] when we otherwise shouldn&apos;t.
// Using reference constness gives it an extra hint that it can
// return the value_type from operator[] directly, but is not
// strictly necessary.  Not sure how best to resolve this one.</doc>
