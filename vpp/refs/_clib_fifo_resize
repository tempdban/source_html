<dec f='vpp_1804/src/vppinfra/fifo.h' l='99' type='void * _clib_fifo_resize(void * v, uword n_elts, uword elt_bytes)'/>
<use f='vpp_1804/src/vppinfra/fifo.h' l='108' u='c' c='_clib_fifo_validate'/>
<use f='vpp_1804/src/vppinfra/fifo.h' l='126' u='c' c='_clib_fifo_advance_tail'/>
<doc f='vpp_1804/src/vppinfra/fifo.h' l='98'>/* External resize function. */</doc>
<use f='vpp_1804/src/vnet/pg/input.c' l='1296' macro='1' u='c'/>
<def f='vpp_1804/src/vppinfra/fifo.c' l='79' ll='129' type='void * _clib_fifo_resize(void * v_old, uword n_new_elts, uword elt_bytes)'/>
<doc f='vpp_1804/src/vppinfra/fifo.c' l='43'>/*
  General first in/first out queues.
  FIFOs can have arbitrary size and type.
  Let T be any type (i.e. char, int, struct foo, etc.).

  A null fifo is initialized:

    T * f = 0;

  For example, typedef struct { int a, b; } T;

  Elements can be added in 3 ways.

    #1 1 element is added:
       T x;
       x.a = 10; x.b = 20;
       fifo_add1 (f, x);

    #2 n elements are added
       T buf[10];
       initialize buf[0] .. buf[9];
       fifo_add (f, buf, 10);

    #3 1 element is added, pointer is returned
       T * x;
       fifo_add2 (f, x);
       x-&gt;a = 10;
       x-&gt;b = 20;

   Elements are removed 1 at a time:
       T x;
       fifo_sub1 (f, x);

   fifo_free (f) frees fifo.
*/</doc>
