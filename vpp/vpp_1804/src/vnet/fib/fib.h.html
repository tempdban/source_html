<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>fib.h source code [vpp_1804/src/vnet/fib/fib.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'vpp_1804/src/vnet/fib/fib.h'; var root_path = '../../../..'; var data_path = '../../../../../data';</script>
<script src='../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>vpp_1804</a>/<a href='../..'>src</a>/<a href='..'>vnet</a>/<a href='./'>fib</a>/<a href='fib.h.html'>fib.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i> * Copyright (c) 2016 Cisco and/or its affiliates.</i></td></tr>
<tr><th id="3">3</th><td><i> * Licensed under the Apache License, Version 2.0 (the "License");</i></td></tr>
<tr><th id="4">4</th><td><i> * you may not use this file except in compliance with the License.</i></td></tr>
<tr><th id="5">5</th><td><i> * You may obtain a copy of the License at:</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></i></td></tr>
<tr><th id="8">8</th><td><i> *</i></td></tr>
<tr><th id="9">9</th><td><i> * Unless required by applicable law or agreed to in writing, software</i></td></tr>
<tr><th id="10">10</th><td><i> * distributed under the License is distributed on an "AS IS" BASIS,</i></td></tr>
<tr><th id="11">11</th><td><i> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i></td></tr>
<tr><th id="12">12</th><td><i> * See the License for the specific language governing permissions and</i></td></tr>
<tr><th id="13">13</th><td><i> * limitations under the License.</i></td></tr>
<tr><th id="14">14</th><td><i> */</i></td></tr>
<tr><th id="15">15</th><td><i class="doc">/**</i></td></tr>
<tr><th id="16">16</th><td><i class="doc"> * <span class="command">\brief</span></i></td></tr>
<tr><th id="17">17</th><td><i class="doc"> * A IP v4/6 independent FIB.</i></td></tr>
<tr><th id="18">18</th><td><i class="doc"> *</i></td></tr>
<tr><th id="19">19</th><td><i class="doc"> * The main functions provided by the FIB are as follows;</i></td></tr>
<tr><th id="20">20</th><td><i class="doc"> *</i></td></tr>
<tr><th id="21">21</th><td><i class="doc"> *  - source priorities</i></td></tr>
<tr><th id="22">22</th><td><i class="doc"> *</i></td></tr>
<tr><th id="23">23</th><td><i class="doc"> *   A route can be added to the FIB by more than entity or source. Sources</i></td></tr>
<tr><th id="24">24</th><td><i class="doc"> * include, but are not limited to, API, CLI, LISP, MAP, etc (for the full list</i></td></tr>
<tr><th id="25">25</th><td><i class="doc"> * see fib_entry.h). Each source provides the forwarding information (FI) that</i></td></tr>
<tr><th id="26">26</th><td><i class="doc"> * is has determined as required for that route. Since each source determines the</i></td></tr>
<tr><th id="27">27</th><td><i class="doc"> * FI using different best  path and loop prevention algorithms, it is not</i></td></tr>
<tr><th id="28">28</th><td><i class="doc"> * correct for the FI of multiple sources to be combined. Instead the FIB must</i></td></tr>
<tr><th id="29">29</th><td><i class="doc"> * choose to use the FI from only one source. This choose is based on a static</i></td></tr>
<tr><th id="30">30</th><td><i class="doc"> * priority assignment. For example;</i></td></tr>
<tr><th id="31">31</th><td><i class="doc"> * IF a prefix is added as a result of interface configuration:</i></td></tr>
<tr><th id="32">32</th><td><i class="doc"> *    set interface address 192.168.1.1/24 GigE0</i></td></tr>
<tr><th id="33">33</th><td><i class="doc"> * and then it is also added from the CLI</i></td></tr>
<tr><th id="34">34</th><td><i class="doc"> *    ip route 192.168.1.1/32 via 2.2.2.2/32</i></td></tr>
<tr><th id="35">35</th><td><i class="doc"> * then the 'interface' source will prevail, and the route will remain as</i></td></tr>
<tr><th id="36">36</th><td><i class="doc"> * 'local'.</i></td></tr>
<tr><th id="37">37</th><td><i class="doc"> * The requirement of the FIB is to always install the FI from the winning</i></td></tr>
<tr><th id="38">38</th><td><i class="doc"> * source and thus to maintain the FI added by losing sources so it can be</i></td></tr>
<tr><th id="39">39</th><td><i class="doc"> * installed should the winning source be withdrawn.</i></td></tr>
<tr><th id="40">40</th><td><i class="doc"> *</i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> *  - adj-fib maintenance</i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> *</i></td></tr>
<tr><th id="43">43</th><td><i class="doc"> *   When ARP or ND discover a neighbour on a link an adjacency forms for the</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> * address of that neighbour. It is also required to insert a route in the</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> * appropriate FIB table, corresponding to the VRF for the link, an entry for</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> * that neighbour. This entry is often referred to as an adj-fib. Adj-fibs</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> * have a dedicated source; 'ADJ'.</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> * The priority of the ADJ source is lower than most. This is so the following</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> * config;</i></td></tr>
<tr><th id="50">50</th><td><i class="doc"> *    set interface address 192.168.1.1/32 GigE0</i></td></tr>
<tr><th id="51">51</th><td><i class="doc"> *    ip arp 192.168.1.2 GigE0 dead.dead.dead</i></td></tr>
<tr><th id="52">52</th><td><i class="doc"> *    ip route add 192.168.1.2 via 10.10.10.10 GigE1</i></td></tr>
<tr><th id="53">53</th><td><i class="doc"> * will forward traffic for 192.168.1.2 via GigE1. That is the route added</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> * by the control plane is favoured over the adjacency discovered by ARP.</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> * The control plane, with its associated authentication, is considered the</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> * authoritative source.</i></td></tr>
<tr><th id="57">57</th><td><i class="doc"> * To counter the nefarious addition of adj-fib, through the nefarious injection</i></td></tr>
<tr><th id="58">58</th><td><i class="doc"> * of adjacencies, the FIB is also required to ensure that only adj-fibs whose</i></td></tr>
<tr><th id="59">59</th><td><i class="doc"> * less specific covering prefix is connected are installed in forwarding. This</i></td></tr>
<tr><th id="60">60</th><td><i class="doc"> * requires the use of 'cover tracking', where a route maintains a dependency</i></td></tr>
<tr><th id="61">61</th><td><i class="doc"> * relationship with the route that is its less specific cover. When this cover</i></td></tr>
<tr><th id="62">62</th><td><i class="doc"> * changes (i.e. there is a new covering route) or the forwarding information</i></td></tr>
<tr><th id="63">63</th><td><i class="doc"> * of the cover changes, then the covered route is notified.</i></td></tr>
<tr><th id="64">64</th><td><i class="doc"> *</i></td></tr>
<tr><th id="65">65</th><td><i class="doc"> * Overlapping sub-nets are not supported, so no adj-fib has multiple paths.</i></td></tr>
<tr><th id="66">66</th><td><i class="doc"> * The control plane is expected to remove a prefix configured for an interface</i></td></tr>
<tr><th id="67">67</th><td><i class="doc"> * before the interface changes VRF.</i></td></tr>
<tr><th id="68">68</th><td><i class="doc"> * So while the following config is accepted:</i></td></tr>
<tr><th id="69">69</th><td><i class="doc"> *    set interface address 192.168.1.1/32 GigE0</i></td></tr>
<tr><th id="70">70</th><td><i class="doc"> *    ip arp 192.168.1.2 GigE0 dead.dead.dead</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> *    set interface ip table GigE0 2</i></td></tr>
<tr><th id="72">72</th><td><i class="doc"> * it does not result in the desired behaviour.</i></td></tr>
<tr><th id="73">73</th><td><i class="doc"> *</i></td></tr>
<tr><th id="74">74</th><td><i class="doc"> *  - attached export.</i></td></tr>
<tr><th id="75">75</th><td><i class="doc"> *</i></td></tr>
<tr><th id="76">76</th><td><i class="doc"> * Further to adj-fib maintenance above consider the following config:</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> *    set interface address 192.168.1.1/24 GigE0</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> *    ip route add table 2 192.168.1.0/24 GigE0</i></td></tr>
<tr><th id="79">79</th><td><i class="doc"> * Traffic destined for 192.168.1.2 in table 2 will generate an ARP request</i></td></tr>
<tr><th id="80">80</th><td><i class="doc"> * on GigE0. However, since GigE0 is in table 0, all adj-fibs will be added in</i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> * FIB 0. Hence all hosts in the sub-net are unreachable from table 2. To resolve</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> * this, all adj-fib and local prefixes are exported (i.e. copied) from the </i></td></tr>
<tr><th id="83">83</th><td><i class="doc"> * 'export' table 0, to the 'import' table 2. There can be many import tables</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * for a single export table.</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> *</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> *  - recursive route resolution</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> *</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> *   A recursive route is of the form:</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> *       1.1.1.1/32 via 10.10.10.10</i></td></tr>
<tr><th id="90">90</th><td><i class="doc"> * i.e. a route for which no egress interface is provided. In order to forward</i></td></tr>
<tr><th id="91">91</th><td><i class="doc"> * traffic to 1.1.1.1/32 the FIB must therefore first determine how to forward</i></td></tr>
<tr><th id="92">92</th><td><i class="doc"> * traffic to 10.10.10.10/32. This is recursive resolution.</i></td></tr>
<tr><th id="93">93</th><td><i class="doc"> * Recursive resolution, just like normal resolution, proceeds via a longest</i></td></tr>
<tr><th id="94">94</th><td><i class="doc"> * prefix match for the 'via-address' 10.10.10.10. Note it is only possible</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> * to add routes via an address (i.e. a /32 or /128) not via a shorter mask</i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> * prefix. There is no use case for the latter.</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> * Since recursive resolution proceeds via a longest prefix match, the entry</i></td></tr>
<tr><th id="98">98</th><td><i class="doc"> * in the FIB that will resolve the recursive route, termed the via-entry, may</i></td></tr>
<tr><th id="99">99</th><td><i class="doc"> * change as other routes are added to the FIB. Consider the recursive</i></td></tr>
<tr><th id="100">100</th><td><i class="doc"> * route shown above, and this non-recursive route:</i></td></tr>
<tr><th id="101">101</th><td><i class="doc"> *       10.10.10.0/24 via 192.168.16.1 GigE0</i></td></tr>
<tr><th id="102">102</th><td><i class="doc"> * The entry for 10.10.10.0/24 is thus the resolving via-entry. If this entry is</i></td></tr>
<tr><th id="103">103</th><td><i class="doc"> * modified, to say;</i></td></tr>
<tr><th id="104">104</th><td><i class="doc"> *       10.10.10.0/24 via 192.16.1.3 GigE0</i></td></tr>
<tr><th id="105">105</th><td><i class="doc"> * Then packet for 1.1.1.1/32 must also be sent to the new next-hop.</i></td></tr>
<tr><th id="106">106</th><td><i class="doc"> * Now consider the addition of;</i></td></tr>
<tr><th id="107">107</th><td><i class="doc"> *       10.10.10.0/28 via 192.168.16.2 GigE0</i></td></tr>
<tr><th id="108">108</th><td><i class="doc"> * The more specific /28 is a better longest prefix match and thus becomes the</i></td></tr>
<tr><th id="109">109</th><td><i class="doc"> * via-entry. Removal of the /28 means the resolution will revert to the /24.</i></td></tr>
<tr><th id="110">110</th><td><i class="doc"> * The tracking to the changes in recursive resolution is the requirement of</i></td></tr>
<tr><th id="111">111</th><td><i class="doc"> * the FIB. When the forwarding information of the via-entry changes a back-walk</i></td></tr>
<tr><th id="112">112</th><td><i class="doc"> * is used to update dependent recursive routes. When new routes are added to</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * the table the cover tracking feature provides the necessary notifications to</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> * the via-entry routes.</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> * The adjacency constructed for 1.1.1.1/32 will be a recursive adjacency</i></td></tr>
<tr><th id="116">116</th><td><i class="doc"> * whose next adjacency will be contributed from the via-entry. Maintaining</i></td></tr>
<tr><th id="117">117</th><td><i class="doc"> * the validity of this recursive adjacency is a requirement of the FIB.</i></td></tr>
<tr><th id="118">118</th><td><i class="doc"> *</i></td></tr>
<tr><th id="119">119</th><td><i class="doc"> *  - recursive loop avoidance</i></td></tr>
<tr><th id="120">120</th><td><i class="doc"> *</i></td></tr>
<tr><th id="121">121</th><td><i class="doc"> * Consider this set of routes:</i></td></tr>
<tr><th id="122">122</th><td><i class="doc"> *     1.1.1.1/32 via 2.2.2.2</i></td></tr>
<tr><th id="123">123</th><td><i class="doc"> *     2.2.2.2/32 via 3.3.3.3</i></td></tr>
<tr><th id="124">124</th><td><i class="doc"> *     3.3.3.3/32 via 1.1.1.1</i></td></tr>
<tr><th id="125">125</th><td><i class="doc"> * this is termed a recursion loop - all of the routes in the loop are</i></td></tr>
<tr><th id="126">126</th><td><i class="doc"> * unresolved in so far as they do not have a resolving adjacency, but each</i></td></tr>
<tr><th id="127">127</th><td><i class="doc"> * is resolved because the via-entry is known. It is important here to note</i></td></tr>
<tr><th id="128">128</th><td><i class="doc"> * the distinction between the control-plane objects and the data-plane objects</i></td></tr>
<tr><th id="129">129</th><td><i class="doc"> * (more details in the implementation section). The control plane objects must</i></td></tr>
<tr><th id="130">130</th><td><i class="doc"> * allow the loop to form (i.e. the graph becomes cyclic), however, the</i></td></tr>
<tr><th id="131">131</th><td><i class="doc"> * data-plane absolutely must not allow the loop to form, otherwise the packet</i></td></tr>
<tr><th id="132">132</th><td><i class="doc"> * would loop indefinitely and never egress the device - meltdown would follow.</i></td></tr>
<tr><th id="133">133</th><td><i class="doc"> * The control plane must allow the loop to form, because when the loop breaks,</i></td></tr>
<tr><th id="134">134</th><td><i class="doc"> * all members of the loop need to be updated. Forming the loop allows the</i></td></tr>
<tr><th id="135">135</th><td><i class="doc"> * dependencies to be correctly setup to allow this to happen.</i></td></tr>
<tr><th id="136">136</th><td><i class="doc"> * There is no limit to the depth of recursion supported by VPP so:</i></td></tr>
<tr><th id="137">137</th><td><i class="doc"> *    9.9.9.100/32 via 9.9.9.99</i></td></tr>
<tr><th id="138">138</th><td><i class="doc"> *    9.9.9.99/32  via 9.9.9.98</i></td></tr>
<tr><th id="139">139</th><td><i class="doc"> *    9.9.9.98/32  via 9.9.9.97</i></td></tr>
<tr><th id="140">140</th><td><i class="doc"> *      ... turtles, turtles, turtles ...</i></td></tr>
<tr><th id="141">141</th><td><i class="doc"> *    9.9.9.1/32 via 10.10.10.10 Gig0</i></td></tr>
<tr><th id="142">142</th><td><i class="doc"> * is supported to as many layers of turtles is desired, however, when</i></td></tr>
<tr><th id="143">143</th><td><i class="doc"> * back-walking a graph (in this case from 9.9.9.1/32 up toward 9.9.9.100/32)</i></td></tr>
<tr><th id="144">144</th><td><i class="doc"> * a FIB needs to differentiate the case where the recursion is deep versus</i></td></tr>
<tr><th id="145">145</th><td><i class="doc"> * the case where the recursion is looped. A simple method, employed by VPP FIB,</i></td></tr>
<tr><th id="146">146</th><td><i class="doc"> * is to limit the number of steps. VPP FIB limit is 16. Typical BGP scenarios</i></td></tr>
<tr><th id="147">147</th><td><i class="doc"> * in the wild do not exceed 3 (BGP Inter-AS option C).</i></td></tr>
<tr><th id="148">148</th><td><i class="doc"> * </i></td></tr>
<tr><th id="149">149</th><td><i class="doc"> * - Fast Convergence</i></td></tr>
<tr><th id="150">150</th><td><i class="doc"> * </i></td></tr>
<tr><th id="151">151</th><td><i class="doc"> * After a network topology change, the 'convergence' time, is the time taken</i></td></tr>
<tr><th id="152">152</th><td><i class="doc"> * for the router to complete a transition to forward traffic using the new</i></td></tr>
<tr><th id="153">153</th><td><i class="doc"> * topology. The convergence time is therefore a summation of the time to;</i></td></tr>
<tr><th id="154">154</th><td><i class="doc"> *  - detect the failure.</i></td></tr>
<tr><th id="155">155</th><td><i class="doc"> *  - calculate the new 'best path' information</i></td></tr>
<tr><th id="156">156</th><td><i class="doc"> *  - download the new best paths to the data-plane.</i></td></tr>
<tr><th id="157">157</th><td><i class="doc"> *  - install those best best in data-plane forwarding.</i></td></tr>
<tr><th id="158">158</th><td><i class="doc"> * The last two points are of relevance to VPP architecture. The download API is</i></td></tr>
<tr><th id="159">159</th><td><i class="doc"> * binary and batch, details are not discussed here. There is no HW component to</i></td></tr>
<tr><th id="160">160</th><td><i class="doc"> * programme, installation time is bounded by the memory allocation and table</i></td></tr>
<tr><th id="161">161</th><td><i class="doc"> * lookup and insert access times.</i></td></tr>
<tr><th id="162">162</th><td><i class="doc"> *</i></td></tr>
<tr><th id="163">163</th><td><i class="doc"> * 'Fast' convergence refers to a set of technologies that a FIB can employ to</i></td></tr>
<tr><th id="164">164</th><td><i class="doc"> * completely or partially restore forwarding whilst the convergence actions</i></td></tr>
<tr><th id="165">165</th><td><i class="doc"> * listed above are ongoing. Fast convergence technologies are further</i></td></tr>
<tr><th id="166">166</th><td><i class="doc"> * sub-divided into Prefix Independent Convergence (PIC) and Loop Free</i></td></tr>
<tr><th id="167">167</th><td><i class="doc"> * Alternate path Fast re-route (LFA-FRR or sometimes called IP-FRR) which</i></td></tr>
<tr><th id="168">168</th><td><i class="doc"> * affect recursive and non-recursive routes respectively.</i></td></tr>
<tr><th id="169">169</th><td><i class="doc"> *</i></td></tr>
<tr><th id="170">170</th><td><i class="doc"> * LFA-FRR</i></td></tr>
<tr><th id="171">171</th><td><i class="doc"> *</i></td></tr>
<tr><th id="172">172</th><td><i class="doc"> * Consider the network topology below:</i></td></tr>
<tr><th id="173">173</th><td><i class="doc"> *</i></td></tr>
<tr><th id="174">174</th><td><i class="doc"> *          C</i></td></tr>
<tr><th id="175">175</th><td><i class="doc"> *        /   \</i></td></tr>
<tr><th id="176">176</th><td><i class="doc"> *  X -- A --- B - Y</i></td></tr>
<tr><th id="177">177</th><td><i class="doc"> *       |     |</i></td></tr>
<tr><th id="178">178</th><td><i class="doc"> *       D     F</i></td></tr>
<tr><th id="179">179</th><td><i class="doc"> *        \   /</i></td></tr>
<tr><th id="180">180</th><td><i class="doc"> *          E</i></td></tr>
<tr><th id="181">181</th><td><i class="doc"> *</i></td></tr>
<tr><th id="182">182</th><td><i class="doc"> * all links are equal cost, traffic is passing from X to Y. the best path is</i></td></tr>
<tr><th id="183">183</th><td><i class="doc"> * X-A-B-Y. There are two alternative paths, one via C and one via E. An</i></td></tr>
<tr><th id="184">184</th><td><i class="doc"> * alternate path is considered to be loop free if no other router on that path</i></td></tr>
<tr><th id="185">185</th><td><i class="doc"> * would forward the traffic back to the sender. Consider router C, its best</i></td></tr>
<tr><th id="186">186</th><td><i class="doc"> * path to Y is via B, so if A were to send traffic destined to Y to C, then C</i></td></tr>
<tr><th id="187">187</th><td><i class="doc"> * would forward that traffic to B - this is a loop-free alternate path. In</i></td></tr>
<tr><th id="188">188</th><td><i class="doc"> * contrast consider router D. D's shortest path to Y is via A, so if A were to</i></td></tr>
<tr><th id="189">189</th><td><i class="doc"> * send traffic destined to Y via D, then D would send it back to A; this is</i></td></tr>
<tr><th id="190">190</th><td><i class="doc"> * not a loop-free alternate path. There are several points of note;</i></td></tr>
<tr><th id="191">191</th><td><i class="doc"> *   - we are considering the pre-failure routing topology</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"> *   - any equal-cost multi-path between A and B is also a LFA path.</i></td></tr>
<tr><th id="193">193</th><td><i class="doc"> *   - in order for A to calculate LFA paths it must be aware of the best-path</i></td></tr>
<tr><th id="194">194</th><td><i class="doc"> *     to Y from the perspective of D. These calculations are thus limited to</i></td></tr>
<tr><th id="195">195</th><td><i class="doc"> *     routing protocols that have a full view of the network topology, i.e.</i></td></tr>
<tr><th id="196">196</th><td><i class="doc"> *     link-state DB protocols like OSPF or an SDN controller. LFA protected</i></td></tr>
<tr><th id="197">197</th><td><i class="doc"> *     prefixes are thus non-recursive.</i></td></tr>
<tr><th id="198">198</th><td><i class="doc"> *</i></td></tr>
<tr><th id="199">199</th><td><i class="doc"> * LFA is specified as a 1 to 1 redundancy; a primary path has only one LFA</i></td></tr>
<tr><th id="200">200</th><td><i class="doc"> * (a.k.a. backup) path. To my knowledge this limitation is one of complexity</i></td></tr>
<tr><th id="201">201</th><td><i class="doc"> * in the calculation of and capacity planning using a 1-n redundancy. </i></td></tr>
<tr><th id="202">202</th><td><i class="doc"> *</i></td></tr>
<tr><th id="203">203</th><td><i class="doc"> * In the event that the link A-B fails, the alternate path via C can be used.</i></td></tr>
<tr><th id="204">204</th><td><i class="doc"> * In order to provide 'fast' failover in the event of a failure, the control</i></td></tr>
<tr><th id="205">205</th><td><i class="doc"> * plane will download both the primary and the backup path to the FIB. It is</i></td></tr>
<tr><th id="206">206</th><td><i class="doc"> * then a requirement of the FIB to perform the failover (a.k.a cutover) from</i></td></tr>
<tr><th id="207">207</th><td><i class="doc"> * the primary to the backup path as quickly as possible, and particularly</i></td></tr>
<tr><th id="208">208</th><td><i class="doc"> * without any other control-plane intervention. The expectation is cutover is</i></td></tr>
<tr><th id="209">209</th><td><i class="doc"> * less than 50 milli-seconds - a value allegedly from the VOIP QoS. Note that</i></td></tr>
<tr><th id="210">210</th><td><i class="doc"> * cutover time still includes the fault detection time, which in a vitalised</i></td></tr>
<tr><th id="211">211</th><td><i class="doc"> * environment could be the dominant factor. Failure detection can be either a</i></td></tr>
<tr><th id="212">212</th><td><i class="doc"> * link down, which will affect multiple paths on a multi-access interface, or</i></td></tr>
<tr><th id="213">213</th><td><i class="doc"> * via a specific path heartbeat (i.e. BFD). </i></td></tr>
<tr><th id="214">214</th><td><i class="doc"> * At this time VPP does not support LFA, that is it does not support the</i></td></tr>
<tr><th id="215">215</th><td><i class="doc"> * installation of a primary and backup path[s] for a route. However, it does</i></td></tr>
<tr><th id="216">216</th><td><i class="doc"> * support ECMP, and VPP FIB is designed to quickly remove failed paths from</i></td></tr>
<tr><th id="217">217</th><td><i class="doc"> * the ECMP set, however, it does not insert shared objects specific to the</i></td></tr>
<tr><th id="218">218</th><td><i class="doc"> * protected resource into the forwarding object graph, since this would incur</i></td></tr>
<tr><th id="219">219</th><td><i class="doc"> * a forwarding/performance cost. Failover time is thus route number dependent.</i></td></tr>
<tr><th id="220">220</th><td><i class="doc"> * Details are provided in the implementation section below.</i></td></tr>
<tr><th id="221">221</th><td><i class="doc"> *</i></td></tr>
<tr><th id="222">222</th><td><i class="doc"> * PIC</i></td></tr>
<tr><th id="223">223</th><td><i class="doc"> *</i></td></tr>
<tr><th id="224">224</th><td><i class="doc"> * PIC refers to the concept that the converge time should be independent of</i></td></tr>
<tr><th id="225">225</th><td><i class="doc"> * the number of prefixes/routes that are affected by the failure. PIC is</i></td></tr>
<tr><th id="226">226</th><td><i class="doc"> * therefore most appropriate when considering networks with large number of</i></td></tr>
<tr><th id="227">227</th><td><i class="doc"> * prefixes, i.e. BGP networks and thus recursive prefixes. There are several</i></td></tr>
<tr><th id="228">228</th><td><i class="doc"> * flavours of PIC covering different locations of protection and failure</i></td></tr>
<tr><th id="229">229</th><td><i class="doc"> * scenarios. An outline is given below, see the literature for more details:</i></td></tr>
<tr><th id="230">230</th><td><i class="doc"> *</i></td></tr>
<tr><th id="231">231</th><td><i class="doc"> * Y/16 - CE1 -- PE1---\</i></td></tr>
<tr><th id="232">232</th><td><i class="doc"> *                | \   P1---\</i></td></tr>
<tr><th id="233">233</th><td><i class="doc"> *                |  \        PE3 -- CE3 - X/16</i></td></tr>
<tr><th id="234">234</th><td><i class="doc"> *                |   - P2---/</i></td></tr>
<tr><th id="235">235</th><td><i class="doc"> * Y/16 - CE2 -- PE2---/</i></td></tr>
<tr><th id="236">236</th><td><i class="doc"> *</i></td></tr>
<tr><th id="237">237</th><td><i class="doc"> * CE = customer edge, PE = provider edge. external-BGP runs between customer</i></td></tr>
<tr><th id="238">238</th><td><i class="doc"> * and provider, internal-BGP runs between provider and provider.</i></td></tr>
<tr><th id="239">239</th><td><i class="doc"> *</i></td></tr>
<tr><th id="240">240</th><td><i class="doc"> * 1) iBGP PIC-core: consider traffic from CE1 to X/16 via CE3. On PE1 there is</i></td></tr>
<tr><th id="241">241</th><td><i class="doc"> *    are routes;</i></td></tr>
<tr><th id="242">242</th><td><i class="doc"> *       X/16 (and hundreds of thousands of others like it)</i></td></tr>
<tr><th id="243">243</th><td><i class="doc"> *         via PE3</i></td></tr>
<tr><th id="244">244</th><td><i class="doc"> *    and</i></td></tr>
<tr><th id="245">245</th><td><i class="doc"> *      PE3/32 (its loopback address)</i></td></tr>
<tr><th id="246">246</th><td><i class="doc"> *        via 10.0.0.1 Link0 (this is P1)</i></td></tr>
<tr><th id="247">247</th><td><i class="doc"> *        via 10.1.1.1 Link1 (this is P2)</i></td></tr>
<tr><th id="248">248</th><td><i class="doc"> * the failure is the loss of link0 or link1</i></td></tr>
<tr><th id="249">249</th><td><i class="doc"> * As in all PIC scenarios, in order to provide prefix independent convergence</i></td></tr>
<tr><th id="250">250</th><td><i class="doc"> * it must be that the route for X/16 (and all other routes via PE3) do not</i></td></tr>
<tr><th id="251">251</th><td><i class="doc"> * need to be updated in the FIB. The FIB therefore needs to update a single</i></td></tr>
<tr><th id="252">252</th><td><i class="doc"> * object that is shared by all routes - once this shared object is updated,</i></td></tr>
<tr><th id="253">253</th><td><i class="doc"> * then all routes using it will be instantly updated to use the new forwarding</i></td></tr>
<tr><th id="254">254</th><td><i class="doc"> * information. In this case the shared object is the resolving route via PE3.</i></td></tr>
<tr><th id="255">255</th><td><i class="doc"> * Once the route via PE3 is updated via IGP (OSPF) convergence, then all</i></td></tr>
<tr><th id="256">256</th><td><i class="doc"> * recursive routes that resolve through it are also updated. VPP FIB</i></td></tr>
<tr><th id="257">257</th><td><i class="doc"> * implements this scenario via a recursive-adjacency. the X/16 and it sibling</i></td></tr>
<tr><th id="258">258</th><td><i class="doc"> * routes share a recursive-adjacency that links to/points at/stacks on the</i></td></tr>
<tr><th id="259">259</th><td><i class="doc"> * normal adjacency contributed by the route for PE3. Once this shared</i></td></tr>
<tr><th id="260">260</th><td><i class="doc"> * recursive adj is re-linked then all routes are switched to using the new</i></td></tr>
<tr><th id="261">261</th><td><i class="doc"> * forwarding information. This is shown below;</i></td></tr>
<tr><th id="262">262</th><td><i class="doc"> *</i></td></tr>
<tr><th id="263">263</th><td><i class="doc"> * pre-failure;</i></td></tr>
<tr><th id="264">264</th><td><i class="doc"> *   X/16 --&gt; R-ADJ-1 --&gt; ADJ-1-PE3 (multi-path via P1 and P2)</i></td></tr>
<tr><th id="265">265</th><td><i class="doc"> *</i></td></tr>
<tr><th id="266">266</th><td><i class="doc"> * post-failure:</i></td></tr>
<tr><th id="267">267</th><td><i class="doc"> *   X/16 --&gt; R-ADJ-1 --&gt; ADJ-2-PE3 (single path via P1)</i></td></tr>
<tr><th id="268">268</th><td><i class="doc"> *</i></td></tr>
<tr><th id="269">269</th><td><i class="doc"> * note that R-ADJ-1 (the recursive adj) remains in the forwarding graph,</i></td></tr>
<tr><th id="270">270</th><td><i class="doc"> * therefore X/16 (and all its siblings) is not updated.</i></td></tr>
<tr><th id="271">271</th><td><i class="doc"> * X/16 and its siblings share the recursive adj since they share the same</i></td></tr>
<tr><th id="272">272</th><td><i class="doc"> * path-list. It is the path-list object that contributes the recursive-adj</i></td></tr>
<tr><th id="273">273</th><td><i class="doc"> * (see next section for more details)</i></td></tr>
<tr><th id="274">274</th><td><i class="doc"> *</i></td></tr>
<tr><th id="275">275</th><td><i class="doc"> *</i></td></tr>
<tr><th id="276">276</th><td><i class="doc"> * 2) iBGP PIC-edge; Traffic from CE3 to Y/16. On PE3 there is are routes;</i></td></tr>
<tr><th id="277">277</th><td><i class="doc"> *      Y/16  (and hundreds of thousands of others like it)</i></td></tr>
<tr><th id="278">278</th><td><i class="doc"> *        via PE1</i></td></tr>
<tr><th id="279">279</th><td><i class="doc"> *        via PE2 </i></td></tr>
<tr><th id="280">280</th><td><i class="doc"> *  and</i></td></tr>
<tr><th id="281">281</th><td><i class="doc"> *     PE1/32 (PE1's loopback address)</i></td></tr>
<tr><th id="282">282</th><td><i class="doc"> *       via 10.0.2.2 Link0 (this is P1)</i></td></tr>
<tr><th id="283">283</th><td><i class="doc"> *     PE2/32 (PE2's loopback address)</i></td></tr>
<tr><th id="284">284</th><td><i class="doc"> *       via 10.0.3.3 Link1 (this is P2)</i></td></tr>
<tr><th id="285">285</th><td><i class="doc"> *</i></td></tr>
<tr><th id="286">286</th><td><i class="doc"> * the failure is the loss of reachability to PE2. this could be either the</i></td></tr>
<tr><th id="287">287</th><td><i class="doc"> * loss of the link P2-PE2 or the loss of the node PE2. This is detected either</i></td></tr>
<tr><th id="288">288</th><td><i class="doc"> * by the withdrawal of the PE2's loopback route or by some form of failure</i></td></tr>
<tr><th id="289">289</th><td><i class="doc"> * detection (i.e. BFD).</i></td></tr>
<tr><th id="290">290</th><td><i class="doc"> * VPP FIB again provides PIC via the use of the shared recursive-adj. Y/16 and</i></td></tr>
<tr><th id="291">291</th><td><i class="doc"> * its siblings will again share a path-list for the list {PE1,PE2}, this</i></td></tr>
<tr><th id="292">292</th><td><i class="doc"> * path-list will contribute a multi-path-recursive-adj, i.e. a multi-path-adj</i></td></tr>
<tr><th id="293">293</th><td><i class="doc"> * with each choice therein being another adj;</i></td></tr>
<tr><th id="294">294</th><td><i class="doc"> *</i></td></tr>
<tr><th id="295">295</th><td><i class="doc"> *  Y/16 -&gt; RM-ADJ --&gt; ADJ1 (for PE1)</i></td></tr>
<tr><th id="296">296</th><td><i class="doc"> *                 --&gt; ADJ2 (for PE2)</i></td></tr>
<tr><th id="297">297</th><td><i class="doc"> *</i></td></tr>
<tr><th id="298">298</th><td><i class="doc"> * when the route for PE1 is withdrawn then the multi-path-recursive-adjacency</i></td></tr>
<tr><th id="299">299</th><td><i class="doc"> * is updated to be;</i></td></tr>
<tr><th id="300">300</th><td><i class="doc"> *</i></td></tr>
<tr><th id="301">301</th><td><i class="doc"> * Y/16 --&gt; RM-ADJ --&gt; ADJ1 (for PE1)</i></td></tr>
<tr><th id="302">302</th><td><i class="doc"> *                 --&gt; ADJ1 (for PE1)</i></td></tr>
<tr><th id="303">303</th><td><i class="doc"> *</i></td></tr>
<tr><th id="304">304</th><td><i class="doc"> * that is both choices in the ECMP set are the same and thus all traffic is</i></td></tr>
<tr><th id="305">305</th><td><i class="doc"> * forwarded to PE1. Eventually the control plane will download a route update</i></td></tr>
<tr><th id="306">306</th><td><i class="doc"> * for Y/16 to be via PE1 only. At that time the situation will be:</i></td></tr>
<tr><th id="307">307</th><td><i class="doc"> *</i></td></tr>
<tr><th id="308">308</th><td><i class="doc"> * Y/16 -&gt; R-ADJ --&gt; ADJ1 (for PE1)</i></td></tr>
<tr><th id="309">309</th><td><i class="doc"> *</i></td></tr>
<tr><th id="310">310</th><td><i class="doc"> * In the scenario above we assumed that PE1 and PE2 are ECMP for Y/16. eBGP</i></td></tr>
<tr><th id="311">311</th><td><i class="doc"> * PIC core is also specified for the case were one PE is primary and the other</i></td></tr>
<tr><th id="312">312</th><td><i class="doc"> * backup - VPP FIB does not support that case at this time.</i></td></tr>
<tr><th id="313">313</th><td><i class="doc"> *</i></td></tr>
<tr><th id="314">314</th><td><i class="doc"> * 3) eBGP PIC Edge; Traffic from CE3 to Y/16. On PE1 there is are routes;</i></td></tr>
<tr><th id="315">315</th><td><i class="doc"> *      Y/16 (and hundreds of thousands of others like it)</i></td></tr>
<tr><th id="316">316</th><td><i class="doc"> *         via CE1 (primary)</i></td></tr>
<tr><th id="317">317</th><td><i class="doc"> *         via PE2 (backup)</i></td></tr>
<tr><th id="318">318</th><td><i class="doc"> *   and</i></td></tr>
<tr><th id="319">319</th><td><i class="doc"> *     CE1 (this is an adj-fib)</i></td></tr>
<tr><th id="320">320</th><td><i class="doc"> *       via 11.0.0.1 Link0 (this is CE1) &lt;&lt; this is an adj-fib</i></td></tr>
<tr><th id="321">321</th><td><i class="doc"> *     PE2 (PE2's loopback address)</i></td></tr>
<tr><th id="322">322</th><td><i class="doc"> *       via 10.0.5.5 Link1 (this is link PE1-PE2)</i></td></tr>
<tr><th id="323">323</th><td><i class="doc"> * the failure is the loss of link0 to CE1. The failure can be detected by FIB</i></td></tr>
<tr><th id="324">324</th><td><i class="doc"> * either as a link down event or by the control plane withdrawing the connected</i></td></tr>
<tr><th id="325">325</th><td><i class="doc"> * prefix on the link0 (say 10.0.5.4/30). The latter works because the resolving</i></td></tr>
<tr><th id="326">326</th><td><i class="doc"> * entry is an adj-fib, so removing the connected will withdraw the adj-fib, and</i></td></tr>
<tr><th id="327">327</th><td><i class="doc"> * hence the recursive path becomes unresolved. The former is faster,</i></td></tr>
<tr><th id="328">328</th><td><i class="doc"> * particularly in the case of Inter-AS option A where there are many VLAN</i></td></tr>
<tr><th id="329">329</th><td><i class="doc"> * sub-interfaces on the PE-CE link, one for each VRF, and so the control plane</i></td></tr>
<tr><th id="330">330</th><td><i class="doc"> * must remove the connected prefix for each sub-interface to trigger PIC in</i></td></tr>
<tr><th id="331">331</th><td><i class="doc"> * each VRF. Note though that total PIC cutover time will depend on VRF scale</i></td></tr>
<tr><th id="332">332</th><td><i class="doc"> * with either trigger.</i></td></tr>
<tr><th id="333">333</th><td><i class="doc"> * Primary and backup paths in this eBGP PIC-edge scenario are calculated by</i></td></tr>
<tr><th id="334">334</th><td><i class="doc"> * BGP. Each peer is configured to always advertise its best external path to</i></td></tr>
<tr><th id="335">335</th><td><i class="doc"> * its iBGP peers. Backup paths therefore send traffic from the PE back into the</i></td></tr>
<tr><th id="336">336</th><td><i class="doc"> * core to an alternate PE. A PE may have multiple external paths, i.e. multiple</i></td></tr>
<tr><th id="337">337</th><td><i class="doc"> * directly connected CEs, it may also have multiple backup PEs, however there</i></td></tr>
<tr><th id="338">338</th><td><i class="doc"> * is no correlation between the two, so unlike LFA-FRR, the redundancy model is</i></td></tr>
<tr><th id="339">339</th><td><i class="doc"> * N-M; N primary paths are backed-up by M backup paths - only when all primary</i></td></tr>
<tr><th id="340">340</th><td><i class="doc"> * paths fail, then the cutover is performed onto the M backup paths. Note that</i></td></tr>
<tr><th id="341">341</th><td><i class="doc"> * PE2 must be suitably configured to forward traffic on its external path that</i></td></tr>
<tr><th id="342">342</th><td><i class="doc"> * was received from PE1. VPP FIB does not support external-internal-BGP (eiBGP)</i></td></tr>
<tr><th id="343">343</th><td><i class="doc"> * load-balancing.</i></td></tr>
<tr><th id="344">344</th><td><i class="doc"> *</i></td></tr>
<tr><th id="345">345</th><td><i class="doc"> * As with LFA-FRR the use of primary and backup paths is not currently</i></td></tr>
<tr><th id="346">346</th><td><i class="doc"> * supported, however, the use of a recursive-multi-path-adj, and a suitably</i></td></tr>
<tr><th id="347">347</th><td><i class="doc"> * constrained hashing algorithm to choose from the primary or backup path sets,</i></td></tr>
<tr><th id="348">348</th><td><i class="doc"> * would again provide the necessary shared object and hence the prefix scale</i></td></tr>
<tr><th id="349">349</th><td><i class="doc"> * independent cutover.</i></td></tr>
<tr><th id="350">350</th><td><i class="doc"> *</i></td></tr>
<tr><th id="351">351</th><td><i class="doc"> * Astute readers will recognise that both of the eBGP PIC scenarios refer only</i></td></tr>
<tr><th id="352">352</th><td><i class="doc"> * to a BGP free core.</i></td></tr>
<tr><th id="353">353</th><td><i class="doc"> *</i></td></tr>
<tr><th id="354">354</th><td><i class="doc"> * Fast convergence implementation options come in two flavours:</i></td></tr>
<tr><th id="355">355</th><td><i class="doc"> *  1) Insert switches into the data-path. The switch represents the protected</i></td></tr>
<tr><th id="356">356</th><td><i class="doc"> *     resource. If the switch is 'on' the primary path is taken, otherwise</i></td></tr>
<tr><th id="357">357</th><td><i class="doc"> *     the backup path is taken. Testing the switch in the data-path comes with</i></td></tr>
<tr><th id="358">358</th><td><i class="doc"> *     an associated performance cost. A given packet may encounter more than</i></td></tr>
<tr><th id="359">359</th><td><i class="doc"> *     one protected resource as it is forwarded. This approach minimises</i></td></tr>
<tr><th id="360">360</th><td><i class="doc"> *     cutover times as packets will be forwarded on the backup path as soon</i></td></tr>
<tr><th id="361">361</th><td><i class="doc"> *     as the protected resource is detected to be down and the single switch</i></td></tr>
<tr><th id="362">362</th><td><i class="doc"> *     is tripped. However, it comes at a performance cost, which increases</i></td></tr>
<tr><th id="363">363</th><td><i class="doc"> *     with each shared resource a packet encounters in the data-path.</i></td></tr>
<tr><th id="364">364</th><td><i class="doc"> *     This approach is thus best suited to LFA-FRR where the protected routes</i></td></tr>
<tr><th id="365">365</th><td><i class="doc"> *     are non-recursive (i.e. encounter few shared resources) and the</i></td></tr>
<tr><th id="366">366</th><td><i class="doc"> *     expectation on cutover times is more stringent (&lt;50msecs).</i></td></tr>
<tr><th id="367">367</th><td><i class="doc"> *  2) Update shared objects. Identify objects in the data-path, that are</i></td></tr>
<tr><th id="368">368</th><td><i class="doc"> *     required to be present whether or not fast convergence is required (i.e.</i></td></tr>
<tr><th id="369">369</th><td><i class="doc"> *     adjacencies) that can be shared by multiple routes. Create a dependency</i></td></tr>
<tr><th id="370">370</th><td><i class="doc"> *     between these objects at the protected resource. When the protected</i></td></tr>
<tr><th id="371">371</th><td><i class="doc"> *     resource fails, each of the shared objects is updated in a way that all</i></td></tr>
<tr><th id="372">372</th><td><i class="doc"> *     users of it see a consistent change. This approach incurs no performance</i></td></tr>
<tr><th id="373">373</th><td><i class="doc"> *     penalty as the data-path structure is unchanged, however, the cutover</i></td></tr>
<tr><th id="374">374</th><td><i class="doc"> *     times are longer as more work is required when the resource fails. This</i></td></tr>
<tr><th id="375">375</th><td><i class="doc"> *     scheme is thus more appropriate to recursive prefixes (where the packet</i></td></tr>
<tr><th id="376">376</th><td><i class="doc"> *     will encounter multiple protected resources) and to fast-convergence</i></td></tr>
<tr><th id="377">377</th><td><i class="doc"> *     technologies where the cutover times are less stringent (i.e. PIC).</i></td></tr>
<tr><th id="378">378</th><td><i class="doc"> *</i></td></tr>
<tr><th id="379">379</th><td><i class="doc"> * Implementation:</i></td></tr>
<tr><th id="380">380</th><td><i class="doc"> * ---------------</i></td></tr>
<tr><th id="381">381</th><td><i class="doc"> *</i></td></tr>
<tr><th id="382">382</th><td><i class="doc"> * Due to the requirements outlined above, not all routes known to FIB</i></td></tr>
<tr><th id="383">383</th><td><i class="doc"> * (e.g. adj-fibs) are installed in forwarding. However, should circumstances</i></td></tr>
<tr><th id="384">384</th><td><i class="doc"> * change, those routes will need to be added. This adds the requirement that</i></td></tr>
<tr><th id="385">385</th><td><i class="doc"> * a FIB maintains two tables per-VRF, per-AF (where a 'table' is indexed by</i></td></tr>
<tr><th id="386">386</th><td><i class="doc"> * prefix); the forwarding and non-forwarding tables.</i></td></tr>
<tr><th id="387">387</th><td><i class="doc"> *</i></td></tr>
<tr><th id="388">388</th><td><i class="doc"> * For DP speed in VPP we want the lookup in the forwarding table to directly </i></td></tr>
<tr><th id="389">389</th><td><i class="doc"> * result in the ADJ. So the two tables; one contains all the routes (a </i></td></tr>
<tr><th id="390">390</th><td><i class="doc"> * lookup therein yields a fib_entry_t), the other contains only the forwarding </i></td></tr>
<tr><th id="391">391</th><td><i class="doc"> * routes (a lookup therein yields an ip_adjacency_t). The latter is used by the</i></td></tr>
<tr><th id="392">392</th><td><i class="doc"> * DP. </i></td></tr>
<tr><th id="393">393</th><td><i class="doc"> * This trades memory for forwarding performance. A good trade-off in VPP's</i></td></tr>
<tr><th id="394">394</th><td><i class="doc"> * expected operating environments.</i></td></tr>
<tr><th id="395">395</th><td><i class="doc"> *</i></td></tr>
<tr><th id="396">396</th><td><i class="doc"> * Note these tables are keyed only by the prefix (and since there 2 two</i></td></tr>
<tr><th id="397">397</th><td><i class="doc"> * per-VRF, implicitly by the VRF too). The key for an adjacency is the</i></td></tr>
<tr><th id="398">398</th><td><i class="doc"> * tuple:{next-hop, address (and it's AF), interface, link/ether-type}.</i></td></tr>
<tr><th id="399">399</th><td><i class="doc"> * consider this curious, but allowed, config;</i></td></tr>
<tr><th id="400">400</th><td><i class="doc"> *</i></td></tr>
<tr><th id="401">401</th><td><i class="doc"> *   set int ip addr 10.0.0.1/24 Gig0</i></td></tr>
<tr><th id="402">402</th><td><i class="doc"> *   set ip arp Gig0 10.0.0.2 dead.dead.dead</i></td></tr>
<tr><th id="403">403</th><td><i class="doc"> *   # a host in that sub-net is routed via a better next hop (say it avoids a</i></td></tr>
<tr><th id="404">404</th><td><i class="doc"> *   # big L2 domain)</i></td></tr>
<tr><th id="405">405</th><td><i class="doc"> *   ip route add 10.0.0.2 Gig1 192.168.1.1</i></td></tr>
<tr><th id="406">406</th><td><i class="doc"> *   # this recursive should go via Gig1</i></td></tr>
<tr><th id="407">407</th><td><i class="doc"> *   ip route add 1.1.1.1/32 via 10.0.0.2</i></td></tr>
<tr><th id="408">408</th><td><i class="doc"> *   # this non-recursive should go via Gig0</i></td></tr>
<tr><th id="409">409</th><td><i class="doc"> *   ip route add 2.2.2.2/32 via Gig0 10.0.0.2</i></td></tr>
<tr><th id="410">410</th><td><i class="doc"> *</i></td></tr>
<tr><th id="411">411</th><td><i class="doc"> * for the last route, the lookup for the path (via {Gig0, 10.0.0.2}) in the</i></td></tr>
<tr><th id="412">412</th><td><i class="doc"> * prefix table would not yield the correct result. To fix this we need a</i></td></tr>
<tr><th id="413">413</th><td><i class="doc"> * separate table for the adjacencies.</i></td></tr>
<tr><th id="414">414</th><td><i class="doc"> *</i></td></tr>
<tr><th id="415">415</th><td><i class="doc"> *  - FIB data structures;</i></td></tr>
<tr><th id="416">416</th><td><i class="doc"> *</i></td></tr>
<tr><th id="417">417</th><td><i class="doc"> * fib_entry_t:</i></td></tr>
<tr><th id="418">418</th><td><i class="doc"> *   - a representation of a route.</i></td></tr>
<tr><th id="419">419</th><td><i class="doc"> *     - has a prefix.</i></td></tr>
<tr><th id="420">420</th><td><i class="doc"> *    - it maintains an array of path-lists that have been contributed by the</i></td></tr>
<tr><th id="421">421</th><td><i class="doc"> *      different sources</i></td></tr>
<tr><th id="422">422</th><td><i class="doc"> *    - install an adjacency in the forwarding table contributed by the best</i></td></tr>
<tr><th id="423">423</th><td><i class="doc"> *      source's path-list.</i></td></tr>
<tr><th id="424">424</th><td><i class="doc"> *</i></td></tr>
<tr><th id="425">425</th><td><i class="doc"> * fib_path_list_t:</i></td></tr>
<tr><th id="426">426</th><td><i class="doc"> *   - a list of paths</i></td></tr>
<tr><th id="427">427</th><td><i class="doc"> *   - path-lists may be shared between FIB entries. The path-lists are thus</i></td></tr>
<tr><th id="428">428</th><td><i class="doc"> *     kept in a DB. The key is the combined description of the paths. We share</i></td></tr>
<tr><th id="429">429</th><td><i class="doc"> *     path-lists  when it will aid convergence to do so. Adding path-lists to</i></td></tr>
<tr><th id="430">430</th><td><i class="doc"> *     this DB that are never shared, or are not shared by prefixes that are</i></td></tr>
<tr><th id="431">431</th><td><i class="doc"> *     not subject to PIC, will increase the size of the DB unnecessarily and</i></td></tr>
<tr><th id="432">432</th><td><i class="doc"> *     may lead to increased search times due to hash collisions.</i></td></tr>
<tr><th id="433">433</th><td><i class="doc"> *   - the path-list contributes the appropriate adj for the entry in the </i></td></tr>
<tr><th id="434">434</th><td><i class="doc"> *     forwarding table. The adj can be 'normal', multi-path or recursive,</i></td></tr>
<tr><th id="435">435</th><td><i class="doc"> *     depending on the number of paths and their types.</i></td></tr>
<tr><th id="436">436</th><td><i class="doc"> *   - since path-lists are shared there is only one instance of the multi-path </i></td></tr>
<tr><th id="437">437</th><td><i class="doc"> *     adj that they [may] create. As such multi-path adjacencies do not need a</i></td></tr>
<tr><th id="438">438</th><td><i class="doc"> *     separate DB.</i></td></tr>
<tr><th id="439">439</th><td><i class="doc"> * The path-list with recursive paths and the recursive adjacency that it</i></td></tr>
<tr><th id="440">440</th><td><i class="doc"> * contributes forms the backbone of the fast convergence architecture (as </i></td></tr>
<tr><th id="441">441</th><td><i class="doc"> * described previously). </i></td></tr>
<tr><th id="442">442</th><td><i class="doc"> *</i></td></tr>
<tr><th id="443">443</th><td><i class="doc"> * fib_path_t:</i></td></tr>
<tr><th id="444">444</th><td><i class="doc"> *   - a description of how to forward the traffic (i.e. via {Gig1, K}).</i></td></tr>
<tr><th id="445">445</th><td><i class="doc"> *   - the path describes the intent on how to forward. This differs from how </i></td></tr>
<tr><th id="446">446</th><td><i class="doc"> *     the path resolves. I.e. it might not be resolved at all (since the</i></td></tr>
<tr><th id="447">447</th><td><i class="doc"> *     interface is deleted or down).</i></td></tr>
<tr><th id="448">448</th><td><i class="doc"> *   - paths have different types, most notably recursive or non-recursive.</i></td></tr>
<tr><th id="449">449</th><td><i class="doc"> *   - a fib_path_t will contribute the appropriate adjacency object. It is from</i></td></tr>
<tr><th id="450">450</th><td><i class="doc"> *     these contributions that the DP graph/chain for the route is built.</i></td></tr>
<tr><th id="451">451</th><td><i class="doc"> *   - if the path is recursive and a recursion loop is detected, then the path</i></td></tr>
<tr><th id="452">452</th><td><i class="doc"> *     will contribute the special DROP adjacency. This way, whilst the control</i></td></tr>
<tr><th id="453">453</th><td><i class="doc"> *     plane graph is looped, the data-plane graph does not.</i></td></tr>
<tr><th id="454">454</th><td><i class="doc"> *</i></td></tr>
<tr><th id="455">455</th><td><i class="doc"> * we build a graph of these objects;</i></td></tr>
<tr><th id="456">456</th><td><i class="doc"> *</i></td></tr>
<tr><th id="457">457</th><td><i class="doc"> *  fib_entry_t -&gt; fib_path_list_t -&gt; fib_path_t -&gt; ...</i></td></tr>
<tr><th id="458">458</th><td><i class="doc"> *</i></td></tr>
<tr><th id="459">459</th><td><i class="doc"> * for recursive paths:</i></td></tr>
<tr><th id="460">460</th><td><i class="doc"> *</i></td></tr>
<tr><th id="461">461</th><td><i class="doc"> *   fib_path_t -&gt; fib_entry_t -&gt; ....</i></td></tr>
<tr><th id="462">462</th><td><i class="doc"> *</i></td></tr>
<tr><th id="463">463</th><td><i class="doc"> * for non-recursive paths</i></td></tr>
<tr><th id="464">464</th><td><i class="doc"> *</i></td></tr>
<tr><th id="465">465</th><td><i class="doc"> *  fib_path_t -&gt; ip_adjacency_t -&gt; interface</i></td></tr>
<tr><th id="466">466</th><td><i class="doc"> *</i></td></tr>
<tr><th id="467">467</th><td><i class="doc"> * These objects, which constitute the 'control plane' part of the FIB are used</i></td></tr>
<tr><th id="468">468</th><td><i class="doc"> * to represent the resolution of a route. As a whole this is referred to as the</i></td></tr>
<tr><th id="469">469</th><td><i class="doc"> * control plane graph. There is a separate DP graph to represent the forwarding</i></td></tr>
<tr><th id="470">470</th><td><i class="doc"> * of a packet. In the DP graph each object represents an action that is applied</i></td></tr>
<tr><th id="471">471</th><td><i class="doc"> * to a packet as it traverses the graph. For example, a lookup of a IP address</i></td></tr>
<tr><th id="472">472</th><td><i class="doc"> * in the forwarding table could result in the following graph:</i></td></tr>
<tr><th id="473">473</th><td><i class="doc"> *</i></td></tr>
<tr><th id="474">474</th><td><i class="doc"> *    recursive-adj --&gt; multi-path-adj --&gt; interface_A</i></td></tr>
<tr><th id="475">475</th><td><i class="doc"> *                                     --&gt; interface_B</i></td></tr>
<tr><th id="476">476</th><td><i class="doc"> *</i></td></tr>
<tr><th id="477">477</th><td><i class="doc"> * A packet traversing this FIB DP graph would thus also traverse a VPP node</i></td></tr>
<tr><th id="478">478</th><td><i class="doc"> * graph of:</i></td></tr>
<tr><th id="479">479</th><td><i class="doc"> *</i></td></tr>
<tr><th id="480">480</th><td><i class="doc"> *    ipX_recursive --&gt; ipX_rewrite --&gt; interface_A_tx --&gt; etc</i></td></tr>
<tr><th id="481">481</th><td><i class="doc"> *</i></td></tr>
<tr><th id="482">482</th><td><i class="doc"> * The taxonomy of objects in a FIB graph is as follows, consider;</i></td></tr>
<tr><th id="483">483</th><td><i class="doc"> *</i></td></tr>
<tr><th id="484">484</th><td><i class="doc"> *   A --&gt;  </i></td></tr>
<tr><th id="485">485</th><td><i class="doc"> *   B --&gt; D</i></td></tr>
<tr><th id="486">486</th><td><i class="doc"> *   C --&gt;</i></td></tr>
<tr><th id="487">487</th><td><i class="doc"> *</i></td></tr>
<tr><th id="488">488</th><td><i class="doc"> * Where A,B and C are (for example) routes that resolve through D. </i></td></tr>
<tr><th id="489">489</th><td><i class="doc"> *  parent; D is the parent of A, B, and C.</i></td></tr>
<tr><th id="490">490</th><td><i class="doc"> *  children: A, B, and C are children of D. </i></td></tr>
<tr><th id="491">491</th><td><i class="doc"> *  sibling: A, B and C are siblings of one another.</i></td></tr>
<tr><th id="492">492</th><td><i class="doc"> *</i></td></tr>
<tr><th id="493">493</th><td><i class="doc"> * All shared objects in the FIB are reference counted. Users of these objects</i></td></tr>
<tr><th id="494">494</th><td><i class="doc"> * are thus expected to use the add_lock/unlock semantics (as one would</i></td></tr>
<tr><th id="495">495</th><td><i class="doc"> * normally use malloc/free).</i></td></tr>
<tr><th id="496">496</th><td><i class="doc"> *</i></td></tr>
<tr><th id="497">497</th><td><i class="doc"> * WALKS</i></td></tr>
<tr><th id="498">498</th><td><i class="doc"> *</i></td></tr>
<tr><th id="499">499</th><td><i class="doc"> * It is necessary to walk/traverse the graph forwards (entry to interface) to</i></td></tr>
<tr><th id="500">500</th><td><i class="doc"> * perform a collapse or build a recursive adj and backwards (interface</i></td></tr>
<tr><th id="501">501</th><td><i class="doc"> * to entry) to perform updates, i.e. when interface state changes or when</i></td></tr>
<tr><th id="502">502</th><td><i class="doc"> * recursive route resolution updates occur.</i></td></tr>
<tr><th id="503">503</th><td><i class="doc"> * A forward walk follows simply by navigating an object's parent pointer to</i></td></tr>
<tr><th id="504">504</th><td><i class="doc"> * access its parent object. For objects with multiple parents (e.g. a </i></td></tr>
<tr><th id="505">505</th><td><i class="doc"> * path-list), each parent is walked in turn.</i></td></tr>
<tr><th id="506">506</th><td><i class="doc"> * To support back-walks direct dependencies are maintained between objects,</i></td></tr>
<tr><th id="507">507</th><td><i class="doc"> * i.e. in the relationship, {A, B, C} --&gt; D, then object D will maintain a list</i></td></tr>
<tr><th id="508">508</th><td><i class="doc"> * of 'pointers' to its children {A, B, C}. Bare C-language pointers are not </i></td></tr>
<tr><th id="509">509</th><td><i class="doc"> * allowed, so a pointer is described in terms of an object type (i.e. entry,</i></td></tr>
<tr><th id="510">510</th><td><i class="doc"> * path-list, etc) and index - this allows the object to be retrieved from the</i></td></tr>
<tr><th id="511">511</th><td><i class="doc"> * appropriate pool. A list is maintained to achieve fast convergence at scale.</i></td></tr>
<tr><th id="512">512</th><td><i class="doc"> * When there are millions or recursive prefixes, it is very inefficient to</i></td></tr>
<tr><th id="513">513</th><td><i class="doc"> * blindly walk the tables looking for entries that were affected by a given</i></td></tr>
<tr><th id="514">514</th><td><i class="doc"> * topology change. The lowest hanging fruit when optimising is to remove</i></td></tr>
<tr><th id="515">515</th><td><i class="doc"> * actions that are not required, so all back-walks only traverse objects that</i></td></tr>
<tr><th id="516">516</th><td><i class="doc"> * are directly affected by the change.</i></td></tr>
<tr><th id="517">517</th><td><i class="doc"> *</i></td></tr>
<tr><th id="518">518</th><td><i class="doc"> * PIC Core and fast-reroute rely on FIB reacting quickly to an interface</i></td></tr>
<tr><th id="519">519</th><td><i class="doc"> * state change to update the multi-path-adjacencies that use this interface.</i></td></tr>
<tr><th id="520">520</th><td><i class="doc"> * An example graph is shown below:</i></td></tr>
<tr><th id="521">521</th><td><i class="doc"> *</i></td></tr>
<tr><th id="522">522</th><td><i class="doc"> *    E_a --&gt;</i></td></tr>
<tr><th id="523">523</th><td><i class="doc"> *    E_b --&gt; PL_2 --&gt; P_a --&gt; Interface_A</i></td></tr>
<tr><th id="524">524</th><td><i class="doc"> *    ...          --&gt; P_c -\</i></td></tr>
<tr><th id="525">525</th><td><i class="doc"> *    E_k --&gt;                \</i></td></tr>
<tr><th id="526">526</th><td><i class="doc"> *                            Interface_K</i></td></tr>
<tr><th id="527">527</th><td><i class="doc"> *                            /</i></td></tr>
<tr><th id="528">528</th><td><i class="doc"> *    E_l --&gt;                /</i></td></tr>
<tr><th id="529">529</th><td><i class="doc"> *    E_m --&gt; PL_1 --&gt; P_d -/ </i></td></tr>
<tr><th id="530">530</th><td><i class="doc"> *    ...          --&gt; P_f --&gt; Interface_F</i></td></tr>
<tr><th id="531">531</th><td><i class="doc"> *    E_z --&gt;</i></td></tr>
<tr><th id="532">532</th><td><i class="doc"> *</i></td></tr>
<tr><th id="533">533</th><td><i class="doc"> * E  = fib_entry_t</i></td></tr>
<tr><th id="534">534</th><td><i class="doc"> * PL = fib_path_list_t</i></td></tr>
<tr><th id="535">535</th><td><i class="doc"> * P  = fib_path_t </i></td></tr>
<tr><th id="536">536</th><td><i class="doc"> * The subscripts are arbitrary and serve only to distinguish object instances.</i></td></tr>
<tr><th id="537">537</th><td><i class="doc"> * This CP graph result in the following DP graph:</i></td></tr>
<tr><th id="538">538</th><td><i class="doc"> *</i></td></tr>
<tr><th id="539">539</th><td><i class="doc"> *     M-ADJ-2 --&gt; Interface_A</i></td></tr>
<tr><th id="540">540</th><td><i class="doc"> *             \</i></td></tr>
<tr><th id="541">541</th><td><i class="doc"> *              -&gt; Interface_K</i></td></tr>
<tr><th id="542">542</th><td><i class="doc"> *             / </i></td></tr>
<tr><th id="543">543</th><td><i class="doc"> *     M-ADJ-1 --&gt; Interface_F</i></td></tr>
<tr><th id="544">544</th><td><i class="doc"> *</i></td></tr>
<tr><th id="545">545</th><td><i class="doc"> * M-ADJ = multi-path-adjacency.</i></td></tr>
<tr><th id="546">546</th><td><i class="doc"> *</i></td></tr>
<tr><th id="547">547</th><td><i class="doc"> * When interface K goes down a back-walk is started over its dependants in the</i></td></tr>
<tr><th id="548">548</th><td><i class="doc"> * control plane graph. This back-walk will reach PL_1 and PL_2 and result in</i></td></tr>
<tr><th id="549">549</th><td><i class="doc"> * the calculation of new adjacencies that have interface K removed. The walk</i></td></tr>
<tr><th id="550">550</th><td><i class="doc"> * will continue to the entry objects and thus the forwarding table is updated</i></td></tr>
<tr><th id="551">551</th><td><i class="doc"> * for each prefix with the new adjacency. The DP graph then becomes:</i></td></tr>
<tr><th id="552">552</th><td><i class="doc"> *</i></td></tr>
<tr><th id="553">553</th><td><i class="doc"> *    ADJ-3 --&gt; Interface_A</i></td></tr>
<tr><th id="554">554</th><td><i class="doc"> *</i></td></tr>
<tr><th id="555">555</th><td><i class="doc"> *    ADJ-4 --&gt; Interface_F</i></td></tr>
<tr><th id="556">556</th><td><i class="doc"> * </i></td></tr>
<tr><th id="557">557</th><td><i class="doc"> * The eBGP PIC scenarios described above relied on the update of a path-list's</i></td></tr>
<tr><th id="558">558</th><td><i class="doc"> * recursive-adjacency to provide the shared point of cutover. This is shown</i></td></tr>
<tr><th id="559">559</th><td><i class="doc"> * below</i></td></tr>
<tr><th id="560">560</th><td><i class="doc"> *</i></td></tr>
<tr><th id="561">561</th><td><i class="doc"> *    E_a --&gt;</i></td></tr>
<tr><th id="562">562</th><td><i class="doc"> *    E_b --&gt; PL_2 --&gt; P_a --&gt; E_44 --&gt; PL_a --&gt; P_b --&gt; Interface_A</i></td></tr>
<tr><th id="563">563</th><td><i class="doc"> *    ...          --&gt; P_c -\</i></td></tr>
<tr><th id="564">564</th><td><i class="doc"> *    E_k --&gt;                \</i></td></tr>
<tr><th id="565">565</th><td><i class="doc"> *                            \</i></td></tr>
<tr><th id="566">566</th><td><i class="doc"> *                           E_1 --&gt; PL_k -&gt; P_k --&gt; Interface_K</i></td></tr>
<tr><th id="567">567</th><td><i class="doc"> *                            /</i></td></tr>
<tr><th id="568">568</th><td><i class="doc"> *    E_l --&gt;                /</i></td></tr>
<tr><th id="569">569</th><td><i class="doc"> *    E_m --&gt; PL_1 --&gt; P_d -/ </i></td></tr>
<tr><th id="570">570</th><td><i class="doc"> *    ...          --&gt; P_f --&gt; E_55 --&gt; PL_e --&gt; P_e --&gt; Interface_E</i></td></tr>
<tr><th id="571">571</th><td><i class="doc"> *    E_z --&gt;</i></td></tr>
<tr><th id="572">572</th><td><i class="doc"> *</i></td></tr>
<tr><th id="573">573</th><td><i class="doc"> * The failure scenario is the removal of entry E_1 and thus the paths P_c and</i></td></tr>
<tr><th id="574">574</th><td><i class="doc"> * P_d become unresolved. To achieve PIC the two shared recursive path-lists,</i></td></tr>
<tr><th id="575">575</th><td><i class="doc"> * PL_1 and PL_2 must be updated to remove E_1 from the recursive-multi-path-</i></td></tr>
<tr><th id="576">576</th><td><i class="doc"> * adjacencies that they contribute, before any entry E_a to E_z is updated.</i></td></tr>
<tr><th id="577">577</th><td><i class="doc"> * This means that as the update propagates backwards (right to left) in the</i></td></tr>
<tr><th id="578">578</th><td><i class="doc"> * graph it must do so breadth first not depth first. Note this approach leads</i></td></tr>
<tr><th id="579">579</th><td><i class="doc"> * to convergence times that are dependent on the number of path-list and so</i></td></tr>
<tr><th id="580">580</th><td><i class="doc"> * the number of combinations of egress PEs - this is desirable as this</i></td></tr>
<tr><th id="581">581</th><td><i class="doc"> * scale is considerably lower than the number of prefixes.</i></td></tr>
<tr><th id="582">582</th><td><i class="doc"> *</i></td></tr>
<tr><th id="583">583</th><td><i class="doc"> * If we consider another section of the graph that is similar to the one</i></td></tr>
<tr><th id="584">584</th><td><i class="doc"> * shown above where there is another prefix E_2 in a similar position to E_1</i></td></tr>
<tr><th id="585">585</th><td><i class="doc"> * and so also has many dependent children. It is reasonable to expect that a</i></td></tr>
<tr><th id="586">586</th><td><i class="doc"> * particular network failure may simultaneously render E_1 and E_2 unreachable.</i></td></tr>
<tr><th id="587">587</th><td><i class="doc"> * This means that the update to withdraw E_2 is download immediately after the</i></td></tr>
<tr><th id="588">588</th><td><i class="doc"> * update to withdraw E_1. It is a requirement on the FIB to not spend large</i></td></tr>
<tr><th id="589">589</th><td><i class="doc"> * amounts of time in a back-walk whilst processing the update for E_1, i.e. the</i></td></tr>
<tr><th id="590">590</th><td><i class="doc"> * back-walk must not reach as far as E_a and its siblings. Therefore, after the</i></td></tr>
<tr><th id="591">591</th><td><i class="doc"> * back-walk has traversed one generation (breadth first) to update all the</i></td></tr>
<tr><th id="592">592</th><td><i class="doc"> * path-lists it should be suspended/back-ground and further updates allowed</i></td></tr>
<tr><th id="593">593</th><td><i class="doc"> * to be handled. Once the update queue is empty, the suspended walks can be</i></td></tr>
<tr><th id="594">594</th><td><i class="doc"> * resumed. Note that in the case that multiple updates affect the same entry</i></td></tr>
<tr><th id="595">595</th><td><i class="doc"> * (say E_1) then this will trigger multiple similar walks, these are merged,</i></td></tr>
<tr><th id="596">596</th><td><i class="doc"> * so each child is updated only once.</i></td></tr>
<tr><th id="597">597</th><td><i class="doc"> * In the presence of more layers of recursion PIC is still a desirable</i></td></tr>
<tr><th id="598">598</th><td><i class="doc"> * feature. Consider an extension to the diagram above, where more recursive</i></td></tr>
<tr><th id="599">599</th><td><i class="doc"> * routes (E_100 -&gt; E_200) are added as children of E_a:</i></td></tr>
<tr><th id="600">600</th><td><i class="doc"> *</i></td></tr>
<tr><th id="601">601</th><td><i class="doc"> * E_100 --&gt;</i></td></tr>
<tr><th id="602">602</th><td><i class="doc"> * E_101 --&gt; PL_3 --&gt; P_j-\</i></td></tr>
<tr><th id="603">603</th><td><i class="doc"> * ...                     \</i></td></tr>
<tr><th id="604">604</th><td><i class="doc"> * E_199 --&gt;               E_a --&gt;</i></td></tr>
<tr><th id="605">605</th><td><i class="doc"> *                         E_b --&gt; PL_2 --&gt; P_a --&gt; E_44 --&gt; ...etc..</i></td></tr>
<tr><th id="606">606</th><td><i class="doc"> *                         ...          --&gt; P_c -\</i></td></tr>
<tr><th id="607">607</th><td><i class="doc"> *                         E_k                    \</i></td></tr>
<tr><th id="608">608</th><td><i class="doc"> *                                                E_1 --&gt; ...etc..</i></td></tr>
<tr><th id="609">609</th><td><i class="doc"> *                                                 /</i></td></tr>
<tr><th id="610">610</th><td><i class="doc"> *                         E_l --&gt;                /</i></td></tr>
<tr><th id="611">611</th><td><i class="doc"> *                         E_m --&gt; PL_1 --&gt; P_d -/ </i></td></tr>
<tr><th id="612">612</th><td><i class="doc"> *                         ...          --&gt; P_e --&gt; E_55 --&gt; ...etc..</i></td></tr>
<tr><th id="613">613</th><td><i class="doc"> *                         E_z --&gt;</i></td></tr>
<tr><th id="614">614</th><td><i class="doc"> *</i></td></tr>
<tr><th id="615">615</th><td><i class="doc"> * To achieve PIC for the routes E_100-&gt;E_199, PL_3 needs to be updated before</i></td></tr>
<tr><th id="616">616</th><td><i class="doc"> * E_b -&gt; E_z, a breadth first traversal at each level would not achieve this.</i></td></tr>
<tr><th id="617">617</th><td><i class="doc"> * Instead the walk must proceed intelligently. Children on PL_2 are sorted so</i></td></tr>
<tr><th id="618">618</th><td><i class="doc"> * those Entry objects that themselves have children appear first in the list,</i></td></tr>
<tr><th id="619">619</th><td><i class="doc"> * those without later. When an entry object is walked that has children, a</i></td></tr>
<tr><th id="620">620</th><td><i class="doc"> * walk of its children is pushed to the front background queue. The back</i></td></tr>
<tr><th id="621">621</th><td><i class="doc"> * ground queue is a priority queue. As the breadth first traversal proceeds</i></td></tr>
<tr><th id="622">622</th><td><i class="doc"> * across the dependent entry object E_a to E_k, when the first entry that does</i></td></tr>
<tr><th id="623">623</th><td><i class="doc"> * not have children is reached (E_b), the walk is suspended and placed at the</i></td></tr>
<tr><th id="624">624</th><td><i class="doc"> * back of the queue. Following this prioritisation method shared path-list</i></td></tr>
<tr><th id="625">625</th><td><i class="doc"> * updates are performed before all non-resolving entry objects.</i></td></tr>
<tr><th id="626">626</th><td><i class="doc"> * The CPU/core/thread that handles the updates is the same thread that handles</i></td></tr>
<tr><th id="627">627</th><td><i class="doc"> * the back-walks. Handling updates has a higher priority than making walk</i></td></tr>
<tr><th id="628">628</th><td><i class="doc"> * progress, so a walk is required to be interruptable/suspendable when new</i></td></tr>
<tr><th id="629">629</th><td><i class="doc"> * updates are available.</i></td></tr>
<tr><th id="630">630</th><td><i class="doc"> * !!! TODO - this section describes how walks should be not how they are !!!</i></td></tr>
<tr><th id="631">631</th><td><i class="doc"> *</i></td></tr>
<tr><th id="632">632</th><td><i class="doc"> * In the diagram above E_100 is an IP route, however, VPP has no restrictions</i></td></tr>
<tr><th id="633">633</th><td><i class="doc"> * on the type of object that can be a dependent of a FIB entry. Children of</i></td></tr>
<tr><th id="634">634</th><td><i class="doc"> * a FIB entry can be (and are) GRE &amp; VXLAN tunnels endpoints, L2VPN LSPs etc.</i></td></tr>
<tr><th id="635">635</th><td><i class="doc"> * By including all object types into the graph and extending the back-walk, we</i></td></tr>
<tr><th id="636">636</th><td><i class="doc"> * can thus deliver fast convergence to technologies that overlay on an IP</i></td></tr>
<tr><th id="637">637</th><td><i class="doc"> * network.</i></td></tr>
<tr><th id="638">638</th><td><i class="doc"> *</i></td></tr>
<tr><th id="639">639</th><td><i class="doc"> * If having read all the above carefully you are still thinking;  'i don't need</i></td></tr>
<tr><th id="640">640</th><td><i class="doc"> * all this %&amp;$* i have a route only I know about and I just need to jam it in',</i></td></tr>
<tr><th id="641">641</th><td><i class="doc"> * then fib_table_entry_special_add() is your only friend.</i></td></tr>
<tr><th id="642">642</th><td><i class="doc"> */</i></td></tr>
<tr><th id="643">643</th><td></td></tr>
<tr><th id="644">644</th><td><u>#<span data-ppcond="644">ifndef</span> <span class="macro" data-ref="_M/__FIB_H__">__FIB_H__</span></u></td></tr>
<tr><th id="645">645</th><td><u>#define <dfn class="macro" id="_M/__FIB_H__" data-ref="_M/__FIB_H__">__FIB_H__</dfn></u></td></tr>
<tr><th id="646">646</th><td></td></tr>
<tr><th id="647">647</th><td><u>#include <a href="fib_table.h.html">&lt;vnet/fib/fib_table.h&gt;</a></u></td></tr>
<tr><th id="648">648</th><td><u>#include <a href="fib_entry.h.html">&lt;vnet/fib/fib_entry.h&gt;</a></u></td></tr>
<tr><th id="649">649</th><td></td></tr>
<tr><th id="650">650</th><td><u>#<span data-ppcond="644">endif</span></u></td></tr>
<tr><th id="651">651</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../tests/vnet/session/tcp_echo.c.html'>vpp_1804/src/tests/vnet/session/tcp_echo.c</a><br/>Generated on <em>2018-Jul-30</em> from project vpp_1804 revision <em>18.05</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
