<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>nasm.h source code [vpp_1804/build-root/build-vpp_debug-native/dpdk/nasm-2.13.01/include/nasm.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="ccode,decorator_tokens,dfmt,directive_result,ea_flags,ea_type,eval_hint,eval_hints,extop,extop_type,floatize,ifunc,insn,location,ofmt,ofmt_alias,operand,out_data,out_sign,out_type,pragma,pragma_facility,prefix_pos,prefixes,preproc_ops,special_tokens,strfunc,token_type,tokenval,ttypes,vectlens,vex_class "/>
<link rel="stylesheet" href="../../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'vpp_1804/build-root/build-vpp_debug-native/dpdk/nasm-2.13.01/include/nasm.h'; var root_path = '../../../../../..'; var data_path = '../../../../../../../data';</script>
<script src='../../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>vpp_1804</a>/<a href='../../../..'>build-root</a>/<a href='../../..'>build-vpp_debug-native</a>/<a href='../..'>dpdk</a>/<a href='..'>nasm-2.13.01</a>/<a href='./'>include</a>/<a href='nasm.h.html'>nasm.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* ----------------------------------------------------------------------- *</i></td></tr>
<tr><th id="2">2</th><td><i> *</i></td></tr>
<tr><th id="3">3</th><td><i> *   Copyright 1996-2017 The NASM Authors - All Rights Reserved</i></td></tr>
<tr><th id="4">4</th><td><i> *   See the file AUTHORS included with the NASM distribution for</i></td></tr>
<tr><th id="5">5</th><td><i> *   the specific copyright holders.</i></td></tr>
<tr><th id="6">6</th><td><i> *</i></td></tr>
<tr><th id="7">7</th><td><i> *   Redistribution and use in source and binary forms, with or without</i></td></tr>
<tr><th id="8">8</th><td><i> *   modification, are permitted provided that the following</i></td></tr>
<tr><th id="9">9</th><td><i> *   conditions are met:</i></td></tr>
<tr><th id="10">10</th><td><i> *</i></td></tr>
<tr><th id="11">11</th><td><i> *   * Redistributions of source code must retain the above copyright</i></td></tr>
<tr><th id="12">12</th><td><i> *     notice, this list of conditions and the following disclaimer.</i></td></tr>
<tr><th id="13">13</th><td><i> *   * Redistributions in binary form must reproduce the above</i></td></tr>
<tr><th id="14">14</th><td><i> *     copyright notice, this list of conditions and the following</i></td></tr>
<tr><th id="15">15</th><td><i> *     disclaimer in the documentation and/or other materials provided</i></td></tr>
<tr><th id="16">16</th><td><i> *     with the distribution.</i></td></tr>
<tr><th id="17">17</th><td><i> *</i></td></tr>
<tr><th id="18">18</th><td><i> *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND</i></td></tr>
<tr><th id="19">19</th><td><i> *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,</i></td></tr>
<tr><th id="20">20</th><td><i> *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</i></td></tr>
<tr><th id="21">21</th><td><i> *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</i></td></tr>
<tr><th id="22">22</th><td><i> *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR</i></td></tr>
<tr><th id="23">23</th><td><i> *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</i></td></tr>
<tr><th id="24">24</th><td><i> *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</i></td></tr>
<tr><th id="25">25</th><td><i> *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</i></td></tr>
<tr><th id="26">26</th><td><i> *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</i></td></tr>
<tr><th id="27">27</th><td><i> *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</i></td></tr>
<tr><th id="28">28</th><td><i> *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR</i></td></tr>
<tr><th id="29">29</th><td><i> *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</i></td></tr>
<tr><th id="30">30</th><td><i> *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</i></td></tr>
<tr><th id="31">31</th><td><i> *</i></td></tr>
<tr><th id="32">32</th><td><i> * ----------------------------------------------------------------------- */</i></td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td><i>/*</i></td></tr>
<tr><th id="35">35</th><td><i> * nasm.h   main header file for the Netwide Assembler: inter-module interface</i></td></tr>
<tr><th id="36">36</th><td><i> */</i></td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><u>#<span data-ppcond="38">ifndef</span> <span class="macro" data-ref="_M/NASM_NASM_H">NASM_NASM_H</span></u></td></tr>
<tr><th id="39">39</th><td><u>#define <dfn class="macro" id="_M/NASM_NASM_H" data-ref="_M/NASM_NASM_H">NASM_NASM_H</dfn></u></td></tr>
<tr><th id="40">40</th><td></td></tr>
<tr><th id="41">41</th><td><u>#include <a href="compiler.h.html">"compiler.h"</a></u></td></tr>
<tr><th id="42">42</th><td></td></tr>
<tr><th id="43">43</th><td><u>#include <a href="../../../../../../include/stdio.h.html">&lt;stdio.h&gt;</a></u></td></tr>
<tr><th id="44">44</th><td><u>#include <a href="nasmlib.h.html">"nasmlib.h"</a></u></td></tr>
<tr><th id="45">45</th><td><u>#include <a href="strlist.h.html">"strlist.h"</a></u></td></tr>
<tr><th id="46">46</th><td><u>#include <a href="../asm/preproc.h.html">"preproc.h"</a></u></td></tr>
<tr><th id="47">47</th><td><u>#include <a href="../x86/insnsi.h.html">"insnsi.h"</a>     /* For enum opcode */</u></td></tr>
<tr><th id="48">48</th><td><u>#include <a href="../asm/directiv.h.html">"directiv.h"</a>   /* For enum directive */</u></td></tr>
<tr><th id="49">49</th><td><u>#include <a href="opflags.h.html">"opflags.h"</a></u></td></tr>
<tr><th id="50">50</th><td><u>#include <a href="../x86/regs.h.html">"regs.h"</a></u></td></tr>
<tr><th id="51">51</th><td></td></tr>
<tr><th id="52">52</th><td><u>#define <dfn class="macro" id="_M/NO_SEG" data-ref="_M/NO_SEG">NO_SEG</dfn> -1L              /* null segment value */</u></td></tr>
<tr><th id="53">53</th><td><u>#define <dfn class="macro" id="_M/SEG_ABS" data-ref="_M/SEG_ABS">SEG_ABS</dfn> 0x40000000L     /* mask for far-absolute segments */</u></td></tr>
<tr><th id="54">54</th><td></td></tr>
<tr><th id="55">55</th><td><u>#<span data-ppcond="55">ifndef</span> <a class="macro" href="../../../../../../include/bits/stdio_lim.h.html#25" data-ref="_M/FILENAME_MAX">FILENAME_MAX</a></u></td></tr>
<tr><th id="56">56</th><td><u>#define FILENAME_MAX 256</u></td></tr>
<tr><th id="57">57</th><td><u>#<span data-ppcond="55">endif</span></u></td></tr>
<tr><th id="58">58</th><td></td></tr>
<tr><th id="59">59</th><td><u>#<span data-ppcond="59">ifndef</span> <span class="macro" data-ref="_M/PREFIX_MAX">PREFIX_MAX</span></u></td></tr>
<tr><th id="60">60</th><td><u>#define <dfn class="macro" id="_M/PREFIX_MAX" data-ref="_M/PREFIX_MAX">PREFIX_MAX</dfn> 10</u></td></tr>
<tr><th id="61">61</th><td><u>#<span data-ppcond="59">endif</span></u></td></tr>
<tr><th id="62">62</th><td></td></tr>
<tr><th id="63">63</th><td><u>#<span data-ppcond="63">ifndef</span> <span class="macro" data-ref="_M/POSTFIX_MAX">POSTFIX_MAX</span></u></td></tr>
<tr><th id="64">64</th><td><u>#define <dfn class="macro" id="_M/POSTFIX_MAX" data-ref="_M/POSTFIX_MAX">POSTFIX_MAX</dfn> 10</u></td></tr>
<tr><th id="65">65</th><td><u>#<span data-ppcond="63">endif</span></u></td></tr>
<tr><th id="66">66</th><td></td></tr>
<tr><th id="67">67</th><td><u>#define <dfn class="macro" id="_M/IDLEN_MAX" data-ref="_M/IDLEN_MAX">IDLEN_MAX</dfn> 4096</u></td></tr>
<tr><th id="68">68</th><td><u>#define <dfn class="macro" id="_M/DECOLEN_MAX" data-ref="_M/DECOLEN_MAX">DECOLEN_MAX</dfn> 32</u></td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td><i>/*</i></td></tr>
<tr><th id="71">71</th><td><i> * Name pollution problems: &lt;time.h&gt; on Digital UNIX pulls in some</i></td></tr>
<tr><th id="72">72</th><td><i> * strange hardware header file which sees fit to define R_SP. We</i></td></tr>
<tr><th id="73">73</th><td><i> * undefine it here so as not to break the enum below.</i></td></tr>
<tr><th id="74">74</th><td><i> */</i></td></tr>
<tr><th id="75">75</th><td><u>#<span data-ppcond="75">ifdef</span> <span class="macro" data-ref="_M/R_SP">R_SP</span></u></td></tr>
<tr><th id="76">76</th><td><u>#undef R_SP</u></td></tr>
<tr><th id="77">77</th><td><u>#<span data-ppcond="75">endif</span></u></td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td><i>/*</i></td></tr>
<tr><th id="80">80</th><td><i> * We must declare the existence of this structure type up here,</i></td></tr>
<tr><th id="81">81</th><td><i> * since we have to reference it before we define it...</i></td></tr>
<tr><th id="82">82</th><td><i> */</i></td></tr>
<tr><th id="83">83</th><td><b>struct</b> <a class="type" href="#ofmt" title='ofmt' data-ref="ofmt">ofmt</a>;</td></tr>
<tr><th id="84">84</th><td></td></tr>
<tr><th id="85">85</th><td><i>/*</i></td></tr>
<tr><th id="86">86</th><td><i> * Values for the `type' parameter to an output function.</i></td></tr>
<tr><th id="87">87</th><td><i> */</i></td></tr>
<tr><th id="88">88</th><td><b>enum</b> <dfn class="type def" id="out_type" title='out_type' data-ref="out_type">out_type</dfn> {</td></tr>
<tr><th id="89">89</th><td>    <dfn class="enum" id="OUT_RAWDATA" title='OUT_RAWDATA' data-ref="OUT_RAWDATA">OUT_RAWDATA</dfn>,    <i>/* Plain bytes */</i></td></tr>
<tr><th id="90">90</th><td>    <dfn class="enum" id="OUT_RESERVE" title='OUT_RESERVE' data-ref="OUT_RESERVE">OUT_RESERVE</dfn>,    <i>/* Reserved bytes (RESB et al) */</i></td></tr>
<tr><th id="91">91</th><td>    <dfn class="enum" id="OUT_ADDRESS" title='OUT_ADDRESS' data-ref="OUT_ADDRESS">OUT_ADDRESS</dfn>,    <i>/* An address (symbol value) */</i></td></tr>
<tr><th id="92">92</th><td>    <dfn class="enum" id="OUT_RELADDR" title='OUT_RELADDR' data-ref="OUT_RELADDR">OUT_RELADDR</dfn>,    <i>/* A relative address */</i></td></tr>
<tr><th id="93">93</th><td>    <dfn class="enum" id="OUT_SEGMENT" title='OUT_SEGMENT' data-ref="OUT_SEGMENT">OUT_SEGMENT</dfn>,    <i>/* A segment number */</i></td></tr>
<tr><th id="94">94</th><td></td></tr>
<tr><th id="95">95</th><td>    <i>/*</i></td></tr>
<tr><th id="96">96</th><td><i>     * These values are used by the legacy backend interface only;</i></td></tr>
<tr><th id="97">97</th><td><i>     * see output/legacy.c for more information.  These should never</i></td></tr>
<tr><th id="98">98</th><td><i>     * be used otherwise.  Once all backends have been migrated to the</i></td></tr>
<tr><th id="99">99</th><td><i>     * new interface they should be removed.</i></td></tr>
<tr><th id="100">100</th><td><i>     */</i></td></tr>
<tr><th id="101">101</th><td>    <dfn class="enum" id="OUT_REL1ADR" title='OUT_REL1ADR' data-ref="OUT_REL1ADR">OUT_REL1ADR</dfn>,</td></tr>
<tr><th id="102">102</th><td>    <dfn class="enum" id="OUT_REL2ADR" title='OUT_REL2ADR' data-ref="OUT_REL2ADR">OUT_REL2ADR</dfn>,</td></tr>
<tr><th id="103">103</th><td>    <dfn class="enum" id="OUT_REL4ADR" title='OUT_REL4ADR' data-ref="OUT_REL4ADR">OUT_REL4ADR</dfn>,</td></tr>
<tr><th id="104">104</th><td>    <dfn class="enum" id="OUT_REL8ADR" title='OUT_REL8ADR' data-ref="OUT_REL8ADR">OUT_REL8ADR</dfn></td></tr>
<tr><th id="105">105</th><td>};</td></tr>
<tr><th id="106">106</th><td></td></tr>
<tr><th id="107">107</th><td><b>enum</b> <dfn class="type def" id="out_sign" title='out_sign' data-ref="out_sign">out_sign</dfn> {</td></tr>
<tr><th id="108">108</th><td>    <dfn class="enum" id="OUT_WRAP" title='OUT_WRAP' data-ref="OUT_WRAP">OUT_WRAP</dfn>,                   <i>/* Undefined signedness (wraps) */</i></td></tr>
<tr><th id="109">109</th><td>    <dfn class="enum" id="OUT_SIGNED" title='OUT_SIGNED' data-ref="OUT_SIGNED">OUT_SIGNED</dfn>,                 <i>/* Value is signed */</i></td></tr>
<tr><th id="110">110</th><td>    <dfn class="enum" id="OUT_UNSIGNED" title='OUT_UNSIGNED' data-ref="OUT_UNSIGNED">OUT_UNSIGNED</dfn>                <i>/* Value is unsigned */</i></td></tr>
<tr><th id="111">111</th><td>};</td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td><i>/*</i></td></tr>
<tr><th id="114">114</th><td><i> * The data we send down to the backend.</i></td></tr>
<tr><th id="115">115</th><td><i> * XXX: We still want to push down the base address symbol if</i></td></tr>
<tr><th id="116">116</th><td><i> * available, and replace the segment numbers with a structure.</i></td></tr>
<tr><th id="117">117</th><td><i> */</i></td></tr>
<tr><th id="118">118</th><td><b>struct</b> <dfn class="type def" id="out_data" title='out_data' data-ref="out_data">out_data</dfn> {</td></tr>
<tr><th id="119">119</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl field" id="out_data::offset" title='out_data::offset' data-ref="out_data::offset">offset</dfn>;             <i>/* Offset within segment */</i></td></tr>
<tr><th id="120">120</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl field" id="out_data::segment" title='out_data::segment' data-ref="out_data::segment">segment</dfn>;            <i>/* Segment written to */</i></td></tr>
<tr><th id="121">121</th><td>    <b>enum</b> <a class="type" href="#out_type" title='out_type' data-ref="out_type">out_type</a> <dfn class="decl field" id="out_data::type" title='out_data::type' data-ref="out_data::type">type</dfn>;         <i>/* See above */</i></td></tr>
<tr><th id="122">122</th><td>    <b>enum</b> <a class="type" href="#out_sign" title='out_sign' data-ref="out_sign">out_sign</a> <dfn class="decl field" id="out_data::sign" title='out_data::sign' data-ref="out_data::sign">sign</dfn>;         <i>/* See above */</i></td></tr>
<tr><th id="123">123</th><td>    <em>int</em> <dfn class="decl field" id="out_data::inslen" title='out_data::inslen' data-ref="out_data::inslen">inslen</dfn>;                 <i>/* Length of instruction */</i></td></tr>
<tr><th id="124">124</th><td>    <em>int</em> <dfn class="decl field" id="out_data::insoffs" title='out_data::insoffs' data-ref="out_data::insoffs">insoffs</dfn>;                <i>/* Offset inside instruction */</i></td></tr>
<tr><th id="125">125</th><td>    <em>int</em> <dfn class="decl field" id="out_data::bits" title='out_data::bits' data-ref="out_data::bits">bits</dfn>;                   <i>/* Bits mode of compilation */</i></td></tr>
<tr><th id="126">126</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a> <dfn class="decl field" id="out_data::size" title='out_data::size' data-ref="out_data::size">size</dfn>;              <i>/* Size of output */</i></td></tr>
<tr><th id="127">127</th><td>    <em>const</em> <b>struct</b> <a class="type" href="insns.h.html#itemplate" title='itemplate' data-ref="itemplate" id="itemplate"><a class="type" href="insns.h.html#itemplate" title='itemplate' data-ref="itemplate">itemplate</a></a> *<dfn class="decl field" id="out_data::itemp" title='out_data::itemp' data-ref="out_data::itemp">itemp</dfn>; <i>/* Instruction template */</i></td></tr>
<tr><th id="128">128</th><td>    <em>const</em> <em>void</em> *<dfn class="decl field" id="out_data::data" title='out_data::data' data-ref="out_data::data">data</dfn>;           <i>/* Data for OUT_RAWDATA */</i></td></tr>
<tr><th id="129">129</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a> <dfn class="decl field" id="out_data::toffset" title='out_data::toffset' data-ref="out_data::toffset">toffset</dfn>;           <i>/* Target address offset for relocation */</i></td></tr>
<tr><th id="130">130</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl field" id="out_data::tsegment" title='out_data::tsegment' data-ref="out_data::tsegment">tsegment</dfn>;           <i>/* Target segment for relocation */</i></td></tr>
<tr><th id="131">131</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl field" id="out_data::twrt" title='out_data::twrt' data-ref="out_data::twrt">twrt</dfn>;               <i>/* Relocation with respect to */</i></td></tr>
<tr><th id="132">132</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl field" id="out_data::relbase" title='out_data::relbase' data-ref="out_data::relbase">relbase</dfn>;            <i>/* Relative base for OUT_RELADDR */</i></td></tr>
<tr><th id="133">133</th><td>};</td></tr>
<tr><th id="134">134</th><td></td></tr>
<tr><th id="135">135</th><td><i>/*</i></td></tr>
<tr><th id="136">136</th><td><i> * A label-lookup function.</i></td></tr>
<tr><th id="137">137</th><td><i> */</i></td></tr>
<tr><th id="138">138</th><td><b>typedef</b> <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> (*<dfn class="typedef" id="lfunc" title='lfunc' data-type='_Bool (*)(char *, int32_t *, int64_t *)' data-ref="lfunc">lfunc</dfn>)(<em>char</em> *<dfn class="local col4 decl" id="94label" title='label' data-type='char *' data-ref="94label">label</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> *<dfn class="local col5 decl" id="95segment" title='segment' data-type='int32_t *' data-ref="95segment">segment</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> *<dfn class="local col6 decl" id="96offset" title='offset' data-type='int64_t *' data-ref="96offset">offset</dfn>);</td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td><i>/*</i></td></tr>
<tr><th id="141">141</th><td><i> * And a label-definition function. The boolean parameter</i></td></tr>
<tr><th id="142">142</th><td><i> * `is_norm' states whether the label is a `normal' label (which</i></td></tr>
<tr><th id="143">143</th><td><i> * should affect the local-label system), or something odder like</i></td></tr>
<tr><th id="144">144</th><td><i> * an EQU or a segment-base symbol, which shouldn't.</i></td></tr>
<tr><th id="145">145</th><td><i> */</i></td></tr>
<tr><th id="146">146</th><td><b>typedef</b> <em>void</em> (*<dfn class="typedef" id="ldfunc" title='ldfunc' data-type='void (*)(char *, int32_t, int64_t, char *, _Bool, _Bool)' data-ref="ldfunc">ldfunc</dfn>)(<em>char</em> *<dfn class="local col7 decl" id="97label" title='label' data-type='char *' data-ref="97label">label</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col8 decl" id="98segment" title='segment' data-type='int32_t' data-ref="98segment">segment</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="local col9 decl" id="99offset" title='offset' data-type='int64_t' data-ref="99offset">offset</dfn>,</td></tr>
<tr><th id="147">147</th><td>                       <em>char</em> *<dfn class="local col0 decl" id="100special" title='special' data-type='char *' data-ref="100special">special</dfn>, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="local col1 decl" id="101is_norm" title='is_norm' data-type='_Bool' data-ref="101is_norm">is_norm</dfn>, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="local col2 decl" id="102isextrn" title='isextrn' data-type='_Bool' data-ref="102isextrn">isextrn</dfn>);</td></tr>
<tr><th id="148">148</th><td></td></tr>
<tr><th id="149">149</th><td><em>void</em> <dfn class="decl fn" id="define_label" title='define_label' data-ref="define_label">define_label</dfn>(<em>char</em> *<dfn class="local col3 decl" id="103label" title='label' data-type='char *' data-ref="103label">label</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col4 decl" id="104segment" title='segment' data-type='int32_t' data-ref="104segment">segment</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="local col5 decl" id="105offset" title='offset' data-type='int64_t' data-ref="105offset">offset</dfn>,</td></tr>
<tr><th id="150">150</th><td>                  <em>char</em> *<dfn class="local col6 decl" id="106special" title='special' data-type='char *' data-ref="106special">special</dfn>, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="local col7 decl" id="107is_norm" title='is_norm' data-type='_Bool' data-ref="107is_norm">is_norm</dfn>, <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="local col8 decl" id="108isextrn" title='isextrn' data-type='_Bool' data-ref="108isextrn">isextrn</dfn>);</td></tr>
<tr><th id="151">151</th><td></td></tr>
<tr><th id="152">152</th><td><i>/*</i></td></tr>
<tr><th id="153">153</th><td><i> * Token types returned by the scanner, in addition to ordinary</i></td></tr>
<tr><th id="154">154</th><td><i> * ASCII character values, and zero for end-of-string.</i></td></tr>
<tr><th id="155">155</th><td><i> */</i></td></tr>
<tr><th id="156">156</th><td><b>enum</b> <dfn class="type def" id="token_type" title='token_type' data-ref="token_type">token_type</dfn> { <i>/* token types, other than chars */</i></td></tr>
<tr><th id="157">157</th><td>    <dfn class="enum" id="TOKEN_INVALID" title='TOKEN_INVALID' data-ref="TOKEN_INVALID">TOKEN_INVALID</dfn> = -<var>1</var>, <i>/* a placeholder value */</i></td></tr>
<tr><th id="158">158</th><td>    <dfn class="enum" id="TOKEN_EOS" title='TOKEN_EOS' data-ref="TOKEN_EOS">TOKEN_EOS</dfn> = <var>0</var>,      <i>/* end of string */</i></td></tr>
<tr><th id="159">159</th><td>    <dfn class="enum" id="TOKEN_EQ" title='TOKEN_EQ' data-ref="TOKEN_EQ">TOKEN_EQ</dfn> = <kbd>'='</kbd>,</td></tr>
<tr><th id="160">160</th><td>    <dfn class="enum" id="TOKEN_GT" title='TOKEN_GT' data-ref="TOKEN_GT">TOKEN_GT</dfn> = <kbd>'&gt;'</kbd>,</td></tr>
<tr><th id="161">161</th><td>    <dfn class="enum" id="TOKEN_LT" title='TOKEN_LT' data-ref="TOKEN_LT">TOKEN_LT</dfn> = <kbd>'&lt;'</kbd>,     <i>/* aliases */</i></td></tr>
<tr><th id="162">162</th><td>    <dfn class="enum" id="TOKEN_ID" title='TOKEN_ID' data-ref="TOKEN_ID">TOKEN_ID</dfn> = <var>256</var>,     <i>/* identifier */</i></td></tr>
<tr><th id="163">163</th><td>    <dfn class="enum" id="TOKEN_NUM" title='TOKEN_NUM' data-ref="TOKEN_NUM">TOKEN_NUM</dfn>,          <i>/* numeric constant */</i></td></tr>
<tr><th id="164">164</th><td>    <dfn class="enum" id="TOKEN_ERRNUM" title='TOKEN_ERRNUM' data-ref="TOKEN_ERRNUM">TOKEN_ERRNUM</dfn>,       <i>/* malformed numeric constant */</i></td></tr>
<tr><th id="165">165</th><td>    <dfn class="enum" id="TOKEN_STR" title='TOKEN_STR' data-ref="TOKEN_STR">TOKEN_STR</dfn>,          <i>/* string constant */</i></td></tr>
<tr><th id="166">166</th><td>    <dfn class="enum" id="TOKEN_ERRSTR" title='TOKEN_ERRSTR' data-ref="TOKEN_ERRSTR">TOKEN_ERRSTR</dfn>,       <i>/* unterminated string constant */</i></td></tr>
<tr><th id="167">167</th><td>    <dfn class="enum" id="TOKEN_FLOAT" title='TOKEN_FLOAT' data-ref="TOKEN_FLOAT">TOKEN_FLOAT</dfn>,        <i>/* floating-point constant */</i></td></tr>
<tr><th id="168">168</th><td>    <dfn class="enum" id="TOKEN_REG" title='TOKEN_REG' data-ref="TOKEN_REG">TOKEN_REG</dfn>,          <i>/* register name */</i></td></tr>
<tr><th id="169">169</th><td>    <dfn class="enum" id="TOKEN_INSN" title='TOKEN_INSN' data-ref="TOKEN_INSN">TOKEN_INSN</dfn>,         <i>/* instruction name */</i></td></tr>
<tr><th id="170">170</th><td>    <dfn class="enum" id="TOKEN_HERE" title='TOKEN_HERE' data-ref="TOKEN_HERE">TOKEN_HERE</dfn>,         <i>/* $ */</i></td></tr>
<tr><th id="171">171</th><td>    <dfn class="enum" id="TOKEN_BASE" title='TOKEN_BASE' data-ref="TOKEN_BASE">TOKEN_BASE</dfn>,         <i>/* $$ */</i></td></tr>
<tr><th id="172">172</th><td>    <dfn class="enum" id="TOKEN_SPECIAL" title='TOKEN_SPECIAL' data-ref="TOKEN_SPECIAL">TOKEN_SPECIAL</dfn>,      <i>/* BYTE, WORD, DWORD, QWORD, FAR, NEAR, etc */</i></td></tr>
<tr><th id="173">173</th><td>    <dfn class="enum" id="TOKEN_PREFIX" title='TOKEN_PREFIX' data-ref="TOKEN_PREFIX">TOKEN_PREFIX</dfn>,       <i>/* A32, O16, LOCK, REPNZ, TIMES, etc */</i></td></tr>
<tr><th id="174">174</th><td>    <dfn class="enum" id="TOKEN_SHL" title='TOKEN_SHL' data-ref="TOKEN_SHL">TOKEN_SHL</dfn>,          <i>/* &lt;&lt; */</i></td></tr>
<tr><th id="175">175</th><td>    <dfn class="enum" id="TOKEN_SHR" title='TOKEN_SHR' data-ref="TOKEN_SHR">TOKEN_SHR</dfn>,          <i>/* &gt;&gt; */</i></td></tr>
<tr><th id="176">176</th><td>    <dfn class="enum" id="TOKEN_SDIV" title='TOKEN_SDIV' data-ref="TOKEN_SDIV">TOKEN_SDIV</dfn>,         <i>/* // */</i></td></tr>
<tr><th id="177">177</th><td>    <dfn class="enum" id="TOKEN_SMOD" title='TOKEN_SMOD' data-ref="TOKEN_SMOD">TOKEN_SMOD</dfn>,         <i>/* %% */</i></td></tr>
<tr><th id="178">178</th><td>    <dfn class="enum" id="TOKEN_GE" title='TOKEN_GE' data-ref="TOKEN_GE">TOKEN_GE</dfn>,           <i>/* &gt;= */</i></td></tr>
<tr><th id="179">179</th><td>    <dfn class="enum" id="TOKEN_LE" title='TOKEN_LE' data-ref="TOKEN_LE">TOKEN_LE</dfn>,           <i>/* &lt;= */</i></td></tr>
<tr><th id="180">180</th><td>    <dfn class="enum" id="TOKEN_NE" title='TOKEN_NE' data-ref="TOKEN_NE">TOKEN_NE</dfn>,           <i>/* &lt;&gt; (!= is same as &lt;&gt;) */</i></td></tr>
<tr><th id="181">181</th><td>    <dfn class="enum" id="TOKEN_DBL_AND" title='TOKEN_DBL_AND' data-ref="TOKEN_DBL_AND">TOKEN_DBL_AND</dfn>,      <i>/* &amp;&amp; */</i></td></tr>
<tr><th id="182">182</th><td>    <dfn class="enum" id="TOKEN_DBL_OR" title='TOKEN_DBL_OR' data-ref="TOKEN_DBL_OR">TOKEN_DBL_OR</dfn>,       <i>/* || */</i></td></tr>
<tr><th id="183">183</th><td>    <dfn class="enum" id="TOKEN_DBL_XOR" title='TOKEN_DBL_XOR' data-ref="TOKEN_DBL_XOR">TOKEN_DBL_XOR</dfn>,      <i>/* ^^ */</i></td></tr>
<tr><th id="184">184</th><td>    <dfn class="enum" id="TOKEN_SEG" title='TOKEN_SEG' data-ref="TOKEN_SEG">TOKEN_SEG</dfn>,          <i>/* SEG */</i></td></tr>
<tr><th id="185">185</th><td>    <dfn class="enum" id="TOKEN_WRT" title='TOKEN_WRT' data-ref="TOKEN_WRT">TOKEN_WRT</dfn>,          <i>/* WRT */</i></td></tr>
<tr><th id="186">186</th><td>    <dfn class="enum" id="TOKEN_FLOATIZE" title='TOKEN_FLOATIZE' data-ref="TOKEN_FLOATIZE">TOKEN_FLOATIZE</dfn>,     <i>/* __floatX__ */</i></td></tr>
<tr><th id="187">187</th><td>    <dfn class="enum" id="TOKEN_STRFUNC" title='TOKEN_STRFUNC' data-ref="TOKEN_STRFUNC">TOKEN_STRFUNC</dfn>,      <i>/* __utf16*__, __utf32*__ */</i></td></tr>
<tr><th id="188">188</th><td>    <dfn class="enum" id="TOKEN_IFUNC" title='TOKEN_IFUNC' data-ref="TOKEN_IFUNC">TOKEN_IFUNC</dfn>,        <i>/* __ilog2*__ */</i></td></tr>
<tr><th id="189">189</th><td>    <dfn class="enum" id="TOKEN_DECORATOR" title='TOKEN_DECORATOR' data-ref="TOKEN_DECORATOR">TOKEN_DECORATOR</dfn>,    <i>/* decorators such as {...} */</i></td></tr>
<tr><th id="190">190</th><td>    <dfn class="enum" id="TOKEN_OPMASK" title='TOKEN_OPMASK' data-ref="TOKEN_OPMASK">TOKEN_OPMASK</dfn>        <i>/* translated token for opmask registers */</i></td></tr>
<tr><th id="191">191</th><td>};</td></tr>
<tr><th id="192">192</th><td></td></tr>
<tr><th id="193">193</th><td><b>enum</b> <dfn class="type def" id="floatize" title='floatize' data-ref="floatize">floatize</dfn> {</td></tr>
<tr><th id="194">194</th><td>    <dfn class="enum" id="FLOAT_8" title='FLOAT_8' data-ref="FLOAT_8">FLOAT_8</dfn>,</td></tr>
<tr><th id="195">195</th><td>    <dfn class="enum" id="FLOAT_16" title='FLOAT_16' data-ref="FLOAT_16">FLOAT_16</dfn>,</td></tr>
<tr><th id="196">196</th><td>    <dfn class="enum" id="FLOAT_32" title='FLOAT_32' data-ref="FLOAT_32">FLOAT_32</dfn>,</td></tr>
<tr><th id="197">197</th><td>    <dfn class="enum" id="FLOAT_64" title='FLOAT_64' data-ref="FLOAT_64">FLOAT_64</dfn>,</td></tr>
<tr><th id="198">198</th><td>    <dfn class="enum" id="FLOAT_80M" title='FLOAT_80M' data-ref="FLOAT_80M">FLOAT_80M</dfn>,</td></tr>
<tr><th id="199">199</th><td>    <dfn class="enum" id="FLOAT_80E" title='FLOAT_80E' data-ref="FLOAT_80E">FLOAT_80E</dfn>,</td></tr>
<tr><th id="200">200</th><td>    <dfn class="enum" id="FLOAT_128L" title='FLOAT_128L' data-ref="FLOAT_128L">FLOAT_128L</dfn>,</td></tr>
<tr><th id="201">201</th><td>    <dfn class="enum" id="FLOAT_128H" title='FLOAT_128H' data-ref="FLOAT_128H">FLOAT_128H</dfn></td></tr>
<tr><th id="202">202</th><td>};</td></tr>
<tr><th id="203">203</th><td></td></tr>
<tr><th id="204">204</th><td><i>/* Must match the list in string_transform(), in strfunc.c */</i></td></tr>
<tr><th id="205">205</th><td><b>enum</b> <dfn class="type def" id="strfunc" title='strfunc' data-ref="strfunc">strfunc</dfn> {</td></tr>
<tr><th id="206">206</th><td>    <dfn class="enum" id="STRFUNC_UTF16" title='STRFUNC_UTF16' data-ref="STRFUNC_UTF16">STRFUNC_UTF16</dfn>,</td></tr>
<tr><th id="207">207</th><td>    <dfn class="enum" id="STRFUNC_UTF16LE" title='STRFUNC_UTF16LE' data-ref="STRFUNC_UTF16LE">STRFUNC_UTF16LE</dfn>,</td></tr>
<tr><th id="208">208</th><td>    <dfn class="enum" id="STRFUNC_UTF16BE" title='STRFUNC_UTF16BE' data-ref="STRFUNC_UTF16BE">STRFUNC_UTF16BE</dfn>,</td></tr>
<tr><th id="209">209</th><td>    <dfn class="enum" id="STRFUNC_UTF32" title='STRFUNC_UTF32' data-ref="STRFUNC_UTF32">STRFUNC_UTF32</dfn>,</td></tr>
<tr><th id="210">210</th><td>    <dfn class="enum" id="STRFUNC_UTF32LE" title='STRFUNC_UTF32LE' data-ref="STRFUNC_UTF32LE">STRFUNC_UTF32LE</dfn>,</td></tr>
<tr><th id="211">211</th><td>    <dfn class="enum" id="STRFUNC_UTF32BE" title='STRFUNC_UTF32BE' data-ref="STRFUNC_UTF32BE">STRFUNC_UTF32BE</dfn></td></tr>
<tr><th id="212">212</th><td>};</td></tr>
<tr><th id="213">213</th><td></td></tr>
<tr><th id="214">214</th><td><b>enum</b> <dfn class="type def" id="ifunc" title='ifunc' data-ref="ifunc">ifunc</dfn> {</td></tr>
<tr><th id="215">215</th><td>    <dfn class="enum" id="IFUNC_ILOG2E" title='IFUNC_ILOG2E' data-ref="IFUNC_ILOG2E">IFUNC_ILOG2E</dfn>,</td></tr>
<tr><th id="216">216</th><td>    <dfn class="enum" id="IFUNC_ILOG2W" title='IFUNC_ILOG2W' data-ref="IFUNC_ILOG2W">IFUNC_ILOG2W</dfn>,</td></tr>
<tr><th id="217">217</th><td>    <dfn class="enum" id="IFUNC_ILOG2F" title='IFUNC_ILOG2F' data-ref="IFUNC_ILOG2F">IFUNC_ILOG2F</dfn>,</td></tr>
<tr><th id="218">218</th><td>    <dfn class="enum" id="IFUNC_ILOG2C" title='IFUNC_ILOG2C' data-ref="IFUNC_ILOG2C">IFUNC_ILOG2C</dfn></td></tr>
<tr><th id="219">219</th><td>};</td></tr>
<tr><th id="220">220</th><td></td></tr>
<tr><th id="221">221</th><td><span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span> <dfn class="decl fn" id="string_transform" title='string_transform' data-ref="string_transform">string_transform</dfn>(<em>char</em> *, <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span>, <em>char</em> **, <b>enum</b> <a class="type" href="#strfunc" title='strfunc' data-ref="strfunc">strfunc</a>);</td></tr>
<tr><th id="222">222</th><td></td></tr>
<tr><th id="223">223</th><td><i>/*</i></td></tr>
<tr><th id="224">224</th><td><i> * The expression evaluator must be passed a scanner function; a</i></td></tr>
<tr><th id="225">225</th><td><i> * standard scanner is provided as part of nasmlib.c. The</i></td></tr>
<tr><th id="226">226</th><td><i> * preprocessor will use a different one. Scanners, and the</i></td></tr>
<tr><th id="227">227</th><td><i> * token-value structures they return, look like this.</i></td></tr>
<tr><th id="228">228</th><td><i> *</i></td></tr>
<tr><th id="229">229</th><td><i> * The return value from the scanner is always a copy of the</i></td></tr>
<tr><th id="230">230</th><td><i> * `t_type' field in the structure.</i></td></tr>
<tr><th id="231">231</th><td><i> */</i></td></tr>
<tr><th id="232">232</th><td><b>struct</b> <dfn class="type def" id="tokenval" title='tokenval' data-ref="tokenval">tokenval</dfn> {</td></tr>
<tr><th id="233">233</th><td>    <em>char</em>                *<dfn class="decl field" id="tokenval::t_charptr" title='tokenval::t_charptr' data-ref="tokenval::t_charptr">t_charptr</dfn>;</td></tr>
<tr><th id="234">234</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a>             <dfn class="decl field" id="tokenval::t_integer" title='tokenval::t_integer' data-ref="tokenval::t_integer">t_integer</dfn>;</td></tr>
<tr><th id="235">235</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a>             <dfn class="decl field" id="tokenval::t_inttwo" title='tokenval::t_inttwo' data-ref="tokenval::t_inttwo">t_inttwo</dfn>;</td></tr>
<tr><th id="236">236</th><td>    <b>enum</b> <a class="type" href="#token_type" title='token_type' data-ref="token_type">token_type</a>     <dfn class="decl field" id="tokenval::t_type" title='tokenval::t_type' data-ref="tokenval::t_type">t_type</dfn>;</td></tr>
<tr><th id="237">237</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int8_t" title='int8_t' data-type='signed char' data-ref="int8_t">int8_t</a>              <dfn class="decl field" id="tokenval::t_flag" title='tokenval::t_flag' data-ref="tokenval::t_flag">t_flag</dfn>;</td></tr>
<tr><th id="238">238</th><td>};</td></tr>
<tr><th id="239">239</th><td><b>typedef</b> <em>int</em> (*<dfn class="typedef" id="scanner" title='scanner' data-type='int (*)(void *, struct tokenval *)' data-ref="scanner">scanner</dfn>)(<em>void</em> *<dfn class="local col9 decl" id="109private_data" title='private_data' data-type='void *' data-ref="109private_data">private_data</dfn>, <b>struct</b> <a class="type" href="#tokenval" title='tokenval' data-ref="tokenval">tokenval</a> *<dfn class="local col0 decl" id="110tv" title='tv' data-type='struct tokenval *' data-ref="110tv">tv</dfn>);</td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><b>struct</b> <dfn class="type def" id="location" title='location' data-ref="location">location</dfn> {</td></tr>
<tr><th id="242">242</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl field" id="location::offset" title='location::offset' data-ref="location::offset">offset</dfn>;</td></tr>
<tr><th id="243">243</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl field" id="location::segment" title='location::segment' data-ref="location::segment">segment</dfn>;</td></tr>
<tr><th id="244">244</th><td>    <em>int</em>     <dfn class="decl field" id="location::known" title='location::known' data-ref="location::known">known</dfn>;</td></tr>
<tr><th id="245">245</th><td>};</td></tr>
<tr><th id="246">246</th><td><b>extern</b> <b>struct</b> <a class="type" href="#location" title='location' data-ref="location">location</a> <dfn class="decl" id="location" title='location' data-ref="location">location</dfn>;</td></tr>
<tr><th id="247">247</th><td></td></tr>
<tr><th id="248">248</th><td><i>/*</i></td></tr>
<tr><th id="249">249</th><td><i> * Expression-evaluator datatype. Expressions, within the</i></td></tr>
<tr><th id="250">250</th><td><i> * evaluator, are stored as an array of these beasts, terminated by</i></td></tr>
<tr><th id="251">251</th><td><i> * a record with type==0. Mostly, it's a vector type: each type</i></td></tr>
<tr><th id="252">252</th><td><i> * denotes some kind of a component, and the value denotes the</i></td></tr>
<tr><th id="253">253</th><td><i> * multiple of that component present in the expression. The</i></td></tr>
<tr><th id="254">254</th><td><i> * exception is the WRT type, whose `value' field denotes the</i></td></tr>
<tr><th id="255">255</th><td><i> * segment to which the expression is relative. These segments will</i></td></tr>
<tr><th id="256">256</th><td><i> * be segment-base types, i.e. either odd segment values or SEG_ABS</i></td></tr>
<tr><th id="257">257</th><td><i> * types. So it is still valid to assume that anything with a</i></td></tr>
<tr><th id="258">258</th><td><i> * `value' field of zero is insignificant.</i></td></tr>
<tr><th id="259">259</th><td><i> */</i></td></tr>
<tr><th id="260">260</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="261">261</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl field" id="(anonymous)::type" title='(anonymous struct)::type' data-ref="(anonymous)::type">type</dfn>;                  <i>/* a register, or EXPR_xxx */</i></td></tr>
<tr><th id="262">262</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl field" id="(anonymous)::value" title='(anonymous struct)::value' data-ref="(anonymous)::value">value</dfn>;                 <i>/* must be &gt;= 32 bits */</i></td></tr>
<tr><th id="263">263</th><td>} <dfn class="typedef" id="expr" title='expr' data-type='struct expr' data-ref="expr">expr</dfn>;</td></tr>
<tr><th id="264">264</th><td></td></tr>
<tr><th id="265">265</th><td><i>/*</i></td></tr>
<tr><th id="266">266</th><td><i> * Library routines to manipulate expression data types.</i></td></tr>
<tr><th id="267">267</th><td><i> */</i></td></tr>
<tr><th id="268">268</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="is_reloc" title='is_reloc' data-ref="is_reloc">is_reloc</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col1 decl" id="111vect" title='vect' data-type='const expr *' data-ref="111vect">vect</dfn>);</td></tr>
<tr><th id="269">269</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="is_simple" title='is_simple' data-ref="is_simple">is_simple</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col2 decl" id="112vect" title='vect' data-type='const expr *' data-ref="112vect">vect</dfn>);</td></tr>
<tr><th id="270">270</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="is_really_simple" title='is_really_simple' data-ref="is_really_simple">is_really_simple</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col3 decl" id="113vect" title='vect' data-type='const expr *' data-ref="113vect">vect</dfn>);</td></tr>
<tr><th id="271">271</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="is_unknown" title='is_unknown' data-ref="is_unknown">is_unknown</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col4 decl" id="114vect" title='vect' data-type='const expr *' data-ref="114vect">vect</dfn>);</td></tr>
<tr><th id="272">272</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="is_just_unknown" title='is_just_unknown' data-ref="is_just_unknown">is_just_unknown</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col5 decl" id="115vect" title='vect' data-type='const expr *' data-ref="115vect">vect</dfn>);</td></tr>
<tr><th id="273">273</th><td><a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl fn" id="reloc_value" title='reloc_value' data-ref="reloc_value">reloc_value</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col6 decl" id="116vect" title='vect' data-type='const expr *' data-ref="116vect">vect</dfn>);</td></tr>
<tr><th id="274">274</th><td><a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl fn" id="reloc_seg" title='reloc_seg' data-ref="reloc_seg">reloc_seg</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col7 decl" id="117vect" title='vect' data-type='const expr *' data-ref="117vect">vect</dfn>);</td></tr>
<tr><th id="275">275</th><td><a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="decl fn" id="reloc_wrt" title='reloc_wrt' data-ref="reloc_wrt">reloc_wrt</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col8 decl" id="118vect" title='vect' data-type='const expr *' data-ref="118vect">vect</dfn>);</td></tr>
<tr><th id="276">276</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="is_self_relative" title='is_self_relative' data-ref="is_self_relative">is_self_relative</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col9 decl" id="119vect" title='vect' data-type='const expr *' data-ref="119vect">vect</dfn>);</td></tr>
<tr><th id="277">277</th><td><em>void</em> <dfn class="decl fn" id="dump_expr" title='dump_expr' data-ref="dump_expr">dump_expr</dfn>(<em>const</em> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *<dfn class="local col0 decl" id="120vect" title='vect' data-type='const expr *' data-ref="120vect">vect</dfn>);</td></tr>
<tr><th id="278">278</th><td></td></tr>
<tr><th id="279">279</th><td><i>/*</i></td></tr>
<tr><th id="280">280</th><td><i> * The evaluator can also return hints about which of two registers</i></td></tr>
<tr><th id="281">281</th><td><i> * used in an expression should be the base register. See also the</i></td></tr>
<tr><th id="282">282</th><td><i> * `operand' structure.</i></td></tr>
<tr><th id="283">283</th><td><i> */</i></td></tr>
<tr><th id="284">284</th><td><b>struct</b> <dfn class="type def" id="eval_hints" title='eval_hints' data-ref="eval_hints">eval_hints</dfn> {</td></tr>
<tr><th id="285">285</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="decl field" id="eval_hints::base" title='eval_hints::base' data-ref="eval_hints::base">base</dfn>;</td></tr>
<tr><th id="286">286</th><td>    <em>int</em>     <dfn class="decl field" id="eval_hints::type" title='eval_hints::type' data-ref="eval_hints::type">type</dfn>;</td></tr>
<tr><th id="287">287</th><td>};</td></tr>
<tr><th id="288">288</th><td></td></tr>
<tr><th id="289">289</th><td><i>/*</i></td></tr>
<tr><th id="290">290</th><td><i> * The actual expression evaluator function looks like this. When</i></td></tr>
<tr><th id="291">291</th><td><i> * called, it expects the first token of its expression to already</i></td></tr>
<tr><th id="292">292</th><td><i> * be in `*tv'; if it is not, set tv-&gt;t_type to TOKEN_INVALID and</i></td></tr>
<tr><th id="293">293</th><td><i> * it will start by calling the scanner.</i></td></tr>
<tr><th id="294">294</th><td><i> *</i></td></tr>
<tr><th id="295">295</th><td><i> * If a forward reference happens during evaluation, the evaluator</i></td></tr>
<tr><th id="296">296</th><td><i> * must set `*fwref' to true if `fwref' is non-NULL.</i></td></tr>
<tr><th id="297">297</th><td><i> *</i></td></tr>
<tr><th id="298">298</th><td><i> * `critical' is non-zero if the expression may not contain forward</i></td></tr>
<tr><th id="299">299</th><td><i> * references. The evaluator will report its own error if this</i></td></tr>
<tr><th id="300">300</th><td><i> * occurs; if `critical' is 1, the error will be "symbol not</i></td></tr>
<tr><th id="301">301</th><td><i> * defined before use", whereas if `critical' is 2, the error will</i></td></tr>
<tr><th id="302">302</th><td><i> * be "symbol undefined".</i></td></tr>
<tr><th id="303">303</th><td><i> *</i></td></tr>
<tr><th id="304">304</th><td><i> * If `critical' has bit 8 set (in addition to its main value: 0x101</i></td></tr>
<tr><th id="305">305</th><td><i> * and 0x102 correspond to 1 and 2) then an extended expression</i></td></tr>
<tr><th id="306">306</th><td><i> * syntax is recognised, in which relational operators such as =, &lt;</i></td></tr>
<tr><th id="307">307</th><td><i> * and &gt;= are accepted, as well as low-precedence logical operators</i></td></tr>
<tr><th id="308">308</th><td><i> * &amp;&amp;, ^^ and ||.</i></td></tr>
<tr><th id="309">309</th><td><i> *</i></td></tr>
<tr><th id="310">310</th><td><i> * If `hints' is non-NULL, it gets filled in with some hints as to</i></td></tr>
<tr><th id="311">311</th><td><i> * the base register in complex effective addresses.</i></td></tr>
<tr><th id="312">312</th><td><i> */</i></td></tr>
<tr><th id="313">313</th><td><u>#define <dfn class="macro" id="_M/CRITICAL" data-ref="_M/CRITICAL">CRITICAL</dfn> 0x100</u></td></tr>
<tr><th id="314">314</th><td><b>typedef</b> <a class="typedef" href="#expr" title='expr' data-type='struct expr' data-ref="expr">expr</a> *(*<dfn class="typedef" id="evalfunc" title='evalfunc' data-type='expr *(*)(scanner, void *, struct tokenval *, int *, int, struct eval_hints *)' data-ref="evalfunc">evalfunc</dfn>)(<a class="typedef" href="#scanner" title='scanner' data-type='int (*)(void *, struct tokenval *)' data-ref="scanner">scanner</a> <dfn class="local col1 decl" id="121sc" title='sc' data-type='scanner' data-ref="121sc">sc</dfn>, <em>void</em> *<dfn class="local col2 decl" id="122scprivate" title='scprivate' data-type='void *' data-ref="122scprivate">scprivate</dfn>,</td></tr>
<tr><th id="315">315</th><td>                          <b>struct</b> <a class="type" href="#tokenval" title='tokenval' data-ref="tokenval">tokenval</a> *<dfn class="local col3 decl" id="123tv" title='tv' data-type='struct tokenval *' data-ref="123tv">tv</dfn>, <em>int</em> *<dfn class="local col4 decl" id="124fwref" title='fwref' data-type='int *' data-ref="124fwref">fwref</dfn>, <em>int</em> <dfn class="local col5 decl" id="125critical" title='critical' data-type='int' data-ref="125critical">critical</dfn>,</td></tr>
<tr><th id="316">316</th><td>                          <b>struct</b> <a class="type" href="#eval_hints" title='eval_hints' data-ref="eval_hints">eval_hints</a> *<dfn class="local col6 decl" id="126hints" title='hints' data-type='struct eval_hints *' data-ref="126hints">hints</dfn>);</td></tr>
<tr><th id="317">317</th><td></td></tr>
<tr><th id="318">318</th><td><i>/*</i></td></tr>
<tr><th id="319">319</th><td><i> * Special values for expr-&gt;type.</i></td></tr>
<tr><th id="320">320</th><td><i> * These come after EXPR_REG_END as defined in regs.h.</i></td></tr>
<tr><th id="321">321</th><td><i> * Expr types : 0 ~ EXPR_REG_END, EXPR_UNKNOWN, EXPR_...., EXPR_RDSAE,</i></td></tr>
<tr><th id="322">322</th><td><i> *              EXPR_SEGBASE ~ EXPR_SEGBASE + SEG_ABS, ...</i></td></tr>
<tr><th id="323">323</th><td><i> */</i></td></tr>
<tr><th id="324">324</th><td><u>#define <dfn class="macro" id="_M/EXPR_UNKNOWN" data-ref="_M/EXPR_UNKNOWN">EXPR_UNKNOWN</dfn>    (EXPR_REG_END+1) /* forward references */</u></td></tr>
<tr><th id="325">325</th><td><u>#define <dfn class="macro" id="_M/EXPR_SIMPLE" data-ref="_M/EXPR_SIMPLE">EXPR_SIMPLE</dfn>     (EXPR_REG_END+2)</u></td></tr>
<tr><th id="326">326</th><td><u>#define <dfn class="macro" id="_M/EXPR_WRT" data-ref="_M/EXPR_WRT">EXPR_WRT</dfn>        (EXPR_REG_END+3)</u></td></tr>
<tr><th id="327">327</th><td><u>#define <dfn class="macro" id="_M/EXPR_RDSAE" data-ref="_M/EXPR_RDSAE">EXPR_RDSAE</dfn>      (EXPR_REG_END+4)</u></td></tr>
<tr><th id="328">328</th><td><u>#define <dfn class="macro" id="_M/EXPR_SEGBASE" data-ref="_M/EXPR_SEGBASE">EXPR_SEGBASE</dfn>    (EXPR_REG_END+5)</u></td></tr>
<tr><th id="329">329</th><td></td></tr>
<tr><th id="330">330</th><td><i>/*</i></td></tr>
<tr><th id="331">331</th><td><i> * preprocessors ought to look like this:</i></td></tr>
<tr><th id="332">332</th><td><i> */</i></td></tr>
<tr><th id="333">333</th><td><b>struct</b> <dfn class="type def" id="preproc_ops" title='preproc_ops' data-ref="preproc_ops">preproc_ops</dfn> {</td></tr>
<tr><th id="334">334</th><td>    <i>/*</i></td></tr>
<tr><th id="335">335</th><td><i>     * Called once at the very start of assembly.</i></td></tr>
<tr><th id="336">336</th><td><i>     */</i></td></tr>
<tr><th id="337">337</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::init" title='preproc_ops::init' data-ref="preproc_ops::init">init</dfn>)(<em>void</em>);</td></tr>
<tr><th id="338">338</th><td></td></tr>
<tr><th id="339">339</th><td>    <i>/*</i></td></tr>
<tr><th id="340">340</th><td><i>     * Called at the start of a pass; given a file name, the number</i></td></tr>
<tr><th id="341">341</th><td><i>     * of the pass, an error reporting function, an evaluator</i></td></tr>
<tr><th id="342">342</th><td><i>     * function, and a listing generator to talk to.</i></td></tr>
<tr><th id="343">343</th><td><i>     */</i></td></tr>
<tr><th id="344">344</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::reset" title='preproc_ops::reset' data-ref="preproc_ops::reset">reset</dfn>)(<em>char</em> *<dfn class="local col7 decl" id="127file" title='file' data-type='char *' data-ref="127file">file</dfn>, <em>int</em> <dfn class="local col8 decl" id="128pass" title='pass' data-type='int' data-ref="128pass">pass</dfn>, <a class="typedef" href="strlist.h.html#StrList" title='StrList' data-type='struct string_list' data-ref="StrList">StrList</a> **<dfn class="local col9 decl" id="129deplist" title='deplist' data-type='StrList **' data-ref="129deplist">deplist</dfn>);</td></tr>
<tr><th id="345">345</th><td></td></tr>
<tr><th id="346">346</th><td>    <i>/*</i></td></tr>
<tr><th id="347">347</th><td><i>     * Called to fetch a line of preprocessed source. The line</i></td></tr>
<tr><th id="348">348</th><td><i>     * returned has been malloc'ed, and so should be freed after</i></td></tr>
<tr><th id="349">349</th><td><i>     * use.</i></td></tr>
<tr><th id="350">350</th><td><i>     */</i></td></tr>
<tr><th id="351">351</th><td>    <em>char</em> *(*<dfn class="decl field" id="preproc_ops::getline" title='preproc_ops::getline' data-ref="preproc_ops::getline">getline</dfn>)(<em>void</em>);</td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td>    <i>/* Called at the end of a pass */</i></td></tr>
<tr><th id="354">354</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::cleanup" title='preproc_ops::cleanup' data-ref="preproc_ops::cleanup">cleanup</dfn>)(<em>int</em> <dfn class="local col0 decl" id="130pass" title='pass' data-type='int' data-ref="130pass">pass</dfn>);</td></tr>
<tr><th id="355">355</th><td></td></tr>
<tr><th id="356">356</th><td>    <i>/* Additional macros specific to output format */</i></td></tr>
<tr><th id="357">357</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::extra_stdmac" title='preproc_ops::extra_stdmac' data-ref="preproc_ops::extra_stdmac">extra_stdmac</dfn>)(<a class="typedef" href="../asm/preproc.h.html#macros_t" title='macros_t' data-type='const unsigned char' data-ref="macros_t">macros_t</a> *<dfn class="local col1 decl" id="131macros" title='macros' data-type='macros_t *' data-ref="131macros">macros</dfn>);</td></tr>
<tr><th id="358">358</th><td></td></tr>
<tr><th id="359">359</th><td>    <i>/* Early definitions and undefinitions for macros */</i></td></tr>
<tr><th id="360">360</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::pre_define" title='preproc_ops::pre_define' data-ref="preproc_ops::pre_define">pre_define</dfn>)(<em>char</em> *<dfn class="local col2 decl" id="132definition" title='definition' data-type='char *' data-ref="132definition">definition</dfn>);</td></tr>
<tr><th id="361">361</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::pre_undefine" title='preproc_ops::pre_undefine' data-ref="preproc_ops::pre_undefine">pre_undefine</dfn>)(<em>char</em> *<dfn class="local col3 decl" id="133definition" title='definition' data-type='char *' data-ref="133definition">definition</dfn>);</td></tr>
<tr><th id="362">362</th><td></td></tr>
<tr><th id="363">363</th><td>    <i>/* Include file from command line */</i></td></tr>
<tr><th id="364">364</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::pre_include" title='preproc_ops::pre_include' data-ref="preproc_ops::pre_include">pre_include</dfn>)(<em>char</em> *<dfn class="local col4 decl" id="134fname" title='fname' data-type='char *' data-ref="134fname">fname</dfn>);</td></tr>
<tr><th id="365">365</th><td></td></tr>
<tr><th id="366">366</th><td>    <i>/* Include path from command line */</i></td></tr>
<tr><th id="367">367</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::include_path" title='preproc_ops::include_path' data-ref="preproc_ops::include_path">include_path</dfn>)(<em>char</em> *<dfn class="local col5 decl" id="135path" title='path' data-type='char *' data-ref="135path">path</dfn>);</td></tr>
<tr><th id="368">368</th><td></td></tr>
<tr><th id="369">369</th><td>    <i>/* Unwind the macro stack when printing an error message */</i></td></tr>
<tr><th id="370">370</th><td>    <em>void</em> (*<dfn class="decl field" id="preproc_ops::error_list_macros" title='preproc_ops::error_list_macros' data-ref="preproc_ops::error_list_macros">error_list_macros</dfn>)(<em>int</em> <dfn class="local col6 decl" id="136severity" title='severity' data-type='int' data-ref="136severity">severity</dfn>);</td></tr>
<tr><th id="371">371</th><td>};</td></tr>
<tr><th id="372">372</th><td></td></tr>
<tr><th id="373">373</th><td><b>extern</b> <em>const</em> <b>struct</b> <a class="type" href="#preproc_ops" title='preproc_ops' data-ref="preproc_ops">preproc_ops</a> <dfn class="decl" id="nasmpp" title='nasmpp' data-ref="nasmpp">nasmpp</dfn>;</td></tr>
<tr><th id="374">374</th><td><b>extern</b> <em>const</em> <b>struct</b> <a class="type" href="#preproc_ops" title='preproc_ops' data-ref="preproc_ops">preproc_ops</a> <dfn class="decl" id="preproc_nop" title='preproc_nop' data-ref="preproc_nop">preproc_nop</dfn>;</td></tr>
<tr><th id="375">375</th><td></td></tr>
<tr><th id="376">376</th><td><i>/*</i></td></tr>
<tr><th id="377">377</th><td><i> * Some lexical properties of the NASM source language, included</i></td></tr>
<tr><th id="378">378</th><td><i> * here because they are shared between the parser and preprocessor.</i></td></tr>
<tr><th id="379">379</th><td><i> */</i></td></tr>
<tr><th id="380">380</th><td></td></tr>
<tr><th id="381">381</th><td><i>/*</i></td></tr>
<tr><th id="382">382</th><td><i> * isidstart matches any character that may start an identifier, and isidchar</i></td></tr>
<tr><th id="383">383</th><td><i> * matches any character that may appear at places other than the start of an</i></td></tr>
<tr><th id="384">384</th><td><i> * identifier. E.g. a period may only appear at the start of an identifier</i></td></tr>
<tr><th id="385">385</th><td><i> * (for local labels), whereas a number may appear anywhere *but* at the</i></td></tr>
<tr><th id="386">386</th><td><i> * start.</i></td></tr>
<tr><th id="387">387</th><td><i> * isbrcchar matches any character that may placed inside curly braces as a</i></td></tr>
<tr><th id="388">388</th><td><i> * decorator. E.g. {rn-sae}, {1to8}, {k1}{z}</i></td></tr>
<tr><th id="389">389</th><td><i> */</i></td></tr>
<tr><th id="390">390</th><td></td></tr>
<tr><th id="391">391</th><td><u>#define <dfn class="macro" id="_M/isidstart" data-ref="_M/isidstart">isidstart</dfn>(c) (nasm_isalpha(c)   ||  \</u></td></tr>
<tr><th id="392">392</th><td><u>                      (c) == '_'        ||  \</u></td></tr>
<tr><th id="393">393</th><td><u>                      (c) == '.'        ||  \</u></td></tr>
<tr><th id="394">394</th><td><u>                      (c) == '?'        ||  \</u></td></tr>
<tr><th id="395">395</th><td><u>                      (c) == '@')</u></td></tr>
<tr><th id="396">396</th><td></td></tr>
<tr><th id="397">397</th><td><u>#define <dfn class="macro" id="_M/isidchar" data-ref="_M/isidchar">isidchar</dfn>(c) (isidstart(c)       ||  \</u></td></tr>
<tr><th id="398">398</th><td><u>                     nasm_isdigit(c)    ||  \</u></td></tr>
<tr><th id="399">399</th><td><u>                     (c) == '$'         ||  \</u></td></tr>
<tr><th id="400">400</th><td><u>                     (c) == '#'         ||  \</u></td></tr>
<tr><th id="401">401</th><td><u>                     (c) == '~')</u></td></tr>
<tr><th id="402">402</th><td></td></tr>
<tr><th id="403">403</th><td><u>#define <dfn class="macro" id="_M/isbrcchar" data-ref="_M/isbrcchar">isbrcchar</dfn>(c) (isidchar(c)       ||  \</u></td></tr>
<tr><th id="404">404</th><td><u>                      (c) == '-')</u></td></tr>
<tr><th id="405">405</th><td></td></tr>
<tr><th id="406">406</th><td><i>/* Ditto for numeric constants. */</i></td></tr>
<tr><th id="407">407</th><td></td></tr>
<tr><th id="408">408</th><td><u>#define <dfn class="macro" id="_M/isnumstart" data-ref="_M/isnumstart">isnumstart</dfn>(c)  (nasm_isdigit(c) || (c) == '$')</u></td></tr>
<tr><th id="409">409</th><td><u>#define <dfn class="macro" id="_M/isnumchar" data-ref="_M/isnumchar">isnumchar</dfn>(c)   (nasm_isalnum(c) || (c) == '_')</u></td></tr>
<tr><th id="410">410</th><td></td></tr>
<tr><th id="411">411</th><td><i>/*</i></td></tr>
<tr><th id="412">412</th><td><i> * inline function to skip past an identifier; returns the first character past</i></td></tr>
<tr><th id="413">413</th><td><i> * the identifier if valid, otherwise NULL.</i></td></tr>
<tr><th id="414">414</th><td><i> */</i></td></tr>
<tr><th id="415">415</th><td><em>static</em> <b>inline</b> <em>char</em> *<dfn class="decl def fn" id="nasm_skip_identifier" title='nasm_skip_identifier' data-ref="nasm_skip_identifier">nasm_skip_identifier</dfn>(<em>const</em> <em>char</em> *<dfn class="local col7 decl" id="137str" title='str' data-type='const char *' data-ref="137str">str</dfn>)</td></tr>
<tr><th id="416">416</th><td>{</td></tr>
<tr><th id="417">417</th><td>    <em>const</em> <em>char</em> *<dfn class="local col8 decl" id="138p" title='p' data-type='const char *' data-ref="138p">p</dfn> = <a class="local col7 ref" href="#137str" title='str' data-ref="137str">str</a>;</td></tr>
<tr><th id="418">418</th><td></td></tr>
<tr><th id="419">419</th><td>    <b>if</b> (!<a class="macro" href="#391" title="(((*__ctype_b_loc ())[(int) (((unsigned char)(*p++)))] &amp; (unsigned short int) _ISalpha) || (*p++) == &apos;_&apos; || (*p++) == &apos;.&apos; || (*p++) == &apos;?&apos; || (*p++) == &apos;@&apos;)" data-ref="_M/isidstart">isidstart</a>(*<a class="local col8 ref" href="#138p" title='p' data-ref="138p">p</a>++)) {</td></tr>
<tr><th id="420">420</th><td>        <a class="local col8 ref" href="#138p" title='p' data-ref="138p">p</a> = <span class="macro" title="((void*)0)" data-ref="_M/NULL">NULL</span>;</td></tr>
<tr><th id="421">421</th><td>    } <b>else</b> {</td></tr>
<tr><th id="422">422</th><td>        <b>while</b> (<a class="macro" href="#397" title="((((*__ctype_b_loc ())[(int) (((unsigned char)(*p++)))] &amp; (unsigned short int) _ISalpha) || (*p++) == &apos;_&apos; || (*p++) == &apos;.&apos; || (*p++) == &apos;?&apos; || (*p++) == &apos;@&apos;) || ((*__ctype_b_loc ())[(int) (((unsigned char)(*p++)))] &amp; (unsigned short int) _ISdigit) || (*p++) == &apos;$&apos; || (*p++) == &apos;#&apos; || (*p++) == &apos;~&apos;)" data-ref="_M/isidchar">isidchar</a>(*<a class="local col8 ref" href="#138p" title='p' data-ref="138p">p</a>++))</td></tr>
<tr><th id="423">423</th><td>            ;</td></tr>
<tr><th id="424">424</th><td>    }</td></tr>
<tr><th id="425">425</th><td>    <b>return</b> (<em>char</em> *)<a class="local col8 ref" href="#138p" title='p' data-ref="138p">p</a>;</td></tr>
<tr><th id="426">426</th><td>}</td></tr>
<tr><th id="427">427</th><td></td></tr>
<tr><th id="428">428</th><td><i>/*</i></td></tr>
<tr><th id="429">429</th><td><i> * Data-type flags that get passed to listing-file routines.</i></td></tr>
<tr><th id="430">430</th><td><i> */</i></td></tr>
<tr><th id="431">431</th><td><b>enum</b> {</td></tr>
<tr><th id="432">432</th><td>    <dfn class="enum" id="LIST_READ" title='LIST_READ' data-ref="LIST_READ">LIST_READ</dfn>,</td></tr>
<tr><th id="433">433</th><td>    <dfn class="enum" id="LIST_MACRO" title='LIST_MACRO' data-ref="LIST_MACRO">LIST_MACRO</dfn>,</td></tr>
<tr><th id="434">434</th><td>    <dfn class="enum" id="LIST_MACRO_NOLIST" title='LIST_MACRO_NOLIST' data-ref="LIST_MACRO_NOLIST">LIST_MACRO_NOLIST</dfn>,</td></tr>
<tr><th id="435">435</th><td>    <dfn class="enum" id="LIST_INCLUDE" title='LIST_INCLUDE' data-ref="LIST_INCLUDE">LIST_INCLUDE</dfn>,</td></tr>
<tr><th id="436">436</th><td>    <dfn class="enum" id="LIST_INCBIN" title='LIST_INCBIN' data-ref="LIST_INCBIN">LIST_INCBIN</dfn>,</td></tr>
<tr><th id="437">437</th><td>    <dfn class="enum" id="LIST_TIMES" title='LIST_TIMES' data-ref="LIST_TIMES">LIST_TIMES</dfn></td></tr>
<tr><th id="438">438</th><td>};</td></tr>
<tr><th id="439">439</th><td></td></tr>
<tr><th id="440">440</th><td><i>/*</i></td></tr>
<tr><th id="441">441</th><td><i> * -----------------------------------------------------------</i></td></tr>
<tr><th id="442">442</th><td><i> * Format of the `insn' structure returned from `parser.c' and</i></td></tr>
<tr><th id="443">443</th><td><i> * passed into `assemble.c'</i></td></tr>
<tr><th id="444">444</th><td><i> * -----------------------------------------------------------</i></td></tr>
<tr><th id="445">445</th><td><i> */</i></td></tr>
<tr><th id="446">446</th><td></td></tr>
<tr><th id="447">447</th><td><i>/* Verify value to be a valid register */</i></td></tr>
<tr><th id="448">448</th><td><em>static</em> <b>inline</b> <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl def fn" id="is_register" title='is_register' data-ref="is_register">is_register</dfn>(<em>int</em> <dfn class="local col9 decl" id="139reg" title='reg' data-type='int' data-ref="139reg">reg</dfn>)</td></tr>
<tr><th id="449">449</th><td>{</td></tr>
<tr><th id="450">450</th><td>    <b>return</b> <a class="local col9 ref" href="#139reg" title='reg' data-ref="139reg">reg</a> &gt;= <a class="macro" href="../x86/regs.h.html#6" title="1" data-ref="_M/EXPR_REG_START">EXPR_REG_START</a> &amp;&amp; <a class="local col9 ref" href="#139reg" title='reg' data-ref="139reg">reg</a> &lt; <a class="enum" href="../x86/regs.h.html#REG_ENUM_LIMIT" title='REG_ENUM_LIMIT' data-ref="REG_ENUM_LIMIT">REG_ENUM_LIMIT</a>;</td></tr>
<tr><th id="451">451</th><td>}</td></tr>
<tr><th id="452">452</th><td></td></tr>
<tr><th id="453">453</th><td><b>enum</b> <dfn class="type def" id="ccode" title='ccode' data-ref="ccode">ccode</dfn> { <i>/* condition code names */</i></td></tr>
<tr><th id="454">454</th><td>    <dfn class="enum" id="C_A" title='C_A' data-ref="C_A">C_A</dfn>, <dfn class="enum" id="C_AE" title='C_AE' data-ref="C_AE">C_AE</dfn>, <dfn class="enum" id="C_B" title='C_B' data-ref="C_B">C_B</dfn>, <dfn class="enum" id="C_BE" title='C_BE' data-ref="C_BE">C_BE</dfn>, <dfn class="enum" id="C_C" title='C_C' data-ref="C_C">C_C</dfn>, <dfn class="enum" id="C_E" title='C_E' data-ref="C_E">C_E</dfn>, <dfn class="enum" id="C_G" title='C_G' data-ref="C_G">C_G</dfn>, <dfn class="enum" id="C_GE" title='C_GE' data-ref="C_GE">C_GE</dfn>, <dfn class="enum" id="C_L" title='C_L' data-ref="C_L">C_L</dfn>, <dfn class="enum" id="C_LE" title='C_LE' data-ref="C_LE">C_LE</dfn>, <dfn class="enum" id="C_NA" title='C_NA' data-ref="C_NA">C_NA</dfn>, <dfn class="enum" id="C_NAE" title='C_NAE' data-ref="C_NAE">C_NAE</dfn>,</td></tr>
<tr><th id="455">455</th><td>    <dfn class="enum" id="C_NB" title='C_NB' data-ref="C_NB">C_NB</dfn>, <dfn class="enum" id="C_NBE" title='C_NBE' data-ref="C_NBE">C_NBE</dfn>, <dfn class="enum" id="C_NC" title='C_NC' data-ref="C_NC">C_NC</dfn>, <dfn class="enum" id="C_NE" title='C_NE' data-ref="C_NE">C_NE</dfn>, <dfn class="enum" id="C_NG" title='C_NG' data-ref="C_NG">C_NG</dfn>, <dfn class="enum" id="C_NGE" title='C_NGE' data-ref="C_NGE">C_NGE</dfn>, <dfn class="enum" id="C_NL" title='C_NL' data-ref="C_NL">C_NL</dfn>, <dfn class="enum" id="C_NLE" title='C_NLE' data-ref="C_NLE">C_NLE</dfn>, <dfn class="enum" id="C_NO" title='C_NO' data-ref="C_NO">C_NO</dfn>, <dfn class="enum" id="C_NP" title='C_NP' data-ref="C_NP">C_NP</dfn>,</td></tr>
<tr><th id="456">456</th><td>    <dfn class="enum" id="C_NS" title='C_NS' data-ref="C_NS">C_NS</dfn>, <dfn class="enum" id="C_NZ" title='C_NZ' data-ref="C_NZ">C_NZ</dfn>, <dfn class="enum" id="C_O" title='C_O' data-ref="C_O">C_O</dfn>, <dfn class="enum" id="C_P" title='C_P' data-ref="C_P">C_P</dfn>, <dfn class="enum" id="C_PE" title='C_PE' data-ref="C_PE">C_PE</dfn>, <dfn class="enum" id="C_PO" title='C_PO' data-ref="C_PO">C_PO</dfn>, <dfn class="enum" id="C_S" title='C_S' data-ref="C_S">C_S</dfn>, <dfn class="enum" id="C_Z" title='C_Z' data-ref="C_Z">C_Z</dfn>,</td></tr>
<tr><th id="457">457</th><td>    <dfn class="enum" id="C_none" title='C_none' data-ref="C_none">C_none</dfn> = -<var>1</var></td></tr>
<tr><th id="458">458</th><td>};</td></tr>
<tr><th id="459">459</th><td></td></tr>
<tr><th id="460">460</th><td><i>/*</i></td></tr>
<tr><th id="461">461</th><td><i> * token flags</i></td></tr>
<tr><th id="462">462</th><td><i> */</i></td></tr>
<tr><th id="463">463</th><td><u>#define <dfn class="macro" id="_M/TFLAG_BRC" data-ref="_M/TFLAG_BRC">TFLAG_BRC</dfn>       (1 &lt;&lt; 0)    /* valid only with braces. {1to8}, {rd-sae}, ...*/</u></td></tr>
<tr><th id="464">464</th><td><u>#define <dfn class="macro" id="_M/TFLAG_BRC_OPT" data-ref="_M/TFLAG_BRC_OPT">TFLAG_BRC_OPT</dfn>   (1 &lt;&lt; 1)    /* may or may not have braces. opmasks {k1} */</u></td></tr>
<tr><th id="465">465</th><td><u>#define <dfn class="macro" id="_M/TFLAG_BRC_ANY" data-ref="_M/TFLAG_BRC_ANY">TFLAG_BRC_ANY</dfn>   (TFLAG_BRC | TFLAG_BRC_OPT)</u></td></tr>
<tr><th id="466">466</th><td><u>#define <dfn class="macro" id="_M/TFLAG_BRDCAST" data-ref="_M/TFLAG_BRDCAST">TFLAG_BRDCAST</dfn>   (1 &lt;&lt; 2)    /* broadcasting decorator */</u></td></tr>
<tr><th id="467">467</th><td><u>#define <dfn class="macro" id="_M/TFLAG_WARN" data-ref="_M/TFLAG_WARN">TFLAG_WARN</dfn>	(1 &lt;&lt; 3)    /* warning only, treat as ID */</u></td></tr>
<tr><th id="468">468</th><td></td></tr>
<tr><th id="469">469</th><td><em>static</em> <b>inline</b> <a class="typedef" href="../../../../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a> <dfn class="decl def fn" id="get_cond_opcode" title='get_cond_opcode' data-ref="get_cond_opcode">get_cond_opcode</dfn>(<b>enum</b> <a class="type" href="#ccode" title='ccode' data-ref="ccode">ccode</a> <dfn class="local col0 decl" id="140c" title='c' data-type='enum ccode' data-ref="140c">c</dfn>)</td></tr>
<tr><th id="470">470</th><td>{</td></tr>
<tr><th id="471">471</th><td>    <em>static</em> <em>const</em> <a class="typedef" href="../../../../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a> <dfn class="local col1 decl" id="141ccode_opcodes" title='ccode_opcodes' data-type='const uint8_t [30]' data-ref="141ccode_opcodes">ccode_opcodes</dfn>[] = {</td></tr>
<tr><th id="472">472</th><td>        <var>0x7</var>, <var>0x3</var>, <var>0x2</var>, <var>0x6</var>, <var>0x2</var>, <var>0x4</var>, <var>0xf</var>, <var>0xd</var>, <var>0xc</var>, <var>0xe</var>, <var>0x6</var>, <var>0x2</var>,</td></tr>
<tr><th id="473">473</th><td>        <var>0x3</var>, <var>0x7</var>, <var>0x3</var>, <var>0x5</var>, <var>0xe</var>, <var>0xc</var>, <var>0xd</var>, <var>0xf</var>, <var>0x1</var>, <var>0xb</var>, <var>0x9</var>, <var>0x5</var>,</td></tr>
<tr><th id="474">474</th><td>        <var>0x0</var>, <var>0xa</var>, <var>0xa</var>, <var>0xb</var>, <var>0x8</var>, <var>0x4</var></td></tr>
<tr><th id="475">475</th><td>    };</td></tr>
<tr><th id="476">476</th><td></td></tr>
<tr><th id="477">477</th><td>	<b>return</b> <a class="local col1 ref" href="#141ccode_opcodes" title='ccode_opcodes' data-ref="141ccode_opcodes">ccode_opcodes</a>[(<em>int</em>)<a class="local col0 ref" href="#140c" title='c' data-ref="140c">c</a>];</td></tr>
<tr><th id="478">478</th><td>}</td></tr>
<tr><th id="479">479</th><td></td></tr>
<tr><th id="480">480</th><td><i>/*</i></td></tr>
<tr><th id="481">481</th><td><i> * REX flags</i></td></tr>
<tr><th id="482">482</th><td><i> */</i></td></tr>
<tr><th id="483">483</th><td><u>#define <dfn class="macro" id="_M/REX_MASK" data-ref="_M/REX_MASK">REX_MASK</dfn>    0x4f    /* Actual REX prefix bits */</u></td></tr>
<tr><th id="484">484</th><td><u>#define <dfn class="macro" id="_M/REX_B" data-ref="_M/REX_B">REX_B</dfn>       0x01    /* ModRM r/m extension */</u></td></tr>
<tr><th id="485">485</th><td><u>#define <dfn class="macro" id="_M/REX_X" data-ref="_M/REX_X">REX_X</dfn>       0x02    /* SIB index extension */</u></td></tr>
<tr><th id="486">486</th><td><u>#define <dfn class="macro" id="_M/REX_R" data-ref="_M/REX_R">REX_R</dfn>       0x04    /* ModRM reg extension */</u></td></tr>
<tr><th id="487">487</th><td><u>#define <dfn class="macro" id="_M/REX_W" data-ref="_M/REX_W">REX_W</dfn>       0x08    /* 64-bit operand size */</u></td></tr>
<tr><th id="488">488</th><td><u>#define <dfn class="macro" id="_M/REX_L" data-ref="_M/REX_L">REX_L</dfn>       0x20    /* Use LOCK prefix instead of REX.R */</u></td></tr>
<tr><th id="489">489</th><td><u>#define <dfn class="macro" id="_M/REX_P" data-ref="_M/REX_P">REX_P</dfn>       0x40    /* REX prefix present/required */</u></td></tr>
<tr><th id="490">490</th><td><u>#define <dfn class="macro" id="_M/REX_H" data-ref="_M/REX_H">REX_H</dfn>       0x80    /* High register present, REX forbidden */</u></td></tr>
<tr><th id="491">491</th><td><u>#define <dfn class="macro" id="_M/REX_V" data-ref="_M/REX_V">REX_V</dfn>       0x0100  /* Instruction uses VEX/XOP instead of REX */</u></td></tr>
<tr><th id="492">492</th><td><u>#define <dfn class="macro" id="_M/REX_NH" data-ref="_M/REX_NH">REX_NH</dfn>      0x0200  /* Instruction which doesn't use high regs */</u></td></tr>
<tr><th id="493">493</th><td><u>#define <dfn class="macro" id="_M/REX_EV" data-ref="_M/REX_EV">REX_EV</dfn>      0x0400  /* Instruction uses EVEX instead of REX */</u></td></tr>
<tr><th id="494">494</th><td></td></tr>
<tr><th id="495">495</th><td><i>/*</i></td></tr>
<tr><th id="496">496</th><td><i> * EVEX bit field</i></td></tr>
<tr><th id="497">497</th><td><i> */</i></td></tr>
<tr><th id="498">498</th><td><u>#define <dfn class="macro" id="_M/EVEX_P0MM" data-ref="_M/EVEX_P0MM">EVEX_P0MM</dfn>       0x0f        /* EVEX P[3:0] : Opcode map           */</u></td></tr>
<tr><th id="499">499</th><td><u>#define <dfn class="macro" id="_M/EVEX_P0RP" data-ref="_M/EVEX_P0RP">EVEX_P0RP</dfn>       0x10        /* EVEX P[4] : High-16 reg            */</u></td></tr>
<tr><th id="500">500</th><td><u>#define <dfn class="macro" id="_M/EVEX_P0X" data-ref="_M/EVEX_P0X">EVEX_P0X</dfn>        0x40        /* EVEX P[6] : High-16 rm             */</u></td></tr>
<tr><th id="501">501</th><td><u>#define <dfn class="macro" id="_M/EVEX_P1PP" data-ref="_M/EVEX_P1PP">EVEX_P1PP</dfn>       0x03        /* EVEX P[9:8] : Legacy prefix        */</u></td></tr>
<tr><th id="502">502</th><td><u>#define <dfn class="macro" id="_M/EVEX_P1VVVV" data-ref="_M/EVEX_P1VVVV">EVEX_P1VVVV</dfn>     0x78        /* EVEX P[14:11] : NDS register       */</u></td></tr>
<tr><th id="503">503</th><td><u>#define <dfn class="macro" id="_M/EVEX_P1W" data-ref="_M/EVEX_P1W">EVEX_P1W</dfn>        0x80        /* EVEX P[15] : Osize extension       */</u></td></tr>
<tr><th id="504">504</th><td><u>#define <dfn class="macro" id="_M/EVEX_P2AAA" data-ref="_M/EVEX_P2AAA">EVEX_P2AAA</dfn>      0x07        /* EVEX P[18:16] : Embedded opmask    */</u></td></tr>
<tr><th id="505">505</th><td><u>#define <dfn class="macro" id="_M/EVEX_P2VP" data-ref="_M/EVEX_P2VP">EVEX_P2VP</dfn>       0x08        /* EVEX P[19] : High-16 NDS reg       */</u></td></tr>
<tr><th id="506">506</th><td><u>#define <dfn class="macro" id="_M/EVEX_P2B" data-ref="_M/EVEX_P2B">EVEX_P2B</dfn>        0x10        /* EVEX P[20] : Broadcast / RC / SAE  */</u></td></tr>
<tr><th id="507">507</th><td><u>#define <dfn class="macro" id="_M/EVEX_P2LL" data-ref="_M/EVEX_P2LL">EVEX_P2LL</dfn>       0x60        /* EVEX P[22:21] : Vector length      */</u></td></tr>
<tr><th id="508">508</th><td><u>#define <dfn class="macro" id="_M/EVEX_P2RC" data-ref="_M/EVEX_P2RC">EVEX_P2RC</dfn>       EVEX_P2LL   /* EVEX P[22:21] : Rounding control   */</u></td></tr>
<tr><th id="509">509</th><td><u>#define <dfn class="macro" id="_M/EVEX_P2Z" data-ref="_M/EVEX_P2Z">EVEX_P2Z</dfn>        0x80        /* EVEX P[23] : Zeroing/Merging       */</u></td></tr>
<tr><th id="510">510</th><td></td></tr>
<tr><th id="511">511</th><td><i>/*</i></td></tr>
<tr><th id="512">512</th><td><i> * REX_V "classes" (prefixes which behave like VEX)</i></td></tr>
<tr><th id="513">513</th><td><i> */</i></td></tr>
<tr><th id="514">514</th><td><b>enum</b> <dfn class="type def" id="vex_class" title='vex_class' data-ref="vex_class">vex_class</dfn> {</td></tr>
<tr><th id="515">515</th><td>    <dfn class="enum" id="RV_VEX" title='RV_VEX' data-ref="RV_VEX">RV_VEX</dfn>      = <var>0</var>,    <i>/* C4/C5 */</i></td></tr>
<tr><th id="516">516</th><td>    <dfn class="enum" id="RV_XOP" title='RV_XOP' data-ref="RV_XOP">RV_XOP</dfn>      = <var>1</var>,    <i>/* 8F */</i></td></tr>
<tr><th id="517">517</th><td>    <dfn class="enum" id="RV_EVEX" title='RV_EVEX' data-ref="RV_EVEX">RV_EVEX</dfn>     = <var>2</var>     <i>/* 62 */</i></td></tr>
<tr><th id="518">518</th><td>};</td></tr>
<tr><th id="519">519</th><td></td></tr>
<tr><th id="520">520</th><td><i>/*</i></td></tr>
<tr><th id="521">521</th><td><i> * Note that because segment registers may be used as instruction</i></td></tr>
<tr><th id="522">522</th><td><i> * prefixes, we must ensure the enumerations for prefixes and</i></td></tr>
<tr><th id="523">523</th><td><i> * register names do not overlap.</i></td></tr>
<tr><th id="524">524</th><td><i> */</i></td></tr>
<tr><th id="525">525</th><td><b>enum</b> <dfn class="type def" id="prefixes" title='prefixes' data-ref="prefixes">prefixes</dfn> { <i>/* instruction prefixes */</i></td></tr>
<tr><th id="526">526</th><td>    <dfn class="enum" id="P_none" title='P_none' data-ref="P_none">P_none</dfn> = <var>0</var>,</td></tr>
<tr><th id="527">527</th><td>    <dfn class="enum" id="PREFIX_ENUM_START" title='PREFIX_ENUM_START' data-ref="PREFIX_ENUM_START">PREFIX_ENUM_START</dfn> = <a class="enum" href="../x86/regs.h.html#REG_ENUM_LIMIT" title='REG_ENUM_LIMIT' data-ref="REG_ENUM_LIMIT">REG_ENUM_LIMIT</a>,</td></tr>
<tr><th id="528">528</th><td>    <dfn class="enum" id="P_A16" title='P_A16' data-ref="P_A16">P_A16</dfn> = <a class="enum" href="#PREFIX_ENUM_START" title='PREFIX_ENUM_START' data-ref="PREFIX_ENUM_START">PREFIX_ENUM_START</a>,</td></tr>
<tr><th id="529">529</th><td>    <dfn class="enum" id="P_A32" title='P_A32' data-ref="P_A32">P_A32</dfn>,</td></tr>
<tr><th id="530">530</th><td>    <dfn class="enum" id="P_A64" title='P_A64' data-ref="P_A64">P_A64</dfn>,</td></tr>
<tr><th id="531">531</th><td>    <dfn class="enum" id="P_ASP" title='P_ASP' data-ref="P_ASP">P_ASP</dfn>,</td></tr>
<tr><th id="532">532</th><td>    <dfn class="enum" id="P_LOCK" title='P_LOCK' data-ref="P_LOCK">P_LOCK</dfn>,</td></tr>
<tr><th id="533">533</th><td>    <dfn class="enum" id="P_O16" title='P_O16' data-ref="P_O16">P_O16</dfn>,</td></tr>
<tr><th id="534">534</th><td>    <dfn class="enum" id="P_O32" title='P_O32' data-ref="P_O32">P_O32</dfn>,</td></tr>
<tr><th id="535">535</th><td>    <dfn class="enum" id="P_O64" title='P_O64' data-ref="P_O64">P_O64</dfn>,</td></tr>
<tr><th id="536">536</th><td>    <dfn class="enum" id="P_OSP" title='P_OSP' data-ref="P_OSP">P_OSP</dfn>,</td></tr>
<tr><th id="537">537</th><td>    <dfn class="enum" id="P_REP" title='P_REP' data-ref="P_REP">P_REP</dfn>,</td></tr>
<tr><th id="538">538</th><td>    <dfn class="enum" id="P_REPE" title='P_REPE' data-ref="P_REPE">P_REPE</dfn>,</td></tr>
<tr><th id="539">539</th><td>    <dfn class="enum" id="P_REPNE" title='P_REPNE' data-ref="P_REPNE">P_REPNE</dfn>,</td></tr>
<tr><th id="540">540</th><td>    <dfn class="enum" id="P_REPNZ" title='P_REPNZ' data-ref="P_REPNZ">P_REPNZ</dfn>,</td></tr>
<tr><th id="541">541</th><td>    <dfn class="enum" id="P_REPZ" title='P_REPZ' data-ref="P_REPZ">P_REPZ</dfn>,</td></tr>
<tr><th id="542">542</th><td>    <dfn class="enum" id="P_TIMES" title='P_TIMES' data-ref="P_TIMES">P_TIMES</dfn>,</td></tr>
<tr><th id="543">543</th><td>    <dfn class="enum" id="P_WAIT" title='P_WAIT' data-ref="P_WAIT">P_WAIT</dfn>,</td></tr>
<tr><th id="544">544</th><td>    <dfn class="enum" id="P_XACQUIRE" title='P_XACQUIRE' data-ref="P_XACQUIRE">P_XACQUIRE</dfn>,</td></tr>
<tr><th id="545">545</th><td>    <dfn class="enum" id="P_XRELEASE" title='P_XRELEASE' data-ref="P_XRELEASE">P_XRELEASE</dfn>,</td></tr>
<tr><th id="546">546</th><td>    <dfn class="enum" id="P_BND" title='P_BND' data-ref="P_BND">P_BND</dfn>,</td></tr>
<tr><th id="547">547</th><td>    <dfn class="enum" id="P_NOBND" title='P_NOBND' data-ref="P_NOBND">P_NOBND</dfn>,</td></tr>
<tr><th id="548">548</th><td>    <dfn class="enum" id="P_EVEX" title='P_EVEX' data-ref="P_EVEX">P_EVEX</dfn>,</td></tr>
<tr><th id="549">549</th><td>    <dfn class="enum" id="P_VEX3" title='P_VEX3' data-ref="P_VEX3">P_VEX3</dfn>,</td></tr>
<tr><th id="550">550</th><td>    <dfn class="enum" id="P_VEX2" title='P_VEX2' data-ref="P_VEX2">P_VEX2</dfn>,</td></tr>
<tr><th id="551">551</th><td>    <dfn class="enum" id="PREFIX_ENUM_LIMIT" title='PREFIX_ENUM_LIMIT' data-ref="PREFIX_ENUM_LIMIT">PREFIX_ENUM_LIMIT</dfn></td></tr>
<tr><th id="552">552</th><td>};</td></tr>
<tr><th id="553">553</th><td></td></tr>
<tr><th id="554">554</th><td><b>enum</b> <dfn class="type def" id="extop_type" title='extop_type' data-ref="extop_type">extop_type</dfn> { <i>/* extended operand types */</i></td></tr>
<tr><th id="555">555</th><td>    <dfn class="enum" id="EOT_NOTHING" title='EOT_NOTHING' data-ref="EOT_NOTHING">EOT_NOTHING</dfn>,</td></tr>
<tr><th id="556">556</th><td>    <dfn class="enum" id="EOT_DB_STRING" title='EOT_DB_STRING' data-ref="EOT_DB_STRING">EOT_DB_STRING</dfn>,      <i>/* Byte string */</i></td></tr>
<tr><th id="557">557</th><td>    <dfn class="enum" id="EOT_DB_STRING_FREE" title='EOT_DB_STRING_FREE' data-ref="EOT_DB_STRING_FREE">EOT_DB_STRING_FREE</dfn>, <i>/* Byte string which should be nasm_free'd*/</i></td></tr>
<tr><th id="558">558</th><td>    <dfn class="enum" id="EOT_DB_NUMBER" title='EOT_DB_NUMBER' data-ref="EOT_DB_NUMBER">EOT_DB_NUMBER</dfn>       <i>/* Integer */</i></td></tr>
<tr><th id="559">559</th><td>};</td></tr>
<tr><th id="560">560</th><td></td></tr>
<tr><th id="561">561</th><td><b>enum</b> <dfn class="type def" id="ea_flags" title='ea_flags' data-ref="ea_flags">ea_flags</dfn> { <i>/* special EA flags */</i></td></tr>
<tr><th id="562">562</th><td>    <dfn class="enum" id="EAF_BYTEOFFS" title='EAF_BYTEOFFS' data-ref="EAF_BYTEOFFS">EAF_BYTEOFFS</dfn>    =  <var>1</var>,   <i>/* force offset part to byte size */</i></td></tr>
<tr><th id="563">563</th><td>    <dfn class="enum" id="EAF_WORDOFFS" title='EAF_WORDOFFS' data-ref="EAF_WORDOFFS">EAF_WORDOFFS</dfn>    =  <var>2</var>,   <i>/* force offset part to [d]word size */</i></td></tr>
<tr><th id="564">564</th><td>    <dfn class="enum" id="EAF_TIMESTWO" title='EAF_TIMESTWO' data-ref="EAF_TIMESTWO">EAF_TIMESTWO</dfn>    =  <var>4</var>,   <i>/* really do EAX*2 not EAX+EAX */</i></td></tr>
<tr><th id="565">565</th><td>    <dfn class="enum" id="EAF_REL" title='EAF_REL' data-ref="EAF_REL">EAF_REL</dfn>         =  <var>8</var>,   <i>/* IP-relative addressing */</i></td></tr>
<tr><th id="566">566</th><td>    <dfn class="enum" id="EAF_ABS" title='EAF_ABS' data-ref="EAF_ABS">EAF_ABS</dfn>         = <var>16</var>,   <i>/* non-IP-relative addressing */</i></td></tr>
<tr><th id="567">567</th><td>    <dfn class="enum" id="EAF_FSGS" title='EAF_FSGS' data-ref="EAF_FSGS">EAF_FSGS</dfn>        = <var>32</var>,   <i>/* fs/gs segment override present */</i></td></tr>
<tr><th id="568">568</th><td>    <dfn class="enum" id="EAF_MIB" title='EAF_MIB' data-ref="EAF_MIB">EAF_MIB</dfn>         = <var>64</var>    <i>/* mib operand */</i></td></tr>
<tr><th id="569">569</th><td>};</td></tr>
<tr><th id="570">570</th><td></td></tr>
<tr><th id="571">571</th><td><b>enum</b> <dfn class="type def" id="eval_hint" title='eval_hint' data-ref="eval_hint">eval_hint</dfn> { <i>/* values for `hinttype' */</i></td></tr>
<tr><th id="572">572</th><td>    <dfn class="enum" id="EAH_NOHINT" title='EAH_NOHINT' data-ref="EAH_NOHINT">EAH_NOHINT</dfn>   = <var>0</var>,       <i>/* no hint at all - our discretion */</i></td></tr>
<tr><th id="573">573</th><td>    <dfn class="enum" id="EAH_MAKEBASE" title='EAH_MAKEBASE' data-ref="EAH_MAKEBASE">EAH_MAKEBASE</dfn> = <var>1</var>,       <i>/* try to make given reg the base */</i></td></tr>
<tr><th id="574">574</th><td>    <dfn class="enum" id="EAH_NOTBASE" title='EAH_NOTBASE' data-ref="EAH_NOTBASE">EAH_NOTBASE</dfn>  = <var>2</var>,       <i>/* try _not_ to make reg the base */</i></td></tr>
<tr><th id="575">575</th><td>    <dfn class="enum" id="EAH_SUMMED" title='EAH_SUMMED' data-ref="EAH_SUMMED">EAH_SUMMED</dfn>   = <var>3</var>        <i>/* base and index are summed into index */</i></td></tr>
<tr><th id="576">576</th><td>};</td></tr>
<tr><th id="577">577</th><td></td></tr>
<tr><th id="578">578</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="operand" title='operand' data-ref="operand"><a class="type" href="#operand" title='operand' data-ref="operand">operand</a></dfn> { <i>/* operand to an instruction */</i></td></tr>
<tr><th id="579">579</th><td>    <a class="typedef" href="tables.h.html#opflags_t" title='opflags_t' data-type='uint64_t' data-ref="opflags_t">opflags_t</a>       <dfn class="decl field" id="operand::type" title='operand::type' data-ref="operand::type">type</dfn>;       <i>/* type of operand */</i></td></tr>
<tr><th id="580">580</th><td>    <em>int</em>             <dfn class="decl field" id="operand::disp_size" title='operand::disp_size' data-ref="operand::disp_size">disp_size</dfn>;  <i>/* 0 means default; 16; 32; 64 */</i></td></tr>
<tr><th id="581">581</th><td>    <b>enum</b> <a class="type" href="../x86/regs.h.html#reg_enum" title='reg_enum' data-ref="reg_enum">reg_enum</a>   <dfn class="decl field" id="operand::basereg" title='operand::basereg' data-ref="operand::basereg">basereg</dfn>;</td></tr>
<tr><th id="582">582</th><td>    <b>enum</b> <a class="type" href="../x86/regs.h.html#reg_enum" title='reg_enum' data-ref="reg_enum">reg_enum</a>   <dfn class="decl field" id="operand::indexreg" title='operand::indexreg' data-ref="operand::indexreg">indexreg</dfn>;   <i>/* address registers */</i></td></tr>
<tr><th id="583">583</th><td>    <em>int</em>             <dfn class="decl field" id="operand::scale" title='operand::scale' data-ref="operand::scale">scale</dfn>;      <i>/* index scale */</i></td></tr>
<tr><th id="584">584</th><td>    <em>int</em>             <dfn class="decl field" id="operand::hintbase" title='operand::hintbase' data-ref="operand::hintbase">hintbase</dfn>;</td></tr>
<tr><th id="585">585</th><td>    <b>enum</b> <a class="type" href="#eval_hint" title='eval_hint' data-ref="eval_hint">eval_hint</a>  <dfn class="decl field" id="operand::hinttype" title='operand::hinttype' data-ref="operand::hinttype">hinttype</dfn>;   <i>/* hint as to real base register */</i></td></tr>
<tr><th id="586">586</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>         <dfn class="decl field" id="operand::segment" title='operand::segment' data-ref="operand::segment">segment</dfn>;    <i>/* immediate segment, if needed */</i></td></tr>
<tr><th id="587">587</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a>         <dfn class="decl field" id="operand::offset" title='operand::offset' data-ref="operand::offset">offset</dfn>;     <i>/* any immediate number */</i></td></tr>
<tr><th id="588">588</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>         <dfn class="decl field" id="operand::wrt" title='operand::wrt' data-ref="operand::wrt">wrt</dfn>;        <i>/* segment base it's relative to */</i></td></tr>
<tr><th id="589">589</th><td>    <em>int</em>             <dfn class="decl field" id="operand::eaflags" title='operand::eaflags' data-ref="operand::eaflags">eaflags</dfn>;    <i>/* special EA flags */</i></td></tr>
<tr><th id="590">590</th><td>    <em>int</em>             <dfn class="decl field" id="operand::opflags" title='operand::opflags' data-ref="operand::opflags">opflags</dfn>;    <i>/* see OPFLAG_* defines below */</i></td></tr>
<tr><th id="591">591</th><td>    <a class="typedef" href="tables.h.html#decoflags_t" title='decoflags_t' data-type='uint16_t' data-ref="decoflags_t">decoflags_t</a>     <dfn class="decl field" id="operand::decoflags" title='operand::decoflags' data-ref="operand::decoflags">decoflags</dfn>;  <i>/* decorator flags such as {...} */</i></td></tr>
<tr><th id="592">592</th><td>} <dfn class="typedef" id="operand" title='operand' data-type='struct operand' data-ref="operand">operand</dfn>;</td></tr>
<tr><th id="593">593</th><td></td></tr>
<tr><th id="594">594</th><td><u>#define <dfn class="macro" id="_M/OPFLAG_FORWARD" data-ref="_M/OPFLAG_FORWARD">OPFLAG_FORWARD</dfn>      1   /* operand is a forward reference */</u></td></tr>
<tr><th id="595">595</th><td><u>#define <dfn class="macro" id="_M/OPFLAG_EXTERN" data-ref="_M/OPFLAG_EXTERN">OPFLAG_EXTERN</dfn>       2   /* operand is an external reference */</u></td></tr>
<tr><th id="596">596</th><td><u>#define <dfn class="macro" id="_M/OPFLAG_UNKNOWN" data-ref="_M/OPFLAG_UNKNOWN">OPFLAG_UNKNOWN</dfn>      4   /* operand is an unknown reference</u></td></tr>
<tr><th id="597">597</th><td><u>                                   (always a forward reference also) */</u></td></tr>
<tr><th id="598">598</th><td><u>#define <dfn class="macro" id="_M/OPFLAG_RELATIVE" data-ref="_M/OPFLAG_RELATIVE">OPFLAG_RELATIVE</dfn>     8   /* operand is self-relative, e.g. [foo - $]</u></td></tr>
<tr><th id="599">599</th><td><u>                                   where foo is not in the current segment */</u></td></tr>
<tr><th id="600">600</th><td></td></tr>
<tr><th id="601">601</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="extop" title='extop' data-ref="extop"><a class="type" href="#extop" title='extop' data-ref="extop">extop</a></dfn> { <i>/* extended operand */</i></td></tr>
<tr><th id="602">602</th><td>    <b>struct</b> <a class="type" href="#extop" title='extop' data-ref="extop">extop</a>    *<dfn class="decl field" id="extop::next" title='extop::next' data-ref="extop::next">next</dfn>;      <i>/* linked list */</i></td></tr>
<tr><th id="603">603</th><td>    <em>char</em>            *<dfn class="decl field" id="extop::stringval" title='extop::stringval' data-ref="extop::stringval">stringval</dfn>; <i>/* if it's a string, then here it is */</i></td></tr>
<tr><th id="604">604</th><td>    <span class='typedef' title='size_t' data-type='unsigned long' data-ref="size_t">size_t</span>          <dfn class="decl field" id="extop::stringlen" title='extop::stringlen' data-ref="extop::stringlen">stringlen</dfn>;  <i>/* ... and here's how long it is */</i></td></tr>
<tr><th id="605">605</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a>         <dfn class="decl field" id="extop::offset" title='extop::offset' data-ref="extop::offset">offset</dfn>;     <i>/* ... it's given here ... */</i></td></tr>
<tr><th id="606">606</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>         <dfn class="decl field" id="extop::segment" title='extop::segment' data-ref="extop::segment">segment</dfn>;    <i>/* if it's a number/address, then... */</i></td></tr>
<tr><th id="607">607</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>         <dfn class="decl field" id="extop::wrt" title='extop::wrt' data-ref="extop::wrt">wrt</dfn>;        <i>/* ... and here */</i></td></tr>
<tr><th id="608">608</th><td>    <span class="macro" title="_Bool" data-ref="_M/bool">bool</span>            <dfn class="decl field" id="extop::relative" title='extop::relative' data-ref="extop::relative">relative</dfn>;   <i>/* self-relative expression */</i></td></tr>
<tr><th id="609">609</th><td>    <b>enum</b> <a class="type" href="#extop_type" title='extop_type' data-ref="extop_type">extop_type</a> <dfn class="decl field" id="extop::type" title='extop::type' data-ref="extop::type">type</dfn>;       <i>/* defined above */</i></td></tr>
<tr><th id="610">610</th><td>} <dfn class="typedef" id="extop" title='extop' data-type='struct extop' data-ref="extop">extop</dfn>;</td></tr>
<tr><th id="611">611</th><td></td></tr>
<tr><th id="612">612</th><td><b>enum</b> <dfn class="type def" id="ea_type" title='ea_type' data-ref="ea_type">ea_type</dfn> {</td></tr>
<tr><th id="613">613</th><td>    <dfn class="enum" id="EA_INVALID" title='EA_INVALID' data-ref="EA_INVALID">EA_INVALID</dfn>,     <i>/* Not a valid EA at all */</i></td></tr>
<tr><th id="614">614</th><td>    <dfn class="enum" id="EA_SCALAR" title='EA_SCALAR' data-ref="EA_SCALAR">EA_SCALAR</dfn>,      <i>/* Scalar EA */</i></td></tr>
<tr><th id="615">615</th><td>    <dfn class="enum" id="EA_XMMVSIB" title='EA_XMMVSIB' data-ref="EA_XMMVSIB">EA_XMMVSIB</dfn>,     <i>/* XMM vector EA */</i></td></tr>
<tr><th id="616">616</th><td>    <dfn class="enum" id="EA_YMMVSIB" title='EA_YMMVSIB' data-ref="EA_YMMVSIB">EA_YMMVSIB</dfn>,     <i>/* YMM vector EA */</i></td></tr>
<tr><th id="617">617</th><td>    <dfn class="enum" id="EA_ZMMVSIB" title='EA_ZMMVSIB' data-ref="EA_ZMMVSIB">EA_ZMMVSIB</dfn>      <i>/* ZMM vector EA */</i></td></tr>
<tr><th id="618">618</th><td>};</td></tr>
<tr><th id="619">619</th><td></td></tr>
<tr><th id="620">620</th><td><i>/*</i></td></tr>
<tr><th id="621">621</th><td><i> * Prefix positions: each type of prefix goes in a specific slot.</i></td></tr>
<tr><th id="622">622</th><td><i> * This affects the final ordering of the assembled output, which</i></td></tr>
<tr><th id="623">623</th><td><i> * shouldn't matter to the processor, but if you have stylistic</i></td></tr>
<tr><th id="624">624</th><td><i> * preferences, you can change this.  REX prefixes are handled</i></td></tr>
<tr><th id="625">625</th><td><i> * differently for the time being.</i></td></tr>
<tr><th id="626">626</th><td><i> *</i></td></tr>
<tr><th id="627">627</th><td><i> * LOCK and REP used to be one slot; this is no longer the case since</i></td></tr>
<tr><th id="628">628</th><td><i> * the introduction of HLE.</i></td></tr>
<tr><th id="629">629</th><td><i> */</i></td></tr>
<tr><th id="630">630</th><td><b>enum</b> <dfn class="type def" id="prefix_pos" title='prefix_pos' data-ref="prefix_pos">prefix_pos</dfn> {</td></tr>
<tr><th id="631">631</th><td>    <dfn class="enum" id="PPS_WAIT" title='PPS_WAIT' data-ref="PPS_WAIT">PPS_WAIT</dfn>,   <i>/* WAIT (technically not a prefix!) */</i></td></tr>
<tr><th id="632">632</th><td>    <dfn class="enum" id="PPS_REP" title='PPS_REP' data-ref="PPS_REP">PPS_REP</dfn>,    <i>/* REP/HLE prefix */</i></td></tr>
<tr><th id="633">633</th><td>    <dfn class="enum" id="PPS_LOCK" title='PPS_LOCK' data-ref="PPS_LOCK">PPS_LOCK</dfn>,   <i>/* LOCK prefix */</i></td></tr>
<tr><th id="634">634</th><td>    <dfn class="enum" id="PPS_SEG" title='PPS_SEG' data-ref="PPS_SEG">PPS_SEG</dfn>,    <i>/* Segment override prefix */</i></td></tr>
<tr><th id="635">635</th><td>    <dfn class="enum" id="PPS_OSIZE" title='PPS_OSIZE' data-ref="PPS_OSIZE">PPS_OSIZE</dfn>,  <i>/* Operand size prefix */</i></td></tr>
<tr><th id="636">636</th><td>    <dfn class="enum" id="PPS_ASIZE" title='PPS_ASIZE' data-ref="PPS_ASIZE">PPS_ASIZE</dfn>,  <i>/* Address size prefix */</i></td></tr>
<tr><th id="637">637</th><td>    <dfn class="enum" id="PPS_VEX" title='PPS_VEX' data-ref="PPS_VEX">PPS_VEX</dfn>,    <i>/* VEX type */</i></td></tr>
<tr><th id="638">638</th><td>    <dfn class="enum" id="MAXPREFIX" title='MAXPREFIX' data-ref="MAXPREFIX">MAXPREFIX</dfn>   <i>/* Total number of prefix slots */</i></td></tr>
<tr><th id="639">639</th><td>};</td></tr>
<tr><th id="640">640</th><td></td></tr>
<tr><th id="641">641</th><td><i>/*</i></td></tr>
<tr><th id="642">642</th><td><i> * Tuple types that are used when determining Disp8*N eligibility</i></td></tr>
<tr><th id="643">643</th><td><i> * The order must match with a hash %tuple_codes in insns.pl</i></td></tr>
<tr><th id="644">644</th><td><i> */</i></td></tr>
<tr><th id="645">645</th><td><b>enum</b> <dfn class="type def" id="ttypes" title='ttypes' data-ref="ttypes">ttypes</dfn> {</td></tr>
<tr><th id="646">646</th><td>    <dfn class="enum" id="FV" title='FV' data-ref="FV">FV</dfn>    = <var>001</var>,</td></tr>
<tr><th id="647">647</th><td>    <dfn class="enum" id="HV" title='HV' data-ref="HV">HV</dfn>    = <var>002</var>,</td></tr>
<tr><th id="648">648</th><td>    <dfn class="enum" id="FVM" title='FVM' data-ref="FVM">FVM</dfn>   = <var>003</var>,</td></tr>
<tr><th id="649">649</th><td>    <dfn class="enum" id="T1S8" title='T1S8' data-ref="T1S8">T1S8</dfn>  = <var>004</var>,</td></tr>
<tr><th id="650">650</th><td>    <dfn class="enum" id="T1S16" title='T1S16' data-ref="T1S16">T1S16</dfn> = <var>005</var>,</td></tr>
<tr><th id="651">651</th><td>    <dfn class="enum" id="T1S" title='T1S' data-ref="T1S">T1S</dfn>   = <var>006</var>,</td></tr>
<tr><th id="652">652</th><td>    <dfn class="enum" id="T1F32" title='T1F32' data-ref="T1F32">T1F32</dfn> = <var>007</var>,</td></tr>
<tr><th id="653">653</th><td>    <dfn class="enum" id="T1F64" title='T1F64' data-ref="T1F64">T1F64</dfn> = <var>010</var>,</td></tr>
<tr><th id="654">654</th><td>    <dfn class="enum" id="T2" title='T2' data-ref="T2">T2</dfn>    = <var>011</var>,</td></tr>
<tr><th id="655">655</th><td>    <dfn class="enum" id="T4" title='T4' data-ref="T4">T4</dfn>    = <var>012</var>,</td></tr>
<tr><th id="656">656</th><td>    <dfn class="enum" id="T8" title='T8' data-ref="T8">T8</dfn>    = <var>013</var>,</td></tr>
<tr><th id="657">657</th><td>    <dfn class="enum" id="HVM" title='HVM' data-ref="HVM">HVM</dfn>   = <var>014</var>,</td></tr>
<tr><th id="658">658</th><td>    <dfn class="enum" id="QVM" title='QVM' data-ref="QVM">QVM</dfn>   = <var>015</var>,</td></tr>
<tr><th id="659">659</th><td>    <dfn class="enum" id="OVM" title='OVM' data-ref="OVM">OVM</dfn>   = <var>016</var>,</td></tr>
<tr><th id="660">660</th><td>    <dfn class="enum" id="M128" title='M128' data-ref="M128">M128</dfn>  = <var>017</var>,</td></tr>
<tr><th id="661">661</th><td>    <dfn class="enum" id="DUP" title='DUP' data-ref="DUP">DUP</dfn>   = <var>020</var></td></tr>
<tr><th id="662">662</th><td>};</td></tr>
<tr><th id="663">663</th><td></td></tr>
<tr><th id="664">664</th><td><i>/* EVEX.L'L : Vector length on vector insns */</i></td></tr>
<tr><th id="665">665</th><td><b>enum</b> <dfn class="type def" id="vectlens" title='vectlens' data-ref="vectlens">vectlens</dfn> {</td></tr>
<tr><th id="666">666</th><td>    <dfn class="enum" id="VL128" title='VL128' data-ref="VL128">VL128</dfn> = <var>0</var>,</td></tr>
<tr><th id="667">667</th><td>    <dfn class="enum" id="VL256" title='VL256' data-ref="VL256">VL256</dfn> = <var>1</var>,</td></tr>
<tr><th id="668">668</th><td>    <dfn class="enum" id="VL512" title='VL512' data-ref="VL512">VL512</dfn> = <var>2</var>,</td></tr>
<tr><th id="669">669</th><td>    <dfn class="enum" id="VLMAX" title='VLMAX' data-ref="VLMAX">VLMAX</dfn> = <var>3</var></td></tr>
<tr><th id="670">670</th><td>};</td></tr>
<tr><th id="671">671</th><td></td></tr>
<tr><th id="672">672</th><td><i>/* If you need to change this, also change it in insns.pl */</i></td></tr>
<tr><th id="673">673</th><td><u>#define <dfn class="macro" id="_M/MAX_OPERANDS" data-ref="_M/MAX_OPERANDS">MAX_OPERANDS</dfn> 5</u></td></tr>
<tr><th id="674">674</th><td></td></tr>
<tr><th id="675">675</th><td><b>typedef</b> <b>struct</b> <dfn class="type def" id="insn" title='insn' data-ref="insn"><a class="type" href="#insn" title='insn' data-ref="insn">insn</a></dfn> { <i>/* an instruction itself */</i></td></tr>
<tr><th id="676">676</th><td>    <em>char</em>            *<dfn class="decl field" id="insn::label" title='insn::label' data-ref="insn::label">label</dfn>;                 <i>/* the label defined, or NULL */</i></td></tr>
<tr><th id="677">677</th><td>    <em>int</em>             <dfn class="decl field" id="insn::prefixes" title='insn::prefixes' data-ref="insn::prefixes">prefixes</dfn>[<a class="enum" href="#MAXPREFIX" title='MAXPREFIX' data-ref="MAXPREFIX">MAXPREFIX</a>];    <i>/* instruction prefixes, if any */</i></td></tr>
<tr><th id="678">678</th><td>    <b>enum</b> <a class="type" href="../x86/insnsi.h.html#opcode" title='opcode' data-ref="opcode">opcode</a>     <dfn class="decl field" id="insn::opcode" title='insn::opcode' data-ref="insn::opcode">opcode</dfn>;                 <i>/* the opcode - not just the string */</i></td></tr>
<tr><th id="679">679</th><td>    <b>enum</b> <a class="type" href="#ccode" title='ccode' data-ref="ccode">ccode</a>      <dfn class="decl field" id="insn::condition" title='insn::condition' data-ref="insn::condition">condition</dfn>;              <i>/* the condition code, if Jcc/SETcc */</i></td></tr>
<tr><th id="680">680</th><td>    <em>int</em>             <dfn class="decl field" id="insn::operands" title='insn::operands' data-ref="insn::operands">operands</dfn>;               <i>/* how many operands? 0-3 (more if db et al) */</i></td></tr>
<tr><th id="681">681</th><td>    <em>int</em>             <dfn class="decl field" id="insn::addr_size" title='insn::addr_size' data-ref="insn::addr_size">addr_size</dfn>;              <i>/* address size */</i></td></tr>
<tr><th id="682">682</th><td>    <a class="typedef" href="#operand" title='operand' data-type='struct operand' data-ref="operand">operand</a>         <dfn class="decl field" id="insn::oprs" title='insn::oprs' data-ref="insn::oprs">oprs</dfn>[<a class="macro" href="#673" title="5" data-ref="_M/MAX_OPERANDS">MAX_OPERANDS</a>];     <i>/* the operands, defined as above */</i></td></tr>
<tr><th id="683">683</th><td>    <a class="typedef" href="#extop" title='extop' data-type='struct extop' data-ref="extop">extop</a>           *<dfn class="decl field" id="insn::eops" title='insn::eops' data-ref="insn::eops">eops</dfn>;                  <i>/* extended operands */</i></td></tr>
<tr><th id="684">684</th><td>    <em>int</em>             <dfn class="decl field" id="insn::eops_float" title='insn::eops_float' data-ref="insn::eops_float">eops_float</dfn>;             <i>/* true if DD and floating */</i></td></tr>
<tr><th id="685">685</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a>         <dfn class="decl field" id="insn::times" title='insn::times' data-ref="insn::times">times</dfn>;                  <i>/* repeat count (TIMES prefix) */</i></td></tr>
<tr><th id="686">686</th><td>    <span class="macro" title="_Bool" data-ref="_M/bool">bool</span>            <dfn class="decl field" id="insn::forw_ref" title='insn::forw_ref' data-ref="insn::forw_ref">forw_ref</dfn>;               <i>/* is there a forward reference? */</i></td></tr>
<tr><th id="687">687</th><td>    <span class="macro" title="_Bool" data-ref="_M/bool">bool</span>            <dfn class="decl field" id="insn::rex_done" title='insn::rex_done' data-ref="insn::rex_done">rex_done</dfn>;               <i>/* REX prefix emitted? */</i></td></tr>
<tr><th id="688">688</th><td>    <em>int</em>             <dfn class="decl field" id="insn::rex" title='insn::rex' data-ref="insn::rex">rex</dfn>;                    <i>/* Special REX Prefix */</i></td></tr>
<tr><th id="689">689</th><td>    <em>int</em>             <dfn class="decl field" id="insn::vexreg" title='insn::vexreg' data-ref="insn::vexreg">vexreg</dfn>;                 <i>/* Register encoded in VEX prefix */</i></td></tr>
<tr><th id="690">690</th><td>    <em>int</em>             <dfn class="decl field" id="insn::vex_cm" title='insn::vex_cm' data-ref="insn::vex_cm">vex_cm</dfn>;                 <i>/* Class and M field for VEX prefix */</i></td></tr>
<tr><th id="691">691</th><td>    <em>int</em>             <dfn class="decl field" id="insn::vex_wlp" title='insn::vex_wlp' data-ref="insn::vex_wlp">vex_wlp</dfn>;                <i>/* W, P and L information for VEX prefix */</i></td></tr>
<tr><th id="692">692</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a>         <dfn class="decl field" id="insn::evex_p" title='insn::evex_p' data-ref="insn::evex_p">evex_p</dfn>[<var>3</var>];              <i>/* EVEX.P0: [RXB,R',00,mm], P1: [W,vvvv,1,pp] */</i></td></tr>
<tr><th id="693">693</th><td>                                            <i>/* EVEX.P2: [z,L'L,b,V',aaa] */</i></td></tr>
<tr><th id="694">694</th><td>    <b>enum</b> <a class="type" href="#ttypes" title='ttypes' data-ref="ttypes">ttypes</a>     <dfn class="decl field" id="insn::evex_tuple" title='insn::evex_tuple' data-ref="insn::evex_tuple">evex_tuple</dfn>;             <i>/* Tuple type for compressed Disp8*N */</i></td></tr>
<tr><th id="695">695</th><td>    <em>int</em>             <dfn class="decl field" id="insn::evex_rm" title='insn::evex_rm' data-ref="insn::evex_rm">evex_rm</dfn>;                <i>/* static rounding mode for AVX512 (EVEX) */</i></td></tr>
<tr><th id="696">696</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int8_t" title='int8_t' data-type='signed char' data-ref="int8_t">int8_t</a>          <dfn class="decl field" id="insn::evex_brerop" title='insn::evex_brerop' data-ref="insn::evex_brerop">evex_brerop</dfn>;            <i>/* BR/ER/SAE operand position */</i></td></tr>
<tr><th id="697">697</th><td>} <dfn class="typedef" id="insn" title='insn' data-type='struct insn' data-ref="insn">insn</dfn>;</td></tr>
<tr><th id="698">698</th><td></td></tr>
<tr><th id="699">699</th><td><i>/* Instruction flags type: IF_* flags are defined in insns.h */</i></td></tr>
<tr><th id="700">700</th><td><b>typedef</b> <a class="typedef" href="../../../../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a> <dfn class="typedef" id="iflags_t" title='iflags_t' data-type='uint64_t' data-ref="iflags_t">iflags_t</dfn>;</td></tr>
<tr><th id="701">701</th><td></td></tr>
<tr><th id="702">702</th><td><i>/*</i></td></tr>
<tr><th id="703">703</th><td><i> * What to return from a directive- or pragma-handling function.</i></td></tr>
<tr><th id="704">704</th><td><i> * Currently DIRR_OK and DIRR_ERROR are treated the same way;</i></td></tr>
<tr><th id="705">705</th><td><i> * in both cases the backend is expected to produce the appropriate</i></td></tr>
<tr><th id="706">706</th><td><i> * error message on its own.</i></td></tr>
<tr><th id="707">707</th><td><i> *</i></td></tr>
<tr><th id="708">708</th><td><i> * DIRR_BADPARAM causes a generic error message to be printed.  Note</i></td></tr>
<tr><th id="709">709</th><td><i> * that it is an error, not a warning, even in the case of pragmas;</i></td></tr>
<tr><th id="710">710</th><td><i> * don't use it where forward compatiblity would be compromised</i></td></tr>
<tr><th id="711">711</th><td><i> * (instead consider adding a DIRR_WARNPARAM.)</i></td></tr>
<tr><th id="712">712</th><td><i> */</i></td></tr>
<tr><th id="713">713</th><td><b>enum</b> <dfn class="type def" id="directive_result" title='directive_result' data-ref="directive_result">directive_result</dfn> {</td></tr>
<tr><th id="714">714</th><td>    <dfn class="enum" id="DIRR_UNKNOWN" title='DIRR_UNKNOWN' data-ref="DIRR_UNKNOWN">DIRR_UNKNOWN</dfn>,               <i>/* Directive not handled by backend */</i></td></tr>
<tr><th id="715">715</th><td>    <dfn class="enum" id="DIRR_OK" title='DIRR_OK' data-ref="DIRR_OK">DIRR_OK</dfn>,                    <i>/* Directive processed */</i></td></tr>
<tr><th id="716">716</th><td>    <dfn class="enum" id="DIRR_ERROR" title='DIRR_ERROR' data-ref="DIRR_ERROR">DIRR_ERROR</dfn>,                 <i>/* Directive processed unsuccessfully */</i></td></tr>
<tr><th id="717">717</th><td>    <dfn class="enum" id="DIRR_BADPARAM" title='DIRR_BADPARAM' data-ref="DIRR_BADPARAM">DIRR_BADPARAM</dfn>               <i>/* Print bad argument error message */</i></td></tr>
<tr><th id="718">718</th><td>};</td></tr>
<tr><th id="719">719</th><td></td></tr>
<tr><th id="720">720</th><td><i>/*</i></td></tr>
<tr><th id="721">721</th><td><i> * A pragma facility: this structure is used to request passing a</i></td></tr>
<tr><th id="722">722</th><td><i> * parsed pragma directive for a specific facility.  If the handler is</i></td></tr>
<tr><th id="723">723</th><td><i> * NULL then this pragma facility is recognized but ignored; pragma</i></td></tr>
<tr><th id="724">724</th><td><i> * processing stops at that point.</i></td></tr>
<tr><th id="725">725</th><td><i> *</i></td></tr>
<tr><th id="726">726</th><td><i> * Note that the handler is passed a pointer to the facility structure</i></td></tr>
<tr><th id="727">727</th><td><i> * as part of the struct pragma.</i></td></tr>
<tr><th id="728">728</th><td><i> */</i></td></tr>
<tr><th id="729">729</th><td><b>struct</b> <a class="type" href="#pragma" title='pragma' data-ref="pragma">pragma</a>;</td></tr>
<tr><th id="730">730</th><td></td></tr>
<tr><th id="731">731</th><td><b>struct</b> <dfn class="type def" id="pragma_facility" title='pragma_facility' data-ref="pragma_facility">pragma_facility</dfn> {</td></tr>
<tr><th id="732">732</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="pragma_facility::name" title='pragma_facility::name' data-ref="pragma_facility::name">name</dfn>;</td></tr>
<tr><th id="733">733</th><td>    <b>enum</b> <a class="type" href="#directive_result" title='directive_result' data-ref="directive_result">directive_result</a> (*<dfn class="decl field" id="pragma_facility::handler" title='pragma_facility::handler' data-ref="pragma_facility::handler">handler</dfn>)(<em>const</em> <b>struct</b> <a class="type" href="#pragma" title='pragma' data-ref="pragma">pragma</a> *);</td></tr>
<tr><th id="734">734</th><td>};</td></tr>
<tr><th id="735">735</th><td></td></tr>
<tr><th id="736">736</th><td><i>/*</i></td></tr>
<tr><th id="737">737</th><td><i> * This structure defines how a pragma directive is passed to a</i></td></tr>
<tr><th id="738">738</th><td><i> * facility.  This structure may be augmented in the future.</i></td></tr>
<tr><th id="739">739</th><td><i> *</i></td></tr>
<tr><th id="740">740</th><td><i> * Any facility MAY, but is not required to, add its operations</i></td></tr>
<tr><th id="741">741</th><td><i> * keywords or a subset thereof into asm/directiv.dat, in which case</i></td></tr>
<tr><th id="742">742</th><td><i> * the "opcode" field will be set to the corresponding D_ constant</i></td></tr>
<tr><th id="743">743</th><td><i> * from directiv.h; otherwise it will be D_unknown.</i></td></tr>
<tr><th id="744">744</th><td><i> */</i></td></tr>
<tr><th id="745">745</th><td><b>struct</b> <dfn class="type def" id="pragma" title='pragma' data-ref="pragma">pragma</dfn> {</td></tr>
<tr><th id="746">746</th><td>    <em>const</em> <b>struct</b> <a class="type" href="#pragma_facility" title='pragma_facility' data-ref="pragma_facility">pragma_facility</a> *<dfn class="decl field" id="pragma::facility" title='pragma::facility' data-ref="pragma::facility">facility</dfn>;</td></tr>
<tr><th id="747">747</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="pragma::facility_name" title='pragma::facility_name' data-ref="pragma::facility_name">facility_name</dfn>;  <i>/* Facility name exactly as entered by user */</i></td></tr>
<tr><th id="748">748</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="pragma::opname" title='pragma::opname' data-ref="pragma::opname">opname</dfn>;         <i>/* First word after the facility name */</i></td></tr>
<tr><th id="749">749</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="pragma::tail" title='pragma::tail' data-ref="pragma::tail">tail</dfn>;           <i>/* Anything after the operation */</i></td></tr>
<tr><th id="750">750</th><td>    <b>enum</b> <a class="type" href="../asm/directiv.h.html#directive" title='directive' data-ref="directive">directive</a> <dfn class="decl field" id="pragma::opcode" title='pragma::opcode' data-ref="pragma::opcode">opcode</dfn>;     <i>/* Operation as a D_ directives constant */</i></td></tr>
<tr><th id="751">751</th><td>};</td></tr>
<tr><th id="752">752</th><td></td></tr>
<tr><th id="753">753</th><td><i>/*</i></td></tr>
<tr><th id="754">754</th><td><i> * The data structure defining an output format driver, and the</i></td></tr>
<tr><th id="755">755</th><td><i> * interfaces to the functions therein.</i></td></tr>
<tr><th id="756">756</th><td><i> */</i></td></tr>
<tr><th id="757">757</th><td><b>struct</b> <dfn class="type def" id="ofmt" title='ofmt' data-ref="ofmt">ofmt</dfn> {</td></tr>
<tr><th id="758">758</th><td>    <i>/*</i></td></tr>
<tr><th id="759">759</th><td><i>     * This is a short (one-liner) description of the type of</i></td></tr>
<tr><th id="760">760</th><td><i>     * output generated by the driver.</i></td></tr>
<tr><th id="761">761</th><td><i>     */</i></td></tr>
<tr><th id="762">762</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="ofmt::fullname" title='ofmt::fullname' data-ref="ofmt::fullname">fullname</dfn>;</td></tr>
<tr><th id="763">763</th><td></td></tr>
<tr><th id="764">764</th><td>    <i>/*</i></td></tr>
<tr><th id="765">765</th><td><i>     * This is a single keyword used to select the driver.</i></td></tr>
<tr><th id="766">766</th><td><i>     */</i></td></tr>
<tr><th id="767">767</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="ofmt::shortname" title='ofmt::shortname' data-ref="ofmt::shortname">shortname</dfn>;</td></tr>
<tr><th id="768">768</th><td></td></tr>
<tr><th id="769">769</th><td>    <i>/*</i></td></tr>
<tr><th id="770">770</th><td><i>     * Output format flags.</i></td></tr>
<tr><th id="771">771</th><td><i>     */</i></td></tr>
<tr><th id="772">772</th><td><u>#define <dfn class="macro" id="_M/OFMT_TEXT" data-ref="_M/OFMT_TEXT">OFMT_TEXT</dfn>   1		/* Text file format */</u></td></tr>
<tr><th id="773">773</th><td>    <em>unsigned</em> <em>int</em> <dfn class="decl field" id="ofmt::flags" title='ofmt::flags' data-ref="ofmt::flags">flags</dfn>;</td></tr>
<tr><th id="774">774</th><td></td></tr>
<tr><th id="775">775</th><td>    <em>int</em> <dfn class="decl field" id="ofmt::maxbits" title='ofmt::maxbits' data-ref="ofmt::maxbits">maxbits</dfn>;                <i>/* Maximum segment bits supported */</i></td></tr>
<tr><th id="776">776</th><td></td></tr>
<tr><th id="777">777</th><td>    <i>/*</i></td></tr>
<tr><th id="778">778</th><td><i>     * this is a pointer to the first element of the debug information</i></td></tr>
<tr><th id="779">779</th><td><i>     */</i></td></tr>
<tr><th id="780">780</th><td>    <em>const</em> <b>struct</b> <a class="type" href="#dfmt" title='dfmt' data-ref="dfmt">dfmt</a> * <em>const</em> *<dfn class="decl field" id="ofmt::debug_formats" title='ofmt::debug_formats' data-ref="ofmt::debug_formats">debug_formats</dfn>;</td></tr>
<tr><th id="781">781</th><td></td></tr>
<tr><th id="782">782</th><td>    <i>/*</i></td></tr>
<tr><th id="783">783</th><td><i>     * the default debugging format if -F is not specified</i></td></tr>
<tr><th id="784">784</th><td><i>     */</i></td></tr>
<tr><th id="785">785</th><td>    <em>const</em> <b>struct</b> <a class="type" href="#dfmt" title='dfmt' data-ref="dfmt">dfmt</a> *<dfn class="decl field" id="ofmt::default_dfmt" title='ofmt::default_dfmt' data-ref="ofmt::default_dfmt">default_dfmt</dfn>;</td></tr>
<tr><th id="786">786</th><td></td></tr>
<tr><th id="787">787</th><td>    <i>/*</i></td></tr>
<tr><th id="788">788</th><td><i>     * This, if non-NULL, is a NULL-terminated list of `char *'s</i></td></tr>
<tr><th id="789">789</th><td><i>     * pointing to extra standard macros supplied by the object</i></td></tr>
<tr><th id="790">790</th><td><i>     * format (e.g. a sensible initial default value of __SECT__,</i></td></tr>
<tr><th id="791">791</th><td><i>     * and user-level equivalents for any format-specific</i></td></tr>
<tr><th id="792">792</th><td><i>     * directives).</i></td></tr>
<tr><th id="793">793</th><td><i>     */</i></td></tr>
<tr><th id="794">794</th><td>    <a class="typedef" href="../asm/preproc.h.html#macros_t" title='macros_t' data-type='const unsigned char' data-ref="macros_t">macros_t</a> *<dfn class="decl field" id="ofmt::stdmac" title='ofmt::stdmac' data-ref="ofmt::stdmac">stdmac</dfn>;</td></tr>
<tr><th id="795">795</th><td></td></tr>
<tr><th id="796">796</th><td>    <i>/*</i></td></tr>
<tr><th id="797">797</th><td><i>     * This procedure is called at the start of an output session to set</i></td></tr>
<tr><th id="798">798</th><td><i>     * up internal parameters.</i></td></tr>
<tr><th id="799">799</th><td><i>     */</i></td></tr>
<tr><th id="800">800</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::init" title='ofmt::init' data-ref="ofmt::init">init</dfn>)(<em>void</em>);</td></tr>
<tr><th id="801">801</th><td></td></tr>
<tr><th id="802">802</th><td>    <i>/*</i></td></tr>
<tr><th id="803">803</th><td><i>     * This is the modern output function, which gets passed</i></td></tr>
<tr><th id="804">804</th><td><i>     * a struct out_data with much more information.  See the</i></td></tr>
<tr><th id="805">805</th><td><i>     * definition of struct out_data.</i></td></tr>
<tr><th id="806">806</th><td><i>     */</i></td></tr>
<tr><th id="807">807</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::output" title='ofmt::output' data-ref="ofmt::output">output</dfn>)(<em>const</em> <b>struct</b> <a class="type" href="#out_data" title='out_data' data-ref="out_data">out_data</a> *<dfn class="local col2 decl" id="142data" title='data' data-type='const struct out_data *' data-ref="142data">data</dfn>);</td></tr>
<tr><th id="808">808</th><td></td></tr>
<tr><th id="809">809</th><td>    <i>/*</i></td></tr>
<tr><th id="810">810</th><td><i>     * This procedure is called by assemble() to write actual</i></td></tr>
<tr><th id="811">811</th><td><i>     * generated code or data to the object file. Typically it</i></td></tr>
<tr><th id="812">812</th><td><i>     * doesn't have to actually _write_ it, just store it for</i></td></tr>
<tr><th id="813">813</th><td><i>     * later.</i></td></tr>
<tr><th id="814">814</th><td><i>     *</i></td></tr>
<tr><th id="815">815</th><td><i>     * The `type' argument specifies the type of output data, and</i></td></tr>
<tr><th id="816">816</th><td><i>     * usually the size as well: its contents are described below.</i></td></tr>
<tr><th id="817">817</th><td><i>     *</i></td></tr>
<tr><th id="818">818</th><td><i>     * This is used for backends which have not yet been ported to</i></td></tr>
<tr><th id="819">819</th><td><i>     * the new interface, and should be NULL on ported backends.</i></td></tr>
<tr><th id="820">820</th><td><i>     * To use this entry point, set the output pointer to</i></td></tr>
<tr><th id="821">821</th><td><i>     * nasm_do_legacy_output.</i></td></tr>
<tr><th id="822">822</th><td><i>     */</i></td></tr>
<tr><th id="823">823</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::legacy_output" title='ofmt::legacy_output' data-ref="ofmt::legacy_output">legacy_output</dfn>)(<a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col3 decl" id="143segto" title='segto' data-type='int32_t' data-ref="143segto">segto</dfn>, <em>const</em> <em>void</em> *<dfn class="local col4 decl" id="144data" title='data' data-type='const void *' data-ref="144data">data</dfn>,</td></tr>
<tr><th id="824">824</th><td>                          <b>enum</b> <a class="type" href="#out_type" title='out_type' data-ref="out_type">out_type</a> <dfn class="local col5 decl" id="145type" title='type' data-type='enum out_type' data-ref="145type">type</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#uint64_t" title='uint64_t' data-type='unsigned long' data-ref="uint64_t">uint64_t</a> <dfn class="local col6 decl" id="146size" title='size' data-type='uint64_t' data-ref="146size">size</dfn>,</td></tr>
<tr><th id="825">825</th><td>                          <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col7 decl" id="147segment" title='segment' data-type='int32_t' data-ref="147segment">segment</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col8 decl" id="148wrt" title='wrt' data-type='int32_t' data-ref="148wrt">wrt</dfn>);</td></tr>
<tr><th id="826">826</th><td></td></tr>
<tr><th id="827">827</th><td>    <i>/*</i></td></tr>
<tr><th id="828">828</th><td><i>     * This procedure is called once for every symbol defined in</i></td></tr>
<tr><th id="829">829</th><td><i>     * the module being assembled. It gives the name and value of</i></td></tr>
<tr><th id="830">830</th><td><i>     * the symbol, in NASM's terms, and indicates whether it has</i></td></tr>
<tr><th id="831">831</th><td><i>     * been declared to be global. Note that the parameter "name",</i></td></tr>
<tr><th id="832">832</th><td><i>     * when passed, will point to a piece of static storage</i></td></tr>
<tr><th id="833">833</th><td><i>     * allocated inside the label manager - it's safe to keep using</i></td></tr>
<tr><th id="834">834</th><td><i>     * that pointer, because the label manager doesn't clean up</i></td></tr>
<tr><th id="835">835</th><td><i>     * until after the output driver has.</i></td></tr>
<tr><th id="836">836</th><td><i>     *</i></td></tr>
<tr><th id="837">837</th><td><i>     * Values of `is_global' are: 0 means the symbol is local; 1</i></td></tr>
<tr><th id="838">838</th><td><i>     * means the symbol is global; 2 means the symbol is common (in</i></td></tr>
<tr><th id="839">839</th><td><i>     * which case `offset' holds the _size_ of the variable).</i></td></tr>
<tr><th id="840">840</th><td><i>     * Anything else is available for the output driver to use</i></td></tr>
<tr><th id="841">841</th><td><i>     * internally.</i></td></tr>
<tr><th id="842">842</th><td><i>     *</i></td></tr>
<tr><th id="843">843</th><td><i>     * This routine explicitly _is_ allowed to call the label</i></td></tr>
<tr><th id="844">844</th><td><i>     * manager to define further symbols, if it wants to, even</i></td></tr>
<tr><th id="845">845</th><td><i>     * though it's been called _from_ the label manager. That much</i></td></tr>
<tr><th id="846">846</th><td><i>     * re-entrancy is guaranteed in the label manager. However, the</i></td></tr>
<tr><th id="847">847</th><td><i>     * label manager will in turn call this routine, so it should</i></td></tr>
<tr><th id="848">848</th><td><i>     * be prepared to be re-entrant itself.</i></td></tr>
<tr><th id="849">849</th><td><i>     *</i></td></tr>
<tr><th id="850">850</th><td><i>     * The `special' parameter contains special information passed</i></td></tr>
<tr><th id="851">851</th><td><i>     * through from the command that defined the label: it may have</i></td></tr>
<tr><th id="852">852</th><td><i>     * been an EXTERN, a COMMON or a GLOBAL. The distinction should</i></td></tr>
<tr><th id="853">853</th><td><i>     * be obvious to the output format from the other parameters.</i></td></tr>
<tr><th id="854">854</th><td><i>     */</i></td></tr>
<tr><th id="855">855</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::symdef" title='ofmt::symdef' data-ref="ofmt::symdef">symdef</dfn>)(<em>char</em> *<dfn class="local col9 decl" id="149name" title='name' data-type='char *' data-ref="149name">name</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col0 decl" id="150segment" title='segment' data-type='int32_t' data-ref="150segment">segment</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="local col1 decl" id="151offset" title='offset' data-type='int64_t' data-ref="151offset">offset</dfn>,</td></tr>
<tr><th id="856">856</th><td>                   <em>int</em> <dfn class="local col2 decl" id="152is_global" title='is_global' data-type='int' data-ref="152is_global">is_global</dfn>, <em>char</em> *<dfn class="local col3 decl" id="153special" title='special' data-type='char *' data-ref="153special">special</dfn>);</td></tr>
<tr><th id="857">857</th><td></td></tr>
<tr><th id="858">858</th><td>    <i>/*</i></td></tr>
<tr><th id="859">859</th><td><i>     * This procedure is called when the source code requests a</i></td></tr>
<tr><th id="860">860</th><td><i>     * segment change. It should return the corresponding segment</i></td></tr>
<tr><th id="861">861</th><td><i>     * _number_ for the name, or NO_SEG if the name is not a valid</i></td></tr>
<tr><th id="862">862</th><td><i>     * segment name.</i></td></tr>
<tr><th id="863">863</th><td><i>     *</i></td></tr>
<tr><th id="864">864</th><td><i>     * It may also be called with NULL, in which case it is to</i></td></tr>
<tr><th id="865">865</th><td><i>     * return the _default_ section number for starting assembly in.</i></td></tr>
<tr><th id="866">866</th><td><i>     *</i></td></tr>
<tr><th id="867">867</th><td><i>     * It is allowed to modify the string it is given a pointer to.</i></td></tr>
<tr><th id="868">868</th><td><i>     *</i></td></tr>
<tr><th id="869">869</th><td><i>     * It is also allowed to specify a default instruction size for</i></td></tr>
<tr><th id="870">870</th><td><i>     * the segment, by setting `*bits' to 16 or 32. Or, if it</i></td></tr>
<tr><th id="871">871</th><td><i>     * doesn't wish to define a default, it can leave `bits' alone.</i></td></tr>
<tr><th id="872">872</th><td><i>     */</i></td></tr>
<tr><th id="873">873</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> (*<dfn class="decl field" id="ofmt::section" title='ofmt::section' data-ref="ofmt::section">section</dfn>)(<em>char</em> *<dfn class="local col4 decl" id="154name" title='name' data-type='char *' data-ref="154name">name</dfn>, <em>int</em> <dfn class="local col5 decl" id="155pass" title='pass' data-type='int' data-ref="155pass">pass</dfn>, <em>int</em> *<dfn class="local col6 decl" id="156bits" title='bits' data-type='int *' data-ref="156bits">bits</dfn>);</td></tr>
<tr><th id="874">874</th><td></td></tr>
<tr><th id="875">875</th><td>    <i>/*</i></td></tr>
<tr><th id="876">876</th><td><i>     * This procedure is called to modify section alignment,</i></td></tr>
<tr><th id="877">877</th><td><i>     * note there is a trick, the alignment can only increase</i></td></tr>
<tr><th id="878">878</th><td><i>     */</i></td></tr>
<tr><th id="879">879</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::sectalign" title='ofmt::sectalign' data-ref="ofmt::sectalign">sectalign</dfn>)(<a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col7 decl" id="157seg" title='seg' data-type='int32_t' data-ref="157seg">seg</dfn>, <em>unsigned</em> <em>int</em> <dfn class="local col8 decl" id="158value" title='value' data-type='unsigned int' data-ref="158value">value</dfn>);</td></tr>
<tr><th id="880">880</th><td></td></tr>
<tr><th id="881">881</th><td>    <i>/*</i></td></tr>
<tr><th id="882">882</th><td><i>     * This procedure is called to modify the segment base values</i></td></tr>
<tr><th id="883">883</th><td><i>     * returned from the SEG operator. It is given a segment base</i></td></tr>
<tr><th id="884">884</th><td><i>     * value (i.e. a segment value with the low bit set), and is</i></td></tr>
<tr><th id="885">885</th><td><i>     * required to produce in return a segment value which may be</i></td></tr>
<tr><th id="886">886</th><td><i>     * different. It can map segment bases to absolute numbers by</i></td></tr>
<tr><th id="887">887</th><td><i>     * means of returning SEG_ABS types.</i></td></tr>
<tr><th id="888">888</th><td><i>     *</i></td></tr>
<tr><th id="889">889</th><td><i>     * It should return NO_SEG if the segment base cannot be</i></td></tr>
<tr><th id="890">890</th><td><i>     * determined; the evaluator (which calls this routine) is</i></td></tr>
<tr><th id="891">891</th><td><i>     * responsible for throwing an error condition if that occurs</i></td></tr>
<tr><th id="892">892</th><td><i>     * in pass two or in a critical expression.</i></td></tr>
<tr><th id="893">893</th><td><i>     */</i></td></tr>
<tr><th id="894">894</th><td>    <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> (*<dfn class="decl field" id="ofmt::segbase" title='ofmt::segbase' data-ref="ofmt::segbase">segbase</dfn>)(<a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col9 decl" id="159segment" title='segment' data-type='int32_t' data-ref="159segment">segment</dfn>);</td></tr>
<tr><th id="895">895</th><td></td></tr>
<tr><th id="896">896</th><td>    <i>/*</i></td></tr>
<tr><th id="897">897</th><td><i>     * This procedure is called to allow the output driver to</i></td></tr>
<tr><th id="898">898</th><td><i>     * process its own specific directives. When called, it has the</i></td></tr>
<tr><th id="899">899</th><td><i>     * directive word in `directive' and the parameter string in</i></td></tr>
<tr><th id="900">900</th><td><i>     * `value'. It is called in both assembly passes, and `pass'</i></td></tr>
<tr><th id="901">901</th><td><i>     * will be either 1 or 2.</i></td></tr>
<tr><th id="902">902</th><td><i>     *</i></td></tr>
<tr><th id="903">903</th><td><i>     * The following values are (currently) possible for</i></td></tr>
<tr><th id="904">904</th><td><i>     * directive_result:</i></td></tr>
<tr><th id="905">905</th><td><i>     *</i></td></tr>
<tr><th id="906">906</th><td><i>     * 0 - DIRR_UNKNOWN		- directive not recognized by backend</i></td></tr>
<tr><th id="907">907</th><td><i>     * 1 - DIRR_OK		- directive processed ok</i></td></tr>
<tr><th id="908">908</th><td><i>     * 2 - DIRR_ERROR		- backend printed its own error message</i></td></tr>
<tr><th id="909">909</th><td><i>     * 3 - DIRR_BADPARAM	- print the generic message</i></td></tr>
<tr><th id="910">910</th><td><i>     *				  "invalid parameter to [*] directive"</i></td></tr>
<tr><th id="911">911</th><td><i>     */</i></td></tr>
<tr><th id="912">912</th><td>    <b>enum</b> <a class="type" href="#directive_result" title='directive_result' data-ref="directive_result">directive_result</a></td></tr>
<tr><th id="913">913</th><td>    (*<dfn class="decl field" id="ofmt::directive" title='ofmt::directive' data-ref="ofmt::directive">directive</dfn>)(<b>enum</b> <a class="type" href="../asm/directiv.h.html#directive" title='directive' data-ref="directive">directive</a> <dfn class="local col0 decl" id="160directive" title='directive' data-type='enum directive' data-ref="160directive">directive</dfn>, <em>char</em> *<dfn class="local col1 decl" id="161value" title='value' data-type='char *' data-ref="161value">value</dfn>, <em>int</em> <dfn class="local col2 decl" id="162pass" title='pass' data-type='int' data-ref="162pass">pass</dfn>);</td></tr>
<tr><th id="914">914</th><td></td></tr>
<tr><th id="915">915</th><td>    <i>/*</i></td></tr>
<tr><th id="916">916</th><td><i>     * This procedure is called before anything else - even before</i></td></tr>
<tr><th id="917">917</th><td><i>     * the "init" routine - and is passed the name of the input</i></td></tr>
<tr><th id="918">918</th><td><i>     * file from which this output file is being generated. It</i></td></tr>
<tr><th id="919">919</th><td><i>     * should return its preferred name for the output file in</i></td></tr>
<tr><th id="920">920</th><td><i>     * `outname', if outname[0] is not '\0', and do nothing to</i></td></tr>
<tr><th id="921">921</th><td><i>     * `outname' otherwise. Since it is called before the driver is</i></td></tr>
<tr><th id="922">922</th><td><i>     * properly initialized, it has to be passed its error handler</i></td></tr>
<tr><th id="923">923</th><td><i>     * separately.</i></td></tr>
<tr><th id="924">924</th><td><i>     *</i></td></tr>
<tr><th id="925">925</th><td><i>     * This procedure may also take its own copy of the input file</i></td></tr>
<tr><th id="926">926</th><td><i>     * name for use in writing the output file: it is _guaranteed_</i></td></tr>
<tr><th id="927">927</th><td><i>     * that it will be called before the "init" routine.</i></td></tr>
<tr><th id="928">928</th><td><i>     *</i></td></tr>
<tr><th id="929">929</th><td><i>     * The parameter `outname' points to an area of storage</i></td></tr>
<tr><th id="930">930</th><td><i>     * guaranteed to be at least FILENAME_MAX in size.</i></td></tr>
<tr><th id="931">931</th><td><i>     */</i></td></tr>
<tr><th id="932">932</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::filename" title='ofmt::filename' data-ref="ofmt::filename">filename</dfn>)(<em>char</em> *<dfn class="local col3 decl" id="163inname" title='inname' data-type='char *' data-ref="163inname">inname</dfn>, <em>char</em> *<dfn class="local col4 decl" id="164outname" title='outname' data-type='char *' data-ref="164outname">outname</dfn>);</td></tr>
<tr><th id="933">933</th><td></td></tr>
<tr><th id="934">934</th><td>    <i>/*</i></td></tr>
<tr><th id="935">935</th><td><i>     * This procedure is called after assembly finishes, to allow</i></td></tr>
<tr><th id="936">936</th><td><i>     * the output driver to clean itself up and free its memory.</i></td></tr>
<tr><th id="937">937</th><td><i>     * Typically, it will also be the point at which the object</i></td></tr>
<tr><th id="938">938</th><td><i>     * file actually gets _written_.</i></td></tr>
<tr><th id="939">939</th><td><i>     *</i></td></tr>
<tr><th id="940">940</th><td><i>     * One thing the cleanup routine should always do is to close</i></td></tr>
<tr><th id="941">941</th><td><i>     * the output file pointer.</i></td></tr>
<tr><th id="942">942</th><td><i>     */</i></td></tr>
<tr><th id="943">943</th><td>    <em>void</em> (*<dfn class="decl field" id="ofmt::cleanup" title='ofmt::cleanup' data-ref="ofmt::cleanup">cleanup</dfn>)(<em>void</em>);</td></tr>
<tr><th id="944">944</th><td></td></tr>
<tr><th id="945">945</th><td>    <i>/*</i></td></tr>
<tr><th id="946">946</th><td><i>     * List of pragma facility names that apply to this backend.</i></td></tr>
<tr><th id="947">947</th><td><i>     */</i></td></tr>
<tr><th id="948">948</th><td>    <em>const</em> <b>struct</b> <a class="type" href="#pragma_facility" title='pragma_facility' data-ref="pragma_facility">pragma_facility</a> *<dfn class="decl field" id="ofmt::pragmas" title='ofmt::pragmas' data-ref="ofmt::pragmas">pragmas</dfn>;</td></tr>
<tr><th id="949">949</th><td>};</td></tr>
<tr><th id="950">950</th><td></td></tr>
<tr><th id="951">951</th><td><i>/*</i></td></tr>
<tr><th id="952">952</th><td><i> * Output format driver alias</i></td></tr>
<tr><th id="953">953</th><td><i> */</i></td></tr>
<tr><th id="954">954</th><td><b>struct</b> <dfn class="type def" id="ofmt_alias" title='ofmt_alias' data-ref="ofmt_alias">ofmt_alias</dfn> {</td></tr>
<tr><th id="955">955</th><td>    <em>const</em> <em>char</em>  *<dfn class="decl field" id="ofmt_alias::shortname" title='ofmt_alias::shortname' data-ref="ofmt_alias::shortname">shortname</dfn>;</td></tr>
<tr><th id="956">956</th><td>    <em>const</em> <em>char</em>  *<dfn class="decl field" id="ofmt_alias::fullname" title='ofmt_alias::fullname' data-ref="ofmt_alias::fullname">fullname</dfn>;</td></tr>
<tr><th id="957">957</th><td>    <em>const</em> <b>struct</b> <a class="type" href="#ofmt" title='ofmt' data-ref="ofmt">ofmt</a> *<dfn class="decl field" id="ofmt_alias::ofmt" title='ofmt_alias::ofmt' data-ref="ofmt_alias::ofmt">ofmt</dfn>;</td></tr>
<tr><th id="958">958</th><td>};</td></tr>
<tr><th id="959">959</th><td></td></tr>
<tr><th id="960">960</th><td><b>extern</b> <em>const</em> <b>struct</b> <a class="type" href="#ofmt" title='ofmt' data-ref="ofmt">ofmt</a> *<dfn class="decl" id="ofmt" title='ofmt' data-ref="ofmt">ofmt</dfn>;</td></tr>
<tr><th id="961">961</th><td><b>extern</b> <a class="typedef" href="../../../../../../include/stdio.h.html#FILE" title='FILE' data-type='struct _IO_FILE' data-ref="FILE">FILE</a> *<dfn class="decl" id="ofile" title='ofile' data-ref="ofile">ofile</dfn>;</td></tr>
<tr><th id="962">962</th><td></td></tr>
<tr><th id="963">963</th><td><i>/*</i></td></tr>
<tr><th id="964">964</th><td><i> * ------------------------------------------------------------</i></td></tr>
<tr><th id="965">965</th><td><i> * The data structure defining a debug format driver, and the</i></td></tr>
<tr><th id="966">966</th><td><i> * interfaces to the functions therein.</i></td></tr>
<tr><th id="967">967</th><td><i> * ------------------------------------------------------------</i></td></tr>
<tr><th id="968">968</th><td><i> */</i></td></tr>
<tr><th id="969">969</th><td></td></tr>
<tr><th id="970">970</th><td><b>struct</b> <dfn class="type def" id="dfmt" title='dfmt' data-ref="dfmt">dfmt</dfn> {</td></tr>
<tr><th id="971">971</th><td>    <i>/*</i></td></tr>
<tr><th id="972">972</th><td><i>     * This is a short (one-liner) description of the type of</i></td></tr>
<tr><th id="973">973</th><td><i>     * output generated by the driver.</i></td></tr>
<tr><th id="974">974</th><td><i>     */</i></td></tr>
<tr><th id="975">975</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="dfmt::fullname" title='dfmt::fullname' data-ref="dfmt::fullname">fullname</dfn>;</td></tr>
<tr><th id="976">976</th><td></td></tr>
<tr><th id="977">977</th><td>    <i>/*</i></td></tr>
<tr><th id="978">978</th><td><i>     * This is a single keyword used to select the driver.</i></td></tr>
<tr><th id="979">979</th><td><i>     */</i></td></tr>
<tr><th id="980">980</th><td>    <em>const</em> <em>char</em> *<dfn class="decl field" id="dfmt::shortname" title='dfmt::shortname' data-ref="dfmt::shortname">shortname</dfn>;</td></tr>
<tr><th id="981">981</th><td></td></tr>
<tr><th id="982">982</th><td>    <i>/*</i></td></tr>
<tr><th id="983">983</th><td><i>     * init - called initially to set up local pointer to object format.</i></td></tr>
<tr><th id="984">984</th><td><i>     */</i></td></tr>
<tr><th id="985">985</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::init" title='dfmt::init' data-ref="dfmt::init">init</dfn>)(<em>void</em>);</td></tr>
<tr><th id="986">986</th><td></td></tr>
<tr><th id="987">987</th><td>    <i>/*</i></td></tr>
<tr><th id="988">988</th><td><i>     * linenum - called any time there is output with a change of</i></td></tr>
<tr><th id="989">989</th><td><i>     * line number or file.</i></td></tr>
<tr><th id="990">990</th><td><i>     */</i></td></tr>
<tr><th id="991">991</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::linenum" title='dfmt::linenum' data-ref="dfmt::linenum">linenum</dfn>)(<em>const</em> <em>char</em> *<dfn class="local col5 decl" id="165filename" title='filename' data-type='const char *' data-ref="165filename">filename</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col6 decl" id="166linenumber" title='linenumber' data-type='int32_t' data-ref="166linenumber">linenumber</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col7 decl" id="167segto" title='segto' data-type='int32_t' data-ref="167segto">segto</dfn>);</td></tr>
<tr><th id="992">992</th><td></td></tr>
<tr><th id="993">993</th><td>    <i>/*</i></td></tr>
<tr><th id="994">994</th><td><i>     * debug_deflabel - called whenever a label is defined. Parameters</i></td></tr>
<tr><th id="995">995</th><td><i>     * are the same as to 'symdef()' in the output format. This function</i></td></tr>
<tr><th id="996">996</th><td><i>     * is called after the output format version.</i></td></tr>
<tr><th id="997">997</th><td><i>     */</i></td></tr>
<tr><th id="998">998</th><td></td></tr>
<tr><th id="999">999</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::debug_deflabel" title='dfmt::debug_deflabel' data-ref="dfmt::debug_deflabel">debug_deflabel</dfn>)(<em>char</em> *<dfn class="local col8 decl" id="168name" title='name' data-type='char *' data-ref="168name">name</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col9 decl" id="169segment" title='segment' data-type='int32_t' data-ref="169segment">segment</dfn>, <a class="typedef" href="../../../../../../include/stdint.h.html#int64_t" title='int64_t' data-type='long' data-ref="int64_t">int64_t</a> <dfn class="local col0 decl" id="170offset" title='offset' data-type='int64_t' data-ref="170offset">offset</dfn>,</td></tr>
<tr><th id="1000">1000</th><td>                           <em>int</em> <dfn class="local col1 decl" id="171is_global" title='is_global' data-type='int' data-ref="171is_global">is_global</dfn>, <em>char</em> *<dfn class="local col2 decl" id="172special" title='special' data-type='char *' data-ref="172special">special</dfn>);</td></tr>
<tr><th id="1001">1001</th><td>    <i>/*</i></td></tr>
<tr><th id="1002">1002</th><td><i>     * debug_directive - called whenever a DEBUG directive other than 'LINE'</i></td></tr>
<tr><th id="1003">1003</th><td><i>     * is encountered. 'directive' contains the first parameter to the</i></td></tr>
<tr><th id="1004">1004</th><td><i>     * DEBUG directive, and params contains the rest. For example,</i></td></tr>
<tr><th id="1005">1005</th><td><i>     * 'DEBUG VAR _somevar:int' would translate to a call to this</i></td></tr>
<tr><th id="1006">1006</th><td><i>     * function with 'directive' equal to "VAR" and 'params' equal to</i></td></tr>
<tr><th id="1007">1007</th><td><i>     * "_somevar:int".</i></td></tr>
<tr><th id="1008">1008</th><td><i>     */</i></td></tr>
<tr><th id="1009">1009</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::debug_directive" title='dfmt::debug_directive' data-ref="dfmt::debug_directive">debug_directive</dfn>)(<em>const</em> <em>char</em> *<dfn class="local col3 decl" id="173directive" title='directive' data-type='const char *' data-ref="173directive">directive</dfn>, <em>const</em> <em>char</em> *<dfn class="local col4 decl" id="174params" title='params' data-type='const char *' data-ref="174params">params</dfn>);</td></tr>
<tr><th id="1010">1010</th><td></td></tr>
<tr><th id="1011">1011</th><td>    <i>/*</i></td></tr>
<tr><th id="1012">1012</th><td><i>     * typevalue - called whenever the assembler wishes to register a type</i></td></tr>
<tr><th id="1013">1013</th><td><i>     * for the last defined label.  This routine MUST detect if a type was</i></td></tr>
<tr><th id="1014">1014</th><td><i>     * already registered and not re-register it.</i></td></tr>
<tr><th id="1015">1015</th><td><i>     */</i></td></tr>
<tr><th id="1016">1016</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::debug_typevalue" title='dfmt::debug_typevalue' data-ref="dfmt::debug_typevalue">debug_typevalue</dfn>)(<a class="typedef" href="../../../../../../include/stdint.h.html#int32_t" title='int32_t' data-type='int' data-ref="int32_t">int32_t</a> <dfn class="local col5 decl" id="175type" title='type' data-type='int32_t' data-ref="175type">type</dfn>);</td></tr>
<tr><th id="1017">1017</th><td></td></tr>
<tr><th id="1018">1018</th><td>    <i>/*</i></td></tr>
<tr><th id="1019">1019</th><td><i>     * debug_output - called whenever output is required</i></td></tr>
<tr><th id="1020">1020</th><td><i>     * 'type' is the type of info required, and this is format-specific</i></td></tr>
<tr><th id="1021">1021</th><td><i>     */</i></td></tr>
<tr><th id="1022">1022</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::debug_output" title='dfmt::debug_output' data-ref="dfmt::debug_output">debug_output</dfn>)(<em>int</em> <dfn class="local col6 decl" id="176type" title='type' data-type='int' data-ref="176type">type</dfn>, <em>void</em> *<dfn class="local col7 decl" id="177param" title='param' data-type='void *' data-ref="177param">param</dfn>);</td></tr>
<tr><th id="1023">1023</th><td></td></tr>
<tr><th id="1024">1024</th><td>    <i>/*</i></td></tr>
<tr><th id="1025">1025</th><td><i>     * cleanup - called after processing of file is complete</i></td></tr>
<tr><th id="1026">1026</th><td><i>     */</i></td></tr>
<tr><th id="1027">1027</th><td>    <em>void</em> (*<dfn class="decl field" id="dfmt::cleanup" title='dfmt::cleanup' data-ref="dfmt::cleanup">cleanup</dfn>)(<em>void</em>);</td></tr>
<tr><th id="1028">1028</th><td></td></tr>
<tr><th id="1029">1029</th><td>    <i>/*</i></td></tr>
<tr><th id="1030">1030</th><td><i>     * List of pragma facility names that apply to this backend.</i></td></tr>
<tr><th id="1031">1031</th><td><i>     */</i></td></tr>
<tr><th id="1032">1032</th><td>    <em>const</em> <b>struct</b> <a class="type" href="#pragma_facility" title='pragma_facility' data-ref="pragma_facility">pragma_facility</a> *<dfn class="decl field" id="dfmt::pragmas" title='dfmt::pragmas' data-ref="dfmt::pragmas">pragmas</dfn>;</td></tr>
<tr><th id="1033">1033</th><td>};</td></tr>
<tr><th id="1034">1034</th><td></td></tr>
<tr><th id="1035">1035</th><td><b>extern</b> <em>const</em> <b>struct</b> <a class="type" href="#dfmt" title='dfmt' data-ref="dfmt">dfmt</a> *<dfn class="decl" id="dfmt" title='dfmt' data-ref="dfmt">dfmt</dfn>;</td></tr>
<tr><th id="1036">1036</th><td></td></tr>
<tr><th id="1037">1037</th><td><i>/*</i></td></tr>
<tr><th id="1038">1038</th><td><i> * The type definition macros</i></td></tr>
<tr><th id="1039">1039</th><td><i> * for debugging</i></td></tr>
<tr><th id="1040">1040</th><td><i> *</i></td></tr>
<tr><th id="1041">1041</th><td><i> * low 3 bits: reserved</i></td></tr>
<tr><th id="1042">1042</th><td><i> * next 5 bits: type</i></td></tr>
<tr><th id="1043">1043</th><td><i> * next 24 bits: number of elements for arrays (0 for labels)</i></td></tr>
<tr><th id="1044">1044</th><td><i> */</i></td></tr>
<tr><th id="1045">1045</th><td></td></tr>
<tr><th id="1046">1046</th><td><u>#define <dfn class="macro" id="_M/TY_UNKNOWN" data-ref="_M/TY_UNKNOWN">TY_UNKNOWN</dfn> 0x00</u></td></tr>
<tr><th id="1047">1047</th><td><u>#define <dfn class="macro" id="_M/TY_LABEL" data-ref="_M/TY_LABEL">TY_LABEL</dfn>   0x08</u></td></tr>
<tr><th id="1048">1048</th><td><u>#define <dfn class="macro" id="_M/TY_BYTE" data-ref="_M/TY_BYTE">TY_BYTE</dfn>    0x10</u></td></tr>
<tr><th id="1049">1049</th><td><u>#define <dfn class="macro" id="_M/TY_WORD" data-ref="_M/TY_WORD">TY_WORD</dfn>    0x18</u></td></tr>
<tr><th id="1050">1050</th><td><u>#define <dfn class="macro" id="_M/TY_DWORD" data-ref="_M/TY_DWORD">TY_DWORD</dfn>   0x20</u></td></tr>
<tr><th id="1051">1051</th><td><u>#define <dfn class="macro" id="_M/TY_FLOAT" data-ref="_M/TY_FLOAT">TY_FLOAT</dfn>   0x28</u></td></tr>
<tr><th id="1052">1052</th><td><u>#define <dfn class="macro" id="_M/TY_QWORD" data-ref="_M/TY_QWORD">TY_QWORD</dfn>   0x30</u></td></tr>
<tr><th id="1053">1053</th><td><u>#define <dfn class="macro" id="_M/TY_TBYTE" data-ref="_M/TY_TBYTE">TY_TBYTE</dfn>   0x38</u></td></tr>
<tr><th id="1054">1054</th><td><u>#define <dfn class="macro" id="_M/TY_OWORD" data-ref="_M/TY_OWORD">TY_OWORD</dfn>   0x40</u></td></tr>
<tr><th id="1055">1055</th><td><u>#define <dfn class="macro" id="_M/TY_YWORD" data-ref="_M/TY_YWORD">TY_YWORD</dfn>   0x48</u></td></tr>
<tr><th id="1056">1056</th><td><u>#define <dfn class="macro" id="_M/TY_ZWORD" data-ref="_M/TY_ZWORD">TY_ZWORD</dfn>   0x50</u></td></tr>
<tr><th id="1057">1057</th><td><u>#define <dfn class="macro" id="_M/TY_COMMON" data-ref="_M/TY_COMMON">TY_COMMON</dfn>  0xE0</u></td></tr>
<tr><th id="1058">1058</th><td><u>#define <dfn class="macro" id="_M/TY_SEG" data-ref="_M/TY_SEG">TY_SEG</dfn>     0xE8</u></td></tr>
<tr><th id="1059">1059</th><td><u>#define <dfn class="macro" id="_M/TY_EXTERN" data-ref="_M/TY_EXTERN">TY_EXTERN</dfn>  0xF0</u></td></tr>
<tr><th id="1060">1060</th><td><u>#define <dfn class="macro" id="_M/TY_EQU" data-ref="_M/TY_EQU">TY_EQU</dfn>     0xF8</u></td></tr>
<tr><th id="1061">1061</th><td></td></tr>
<tr><th id="1062">1062</th><td><u>#define <dfn class="macro" id="_M/TYM_TYPE" data-ref="_M/TYM_TYPE">TYM_TYPE</dfn>(x)     ((x) &amp; 0xF8)</u></td></tr>
<tr><th id="1063">1063</th><td><u>#define <dfn class="macro" id="_M/TYM_ELEMENTS" data-ref="_M/TYM_ELEMENTS">TYM_ELEMENTS</dfn>(x) (((x) &amp; 0xFFFFFF00) &gt;&gt; 8)</u></td></tr>
<tr><th id="1064">1064</th><td></td></tr>
<tr><th id="1065">1065</th><td><u>#define <dfn class="macro" id="_M/TYS_ELEMENTS" data-ref="_M/TYS_ELEMENTS">TYS_ELEMENTS</dfn>(x) ((x) &lt;&lt; 8)</u></td></tr>
<tr><th id="1066">1066</th><td></td></tr>
<tr><th id="1067">1067</th><td><b>enum</b> <dfn class="type def" id="special_tokens" title='special_tokens' data-ref="special_tokens">special_tokens</dfn> {</td></tr>
<tr><th id="1068">1068</th><td>    <dfn class="enum" id="SPECIAL_ENUM_START" title='SPECIAL_ENUM_START' data-ref="SPECIAL_ENUM_START">SPECIAL_ENUM_START</dfn>  = <a class="enum" href="#PREFIX_ENUM_LIMIT" title='PREFIX_ENUM_LIMIT' data-ref="PREFIX_ENUM_LIMIT">PREFIX_ENUM_LIMIT</a>,</td></tr>
<tr><th id="1069">1069</th><td>    <dfn class="enum" id="S_ABS" title='S_ABS' data-ref="S_ABS">S_ABS</dfn>               = <a class="enum" href="#SPECIAL_ENUM_START" title='SPECIAL_ENUM_START' data-ref="SPECIAL_ENUM_START">SPECIAL_ENUM_START</a>,</td></tr>
<tr><th id="1070">1070</th><td>    <dfn class="enum" id="S_BYTE" title='S_BYTE' data-ref="S_BYTE">S_BYTE</dfn>,</td></tr>
<tr><th id="1071">1071</th><td>    <dfn class="enum" id="S_DWORD" title='S_DWORD' data-ref="S_DWORD">S_DWORD</dfn>,</td></tr>
<tr><th id="1072">1072</th><td>    <dfn class="enum" id="S_FAR" title='S_FAR' data-ref="S_FAR">S_FAR</dfn>,</td></tr>
<tr><th id="1073">1073</th><td>    <dfn class="enum" id="S_LONG" title='S_LONG' data-ref="S_LONG">S_LONG</dfn>,</td></tr>
<tr><th id="1074">1074</th><td>    <dfn class="enum" id="S_NEAR" title='S_NEAR' data-ref="S_NEAR">S_NEAR</dfn>,</td></tr>
<tr><th id="1075">1075</th><td>    <dfn class="enum" id="S_NOSPLIT" title='S_NOSPLIT' data-ref="S_NOSPLIT">S_NOSPLIT</dfn>,</td></tr>
<tr><th id="1076">1076</th><td>    <dfn class="enum" id="S_OWORD" title='S_OWORD' data-ref="S_OWORD">S_OWORD</dfn>,</td></tr>
<tr><th id="1077">1077</th><td>    <dfn class="enum" id="S_QWORD" title='S_QWORD' data-ref="S_QWORD">S_QWORD</dfn>,</td></tr>
<tr><th id="1078">1078</th><td>    <dfn class="enum" id="S_REL" title='S_REL' data-ref="S_REL">S_REL</dfn>,</td></tr>
<tr><th id="1079">1079</th><td>    <dfn class="enum" id="S_SHORT" title='S_SHORT' data-ref="S_SHORT">S_SHORT</dfn>,</td></tr>
<tr><th id="1080">1080</th><td>    <dfn class="enum" id="S_STRICT" title='S_STRICT' data-ref="S_STRICT">S_STRICT</dfn>,</td></tr>
<tr><th id="1081">1081</th><td>    <dfn class="enum" id="S_TO" title='S_TO' data-ref="S_TO">S_TO</dfn>,</td></tr>
<tr><th id="1082">1082</th><td>    <dfn class="enum" id="S_TWORD" title='S_TWORD' data-ref="S_TWORD">S_TWORD</dfn>,</td></tr>
<tr><th id="1083">1083</th><td>    <dfn class="enum" id="S_WORD" title='S_WORD' data-ref="S_WORD">S_WORD</dfn>,</td></tr>
<tr><th id="1084">1084</th><td>    <dfn class="enum" id="S_YWORD" title='S_YWORD' data-ref="S_YWORD">S_YWORD</dfn>,</td></tr>
<tr><th id="1085">1085</th><td>    <dfn class="enum" id="S_ZWORD" title='S_ZWORD' data-ref="S_ZWORD">S_ZWORD</dfn>,</td></tr>
<tr><th id="1086">1086</th><td>    <dfn class="enum" id="SPECIAL_ENUM_LIMIT" title='SPECIAL_ENUM_LIMIT' data-ref="SPECIAL_ENUM_LIMIT">SPECIAL_ENUM_LIMIT</dfn></td></tr>
<tr><th id="1087">1087</th><td>};</td></tr>
<tr><th id="1088">1088</th><td></td></tr>
<tr><th id="1089">1089</th><td><b>enum</b> <dfn class="type def" id="decorator_tokens" title='decorator_tokens' data-ref="decorator_tokens">decorator_tokens</dfn> {</td></tr>
<tr><th id="1090">1090</th><td>    <dfn class="enum" id="DECORATOR_ENUM_START" title='DECORATOR_ENUM_START' data-ref="DECORATOR_ENUM_START">DECORATOR_ENUM_START</dfn>    = <a class="enum" href="#SPECIAL_ENUM_LIMIT" title='SPECIAL_ENUM_LIMIT' data-ref="SPECIAL_ENUM_LIMIT">SPECIAL_ENUM_LIMIT</a>,</td></tr>
<tr><th id="1091">1091</th><td>    <dfn class="enum" id="BRC_1TO2" title='BRC_1TO2' data-ref="BRC_1TO2">BRC_1TO2</dfn>                = <a class="enum" href="#DECORATOR_ENUM_START" title='DECORATOR_ENUM_START' data-ref="DECORATOR_ENUM_START">DECORATOR_ENUM_START</a>,</td></tr>
<tr><th id="1092">1092</th><td>    <dfn class="enum" id="BRC_1TO4" title='BRC_1TO4' data-ref="BRC_1TO4">BRC_1TO4</dfn>,</td></tr>
<tr><th id="1093">1093</th><td>    <dfn class="enum" id="BRC_1TO8" title='BRC_1TO8' data-ref="BRC_1TO8">BRC_1TO8</dfn>,</td></tr>
<tr><th id="1094">1094</th><td>    <dfn class="enum" id="BRC_1TO16" title='BRC_1TO16' data-ref="BRC_1TO16">BRC_1TO16</dfn>,</td></tr>
<tr><th id="1095">1095</th><td>    <dfn class="enum" id="BRC_RN" title='BRC_RN' data-ref="BRC_RN">BRC_RN</dfn>,</td></tr>
<tr><th id="1096">1096</th><td>    <dfn class="enum" id="BRC_RD" title='BRC_RD' data-ref="BRC_RD">BRC_RD</dfn>,</td></tr>
<tr><th id="1097">1097</th><td>    <dfn class="enum" id="BRC_RU" title='BRC_RU' data-ref="BRC_RU">BRC_RU</dfn>,</td></tr>
<tr><th id="1098">1098</th><td>    <dfn class="enum" id="BRC_RZ" title='BRC_RZ' data-ref="BRC_RZ">BRC_RZ</dfn>,</td></tr>
<tr><th id="1099">1099</th><td>    <dfn class="enum" id="BRC_SAE" title='BRC_SAE' data-ref="BRC_SAE">BRC_SAE</dfn>,</td></tr>
<tr><th id="1100">1100</th><td>    <dfn class="enum" id="BRC_Z" title='BRC_Z' data-ref="BRC_Z">BRC_Z</dfn>,</td></tr>
<tr><th id="1101">1101</th><td>    <dfn class="enum" id="DECORATOR_ENUM_LIMIT" title='DECORATOR_ENUM_LIMIT' data-ref="DECORATOR_ENUM_LIMIT">DECORATOR_ENUM_LIMIT</dfn></td></tr>
<tr><th id="1102">1102</th><td>};</td></tr>
<tr><th id="1103">1103</th><td></td></tr>
<tr><th id="1104">1104</th><td><i>/*</i></td></tr>
<tr><th id="1105">1105</th><td><i> * AVX512 Decorator (decoflags_t) bits distribution (counted from 0)</i></td></tr>
<tr><th id="1106">1106</th><td><i> *  3         2         1</i></td></tr>
<tr><th id="1107">1107</th><td><i> * 10987654321098765432109876543210</i></td></tr>
<tr><th id="1108">1108</th><td><i> *                |</i></td></tr>
<tr><th id="1109">1109</th><td><i> *                | word boundary</i></td></tr>
<tr><th id="1110">1110</th><td><i> * ............................1111 opmask</i></td></tr>
<tr><th id="1111">1111</th><td><i> * ...........................1.... zeroing / merging</i></td></tr>
<tr><th id="1112">1112</th><td><i> * ..........................1..... broadcast</i></td></tr>
<tr><th id="1113">1113</th><td><i> * .........................1...... static rounding</i></td></tr>
<tr><th id="1114">1114</th><td><i> * ........................1....... SAE</i></td></tr>
<tr><th id="1115">1115</th><td><i> * ......................11........ broadcast element size</i></td></tr>
<tr><th id="1116">1116</th><td><i> * ....................11.......... number of broadcast elements</i></td></tr>
<tr><th id="1117">1117</th><td><i> */</i></td></tr>
<tr><th id="1118">1118</th><td><u>#define <dfn class="macro" id="_M/OP_GENVAL" data-ref="_M/OP_GENVAL">OP_GENVAL</dfn>(val, bits, shift)     (((val) &amp; ((UINT64_C(1) &lt;&lt; (bits)) - 1)) &lt;&lt; (shift))</u></td></tr>
<tr><th id="1119">1119</th><td></td></tr>
<tr><th id="1120">1120</th><td><i>/*</i></td></tr>
<tr><th id="1121">1121</th><td><i> * Opmask register number</i></td></tr>
<tr><th id="1122">1122</th><td><i> * identical to EVEX.aaa</i></td></tr>
<tr><th id="1123">1123</th><td><i> *</i></td></tr>
<tr><th id="1124">1124</th><td><i> * Bits: 0 - 3</i></td></tr>
<tr><th id="1125">1125</th><td><i> */</i></td></tr>
<tr><th id="1126">1126</th><td><u>#define <dfn class="macro" id="_M/OPMASK_SHIFT" data-ref="_M/OPMASK_SHIFT">OPMASK_SHIFT</dfn>            (0)</u></td></tr>
<tr><th id="1127">1127</th><td><u>#define <dfn class="macro" id="_M/OPMASK_BITS" data-ref="_M/OPMASK_BITS">OPMASK_BITS</dfn>             (4)</u></td></tr>
<tr><th id="1128">1128</th><td><u>#define <dfn class="macro" id="_M/OPMASK_MASK" data-ref="_M/OPMASK_MASK">OPMASK_MASK</dfn>             OP_GENMASK(OPMASK_BITS, OPMASK_SHIFT)</u></td></tr>
<tr><th id="1129">1129</th><td><u>#define <dfn class="macro" id="_M/GEN_OPMASK" data-ref="_M/GEN_OPMASK">GEN_OPMASK</dfn>(bit)         OP_GENBIT(bit, OPMASK_SHIFT)</u></td></tr>
<tr><th id="1130">1130</th><td><u>#define <dfn class="macro" id="_M/VAL_OPMASK" data-ref="_M/VAL_OPMASK">VAL_OPMASK</dfn>(val)         OP_GENVAL(val, OPMASK_BITS, OPMASK_SHIFT)</u></td></tr>
<tr><th id="1131">1131</th><td></td></tr>
<tr><th id="1132">1132</th><td><i>/*</i></td></tr>
<tr><th id="1133">1133</th><td><i> * zeroing / merging control available</i></td></tr>
<tr><th id="1134">1134</th><td><i> * matching to EVEX.z</i></td></tr>
<tr><th id="1135">1135</th><td><i> *</i></td></tr>
<tr><th id="1136">1136</th><td><i> * Bits: 4</i></td></tr>
<tr><th id="1137">1137</th><td><i> */</i></td></tr>
<tr><th id="1138">1138</th><td><u>#define <dfn class="macro" id="_M/Z_SHIFT" data-ref="_M/Z_SHIFT">Z_SHIFT</dfn>                 (4)</u></td></tr>
<tr><th id="1139">1139</th><td><u>#define <dfn class="macro" id="_M/Z_BITS" data-ref="_M/Z_BITS">Z_BITS</dfn>                  (1)</u></td></tr>
<tr><th id="1140">1140</th><td><u>#define <dfn class="macro" id="_M/Z_MASK" data-ref="_M/Z_MASK">Z_MASK</dfn>                  OP_GENMASK(Z_BITS, Z_SHIFT)</u></td></tr>
<tr><th id="1141">1141</th><td><u>#define <dfn class="macro" id="_M/GEN_Z" data-ref="_M/GEN_Z">GEN_Z</dfn>(bit)              OP_GENBIT(bit, Z_SHIFT)</u></td></tr>
<tr><th id="1142">1142</th><td></td></tr>
<tr><th id="1143">1143</th><td><i>/*</i></td></tr>
<tr><th id="1144">1144</th><td><i> * broadcast - Whether this operand can be broadcasted</i></td></tr>
<tr><th id="1145">1145</th><td><i> *</i></td></tr>
<tr><th id="1146">1146</th><td><i> * Bits: 5</i></td></tr>
<tr><th id="1147">1147</th><td><i> */</i></td></tr>
<tr><th id="1148">1148</th><td><u>#define <dfn class="macro" id="_M/BRDCAST_SHIFT" data-ref="_M/BRDCAST_SHIFT">BRDCAST_SHIFT</dfn>           (5)</u></td></tr>
<tr><th id="1149">1149</th><td><u>#define <dfn class="macro" id="_M/BRDCAST_BITS" data-ref="_M/BRDCAST_BITS">BRDCAST_BITS</dfn>            (1)</u></td></tr>
<tr><th id="1150">1150</th><td><u>#define <dfn class="macro" id="_M/BRDCAST_MASK" data-ref="_M/BRDCAST_MASK">BRDCAST_MASK</dfn>            OP_GENMASK(BRDCAST_BITS, BRDCAST_SHIFT)</u></td></tr>
<tr><th id="1151">1151</th><td><u>#define <dfn class="macro" id="_M/GEN_BRDCAST" data-ref="_M/GEN_BRDCAST">GEN_BRDCAST</dfn>(bit)        OP_GENBIT(bit, BRDCAST_SHIFT)</u></td></tr>
<tr><th id="1152">1152</th><td></td></tr>
<tr><th id="1153">1153</th><td><i>/*</i></td></tr>
<tr><th id="1154">1154</th><td><i> * Whether this instruction can have a static rounding mode.</i></td></tr>
<tr><th id="1155">1155</th><td><i> * It goes with the last simd operand because the static rounding mode</i></td></tr>
<tr><th id="1156">1156</th><td><i> * decorator is located between the last simd operand and imm8 (if any).</i></td></tr>
<tr><th id="1157">1157</th><td><i> *</i></td></tr>
<tr><th id="1158">1158</th><td><i> * Bits: 6</i></td></tr>
<tr><th id="1159">1159</th><td><i> */</i></td></tr>
<tr><th id="1160">1160</th><td><u>#define <dfn class="macro" id="_M/STATICRND_SHIFT" data-ref="_M/STATICRND_SHIFT">STATICRND_SHIFT</dfn>         (6)</u></td></tr>
<tr><th id="1161">1161</th><td><u>#define <dfn class="macro" id="_M/STATICRND_BITS" data-ref="_M/STATICRND_BITS">STATICRND_BITS</dfn>          (1)</u></td></tr>
<tr><th id="1162">1162</th><td><u>#define <dfn class="macro" id="_M/STATICRND_MASK" data-ref="_M/STATICRND_MASK">STATICRND_MASK</dfn>          OP_GENMASK(STATICRND_BITS, STATICRND_SHIFT)</u></td></tr>
<tr><th id="1163">1163</th><td><u>#define <dfn class="macro" id="_M/GEN_STATICRND" data-ref="_M/GEN_STATICRND">GEN_STATICRND</dfn>(bit)      OP_GENBIT(bit, STATICRND_SHIFT)</u></td></tr>
<tr><th id="1164">1164</th><td></td></tr>
<tr><th id="1165">1165</th><td><i>/*</i></td></tr>
<tr><th id="1166">1166</th><td><i> * SAE(Suppress all exception) available</i></td></tr>
<tr><th id="1167">1167</th><td><i> *</i></td></tr>
<tr><th id="1168">1168</th><td><i> * Bits: 7</i></td></tr>
<tr><th id="1169">1169</th><td><i> */</i></td></tr>
<tr><th id="1170">1170</th><td><u>#define <dfn class="macro" id="_M/SAE_SHIFT" data-ref="_M/SAE_SHIFT">SAE_SHIFT</dfn>               (7)</u></td></tr>
<tr><th id="1171">1171</th><td><u>#define <dfn class="macro" id="_M/SAE_BITS" data-ref="_M/SAE_BITS">SAE_BITS</dfn>                (1)</u></td></tr>
<tr><th id="1172">1172</th><td><u>#define <dfn class="macro" id="_M/SAE_MASK" data-ref="_M/SAE_MASK">SAE_MASK</dfn>                OP_GENMASK(SAE_BITS, SAE_SHIFT)</u></td></tr>
<tr><th id="1173">1173</th><td><u>#define <dfn class="macro" id="_M/GEN_SAE" data-ref="_M/GEN_SAE">GEN_SAE</dfn>(bit)            OP_GENBIT(bit, SAE_SHIFT)</u></td></tr>
<tr><th id="1174">1174</th><td></td></tr>
<tr><th id="1175">1175</th><td><i>/*</i></td></tr>
<tr><th id="1176">1176</th><td><i> * Broadcasting element size.</i></td></tr>
<tr><th id="1177">1177</th><td><i> *</i></td></tr>
<tr><th id="1178">1178</th><td><i> * Bits: 8 - 9</i></td></tr>
<tr><th id="1179">1179</th><td><i> */</i></td></tr>
<tr><th id="1180">1180</th><td><u>#define <dfn class="macro" id="_M/BRSIZE_SHIFT" data-ref="_M/BRSIZE_SHIFT">BRSIZE_SHIFT</dfn>            (8)</u></td></tr>
<tr><th id="1181">1181</th><td><u>#define <dfn class="macro" id="_M/BRSIZE_BITS" data-ref="_M/BRSIZE_BITS">BRSIZE_BITS</dfn>             (2)</u></td></tr>
<tr><th id="1182">1182</th><td><u>#define <dfn class="macro" id="_M/BRSIZE_MASK" data-ref="_M/BRSIZE_MASK">BRSIZE_MASK</dfn>             OP_GENMASK(BRSIZE_BITS, BRSIZE_SHIFT)</u></td></tr>
<tr><th id="1183">1183</th><td><u>#define <dfn class="macro" id="_M/GEN_BRSIZE" data-ref="_M/GEN_BRSIZE">GEN_BRSIZE</dfn>(bit)         OP_GENBIT(bit, BRSIZE_SHIFT)</u></td></tr>
<tr><th id="1184">1184</th><td></td></tr>
<tr><th id="1185">1185</th><td><u>#define <dfn class="macro" id="_M/BR_BITS32" data-ref="_M/BR_BITS32">BR_BITS32</dfn>               GEN_BRSIZE(0)</u></td></tr>
<tr><th id="1186">1186</th><td><u>#define <dfn class="macro" id="_M/BR_BITS64" data-ref="_M/BR_BITS64">BR_BITS64</dfn>               GEN_BRSIZE(1)</u></td></tr>
<tr><th id="1187">1187</th><td></td></tr>
<tr><th id="1188">1188</th><td><i>/*</i></td></tr>
<tr><th id="1189">1189</th><td><i> * Number of broadcasting elements</i></td></tr>
<tr><th id="1190">1190</th><td><i> *</i></td></tr>
<tr><th id="1191">1191</th><td><i> * Bits: 10 - 11</i></td></tr>
<tr><th id="1192">1192</th><td><i> */</i></td></tr>
<tr><th id="1193">1193</th><td><u>#define <dfn class="macro" id="_M/BRNUM_SHIFT" data-ref="_M/BRNUM_SHIFT">BRNUM_SHIFT</dfn>             (10)</u></td></tr>
<tr><th id="1194">1194</th><td><u>#define <dfn class="macro" id="_M/BRNUM_BITS" data-ref="_M/BRNUM_BITS">BRNUM_BITS</dfn>              (2)</u></td></tr>
<tr><th id="1195">1195</th><td><u>#define <dfn class="macro" id="_M/BRNUM_MASK" data-ref="_M/BRNUM_MASK">BRNUM_MASK</dfn>              OP_GENMASK(BRNUM_BITS, BRNUM_SHIFT)</u></td></tr>
<tr><th id="1196">1196</th><td><u>#define <dfn class="macro" id="_M/VAL_BRNUM" data-ref="_M/VAL_BRNUM">VAL_BRNUM</dfn>(val)          OP_GENVAL(val, BRNUM_BITS, BRNUM_SHIFT)</u></td></tr>
<tr><th id="1197">1197</th><td></td></tr>
<tr><th id="1198">1198</th><td><u>#define <dfn class="macro" id="_M/BR_1TO2" data-ref="_M/BR_1TO2">BR_1TO2</dfn>                 VAL_BRNUM(0)</u></td></tr>
<tr><th id="1199">1199</th><td><u>#define <dfn class="macro" id="_M/BR_1TO4" data-ref="_M/BR_1TO4">BR_1TO4</dfn>                 VAL_BRNUM(1)</u></td></tr>
<tr><th id="1200">1200</th><td><u>#define <dfn class="macro" id="_M/BR_1TO8" data-ref="_M/BR_1TO8">BR_1TO8</dfn>                 VAL_BRNUM(2)</u></td></tr>
<tr><th id="1201">1201</th><td><u>#define <dfn class="macro" id="_M/BR_1TO16" data-ref="_M/BR_1TO16">BR_1TO16</dfn>                VAL_BRNUM(3)</u></td></tr>
<tr><th id="1202">1202</th><td></td></tr>
<tr><th id="1203">1203</th><td><u>#define <dfn class="macro" id="_M/MASK" data-ref="_M/MASK">MASK</dfn>                    OPMASK_MASK             /* Opmask (k1 ~ 7) can be used */</u></td></tr>
<tr><th id="1204">1204</th><td><u>#define <dfn class="macro" id="_M/Z" data-ref="_M/Z">Z</dfn>                       Z_MASK</u></td></tr>
<tr><th id="1205">1205</th><td><u>#define <dfn class="macro" id="_M/B32" data-ref="_M/B32">B32</dfn>                     (BRDCAST_MASK|BR_BITS32) /* {1to16} : broadcast 32b * 16 to zmm(512b) */</u></td></tr>
<tr><th id="1206">1206</th><td><u>#define <dfn class="macro" id="_M/B64" data-ref="_M/B64">B64</dfn>                     (BRDCAST_MASK|BR_BITS64) /* {1to8}  : broadcast 64b *  8 to zmm(512b) */</u></td></tr>
<tr><th id="1207">1207</th><td><u>#define <dfn class="macro" id="_M/ER" data-ref="_M/ER">ER</dfn>                      STATICRND_MASK          /* ER(Embedded Rounding) == Static rounding mode */</u></td></tr>
<tr><th id="1208">1208</th><td><u>#define <dfn class="macro" id="_M/SAE" data-ref="_M/SAE">SAE</dfn>                     SAE_MASK                /* SAE(Suppress All Exception) */</u></td></tr>
<tr><th id="1209">1209</th><td></td></tr>
<tr><th id="1210">1210</th><td><i>/*</i></td></tr>
<tr><th id="1211">1211</th><td><i> * Global modes</i></td></tr>
<tr><th id="1212">1212</th><td><i> */</i></td></tr>
<tr><th id="1213">1213</th><td></td></tr>
<tr><th id="1214">1214</th><td><i>/*</i></td></tr>
<tr><th id="1215">1215</th><td><i> * This declaration passes the "pass" number to all other modules</i></td></tr>
<tr><th id="1216">1216</th><td><i> * "pass0" assumes the values: 0, 0, ..., 0, 1, 2</i></td></tr>
<tr><th id="1217">1217</th><td><i> * where 0 = optimizing pass</i></td></tr>
<tr><th id="1218">1218</th><td><i> *       1 = pass 1</i></td></tr>
<tr><th id="1219">1219</th><td><i> *       2 = pass 2</i></td></tr>
<tr><th id="1220">1220</th><td><i> */</i></td></tr>
<tr><th id="1221">1221</th><td></td></tr>
<tr><th id="1222">1222</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="pass0" title='pass0' data-ref="pass0">pass0</dfn>;</td></tr>
<tr><th id="1223">1223</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="passn" title='passn' data-ref="passn">passn</dfn>;               <i>/* Actual pass number */</i></td></tr>
<tr><th id="1224">1224</th><td></td></tr>
<tr><th id="1225">1225</th><td><b>extern</b> <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl" id="tasm_compatible_mode" title='tasm_compatible_mode' data-ref="tasm_compatible_mode">tasm_compatible_mode</dfn>;</td></tr>
<tr><th id="1226">1226</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="optimizing" title='optimizing' data-ref="optimizing">optimizing</dfn>;</td></tr>
<tr><th id="1227">1227</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="globalbits" title='globalbits' data-ref="globalbits">globalbits</dfn>;          <i>/* 16, 32 or 64-bit mode */</i></td></tr>
<tr><th id="1228">1228</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="globalrel" title='globalrel' data-ref="globalrel">globalrel</dfn>;           <i>/* default to relative addressing? */</i></td></tr>
<tr><th id="1229">1229</th><td><b>extern</b> <em>int</em> <dfn class="decl" id="globalbnd" title='globalbnd' data-ref="globalbnd">globalbnd</dfn>;           <i>/* default to using bnd prefix? */</i></td></tr>
<tr><th id="1230">1230</th><td></td></tr>
<tr><th id="1231">1231</th><td><u>#<span data-ppcond="38">endif</span></u></td></tr>
<tr><th id="1232">1232</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../asm/assemble.c.html'>vpp_1804/build-root/build-vpp_debug-native/dpdk/nasm-2.13.01/asm/assemble.c</a><br/>Generated on <em>2018-Jul-29</em> from project vpp_1804 revision <em>18.04</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
