<dec f='include/mbedtls/ssl.h' l='2496' type='int mbedtls_ssl_read(mbedtls_ssl_context * ssl, unsigned char * buf, size_t len)'/>
<use f='vpp_1804/src/plugins/tlsmbedtls/tls_mbedtls.c' l='495' u='c' c='mbedtls_ctx_read'/>
<doc f='include/mbedtls/ssl.h' l='2462'>/**
 * \brief          Read at most &apos;len&apos; application data bytes
 *
 * \param ssl      SSL context
 * \param buf      buffer that will hold the data
 * \param len      maximum number of bytes to read
 *
 * \return         the number of bytes read, or
 *                 0 for EOF, or
 *                 MBEDTLS_ERR_SSL_WANT_READ or MBEDTLS_ERR_SSL_WANT_WRITE, or
 *                 MBEDTLS_ERR_SSL_CLIENT_RECONNECT (see below), or
 *                 another negative error code.
 *
 * \note           If this function returns something other than a positive
 *                 value or MBEDTLS_ERR_SSL_WANT_READ/WRITE or
 *                 MBEDTLS_ERR_SSL_CLIENT_RECONNECT, then the ssl context
 *                 becomes unusable, and you should either free it or call
 *                 \c mbedtls_ssl_session_reset() on it before re-using it for
 *                 a new connection; the current connection must be closed.
 *
 * \note           When this function return MBEDTLS_ERR_SSL_CLIENT_RECONNECT
 *                 (which can only happen server-side), it means that a client
 *                 is initiating a new connection using the same source port.
 *                 You can either treat that as a connection close and wait
 *                 for the client to resend a ClientHello, or directly
 *                 continue with \c mbedtls_ssl_handshake() with the same
 *                 context (as it has beeen reset internally). Either way, you
 *                 should make sure this is seen by the application as a new
 *                 connection: application state, if any, should be reset, and
 *                 most importantly the identity of the client must be checked
 *                 again. WARNING: not validating the identity of the client
 *                 again, or not transmitting the new identity to the
 *                 application layer, would allow authentication bypass!
 */</doc>
