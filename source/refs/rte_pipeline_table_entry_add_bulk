<dec f='dpdk/lib/librte_pipeline/rte_pipeline.h' l='473' type='int rte_pipeline_table_entry_add_bulk(struct rte_pipeline * p, uint32_t table_id, void ** keys, struct rte_pipeline_table_entry ** entries, uint32_t n_keys, int * key_found, struct rte_pipeline_table_entry ** entries_ptr)'/>
<def f='dpdk/lib/librte_pipeline/rte_pipeline.c' l='582' ll='646' type='int rte_pipeline_table_entry_add_bulk(struct rte_pipeline * p, uint32_t table_id, void ** keys, struct rte_pipeline_table_entry ** entries, uint32_t n_keys, int * key_found, struct rte_pipeline_table_entry ** entries_ptr)'/>
<doc f='dpdk/lib/librte_pipeline/rte_pipeline.h' l='447'>/**
 * Pipeline table entry add bulk
 *
 * @param p
 *   Handle to pipeline instance
 * @param table_id
 *   Table ID (returned by previous invocation of pipeline table create)
 * @param keys
 *   Array containing table entry keys
 * @param entries
 *   Array containing new contents for every table entry identified by key
 * @param n_keys
 *   Number of keys to add
 * @param key_found
 *   On successful invocation, key_found for every item in the array is set to
 *   TRUE (value different than 0) if key was already present in the table
 *   before the add operation and to FALSE (value 0) if not
 * @param entries_ptr
 *   On successful invocation, array *entries_ptr stores pointer to every table
 *   entry associated with key. This can be used for further read-write accesses
 *   to this table entry and is valid until the key is deleted from the table or
 *   re-added (usually for associating different actions and/or action meta-data
 *   to the current key)
 * @return
 *   0 on success, error code otherwise
 */</doc>
