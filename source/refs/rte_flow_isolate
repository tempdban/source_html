<dec f='dpdk_18.05/lib/librte_ethdev/rte_flow.h' l='2138' type='int rte_flow_isolate(uint16_t port_id, int set, struct rte_flow_error * error)'/>
<doc f='dpdk_18.05/lib/librte_ethdev/rte_flow.h' l='2096'>/**
 * Restrict ingress traffic to the defined flow rules.
 *
 * Isolated mode guarantees that all ingress traffic comes from defined flow
 * rules only (current and future).
 *
 * Besides making ingress more deterministic, it allows PMDs to safely reuse
 * resources otherwise assigned to handle the remaining traffic, such as
 * global RSS configuration settings, VLAN filters, MAC address entries,
 * legacy filter API rules and so on in order to expand the set of possible
 * flow rule types.
 *
 * Calling this function as soon as possible after device initialization,
 * ideally before the first call to rte_eth_dev_configure(), is recommended
 * to avoid possible failures due to conflicting settings.
 *
 * Once effective, leaving isolated mode may not be possible depending on
 * PMD implementation.
 *
 * Additionally, the following functionality has no effect on the underlying
 * port and may return errors such as ENOTSUP (&quot;not supported&quot;):
 *
 * - Toggling promiscuous mode.
 * - Toggling allmulticast mode.
 * - Configuring MAC addresses.
 * - Configuring multicast addresses.
 * - Configuring VLAN filters.
 * - Configuring Rx filters through the legacy API (e.g. FDIR).
 * - Configuring global RSS settings.
 *
 * @param port_id
 *   Port identifier of Ethernet device.
 * @param set
 *   Nonzero to enter isolated mode, attempt to leave it otherwise.
 * @param[out] error
 *   Perform verbose error reporting if not NULL. PMDs initialize this
 *   structure in case of error only.
 *
 * @return
 *   0 on success, a negative errno value otherwise and rte_errno is set.
 */</doc>
<use f='dpdk_18.05/app/test-pmd/config.c' l='1617' u='c' c='port_flow_isolate'/>
<use f='dpdk_18.05/drivers/net/bonding/rte_eth_bond_api.c' l='238' u='c' c='slave_rte_flow_prepare'/>
<use f='dpdk_18.05/drivers/net/bonding/rte_eth_bond_flow.c' l='208' u='c' c='bond_flow_isolate'/>
<use f='dpdk_18.05/drivers/net/failsafe/failsafe_ether.c' l='60' u='c' c='eth_dev_flow_isolate_set'/>
<use f='dpdk_18.05/drivers/net/failsafe/failsafe_flow.c' l='217' u='c' c='fs_flow_isolate'/>
<def f='dpdk_18.05/lib/librte_ethdev/rte_flow.c' l='254' ll='269' type='int rte_flow_isolate(uint16_t port_id, int set, struct rte_flow_error * error)'/>
<doc f='dpdk_18.05/lib/librte_ethdev/rte_flow.c' l='253'>/* Restrict ingress traffic to the defined flow rules. */</doc>
