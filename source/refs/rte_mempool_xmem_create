<dec f='dpdk_18.05/lib/librte_mempool/rte_mempool.h' l='1037' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<def f='dpdk_18.05/lib/librte_mempool/rte_mempool.c' l='1074' ll='1126' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<doc f='dpdk_18.05/lib/librte_mempool/rte_mempool.c' l='1068'>/*
 * Create the mempool over already allocated chunk of memory.
 * That external memory buffer can consists of physically disjoint pages.
 * Setting vaddr to NULL, makes mempool to fallback to rte_mempool_create()
 * behavior.
 */</doc>
<dec f='vpp_1804/build-root/build-vpp_debug-native/dpdk/dpdk-stable-18.02.1/lib/librte_mempool/rte_mempool.h' l='791' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<doc f='vpp_1804/build-root/build-vpp_debug-native/dpdk/dpdk-stable-18.02.1/lib/librte_mempool/rte_mempool.h' l='732'>/**
 * Create a new mempool named *name* in memory.
 *
 * The pool contains n elements of elt_size. Its size is set to n.
 * This function uses ``memzone_reserve()`` to allocate the mempool header
 * (and the objects if vaddr is NULL).
 * Depending on the input parameters, mempool elements can be either allocated
 * together with the mempool header, or an externally provided memory buffer
 * could be used to store mempool objects. In later case, that external
 * memory buffer can consist of set of disjoint physical pages.
 *
 * @param name
 *   The name of the mempool.
 * @param n
 *   The number of elements in the mempool. The optimum size (in terms of
 *   memory usage) for a mempool is when n is a power of two minus one:
 *   n = (2^q - 1).
 * @param elt_size
 *   The size of each element.
 * @param cache_size
 *   Size of the cache. See rte_mempool_create() for details.
 * @param private_data_size
 *   The size of the private data appended after the mempool
 *   structure. This is useful for storing some private data after the
 *   mempool structure, as is done for rte_mbuf_pool for example.
 * @param mp_init
 *   A function pointer that is called for initialization of the pool,
 *   before object initialization. The user can initialize the private
 *   data in this function if needed. This parameter can be NULL if
 *   not needed.
 * @param mp_init_arg
 *   An opaque pointer to data that can be used in the mempool
 *   constructor function.
 * @param obj_init
 *   A function called for each object at initialization of the pool.
 *   See rte_mempool_create() for details.
 * @param obj_init_arg
 *   An opaque pointer passed to the object constructor function.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   Flags controlling the behavior of the mempool. See
 *   rte_mempool_create() for details.
 * @param vaddr
 *   Virtual address of the externally allocated memory buffer.
 *   Will be used to store mempool objects.
 * @param iova
 *   Array of IO addresses of the pages that comprises given memory buffer.
 * @param pg_num
 *   Number of elements in the iova array.
 * @param pg_shift
 *   LOG2 of the physical pages size.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. See rte_mempool_create() for details.
 */</doc>
<def f='vpp_1804/build-root/build-vpp_debug-native/dpdk/dpdk-stable-18.02.1/lib/librte_mempool/rte_mempool.c' l='953' ll='1005' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<doc f='vpp_1804/build-root/build-vpp_debug-native/dpdk/dpdk-stable-18.02.1/lib/librte_mempool/rte_mempool.c' l='947'>/*
 * Create the mempool over already allocated chunk of memory.
 * That external memory buffer can consists of physically disjoint pages.
 * Setting vaddr to NULL, makes mempool to fallback to rte_mempool_create()
 * behavior.
 */</doc>
<dec f='vpp_1804/build-root/install-vpp_debug-native/dpdk/include/dpdk/rte_mempool.h' l='791' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<doc f='vpp_1804/build-root/install-vpp_debug-native/dpdk/include/dpdk/rte_mempool.h' l='732'>/**
 * Create a new mempool named *name* in memory.
 *
 * The pool contains n elements of elt_size. Its size is set to n.
 * This function uses ``memzone_reserve()`` to allocate the mempool header
 * (and the objects if vaddr is NULL).
 * Depending on the input parameters, mempool elements can be either allocated
 * together with the mempool header, or an externally provided memory buffer
 * could be used to store mempool objects. In later case, that external
 * memory buffer can consist of set of disjoint physical pages.
 *
 * @param name
 *   The name of the mempool.
 * @param n
 *   The number of elements in the mempool. The optimum size (in terms of
 *   memory usage) for a mempool is when n is a power of two minus one:
 *   n = (2^q - 1).
 * @param elt_size
 *   The size of each element.
 * @param cache_size
 *   Size of the cache. See rte_mempool_create() for details.
 * @param private_data_size
 *   The size of the private data appended after the mempool
 *   structure. This is useful for storing some private data after the
 *   mempool structure, as is done for rte_mbuf_pool for example.
 * @param mp_init
 *   A function pointer that is called for initialization of the pool,
 *   before object initialization. The user can initialize the private
 *   data in this function if needed. This parameter can be NULL if
 *   not needed.
 * @param mp_init_arg
 *   An opaque pointer to data that can be used in the mempool
 *   constructor function.
 * @param obj_init
 *   A function called for each object at initialization of the pool.
 *   See rte_mempool_create() for details.
 * @param obj_init_arg
 *   An opaque pointer passed to the object constructor function.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   Flags controlling the behavior of the mempool. See
 *   rte_mempool_create() for details.
 * @param vaddr
 *   Virtual address of the externally allocated memory buffer.
 *   Will be used to store mempool objects.
 * @param iova
 *   Array of IO addresses of the pages that comprises given memory buffer.
 * @param pg_num
 *   Number of elements in the iova array.
 * @param pg_shift
 *   LOG2 of the physical pages size.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. See rte_mempool_create() for details.
 */</doc>
