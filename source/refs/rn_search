<dec f='vpp_1804/src/vnet/util/radix.h' l='144' type='struct radix_node * rn_search(const void * , struct radix_node * )'/>
<def f='vpp_1804/src/vnet/util/radix.c' l='131' ll='146' type='struct radix_node * rn_search(const void * v_arg, struct radix_node * head)'/>
<use f='vpp_1804/src/vnet/util/radix.c' l='424' u='c' c='rn_insert'/>
<use f='vpp_1804/src/vnet/util/radix.c' l='523' u='c' c='rn_addmask'/>
<use f='vpp_1804/src/vnet/util/radix.c' l='775' u='c' c='rn_delete1'/>
<doc f='vpp_1804/src/vnet/util/radix.c' l='97'>/*
 * The data structure for the keys is a radix tree with one way
 * branching removed.  The index rn_b at an internal node n represents a bit
 * position to be tested.  The tree is arranged so that all descendants
 * of a node n have keys whose bits all agree up to position rn_b - 1.
 * (We say the index of n is rn_b.)
 *
 * There is at least one descendant which has a one bit at position rn_b,
 * and at least one with a zero there.
 *
 * A route is determined by a pair of key and mask.  We require that the
 * bit-wise logical and of the key and mask to be the key.
 * We define the index of a route to associated with the mask to be
 * the first bit number in the mask where 0 occurs (with bit number 0
 * representing the highest order bit).
 *
 * We say a mask is normal if every bit is 0, past the index of the mask.
 * If a node n has a descendant (k, m) with index(m) == index(n) == rn_b,
 * and m is a normal mask, then the route applies to every descendant of n.
 * If the index(m) &lt; rn_b, this implies the trailing last few bits of k
 * before bit b are all 0, (and hence consequently true of every descendant
 * of n), so the route applies to all descendants of the node as well.
 *
 * Similar logic shows that a non-normal mask m such that
 * index(m) &lt;= index(n) could potentially apply to many children of n.
 * Thus, for each non-host route, we attach its mask to a list at an internal
 * node as high in the tree as we can go.
 *
 * The present version of the code makes use of normal routes in short-
 * circuiting an explicit mask and compare operation when testing whether
 * a key satisfies a normal route, and also in remembering the unique leaf
 * that governs a subtree.
 */</doc>
