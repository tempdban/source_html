<dec f='dpdk_1805/lib/librte_eal/common/include/rte_launch.h' l='97' type='int rte_eal_mp_remote_launch(lcore_function_t * f, void * arg, enum rte_rmt_call_master_t call_master)'/>
<doc f='dpdk_1805/lib/librte_eal/common/include/rte_launch.h' l='76'>/**
 * Launch a function on all lcores.
 *
 * Check that each SLAVE lcore is in a WAIT state, then call
 * rte_eal_remote_launch() for each lcore.
 *
 * @param f
 *   The function to be called.
 * @param arg
 *   The argument for the function.
 * @param call_master
 *   If call_master set to SKIP_MASTER, the MASTER lcore does not call
 *   the function. If call_master is set to CALL_MASTER, the function
 *   is also called on master before returning. In any case, the master
 *   lcore returns as soon as it finished its job and knows nothing
 *   about the completion of f on the other lcores.
 * @return
 *   - 0: Success. Execution of function f started on all remote lcores.
 *   - (-EBUSY): At least one remote lcore is not in a WAIT state. In this
 *     case, no message is sent to any of the lcores.
 */</doc>
<def f='dpdk_1805/lib/librte_eal/common/eal_common_launch.c' l='43' ll='67' type='int rte_eal_mp_remote_launch(int (*)(void *) f, void * arg, enum rte_rmt_call_master_t call_master)'/>
<doc f='dpdk_1805/lib/librte_eal/common/eal_common_launch.c' l='38'>/*
 * Check that every SLAVE lcores are in WAIT state, then call
 * rte_eal_remote_launch() for all of them. If call_master is true
 * (set to CALL_MASTER), also call the function on the master lcore.
 */</doc>
<use f='dpdk_1805/lib/librte_eal/linuxapp/eal/eal.c' l='1019' u='c' c='rte_eal_init'/>
