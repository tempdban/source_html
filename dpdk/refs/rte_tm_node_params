<def f='dpdk_1805/lib/librte_ethdev/rte_tm.h' l='944' ll='1013'/>
<size>64</size>
<doc f='dpdk_1805/lib/librte_ethdev/rte_tm.h' l='917'>/**
 * Node parameters
 *
 * Each non-leaf node has multiple inputs (its children nodes) and single output
 * (which is input to its parent node). It arbitrates its inputs using Strict
 * Priority (SP) and Weighted Fair Queuing (WFQ) algorithms to schedule input
 * packets to its output while observing its shaping (rate limiting)
 * constraints.
 *
 * Algorithms such as Weighted Round Robin (WRR), Byte-level WRR, Deficit WRR
 * (DWRR), etc. are considered approximations of the WFQ ideal and are
 * assimilated to WFQ, although an associated implementation-dependent trade-off
 * on accuracy, performance and resource usage might exist.
 *
 * Children nodes with different priorities are scheduled using the SP algorithm
 * based on their priority, with zero (0) as the highest priority. Children with
 * the same priority are scheduled using the WFQ algorithm according to their
 * weights. The WFQ weight of a given child node is relative to the sum of the
 * weights of all its sibling nodes that have the same priority, with one (1) as
 * the lowest weight. For each SP priority, the WFQ weight mode can be set as
 * either byte-based or packet-based.
 *
 * Each leaf node sits on top of a TX queue of the current Ethernet port. Hence,
 * the leaf nodes are predefined, with their node IDs set to 0 .. (N-1), where N
 * is the number of TX queues configured for the current Ethernet port. The
 * non-leaf nodes have their IDs generated by the application.
 */</doc>
<mbr r='rte_tm_node_params::shaper_profile_id' o='0' t='uint32_t'/>
<mbr r='rte_tm_node_params::shared_shaper_id' o='64' t='uint32_t *'/>
<mbr r='rte_tm_node_params::n_shared_shapers' o='128' t='uint32_t'/>
<mbr r='rte_tm_node_params::stats_mask' o='448' t='uint64_t'/>
