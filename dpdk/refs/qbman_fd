<def f='master/drivers/bus/fslmc/qbman/include/fsl_qbman_base.h' l='116' ll='130'/>
<size>32</size>
<doc f='master/drivers/bus/fslmc/qbman/include/fsl_qbman_base.h' l='70'>/**
 * struct qbman_fd - basci structure for qbman frame descriptor
 * @words: for easier/faster copying the whole FD structure.
 * @addr_lo: the lower 32 bits of the address in FD.
 * @addr_hi: the upper 32 bits of the address in FD.
 * @len: the length field in FD.
 * @bpid_offset: represent the bpid and offset fields in FD. offset in
 * the MS 16 bits, BPID in the LS 16 bits.
 * @frc: frame context
 * @ctrl: the 32bit control bits including dd, sc,... va, err.
 * @flc_lo: the lower 32bit of flow context.
 * @flc_hi: the upper 32bits of flow context.
 *
 * Place-holder for FDs, we represent it via the simplest form that we need for
 * now. Different overlays may be needed to support different options, etc. (It
 * is impractical to define One True Struct, because the resulting encoding
 * routines (lots of read-modify-writes) would be worst-case performance whether
 * or not circumstances required them.)
 *
 * Note, as with all data-structures exchanged between software and hardware (be
 * they located in the portal register map or DMA&apos;d to and from main-memory),
 * the driver ensures that the caller of the driver API sees the data-structures
 * in host-endianness. &quot;struct qbman_fd&quot; is no exception. The 32-bit words
 * contained within this structure are represented in host-endianness, even if
 * hardware always treats them as little-endian. As such, if any of these fields
 * are interpreted in a binary (rather than numerical) fashion by hardware
 * blocks (eg. accelerators), then the user should be careful. We illustrate
 * with an example;
 *
 * Suppose the desired behaviour of an accelerator is controlled by the &quot;frc&quot;
 * field of the FDs that are sent to it. Suppose also that the behaviour desired
 * by the user corresponds to an &quot;frc&quot; value which is expressed as the literal
 * sequence of bytes 0xfe, 0xed, 0xab, and 0xba. So &quot;frc&quot; should be the 32-bit
 * value in which 0xfe is the first byte and 0xba is the last byte, and as
 * hardware is little-endian, this amounts to a 32-bit &quot;value&quot; of 0xbaabedfe. If
 * the software is little-endian also, this can simply be achieved by setting
 * frc=0xbaabedfe. On the other hand, if software is big-endian, it should set
 * frc=0xfeedabba! The best away of avoiding trouble with this sort of thing is
 * to treat the 32-bit words as numerical values, in which the offset of a field
 * from the beginning of the first byte (as required or generated by hardware)
 * is numerically encoded by a left-shift (ie. by raising the field to a
 * corresponding power of 2).  Ie. in the current example, software could set
 * &quot;frc&quot; in the following way, and it would work correctly on both little-endian
 * and big-endian operation;
 *    fd.frc = (0xfe &lt;&lt; 0) | (0xed &lt;&lt; 8) | (0xab &lt;&lt; 16) | (0xba &lt;&lt; 24);
 */</doc>
