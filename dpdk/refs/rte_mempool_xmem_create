<dec f='dpdk_1805/lib/librte_mempool/rte_mempool.h' l='1037' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<def f='dpdk_1805/lib/librte_mempool/rte_mempool.c' l='1074' ll='1126' type='struct rte_mempool * rte_mempool_xmem_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags, void * vaddr, const rte_iova_t * iova, uint32_t pg_num, uint32_t pg_shift)'/>
<doc f='dpdk_1805/lib/librte_mempool/rte_mempool.c' l='1068'>/*
 * Create the mempool over already allocated chunk of memory.
 * That external memory buffer can consists of physically disjoint pages.
 * Setting vaddr to NULL, makes mempool to fallback to rte_mempool_create()
 * behavior.
 */</doc>
