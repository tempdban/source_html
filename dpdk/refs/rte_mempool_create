<dec f='dpdk_1805/lib/librte_mempool/rte_mempool.h' l='970' type='struct rte_mempool * rte_mempool_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags)'/>
<doc f='dpdk_1805/lib/librte_mempool/rte_mempool.h' l='890'>/**
 * Create a new mempool named *name* in memory.
 *
 * This function uses ``rte_memzone_reserve()`` to allocate memory. The
 * pool contains n elements of elt_size. Its size is set to n.
 *
 * @param name
 *   The name of the mempool.
 * @param n
 *   The number of elements in the mempool. The optimum size (in terms of
 *   memory usage) for a mempool is when n is a power of two minus one:
 *   n = (2^q - 1).
 * @param elt_size
 *   The size of each element.
 * @param cache_size
 *   If cache_size is non-zero, the rte_mempool library will try to
 *   limit the accesses to the common lockless pool, by maintaining a
 *   per-lcore object cache. This argument must be lower or equal to
 *   CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose
 *   cache_size to have &quot;n modulo cache_size == 0&quot;: if this is
 *   not the case, some elements will always stay in the pool and will
 *   never be used. The access to the per-lcore table is of course
 *   faster than the multi-producer/consumer pool. The cache can be
 *   disabled if the cache_size argument is set to 0; it can be useful to
 *   avoid losing objects in cache.
 * @param private_data_size
 *   The size of the private data appended after the mempool
 *   structure. This is useful for storing some private data after the
 *   mempool structure, as is done for rte_mbuf_pool for example.
 * @param mp_init
 *   A function pointer that is called for initialization of the pool,
 *   before object initialization. The user can initialize the private
 *   data in this function if needed. This parameter can be NULL if
 *   not needed.
 * @param mp_init_arg
 *   An opaque pointer to data that can be used in the mempool
 *   constructor function.
 * @param obj_init
 *   A function pointer that is called for each object at
 *   initialization of the pool. The user can set some meta data in
 *   objects if needed. This parameter can be NULL if not needed.
 *   The obj_init() function takes the mempool pointer, the init_arg,
 *   the object pointer and the object number as parameters.
 * @param obj_init_arg
 *   An opaque pointer to data that can be used as an argument for
 *   each call to the object constructor function.
 * @param socket_id
 *   The *socket_id* argument is the socket identifier in the case of
 *   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA
 *   constraint for the reserved zone.
 * @param flags
 *   The *flags* arguments is an OR of following flags:
 *   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread
 *     between channels in RAM: the pool allocator will add padding
 *     between objects depending on the hardware configuration. See
 *     Memory alignment constraints for details. If this flag is set,
 *     the allocator will just align them to a cache line.
 *   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are
 *     cache-aligned. This flag removes this constraint, and no
 *     padding will be present between objects. This flag implies
 *     MEMPOOL_F_NO_SPREAD.
 *   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior
 *     when using rte_mempool_put() or rte_mempool_put_bulk() is
 *     &quot;single-producer&quot;. Otherwise, it is &quot;multi-producers&quot;.
 *   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior
 *     when using rte_mempool_get() or rte_mempool_get_bulk() is
 *     &quot;single-consumer&quot;. Otherwise, it is &quot;multi-consumers&quot;.
 *   - MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won&apos;t
 *     necessarily be contiguous in IO memory.
 * @return
 *   The pointer to the new allocated mempool, on success. NULL on error
 *   with rte_errno set appropriately. Possible rte_errno values include:
 *    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure
 *    - E_RTE_SECONDARY - function was called from a secondary process instance
 *    - EINVAL - cache size provided is too large
 *    - ENOSPC - the maximum number of memzones has already been allocated
 *    - EEXIST - a memzone with the same name already exists
 *    - ENOMEM - no appropriate memory area found in which to create memzone
 */</doc>
<use f='dpdk_1805/app/test-crypto-perf/main.c' l='159' u='c' c='cperf_initialize_cryptodev'/>
<use f='dpdk_1805/app/test-eventdev/test_perf_common.c' l='758' u='c' c='perf_mempool_setup'/>
<use f='dpdk_1805/drivers/crypto/virtio/virtio_cryptodev.c' l='359' u='c' c='virtio_crypto_queue_setup'/>
<use f='dpdk_1805/lib/librte_bbdev/rte_bbdev.c' l='895' u='c' c='rte_bbdev_op_pool_create'/>
<use f='dpdk_1805/lib/librte_compressdev/rte_comp.c' l='136' u='c' c='rte_comp_op_pool_create'/>
<use f='dpdk_1805/lib/librte_cryptodev/rte_cryptodev.c' l='1360' u='c' c='rte_crypto_op_pool_create'/>
<use f='dpdk_1805/lib/librte_eventdev/rte_event_timer_adapter.c' l='908' u='c' c='sw_event_timer_adapter_init'/>
<def f='dpdk_1805/lib/librte_mempool/rte_mempool.c' l='1019' ll='1066' type='struct rte_mempool * rte_mempool_create(const char * name, unsigned int n, unsigned int elt_size, unsigned int cache_size, unsigned int private_data_size, rte_mempool_ctor_t * mp_init, void * mp_init_arg, rte_mempool_obj_cb_t * obj_init, void * obj_init_arg, int socket_id, unsigned int flags)'/>
<use f='dpdk_1805/lib/librte_mempool/rte_mempool.c' l='1087' u='c' c='rte_mempool_xmem_create'/>
<doc f='dpdk_1805/lib/librte_mempool/rte_mempool.c' l='1018'>/* create the mempool */</doc>
<use f='dpdk_1805/lib/librte_vhost/iotlb.c' l='341' u='c' c='vhost_user_iotlb_init'/>
