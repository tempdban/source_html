<dec f='dpdk_1805/drivers/bus/dpaa/include/fsl_qman.h' l='1732' type='int qman_enqueue(struct qman_fq * fq, const struct qm_fd * fd, u32 flags)'/>
<doc f='dpdk_1805/drivers/bus/dpaa/include/fsl_qman.h' l='1699'>/**
 * qman_enqueue - Enqueue a frame to a frame queue
 * @fq: the frame queue object to enqueue to
 * @fd: a descriptor of the frame to be enqueued
 * @flags: bit-mask of QMAN_ENQUEUE_FLAG_*** options
 *
 * Fills an entry in the EQCR of portal @qm to enqueue the frame described by
 * @fd. The descriptor details are copied from @fd to the EQCR entry, the &apos;pid&apos;
 * field is ignored. The return value is non-zero on error, such as ring full
 * (and FLAG_WAIT not specified), congestion avoidance (FLAG_WATCH_CGR
 * specified), etc. If the ring is full and FLAG_WAIT is specified, this
 * function will block. If FLAG_INTERRUPT is set, the EQCI bit of the portal
 * interrupt will assert when Qman consumes the EQCR entry (subject to &quot;status
 * disable&quot;, &quot;enable&quot;, and &quot;inhibit&quot; registers). If FLAG_DCA is set, Qman will
 * perform an implied &quot;discrete consumption acknowledgment&quot; on the dequeue
 * ring&apos;s (DQRR) entry, at the ring index specified by the FLAG_DCA_IDX(x)
 * macro. (As an alternative to issuing explicit DCA actions on DQRR entries,
 * this implicit DCA can delay the release of a &quot;held active&quot; frame queue
 * corresponding to a DQRR entry until Qman consumes the EQCR entry - providing
 * order-preservation semantics in packet-forwarding scenarios.) If FLAG_DCA is
 * set, then FLAG_DCA_PARK can also be set to imply that the DQRR consumption
 * acknowledgment should &quot;park request&quot; the &quot;held active&quot; frame queue. Ie.
 * when the portal eventually releases that frame queue, it will be left in the
 * Parked state rather than Tentatively Scheduled or Truly Scheduled. If the
 * portal is watching congestion groups, the QMAN_ENQUEUE_FLAG_WATCH_CGR flag
 * is requested, and the FQ is a member of a congestion group, then this
 * function returns -EAGAIN if the congestion group is currently congested.
 * Note, this does not eliminate ERNs, as the async interface means we can be
 * sending enqueue commands to an un-congested FQ that becomes congested before
 * the enqueue commands are processed, but it does minimise needless thrashing
 * of an already busy hardware resource by throttling many of the to-be-dropped
 * enqueues &quot;at the source&quot;.
 */</doc>
<def f='dpdk_1805/drivers/bus/dpaa/base/qbman/qman.c' l='2149' ll='2162' type='int qman_enqueue(struct qman_fq * fq, const struct qm_fd * fd, u32 flags)'/>
