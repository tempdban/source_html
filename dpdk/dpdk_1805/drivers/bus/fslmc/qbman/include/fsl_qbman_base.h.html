<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>fsl_qbman_base.h source code [dpdk_1805/drivers/bus/fslmc/qbman/include/fsl_qbman_base.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="qbman_block_desc,qbman_eqcr_mode,qbman_fd,qbman_fd_simple,qbman_swp_desc "/>
<link rel="stylesheet" href="../../../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'dpdk_1805/drivers/bus/fslmc/qbman/include/fsl_qbman_base.h'; var root_path = '../../../../../..'; var data_path = '../../../../../../../data';</script>
<script src='../../../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>dpdk_1805</a>/<a href='../../../..'>drivers</a>/<a href='../../..'>bus</a>/<a href='../..'>fslmc</a>/<a href='..'>qbman</a>/<a href='./'>include</a>/<a href='fsl_qbman_base.h.html'>fsl_qbman_base.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* SPDX-License-Identifier: BSD-3-Clause</i></td></tr>
<tr><th id="2">2</th><td><i> *</i></td></tr>
<tr><th id="3">3</th><td><i> * Copyright (C) 2014 Freescale Semiconductor, Inc.</i></td></tr>
<tr><th id="4">4</th><td><i> *</i></td></tr>
<tr><th id="5">5</th><td><i> */</i></td></tr>
<tr><th id="6">6</th><td><u>#<span data-ppcond="6">ifndef</span> <span class="macro" data-ref="_M/_FSL_QBMAN_BASE_H">_FSL_QBMAN_BASE_H</span></u></td></tr>
<tr><th id="7">7</th><td><u>#define <dfn class="macro" id="_M/_FSL_QBMAN_BASE_H" data-ref="_M/_FSL_QBMAN_BASE_H">_FSL_QBMAN_BASE_H</dfn></u></td></tr>
<tr><th id="8">8</th><td></td></tr>
<tr><th id="9">9</th><td><i class="doc">/**</i></td></tr>
<tr><th id="10">10</th><td><i class="doc"> * DOC: QBMan basic structures</i></td></tr>
<tr><th id="11">11</th><td><i class="doc"> *</i></td></tr>
<tr><th id="12">12</th><td><i class="doc"> * The QBMan block descriptor, software portal descriptor and Frame descriptor</i></td></tr>
<tr><th id="13">13</th><td><i class="doc"> * are defined here.</i></td></tr>
<tr><th id="14">14</th><td><i class="doc"> *</i></td></tr>
<tr><th id="15">15</th><td><i class="doc"> */</i></td></tr>
<tr><th id="16">16</th><td></td></tr>
<tr><th id="17">17</th><td><i class="doc">/**</i></td></tr>
<tr><th id="18">18</th><td><i class="doc"> * struct qbman_block_desc - qbman block descriptor structure</i></td></tr>
<tr><th id="19">19</th><td><i class="doc"> *<span class="command"> @ccsr</span>_reg_bar: CCSR register map.</i></td></tr>
<tr><th id="20">20</th><td><i class="doc"> *<span class="command"> @irq</span>_rerr: Recoverable error interrupt line.</i></td></tr>
<tr><th id="21">21</th><td><i class="doc"> *<span class="command"> @irq</span>_nrerr: Non-recoverable error interrupt line</i></td></tr>
<tr><th id="22">22</th><td><i class="doc"> *</i></td></tr>
<tr><th id="23">23</th><td><i class="doc"> * Descriptor for a QBMan instance on the SoC. On partitions/targets that do not</i></td></tr>
<tr><th id="24">24</th><td><i class="doc"> * control this QBMan instance, these values may simply be place-holders. The</i></td></tr>
<tr><th id="25">25</th><td><i class="doc"> * idea is simply that we be able to distinguish between them, eg. so that SWP</i></td></tr>
<tr><th id="26">26</th><td><i class="doc"> * descriptors can identify which QBMan instance they belong to.</i></td></tr>
<tr><th id="27">27</th><td><i class="doc"> */</i></td></tr>
<tr><th id="28">28</th><td><b>struct</b> <dfn class="type def" id="qbman_block_desc" title='qbman_block_desc' data-ref="qbman_block_desc">qbman_block_desc</dfn> {</td></tr>
<tr><th id="29">29</th><td>	<em>void</em> *<dfn class="decl field" id="qbman_block_desc::ccsr_reg_bar" title='qbman_block_desc::ccsr_reg_bar' data-ref="qbman_block_desc::ccsr_reg_bar">ccsr_reg_bar</dfn>;</td></tr>
<tr><th id="30">30</th><td>	<em>int</em> <dfn class="decl field" id="qbman_block_desc::irq_rerr" title='qbman_block_desc::irq_rerr' data-ref="qbman_block_desc::irq_rerr">irq_rerr</dfn>;</td></tr>
<tr><th id="31">31</th><td>	<em>int</em> <dfn class="decl field" id="qbman_block_desc::irq_nrerr" title='qbman_block_desc::irq_nrerr' data-ref="qbman_block_desc::irq_nrerr">irq_nrerr</dfn>;</td></tr>
<tr><th id="32">32</th><td>};</td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td><b>enum</b> <dfn class="type def" id="qbman_eqcr_mode" title='qbman_eqcr_mode' data-ref="qbman_eqcr_mode">qbman_eqcr_mode</dfn> {</td></tr>
<tr><th id="35">35</th><td>	<dfn class="enum" id="qman_eqcr_vb_ring" title='qman_eqcr_vb_ring' data-ref="qman_eqcr_vb_ring">qman_eqcr_vb_ring</dfn> = <var>2</var>, <i>/* Valid bit, with eqcr in ring mode */</i></td></tr>
<tr><th id="36">36</th><td>	<dfn class="enum" id="qman_eqcr_vb_array" title='qman_eqcr_vb_array' data-ref="qman_eqcr_vb_array">qman_eqcr_vb_array</dfn>, <i>/* Valid bit, with eqcr in array mode */</i></td></tr>
<tr><th id="37">37</th><td>};</td></tr>
<tr><th id="38">38</th><td></td></tr>
<tr><th id="39">39</th><td><i class="doc">/**</i></td></tr>
<tr><th id="40">40</th><td><i class="doc"> * struct qbman_swp_desc - qbman software portal descriptor structure</i></td></tr>
<tr><th id="41">41</th><td><i class="doc"> *<span class="command"> @block</span>: The QBMan instance.</i></td></tr>
<tr><th id="42">42</th><td><i class="doc"> *<span class="command"> @cena</span>_bar: Cache-enabled portal register map.</i></td></tr>
<tr><th id="43">43</th><td><i class="doc"> *<span class="command"> @cinh</span>_bar: Cache-inhibited portal register map.</i></td></tr>
<tr><th id="44">44</th><td><i class="doc"> *<span class="command"> @irq</span>: -1 if unused (or unassigned)</i></td></tr>
<tr><th id="45">45</th><td><i class="doc"> *<span class="command"> @idx</span>: SWPs within a QBMan are indexed. -1 if opaque to the user.</i></td></tr>
<tr><th id="46">46</th><td><i class="doc"> *<span class="command"> @qman</span>_version: the qman version.</i></td></tr>
<tr><th id="47">47</th><td><i class="doc"> *<span class="command"> @eqcr</span>_mode: Select the eqcr mode, currently only valid bit ring mode and</i></td></tr>
<tr><th id="48">48</th><td><i class="doc"> * valid bit array mode are supported.</i></td></tr>
<tr><th id="49">49</th><td><i class="doc"> *</i></td></tr>
<tr><th id="50">50</th><td><i class="doc"> * Descriptor for a QBMan software portal, expressed in terms that make sense to</i></td></tr>
<tr><th id="51">51</th><td><i class="doc"> * the user context. Ie. on MC, this information is likely to be true-physical,</i></td></tr>
<tr><th id="52">52</th><td><i class="doc"> * and instantiated statically at compile-time. On GPP, this information is</i></td></tr>
<tr><th id="53">53</th><td><i class="doc"> * likely to be obtained via "discovery" over a partition's "MC bus"</i></td></tr>
<tr><th id="54">54</th><td><i class="doc"> * (ie. in response to a MC portal command), and would take into account any</i></td></tr>
<tr><th id="55">55</th><td><i class="doc"> * virtualisation of the GPP user's address space and/or interrupt numbering.</i></td></tr>
<tr><th id="56">56</th><td><i class="doc"> */</i></td></tr>
<tr><th id="57">57</th><td><b>struct</b> <dfn class="type def" id="qbman_swp_desc" title='qbman_swp_desc' data-ref="qbman_swp_desc">qbman_swp_desc</dfn> {</td></tr>
<tr><th id="58">58</th><td>	<em>const</em> <b>struct</b> <a class="type" href="#qbman_block_desc" title='qbman_block_desc' data-ref="qbman_block_desc">qbman_block_desc</a> *<dfn class="decl field" id="qbman_swp_desc::block" title='qbman_swp_desc::block' data-ref="qbman_swp_desc::block">block</dfn>;</td></tr>
<tr><th id="59">59</th><td>	<a class="typedef" href="../../../../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a> *<dfn class="decl field" id="qbman_swp_desc::cena_bar" title='qbman_swp_desc::cena_bar' data-ref="qbman_swp_desc::cena_bar">cena_bar</dfn>;</td></tr>
<tr><th id="60">60</th><td>	<a class="typedef" href="../../../../../../include/stdint.h.html#uint8_t" title='uint8_t' data-type='unsigned char' data-ref="uint8_t">uint8_t</a> *<dfn class="decl field" id="qbman_swp_desc::cinh_bar" title='qbman_swp_desc::cinh_bar' data-ref="qbman_swp_desc::cinh_bar">cinh_bar</dfn>;</td></tr>
<tr><th id="61">61</th><td>	<em>int</em> <dfn class="decl field" id="qbman_swp_desc::irq" title='qbman_swp_desc::irq' data-ref="qbman_swp_desc::irq">irq</dfn>;</td></tr>
<tr><th id="62">62</th><td>	<em>int</em> <dfn class="decl field" id="qbman_swp_desc::idx" title='qbman_swp_desc::idx' data-ref="qbman_swp_desc::idx">idx</dfn>;</td></tr>
<tr><th id="63">63</th><td>	<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_swp_desc::qman_version" title='qbman_swp_desc::qman_version' data-ref="qbman_swp_desc::qman_version">qman_version</dfn>;</td></tr>
<tr><th id="64">64</th><td>	<b>enum</b> <a class="type" href="#qbman_eqcr_mode" title='qbman_eqcr_mode' data-ref="qbman_eqcr_mode">qbman_eqcr_mode</a> <dfn class="decl field" id="qbman_swp_desc::eqcr_mode" title='qbman_swp_desc::eqcr_mode' data-ref="qbman_swp_desc::eqcr_mode">eqcr_mode</dfn>;</td></tr>
<tr><th id="65">65</th><td>};</td></tr>
<tr><th id="66">66</th><td></td></tr>
<tr><th id="67">67</th><td><i>/* Driver object for managing a QBMan portal */</i></td></tr>
<tr><th id="68">68</th><td><b>struct</b> <dfn class="type" id="qbman_swp" title='qbman_swp' data-ref="qbman_swp">qbman_swp</dfn>;</td></tr>
<tr><th id="69">69</th><td></td></tr>
<tr><th id="70">70</th><td><i class="doc">/**</i></td></tr>
<tr><th id="71">71</th><td><i class="doc"> * struct qbman_fd - basci structure for qbman frame descriptor</i></td></tr>
<tr><th id="72">72</th><td><i class="doc"> *<span class="command"> @words</span>: for easier/faster copying the whole FD structure.</i></td></tr>
<tr><th id="73">73</th><td><i class="doc"> *<span class="command"> @addr</span>_lo: the lower 32 bits of the address in FD.</i></td></tr>
<tr><th id="74">74</th><td><i class="doc"> *<span class="command"> @addr</span>_hi: the upper 32 bits of the address in FD.</i></td></tr>
<tr><th id="75">75</th><td><i class="doc"> *<span class="command"> @len</span>: the length field in FD.</i></td></tr>
<tr><th id="76">76</th><td><i class="doc"> *<span class="command"> @bpid</span>_offset: represent the bpid and offset fields in FD. offset in</i></td></tr>
<tr><th id="77">77</th><td><i class="doc"> * the MS 16 bits, BPID in the LS 16 bits.</i></td></tr>
<tr><th id="78">78</th><td><i class="doc"> *<span class="command"> @frc</span>: frame context</i></td></tr>
<tr><th id="79">79</th><td><i class="doc"> *<span class="command"> @ctrl</span>: the 32bit control bits including dd, sc,... va, err.</i></td></tr>
<tr><th id="80">80</th><td><i class="doc"> *<span class="command"> @flc</span>_lo: the lower 32bit of flow context.</i></td></tr>
<tr><th id="81">81</th><td><i class="doc"> *<span class="command"> @flc</span>_hi: the upper 32bits of flow context.</i></td></tr>
<tr><th id="82">82</th><td><i class="doc"> *</i></td></tr>
<tr><th id="83">83</th><td><i class="doc"> * Place-holder for FDs, we represent it via the simplest form that we need for</i></td></tr>
<tr><th id="84">84</th><td><i class="doc"> * now. Different overlays may be needed to support different options, etc. (It</i></td></tr>
<tr><th id="85">85</th><td><i class="doc"> * is impractical to define One True Struct, because the resulting encoding</i></td></tr>
<tr><th id="86">86</th><td><i class="doc"> * routines (lots of read-modify-writes) would be worst-case performance whether</i></td></tr>
<tr><th id="87">87</th><td><i class="doc"> * or not circumstances required them.)</i></td></tr>
<tr><th id="88">88</th><td><i class="doc"> *</i></td></tr>
<tr><th id="89">89</th><td><i class="doc"> * Note, as with all data-structures exchanged between software and hardware (be</i></td></tr>
<tr><th id="90">90</th><td><i class="doc"> * they located in the portal register map or DMA'd to and from main-memory),</i></td></tr>
<tr><th id="91">91</th><td><i class="doc"> * the driver ensures that the caller of the driver API sees the data-structures</i></td></tr>
<tr><th id="92">92</th><td><i class="doc"> * in host-endianness. "struct qbman_fd" is no exception. The 32-bit words</i></td></tr>
<tr><th id="93">93</th><td><i class="doc"> * contained within this structure are represented in host-endianness, even if</i></td></tr>
<tr><th id="94">94</th><td><i class="doc"> * hardware always treats them as little-endian. As such, if any of these fields</i></td></tr>
<tr><th id="95">95</th><td><i class="doc"> * are interpreted in a binary (rather than numerical) fashion by hardware</i></td></tr>
<tr><th id="96">96</th><td><i class="doc"> * blocks (eg. accelerators), then the user should be careful. We illustrate</i></td></tr>
<tr><th id="97">97</th><td><i class="doc"> * with an example;</i></td></tr>
<tr><th id="98">98</th><td><i class="doc"> *</i></td></tr>
<tr><th id="99">99</th><td><i class="doc"> * Suppose the desired behaviour of an accelerator is controlled by the "frc"</i></td></tr>
<tr><th id="100">100</th><td><i class="doc"> * field of the FDs that are sent to it. Suppose also that the behaviour desired</i></td></tr>
<tr><th id="101">101</th><td><i class="doc"> * by the user corresponds to an "frc" value which is expressed as the literal</i></td></tr>
<tr><th id="102">102</th><td><i class="doc"> * sequence of bytes 0xfe, 0xed, 0xab, and 0xba. So "frc" should be the 32-bit</i></td></tr>
<tr><th id="103">103</th><td><i class="doc"> * value in which 0xfe is the first byte and 0xba is the last byte, and as</i></td></tr>
<tr><th id="104">104</th><td><i class="doc"> * hardware is little-endian, this amounts to a 32-bit "value" of 0xbaabedfe. If</i></td></tr>
<tr><th id="105">105</th><td><i class="doc"> * the software is little-endian also, this can simply be achieved by setting</i></td></tr>
<tr><th id="106">106</th><td><i class="doc"> * frc=0xbaabedfe. On the other hand, if software is big-endian, it should set</i></td></tr>
<tr><th id="107">107</th><td><i class="doc"> * frc=0xfeedabba! The best away of avoiding trouble with this sort of thing is</i></td></tr>
<tr><th id="108">108</th><td><i class="doc"> * to treat the 32-bit words as numerical values, in which the offset of a field</i></td></tr>
<tr><th id="109">109</th><td><i class="doc"> * from the beginning of the first byte (as required or generated by hardware)</i></td></tr>
<tr><th id="110">110</th><td><i class="doc"> * is numerically encoded by a left-shift (ie. by raising the field to a</i></td></tr>
<tr><th id="111">111</th><td><i class="doc"> * corresponding power of 2).  Ie. in the current example, software could set</i></td></tr>
<tr><th id="112">112</th><td><i class="doc"> * "frc" in the following way, and it would work correctly on both little-endian</i></td></tr>
<tr><th id="113">113</th><td><i class="doc"> * and big-endian operation;</i></td></tr>
<tr><th id="114">114</th><td><i class="doc"> *    fd.frc = (0xfe &lt;&lt; 0) | (0xed &lt;&lt; 8) | (0xab &lt;&lt; 16) | (0xba &lt;&lt; 24);</i></td></tr>
<tr><th id="115">115</th><td><i class="doc"> */</i></td></tr>
<tr><th id="116">116</th><td><b>struct</b> <dfn class="type def" id="qbman_fd" title='qbman_fd' data-ref="qbman_fd">qbman_fd</dfn> {</td></tr>
<tr><th id="117">117</th><td>	<b>union</b> {</td></tr>
<tr><th id="118">118</th><td>		<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd::(anonymous)::words" title='qbman_fd::(anonymous union)::words' data-ref="qbman_fd::(anonymous)::words">words</dfn>[<var>8</var>];</td></tr>
<tr><th id="119">119</th><td>		<b>struct</b> <dfn class="type def" id="qbman_fd_simple" title='qbman_fd_simple' data-ref="qbman_fd_simple"><a class="type" href="#qbman_fd_simple" title='qbman_fd_simple' data-ref="qbman_fd_simple">qbman_fd_simple</a></dfn> {</td></tr>
<tr><th id="120">120</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::addr_lo" title='qbman_fd_simple::addr_lo' data-ref="qbman_fd_simple::addr_lo">addr_lo</dfn>;</td></tr>
<tr><th id="121">121</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::addr_hi" title='qbman_fd_simple::addr_hi' data-ref="qbman_fd_simple::addr_hi">addr_hi</dfn>;</td></tr>
<tr><th id="122">122</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::len" title='qbman_fd_simple::len' data-ref="qbman_fd_simple::len">len</dfn>;</td></tr>
<tr><th id="123">123</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::bpid_offset" title='qbman_fd_simple::bpid_offset' data-ref="qbman_fd_simple::bpid_offset">bpid_offset</dfn>;</td></tr>
<tr><th id="124">124</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::frc" title='qbman_fd_simple::frc' data-ref="qbman_fd_simple::frc">frc</dfn>;</td></tr>
<tr><th id="125">125</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::ctrl" title='qbman_fd_simple::ctrl' data-ref="qbman_fd_simple::ctrl">ctrl</dfn>;</td></tr>
<tr><th id="126">126</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::flc_lo" title='qbman_fd_simple::flc_lo' data-ref="qbman_fd_simple::flc_lo">flc_lo</dfn>;</td></tr>
<tr><th id="127">127</th><td>			<a class="typedef" href="../../../../../../include/stdint.h.html#uint32_t" title='uint32_t' data-type='unsigned int' data-ref="uint32_t">uint32_t</a> <dfn class="decl field" id="qbman_fd_simple::flc_hi" title='qbman_fd_simple::flc_hi' data-ref="qbman_fd_simple::flc_hi">flc_hi</dfn>;</td></tr>
<tr><th id="128">128</th><td>		} <dfn class="decl field" id="qbman_fd::(anonymous)::simple" title='qbman_fd::(anonymous union)::simple' data-ref="qbman_fd::(anonymous)::simple">simple</dfn>;</td></tr>
<tr><th id="129">129</th><td>	};</td></tr>
<tr><th id="130">130</th><td>};</td></tr>
<tr><th id="131">131</th><td></td></tr>
<tr><th id="132">132</th><td><u>#<span data-ppcond="6">endif</span> /* !_FSL_QBMAN_BASE_H */</u></td></tr>
<tr><th id="133">133</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../fslmc_vfio.c.html'>dpdk_1805/drivers/bus/fslmc/fslmc_vfio.c</a><br/>Generated on <em>2018-Aug-19</em> from project dpdk_1805 revision <em>dpdk_1805</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
